{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":""},{"location":"gallery/","text":"Gallery .grid.cards>:-webkit-any(ul,ol) { display: contents !important; } ul { list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } .grid { grid-gap: .4rem; display: grid !important; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .grid>.card { text-size-adjust: none; -webkit-font-smoothing: antialiased; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; box-sizing: inherit; grid-gap: .4rem; display: grid; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .li { text-size-adjust: none; --md-text-font: \"Roboto\"; --md-code-font: \"Roboto Mono\"; -webkit-font-smoothing: antialiased; --md-text-font-family: var(--md-text-font,_),-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif; --md-code-font-family: var(--md-code-font,_),SFMono-Regular,Consolas,Menlo,monospace; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); --md-default-fg-color: rgba(0,0,0,.87); --md-default-fg-color--light: rgba(0,0,0,.54); --md-default-fg-color--lighter: rgba(0,0,0,.32); --md-default-fg-color--lightest: rgba(0,0,0,.07); --md-default-bg-color: #fff; --md-default-bg-color--light: hsla(0,0%,100%,.7); --md-default-bg-color--lighter: hsla(0,0%,100%,.3); --md-default-bg-color--lightest: hsla(0,0%,100%,.12); --md-shadow-z1: 0 0.2rem 0.5rem rgba(0,0,0,.05),0 0 0.05rem rgba(0,0,0,.1); --md-shadow-z2: 0 0.2rem 0.5rem rgba(0,0,0,.1),0 0 0.05rem rgba(0,0,0,.25); --md-shadow-z3: 0 0.2rem 0.5rem rgba(0,0,0,.2),0 0 0.05rem rgba(0,0,0,.35); --md-typeset-table-sort-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m18 21-4-4h3V7h-3l4-4 4 4h-3v10h3M2 19v-2h10v2M2 13v-2h7v2M2 7V5h4v2H2Z\"/></svg>'); --md-typeset-table-sort-icon--asc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 17h3l-4 4-4-4h3V3h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-typeset-table-sort-icon--desc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7h3l-4-4-4 4h3v14h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-toc-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2Z\"/></svg>'); --md-search-result-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h7c-.41-.25-.8-.56-1.14-.9-.33-.33-.61-.7-.86-1.1H6V4h7v5h5v1.18c.71.16 1.39.43 2 .82V8l-6-6m6.31 16.9c1.33-2.11.69-4.9-1.4-6.22-2.11-1.33-4.91-.68-6.22 1.4-1.34 2.11-.69 4.89 1.4 6.22 1.46.93 3.32.93 4.79.02L22 23.39 23.39 22l-3.08-3.1m-3.81.1a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5Z\"/></svg>'); --md-source-forks-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M5 3.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm0 2.122a2.25 2.25 0 1 0-1.5 0v.878A2.25 2.25 0 0 0 5.75 8.5h1.5v2.128a2.251 2.251 0 1 0 1.5 0V8.5h1.5a2.25 2.25 0 0 0 2.25-2.25v-.878a2.25 2.25 0 1 0-1.5 0v.878a.75.75 0 0 1-.75.75h-4.5A.75.75 0 0 1 5 6.25v-.878zm3.75 7.378a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm3-8.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5z\"/></svg>'); --md-source-repositories-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2 2.5A2.5 2.5 0 0 1 4.5 0h8.75a.75.75 0 0 1 .75.75v12.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 1 1 0-1.5h1.75v-2h-8a1 1 0 0 0-.714 1.7.75.75 0 0 1-1.072 1.05A2.495 2.495 0 0 1 2 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 0 1 1-1h8zM5 12.25v3.25a.25.25 0 0 0 .4.2l1.45-1.087a.25.25 0 0 1 .3 0L8.6 15.7a.25.25 0 0 0 .4-.2v-3.25a.25.25 0 0 0-.25-.25h-3.5a.25.25 0 0 0-.25.25z\"/></svg>'); --md-source-stars-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25zm0 2.445L6.615 5.5a.75.75 0 0 1-.564.41l-3.097.45 2.24 2.184a.75.75 0 0 1 .216.664l-.528 3.084 2.769-1.456a.75.75 0 0 1 .698 0l2.77 1.456-.53-3.084a.75.75 0 0 1 .216-.664l2.24-2.183-3.096-.45a.75.75 0 0 1-.564-.41L8 2.694v.001z\"/></svg>'); --md-source-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2.5 7.775V2.75a.25.25 0 0 1 .25-.25h5.025a.25.25 0 0 1 .177.073l6.25 6.25a.25.25 0 0 1 0 .354l-5.025 5.025a.25.25 0 0 1-.354 0l-6.25-6.25a.25.25 0 0 1-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.75 1.75 0 0 1 1 7.775zM6 5a1 1 0 1 0 0 2 1 1 0 0 0 0-2z\"/></svg>'); --md-tag-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m5.41 21 .71-4h-4l.35-2h4l1.06-6h-4l.35-2h4l.71-4h2l-.71 4h6l.71-4h2l-.71 4h4l-.35 2h-4l-1.06 6h4l-.35 2h-4l-.71 4h-2l.71-4h-6l-.71 4h-2M9.53 9l-1.06 6h6l1.06-6h-6Z\"/></svg>'); --md-tooltip-width: 20rem; --md-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 320 512\"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d=\"m310.6 246.6-127.1 128c-7.1 6.3-15.3 9.4-23.5 9.4s-16.38-3.125-22.63-9.375l-127.1-128C.224 237.5-2.516 223.7 2.438 211.8S19.07 192 32 192h255.1c12.94 0 24.62 7.781 29.58 19.75s3.12 25.75-6.08 34.85z\"/></svg>'); --md-footnotes-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.42L5.83 13H21V7h-2Z\"/></svg>'); --md-details-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42Z\"/></svg>'); --md-tasklist-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-tasklist-icon--checked: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-accent-fg-color: #526cfe; --md-accent-fg-color--transparent: rgba(82,108,254,.1); --md-accent-bg-color: #fff; --md-accent-bg-color--light: hsla(0,0%,100%,.7); --md-primary-fg-color: #4051b5; --md-primary-fg-color--light: #5d6cc0; --md-primary-fg-color--dark: #303fa1; --md-primary-bg-color: #fff; --md-primary-bg-color--light: hsla(0,0%,100%,.7); --md-code-fg-color: #36464e; --md-code-bg-color: #f5f5f5; --md-code-hl-color: rgba(255,255,0,.5); --md-code-hl-number-color: #d52a2a; --md-code-hl-special-color: #db1457; --md-code-hl-function-color: #a846b9; --md-code-hl-constant-color: #6e59d9; --md-code-hl-keyword-color: #3f6ec6; --md-code-hl-string-color: #1c7d4d; --md-code-hl-name-color: var(--md-code-fg-color); --md-code-hl-operator-color: var(--md-default-fg-color--light); --md-code-hl-punctuation-color: var(--md-default-fg-color--light); --md-code-hl-comment-color: var(--md-default-fg-color--light); --md-code-hl-generic-color: var(--md-default-fg-color--light); --md-code-hl-variable-color: var(--md-default-fg-color--light); --md-typeset-color: var(--md-default-fg-color); --md-typeset-a-color: var(--md-primary-fg-color); --md-typeset-mark-color: rgba(255,255,0,.5); --md-typeset-del-color: rgba(245,80,61,.15); --md-typeset-ins-color: rgba(11,213,112,.15); --md-typeset-kbd-color: #fafafa; --md-typeset-kbd-accent-color: #fff; --md-typeset-kbd-border-color: #b8b8b8; --md-typeset-table-color: rgba(0,0,0,.12); --md-admonition-fg-color: var(--md-default-fg-color); --md-admonition-bg-color: var(--md-default-bg-color); --md-footer-fg-color: #fff; --md-footer-fg-color--light: hsla(0,0%,100%,.7); --md-footer-fg-color--lighter: hsla(0,0%,100%,.3); --md-footer-bg-color: rgba(0,0,0,.87); --md-footer-bg-color--dark: rgba(0,0,0,.32); --md-mermaid-font-family: var(--md-text-font-family),sans-serif; --md-mermaid-edge-color: var(--md-code-fg-color); --md-mermaid-node-bg-color: var(--md-accent-fg-color--transparent); --md-mermaid-node-fg-color: var(--md-accent-fg-color); --md-mermaid-label-bg-color: var(--md-default-bg-color); --md-mermaid-label-fg-color: var(--md-code-fg-color); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; list-style-type: disc; box-sizing: inherit; border: .05rem solid var(--md-default-fg-color--lightest); border-radius: .1rem; display: block; margin: 0; padding: .8rem; transition: border .25s,box-shadow .25s; } Basic Structures description here skeletal Components Studies cross-section analysis, uniaxial materials and more. Reference Geotech Soil models and geotechnical modeling techniques Geotech Continua Material for MkDocs is licensed under MIT and available on GitHub License","title":"Gallery\n"},{"location":"gallery/continuua/example_6/","text":"Simply Supported Beam In this example a simple problem in solid dynamics is considered. The structure is a simply supported beam modelled with two dimensional solid elements. Example6.1.tcl For two dimensional analysis, a typical solid element is defined as a volume in two dimensional space. Each node of the analysis has two displacement degrees of freedom. Thus the model is defined with \\(ndm := 2\\) and \\(ndf := 2\\) . pp For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4} are prescribed to define the two dimensional domain of the beam, which is of size \\(40\\times10\\) . Three possible quadrilateral elements can be used for the analysis. These may be created using the terms \u201cbbarQuad,\u201d \u201cenhancedQuad\u201d or \u201cquad.\u201d This is a plane strain problem. An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and two vertical nodal loads are used. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Ten static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic - ndm 2 - ndf 2 # create the material nDMaterial ElasticIsotropic 1 1000 0.25 6.75 # Define geometry # --------------- # define some parameters set Quad quad set Quad bbarQuad set Quad enhancedQuad if { $ Quad == \"enhancedQuad\" } { set eleArgs \"PlaneStrain2D 1\" } if { $ Quad == \"quad\" } { set eleArgs \"1 PlaneStrain2D 1\" } if { $ Quad == \"bbarQuad\" } { set eleArgs \"1\" } set nx 8 ; # NOTE: nx MUST BE EVEN FOR THIS EXAMPLE set ny 2 set bn [ expr $ nx + 1 ] set l1 [ expr $ nx / 2 + 1 ] set l2 [ expr $ l1 + $ ny * ( $ nx + 1 ) ] # now create the nodes and elements using the block2D command block2D $ nx $ ny 1 1 $ Quad $ eleArgs { 1 0 0 2 40 0 3 40 10 4 0 10 } # Single point constraints # node u1 u2 fix 1 1 1 fix $ bn 0 1 # Gravity loads pattern Plain 1 Linear { load $ l1 0.0 - 1.0 load $ l2 0.0 - 1.0 } # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-12 10 0 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 10 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ l1 - dof 2 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 # create the display recorder display SimplySupportedBaam 10 10 800 200 - wipe prp 20 5.0 100.0 vup 0 1 0 viewWindow - 30 30 - 10 10 display 10 0 5 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-12 10 0 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (50 sec) # numSteps dt analyze 100 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the bottom center of the beam. The time history is shown in figure [beamdisp$$ .","title":"Simply Supported Beam\n"},{"location":"gallery/continuua/example_7/","text":"Dynamic Shell Analysis In this example a simple problem in shell dynamics is considered. The structure is a curved hoop shell structure that looks like the roof of a Safeway. Example7.1.tcl For shell analysis, a typical shell element is defined as a surface in three dimensional space. Each node of a shell analysis has six degrees of freedom, three displacements and three rotations. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 6\\) . For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4, 5,7,9} are defined such that the structure is curved in three dimensional space. The OpenSees shell element is constructed using the command \u201cShellMITC4\u201d. An elastic membrane-plate material section model, appropriate for shell analysis, is constructed using the \u201cElasticMembranePlateSection\u201d command. In this case, the elastic modulus \\(E := 3.0e3\\) , Poisson\u2019s ratio \\(\\nu := 0.25\\) , the thickness \\(h := 1.175\\) and the mass density per unit volume \\(\\rho := 1.27\\) For initial gravity load analysis, a single load pattern with a linear time series and three vertical nodal loads are used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1, 0,1,1}. All degrees-of-freedom are fixed except rotation about the x-axis, which is free. The same boundary conditions are applied where the z-coordinate is \\(40.0\\) . A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(250\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- model basic - ndm 3 - ndf 6 # create the material section ElasticMembranePlateSection 1 3.0e3 0.25 1.175 1.27 # set some parameters for node and element generation set Plate ShellMITC4 set eleArgs \"1\" #these should both be even set nx 8 set ny 2 #loaded nodes set mid [ expr ( ( $ nx + 1 ) * ( $ ny + 1 ) + 1 ) / 2 ] set side1 [ expr ( $ nx + 2 ) / 2 ] set side2 [ expr ( $ nx + 1 ) * ( $ ny + 1 ) - $ side1 + 1 ] # generate the nodes and elements block2D $ nx $ ny 1 1 $ Plate $ eleArgs { 1 - 20 0 0 2 - 20 0 40 3 20 0 40 4 20 0 0 5 - 10 10 20 7 10 10 20 9 0 10 20 } # add some loads pattern Plain 1 Linear { load $ mid 0.0 - 0.5 0.0 0.0 0.0 0.0 load $ side1 0.0 - 0.25 0.0 0.0 0.0 0.0 load $ side2 0.0 - 0.25 0.0 0.0 0.0 0.0 } # define the boundary conditions # rotation free about x-axis (remember right-hand-rule) fixZ 0.0 1 1 1 0 1 1 fixZ 40.0 1 1 1 0 1 1 # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system SparseGeneral - piv #system ProfileSPD # Analysis for gravity load #analysis Transient analysis Static # Perform the gravity load analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ mid - dof 2 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 recorder display shellDynamics 10 10 600 600 - wipe prp - 100 20 30 vup 0 1 0 display 1 0 100 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain #integrator GeneralizedMidpoint 0.50 integrator Newmark 0.50 0.25 analysis Transient # Perform the transient analysis analyze 250 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the upper center of the hoop structure. The time history is shown in figure [shelldisp$$ .","title":"Dynamic Shell Analysis\n"},{"location":"gallery/continuua/example_8/","text":"Cantilever Beam In this example a simple problem in solid dynamics is considered. The structure is a cantilever beam modelled with three dimensional solid elements. Example8.1.tcl For three dimensional analysis, a typical solid element is defined as a volume in three dimensional space. Each node of the analysis has three displacement degrees of freedom. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 3\\) . For this model, a mesh is generated using the \u201cblock3D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) , the number of nodes in the local y-direction of the block is \\(ny\\) and the number of nodes in the local z-direction of the block is \\(nz\\) . The block3D generation nodes {1,2,3,4,5,6,7,8} are prescribed to define the three dimensional domain of the beam, which is of size \\(2\\times2\\times10\\) . Two possible brick elements can be used for the analysis. These may be created using the terms stdBrick or bbarBrick . An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and a single nodal loads is used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1} , fully fixed. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 2.0\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic - ndm 3 - ndf 3 # create the material nDMaterial ElasticIsotropic 1 100 0.25 1.27 # Define geometry # --------------- # define some parameters set eleArgs \"1\" set element stdBrick #set element BbarBrick set nz 6 set nx 2 set ny 2 set nn [ expr ( $ nz + 1 ) * ( $ nx + 1 ) * ( $ ny + 1 ) ] # mesh generation block3D $ nx $ ny $ nz 1 1 $ element $ eleArgs { 1 - 1 - 1 0 2 1 - 1 0 3 1 1 0 4 - 1 1 0 5 - 1 - 1 10 6 1 - 1 10 7 1 1 10 8 - 1 1 10 } set load 0.10 # Constant point load pattern Plain 1 Linear { load $ nn $ load $ load 0.0 } # boundary conditions fixZ 0.0 1 1 1 # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test NormUnbalance 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ nn - dof 1 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 recorder display ShakingBeam 0 0 300 300 - wipe prp - 100 100 120.5 vup 0 1 0 display 1 0 1 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # add some mass proportional damping rayleigh 0.01 0.0 0.0 0.0 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (20 sec) # numSteps dt analyze 100 2.0 } The results consist of the file cantilever.out, which contains a line for every time step. Each line contains the time and the horizontal displacement at the upper right corner the beam. The time history is as plotted on the screen. figure [cantileverdisp$$ .","title":"Cantilever Beam\n"},{"location":"gallery/geotech/","text":"Geotechnical Examples","title":"Geotechnical Examples\n"},{"location":"gallery/geotech/02_StaticPile/","text":"Laterally-Loaded Pile Example prepared by: Christopher McGann and Pedro Arduino, University of Washington This article describes the OpenSees implementation of a simple laterally-loaded pile example. The problem is modeled as a beam on a nonlinear Winkler foundation (BNWF), utilizing displacement-based beam elements for the pile and nonlinear spring elements which represent the vertical and lateral response of the surrounding soil. This example considers a static analysis only. Provided with this article are the files needed to execute this analysis in OpenSees; the main input file, staticBNWFpile.tcl three procedures to define the soil constitutive behavior, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl a file to define the pile section behavior, elasticPileSection.tcl Download them all in a compressed file: staticBNWFanalysis.zip To run this example, the user must download each of the above files and place them in a single directory. Once this has been done, the user can then type \"source staticBNWFpile.tcl\" into the interpreter of the OpenSees.exe application to run the analysis. Representative results are presented in this article to verify the correct implementation of this example. Additionally, the pile response obtained from this analysis is compared to a similar analysis conducted using the commercial program LPile (http://www.ensoftinc.com) to provide verification the results of the OpenSees analysis. Model Description Fig 1. Schematic representation of the BNWF model. The BNWF model simulates the laterally-loaded pile problem using displacement-based beam elements to represent the pile and a series of nonlinear springs to represent the soil. The soil springs are generated using zero-length elements assigned separate uniaxial material objects in the lateral and vertical directions. An idealized schematic of the laterally-loaded pile model is provided in Fig. 1. The pile axis is oriented in the z-coordinate direction, and all of the nodes are initially located on the z-axis (x- and y- coordinates are zero). Node numbering for each set of nodes begins at the bottom of the pile. The model is created with three separate sets of nodes: fixed spring nodes (numbers 1-85 in example) slave spring nodes (numbers 101-185 in example) pile nodes (numbers 201-285 in example) Geometry and Mesh The geometry is rather simple in this example. There is only a single layer of cohesionless soil, and the groundwater table is assumed to be well below the tip of the pile. The pile geometry controls the meshing of the problem. The user can specify the length of the pile head (above the ground surface), L1, and the embedded pile length (below the ground surface), L2. The default values in staticBNWFpile.tcl are L1 = 1 m, and L2 = 20 m. The pile is also assigned a diameter of 1 m. This value is used in the soil constitutive modeling. The mesh is defined by the number of elements specified in the pile. The default value in this example is 84 elements (85 nodes). For the default pile geometry, this results in 80 elements over the embedded length and 4 elements above the ground surface. Note: The input file is only set up to handle up to 100 nodes. Modifications would need to be made to the node numbering scheme to accommodate a larger number of nodes. Spring Nodes The spring nodes are created with three dimensions and three translational degrees-of-freedom. The input file is set up to automatically generate the necessary spring nodes and elements based upon the input geometry (pile head length, $L1 , embedded length, $L2 , and number of pile elements, $nElePile ). Spring nodes are only created over the embedded length of pile. Since zero-length elements are used for the springs, the two sets of nodes share the same set of locations. One set of spring nodes, the fixed-nodes, are initially fixed in all three degrees-of-freedom. The other set of nodes, the slave nodes, are initially fixed in only two degrees-of-freedom, and are later given equal degrees-of-freedom with the pile nodes. Spring Constitutive Behavior The constitutive behavior of the springs is defined such that the springs oriented in the lateral direction represent p-y springs, and the vertically-oriented springs represent t-z and Q-z springs for the pile shaft and tip, respectively. Three procedures are used to properly define the p-y/t-z/Q-z behavior with depth, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl Several input soil properties are necessary to define these springs: soil unit weight, $gamma soil internal friction angle, $phi soil shear modulus, $Gsoil The default values are set at $gamma = 17 kN/m 3 , $phi = 36 degrees, and $Gsoil = 150000 kPa. The procedure get_pyParam.tcl , which defines the p-y springs, has several options which must be selected. The first switch, $puSwitch, specifies the variation in ultimate lateral resistance with depth. The default, $puSwitch = 1, uses the recommendations of the American Petroleum Institute (API) (1993). The alternative method is that of Brinch Hansen (1961). The second switch, $kSwitch, specifies the variation in initial stiffness with depth. The default, $kSwitch = 1, specifies a linear variation of initial stiffness with depth (API 1993). The alternative uses a modified version of the API stiffness which varies parabolically with depth after Boulanger et al. (2003). The presence of groundwater can be accounted for in the initial stiffness using the third switch, $gwtSwitch. Default, $gwtSwitch = 1, is for no groundwater. The other procedures, get_tzParam.tcl and get_qzParam.tcl , have no input options in this example. The t-z springs have behavior defined using the work of Mosher (1984) and Kulhawy (1991). The Q-z behavior is based on the work of Meyerhof (1976), Vijayvergiya (1977), and Kulhawy and Mayne (1990). The p-y spring constitutive behavior is obtained using the PySimple1 uniaxial material object. The t-z and Q-z springs are defined using the TzSimple1 and QzSimple1 uniaxial materials, respectively. The main input file is set up to automatically generate the required spring material objects based upon the input geometry and soil properties. Spring Elements Zero-length elements are used for the soil springs using the element zeroLength . These elements connect the fixed and slave spring nodes. The the PySimple1 material objects are incorporated in the x-direction (direction of loading), while the TzSimple1 , and at the pile tip, the QzSimple1 , material objects are incorporated in the z-direction (vertical direction). Pile Nodes The pile nodes are created with three dimensions and six degrees-of-freedom (3 translational, 3 rotational). The input file is set up to automatically generate the necessary pile nodes and elements based upon the input geometry. A linear coordinate-transformation object is specified for the orientation of the pile in this example. With the exemption of the uppermost pile head node, the pile nodes are fixed against translation in the y-direction and rotations about the x- and z- axes. The pile head node, where the load is applied, is separated to allow the user to specify a free-head (no rotational fixity) or fixed-head (full rotational fixity) condition at the loading point. The pile nodes over the embedded length of the pile are use linked with the slave spring nodes using the equalDOF command. The pile nodes are the master nodes in this example. These two sets of nodes share equal degrees-of-freedom in the x- and z- translational directions only. Pile Constitutive Behavior and Elements In this example, the pile is given elastic behavior for simplicity. Instead of using the elasticBeamColumn element, this is done using an elastic section object in conjunction with the displacement-based beam element, dispBeamColumn . This was done to facilitate future incorporation of elastoplastic pile section behavior using fiber section models by the user. The properties of the elastic section for this example are defined in the file, elasticPileSection.tcl . The pile is defined with appropriately computed values for the cross-sectional area and the moments of inertia for its 1 m diameter, and is assigned a modulus of elasticity, E = 25000000, and shear modulus, G = 9615385. Recorders Several recorders are defined for this model. The displacements at the pile nodes in all three translational dof are recorded for use in extracting the displaced shape of the pile. The reaction forces in the p-y springs are recorded for use in visualizing the lateral soil response. The element forces in the pile elements are recorded in order to obtain shear and moment diagrams for the pile. The recorders are set up to only record values at 0.5 second increments of pseudo-time during the analysis to facilitate the use of smaller load steps. This is done with the variable $timeStep. A display recorder is included in the input file to allow the user to visualize the deformation of the pile in \"real time\" during the analysis. The parameters are set up for the orientation of the pile in this example. Loading This example considers a 3500 kN load applied in the positive x-direction at the head of the pile (uppermost pile node). This is accomplished in the model using a plain pattern with optional time-series parameters. The load increases linearly from 0 kN to 3500 kN over a 10 second increment of pseudo-time (between 10 and 20 seconds) and is then held constant after the loading period. Setting up the loading object in this manner allows for more control over the analysis. Analysis The analysis is conducted using the load-controlled integrator with a loading step of 0.05. This value is selected based on the 10 second interval specified in the loading object. 200 steps with a loading step of 0.05 will put the last step exactly at 10 seconds of pseudo-time. 201 steps are used in this example to make sure that the last recorded step is at the full loading magnitude. The variables $startT and $endT are used to print the cpu time needed to complete the analysis in the standard output or the OpenSees interpreter. The remaining analysis commands are well-documented in the OpenSees command manual. Representative Results Fig. 2 Lateral soil response after application of full lateral load. A user can verify their downloaded files by running the main input file, staticBNWFpile.tcl , in OpenSees and comparing the recorded results to some representative results included here. The simplest verification is to use the spring reaction forces recorded in the file reaction.out. A plot of the recorded spring reaction forces vs. depth in the final recorded pseudo-time step (20.05) should create something similar to that shown in Fig. 2. The response is negative from the ground surface to about 7.5 m deep, then transitions to positive until about 13 m deep, has a second smaller negative section, and then is nearly zero near the tip of the pile. This verification plot can be made fairly simply using spreadsheet software. For those who prefer Matlab (http://www.mathworks.com/), the following lines will extract the desired information when pasted into an m-file. % create depth vector depth = linspace(-20,1,85); % load data react = load('reaction.out'); % remove pseudo-time information react(:,1) = []; % create plotting variable (divide by tributary area of pile to get force/length) reactPlot = react(end,:)/0.25; plot(reactPlot,depth) The shear and moment diagram plots in the following section can also be used for verification purposes. Comparison of OpenSees Results with LPile Fig. 3 Comparison of OpenSees and LPile analyses for free-head case. Fig. 4 Comparison of OpenSees and LPile analyses for fixed-head case. The commercial pile analysis program LPile (http://www.ensoftinc.com) is used to verify the results obtained using the OpenSees laterally-loaded pile model. The LPile analysis used the same geometric and constitutive parameters defined in the OpenSees analysis, and two cases were considered: A free-head case where there is no rotational fixity about the y-axis at the pile head A fixed-head case where full rotational fixity is enforced at the pile head. The two analysis methods are compared via the recorded pile and soil responses. Figs. 3 and 4 present these comparisons for the free-head and fixed-head cases, respectively. Shown in these figures are the shear and moment diagrams, displaced pile shapes, and the lateral soil response recorded from each analysis. As shown, the LPile and OpenSees results are fairly similar, especially for the free-head case. The main reason for the differences shown in Figs. 3 and 4 is that the p-y curves used in LPile are not the same as those used in the OpenSees analysis. The LPile curves are defined using the method of Reese et al. (1974), while the backbone of the p-y curves for the PySimple1 uniaxial material approximate the API (1993) recommendations. These two sets of curves are similar, and in fact have identical initial and ultimate responses, however, they vary in form over intermediate displacements. This is shown in Fig. 5, which plots the actual p-y response obtained in the OpenSees simulation alongside the p-y curves used by LPile for several depths. As shown, the hyperbolic tangent curves recommended by the API do not match those used by LPile, especially for displacements between approximately 0.001 and 0.037 m. The force returned by the PySimple1 material object for displacements in this range will therefore be greater than corresponding forces used by LPile. This is confirmed by the soil response comparison plots in Figs. 3 and 4. Where the pile displacements are large, the LPile and OpenSees soil reactions are nearly identical, but as the displacements become smaller with increasing depth, the recorded soil reactions begin to differ. This difference in lateral soil response is the main reason behind the small variability observed in the recorded shear and moment diagrams and displaced shapes. [ Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.](pyComp.png \u201d Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.\u201d) Overall, the agreement between the OpenSees and LPile analyses verifies that the BNWF model implemented in OpenSees is capable of returning sensible results for laterally-loaded pile simulations. There are differences between the results, however, these are relatively minor. The OpenSees simulation predicts maximum pile shear, moment, and deflection demands which are similar to those obtained from LPile, and the discrepancies are attributable to known differences between the two analysis methods. References 1. American Petroleum Institute (API) (1987). Recommended Practice for Planning, Designing and Constructing Fixed Offshore Platforms. API Recommended Practice 2A(RP-2A), Washington D.C, 17th edition. 2. Brinch Hansen, J. (1961). \u201cThe ultimate resistance of rigid piles against transversal forces.\u201d Bulletin No. 12, Geoteknisk Institute, Copenhagen, 59. 3. Boulanger, R. W., Kutter, B. L., Brandenberg, S. J., Singh, P., and Chang, D. (2003). Pile Foundations in liquefied and laterally spreading ground during earthquakes: Centrifuge experiments and analyses. Center for Geotechnical Modeling, University of California at Davis, Davis, CA. Rep. UCD/CGM-03/01. 4. Kulhawy, F.H. (1991). \"Drilled shaft foundations.\" Foundation engineering handbook, 2nd Ed., Chap 14, H.-Y. Fang ed., Van Nostrand Reinhold, New York. 5. Kulhawy, F.H. and Mayne, P.W. (1990). Manual on Estimating Soil Properties for Foundation Design. Electrical Power Research Institute. EPRI EL-6800, Project 1493-6 Final Report. 6. Meyerhof G.G. (1976). \"Bearing capacity and settlement of pile foundations.\" J. Geotech. Eng. Div., ASCE, 102(3), 195-228. 7. Mosher, R.L. (1984). \u201cLoad transfer criteria for numerical analysis of axial loaded piles in sand.\u201d U.S. Army Engineering and Waterways Experimental Station, Automatic Data Processing Center, Vicksburg, Miss. 8. Reese, L.C. and Van Impe, W.F. (2001), Single Piles and Pile Groups Under Lateral Loading. A.A. Balkema, Rotterdam, Netherlands. 9. Vijayvergiya, V.N. (1977). \u201cLoad-movement characteristics of piles.\u201d Proc., Ports 77 Conf., ASCE, New York.","title":"Laterally-Loaded Pile"},{"location":"gallery/sections/section_building/","text":"/home/claudio/brace/Scripts/SectionRegions/Tests_2.ipynb","title":"Damage Monitoring Tools\n"},{"location":"gallery/sections/section_limits/","text":"Elastic Limits /home/claudio/projects/SectionEccentricity/SectionLimits-3D.ipynb","title":"Elastic Limits\n"},{"location":"gallery/sections/MomentCurvature/","text":"Moment-Curvature (Concrete) This next example covers the moment-curvature analysis of a reinforced concrete section. The zero-length element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, and procedures are demonstrated. Example 2.1 In this example, a moment-curvature analysis of the fiber section is undertaken. Figure [rcsection4$$ shows the fiber discretization for the section. Example2.1.tcl MomentCurvature.tcl The model consists of two nodes and a ZeroLengthSection element. A depiction of the element geometry is shown in figure [zerolength \\[ ](#zerolength){reference-type=\"ref\" reference=\"zerolength\"}. The drawing on the left of figure [\\[zerolength\\] shows an edge view of the element where the local z-axis, as seen on the right side of the figure and in figure [rcsection0$$ , is coming out of the page. Node 1 is completely restrained, while the applied loads act on node 2. A compressive axial load, P, of 180 kips is applied to the section during the moment-curvature analysis. For the zero length element, a section discretized by concrete and steel is created to represent the resultant behavior. UniaxialMaterial objects are created to define the fiber stress-strain relationships: confined concrete in the column core, unconfined concrete in the column cover, and reinforcing steel. The dimensions of the fiber section are shown in figure [rcsection0 \\[ ](#rcsection0){reference-type=\"ref\" reference=\"rcsection0\"}. The section depth is 24 inches, the width is 15 inches, and there are 1.5 inches of cover around the entire section. Strong axis bending is about the section z-axis. In fact, the section z-axis is the strong axis of bending for all fiber sections in planar problems. The section is separated into confined and unconfined concrete regions, for which separate fiber discretizations will be generated. Reinforcing steel bars will be placed around the boundary of the confined and unconfined regions. The fiber discretization for the section is shown in figure [\\[rcsection4\\] . ::: {.center} ::: The section analysis is performed by the Tcl procedure MomentCurvature defined in the file MomentCurvature.tcl. The arguments to the procedure are the tag of the section to be analyzed, the axial load applied to the section, the maximum curvature, and the number of displacement increments to reach the maximum curvature. The output for the moment-curvature analysis will be the section forces and deformations, stored in the file section1.out. In addition, an estimate of the section yield curvature is printed to the screen. In the script below variables, are set and can then be used with the syntax of $variable . Expressions can be evaluated, although the Tcl syntax at first appears cumbersome. An expression is given by an expr command enclosed in square brackets [] \u2019s. Typically, the result of an expression is then set to another variable. A simple example to add 2.0 to a parameter is shown below: set v 3.0 set sum [expr $v + 2.0 ] puts $sum ; # print the sum Comments with # can appear on the same line as a command, but then the command must be terminated with a semi-colon. # OpenSees Example 2.1 # OpenSees Primer # # Units: kips, in, sec # Define model builder # -------------------- model BasicBuilder - ndm 2 - ndf 3 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 - 6.0 - 0.004 - 5.0 - 0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 - 5.0 - 0.002 0.0 - 0.006 # STEEL # Reinforcing steel set fy 60.0 ; # Yield stress set E 30000.0 ; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $ fy $ E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some parameters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60 ; # area of no. 7 bars # some variables derived from the parameters set y1 [ expr $ colDepth / 2.0 ] set z1 [ expr $ colWidth / 2.0 ] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [ expr $ cover -$ y1 ] [ expr $ cover -$ z1 ] [ expr $ y1 -$ cover ] [ expr $ z1 -$ cover ] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [ expr -$ y1 ] [ expr $ z1 -$ cover ] $ y1 $ z1 patch rect 2 10 1 [ expr -$ y1 ] [ expr -$ z1 ] $ y1 [ expr $ cover -$ z1 ] patch rect 2 2 1 [ expr -$ y1 ] [ expr $ cover -$ z1 ] [ expr $ cover -$ y1 ] [ expr $ z1 -$ cover ] patch rect 2 2 1 [ expr $ y1 -$ cover ] [ expr $ cover -$ z1 ] $ y1 [ expr $ z1 -$ cover ] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $ As [ expr $ y1 -$ cover ] [ expr $ z1 -$ cover ] [ expr $ y1 -$ cover ] [ expr $ cover -$ z1 ] layer straight 3 2 $ As 0.0 [ expr $ z1 -$ cover ] 0.0 [ expr $ cover -$ z1 ] layer straight 3 3 $ As [ expr $ cover -$ y1 ] [ expr $ z1 -$ cover ] [ expr $ cover -$ y1 ] [ expr $ cover -$ z1 ] } # Estimate yield curvature # (Assuming no axial load and only top and bottom steel) set d [ expr $ colDepth -$ cover ] ; # d -- from cover to rebar set epsy [ expr $ fy /$ E ] ; # steel yield strain set Ky [ expr $ epsy / ( 0.7 *$ d )] # Print estimate to standard output puts \"Estimated yield curvature: $Ky\" # Set axial load set P - 180 set mu 15 ; # Target ductility for analysis set numIncr 100 ; # Number of analysis increments # Call the section analysis procedure source MomentCurvature . tcl MomentCurvature 1 $ P [ expr $ Ky *$ mu ] $ numIncr The Tcl procedure to perform the moment-curvature analysis follows. In this procedure, the nodes are defined to be at the same geometric location and the ZeroLengthSection element is used. A single load step is performed for the axial load, then the integrator is changed to DisplacementControl to impose nodal displacements, which map directly to section deformations. A reference moment of 1.0 is defined in a Linear time series. For this reference moment, the DisplacementControl integrator will determine the load factor needed to apply the imposed displacement. A node recorder is defined to track the moment-curvature results. The load factor is the moment, and the nodal rotation is in fact the curvature of the element with zero thickness. # Arguments # secTag -- tag identifying section to be analyzed # axialLoad -- axial load applied to section (negative is compression) # maxK -- maximum curvature reached during analysis # numIncr -- number of increments used to reach maxK (default 100) # # Sets up a recorder which writes moment-curvature results to file # section$secTag.out ... the moment is in column 1, and curvature in column 2 proc MomentCurvature { secTag axialLoad maxK { numIncr 100 } } { # Define two nodes at (0,0) node 1 0.0 0.0 node 2 0.0 0.0 # Fix all degrees of freedom except axial and bending at node 2 fix 1 1 1 1 fix 2 0 1 0 # Define element # tag ndI ndJ secTag element zeroLengthSection 1 1 2 $ secTag # Create recorder recorder Node - file section $ secTag . out - time - node 2 - dof 3 disp # Define constant axial load pattern Plain 1 \"Constant\" { load 2 $ axialLoad 0.0 0.0 } # Define analysis parameters integrator LoadControl 0 1 0 0 system SparseGeneral - piv ; test NormUnbalance 1.0e-9 10 numberer Plain constraints Plain algorithm Newton analysis Static # Do one analysis for constant axial load analyze 1 # Define reference moment pattern Plain 2 \"Linear\" { load 2 0.0 0.0 1.0 } # Compute curvature increment set dK [ expr $ maxK /$ numIncr ] # Use displacement control at node 2 for section analysis integrator DisplacementControl 2 3 $ dK 1 $ dK $ dK # Do the section analysis analyze $ numIncr } Estimated yield curvature : 0.000126984126984 The file section1.out contains for each committed state a line with the load factor and the rotation at node 3. This can be used to plot the moment-curvature relationship as shown in figure [momcurv$$ .","title":"Moment-Curvature (Concrete)"},{"location":"gallery/sections/example_9/","text":"Rectilinear Cross Sections For the case of the uniaxial section, moment-curvature and axial force-deformation curves are defined independently, and numerically. For the case of the fiber sections (steel and RC), uniaxial materials are defined numerically (stress-strain relationship) and are combined into a fiber section where moment-curvature and axial force-deformation characteristics and their interaction are calculated computationally. 2D vs. 3D While this distinction does not affect the section definition itself, it affects the degree-of-freedom associated with moment and curvature in the subsequent analysis. There are two differences between the two models: The space defined with the model command (Defining the model builder, ndm=#dimension ndf=#dofs ) In the 3D model, torsional stiffness needs to be aggregated to the section. Uniaxial Section Notes Flexure and axial behavior are uncoupled in this type of section Fiber Section: AISC Standard W Section Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Unconfined Concrete Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Confined Concrete Core Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Section Notes Coupled biaxial flexure and axial behavior generic rectangular section Fiber Section: Reinforced Concrete Section \u2013 Circular Section, Confined Core Notes Coupled biaxial flexure and axial behavior generic circular section Fiber Section: Reinforced Concrete Hollow Section \u2013 Symmetric Section, Confined Concrete Notes Coupled biaxial flexure and axial behavior Moment-Curvature Analysis This example introduces the moment-curvature procedures for sections in 2D or 3D space, as built in the previous section. (the only difference between them is the degree-of-freedom corresponding to curvature). The moment-curvature analysis of a section is by creating a zero-length rotational-spring element. This section is subjected to a user-defined constant axial load and to a linearly-increasing moment to a user-defined maximum curvature. 2D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature2D.tcl MomentCurvature2D.tcl Notes 3D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature3D.tcl MomentCurvature3D.tcl Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Uniaxial-Section Model, 2D puts \" --------------------------------- 2D Model ---------------\" puts \" a. Uniaxial Section\" source Ex9a.build.UniaxialSection2D.tcl source Ex9.analyze.MomentCurvature2D.tcl To run RC Section: Rectangular, Confined, Symmetric Model, 3D puts \" --------------------------------- 3D Model ---------------\" puts \" d. RC Section: Rectangular, Confined, Symmetric\" source Ex9d.build.RCSection.RectConfinedSymm3D.tcl source Ex9.analyze.MomentCurvature3D.tcl","title":"Rectilinear Cross Sections"},{"location":"guides/01_install/","text":"Installing OpenSeesRT is distributed primarily as a Python package. For those familiar with Python, you can just run pip install opensees New to Python Windows Store VS Code","title":"Installing\n"},{"location":"guides/01_starting/","text":"Getting Started A simulation with opensees is generally configured in the following steps: Modeling : This consists of defining a collection of mathematical abstractions and their relationships with the objective of representing some phenomenon. This generally includes creating Element , Node , LoadPattern and Constraint objects that define the model. Analysis : Once a model is defined, the next step is to create an Analysis. Some common analysis routines are the following: Static Analysis Load or displacement controlled Spectral Decomposition Transient Direct Integration Transient Modal Integration Moment-Curvature Analysis Ultimate N-M Surface Analysis These routines are configured and refined in terms of analysis abstractions which generally may include an Integrator , SolutionAlgorithm , and ConstraintHandler strategy. Post-processing : Once the model and analysis have been defined, the user has the option of specifying what is to be monitored during the analysis. This, for example, could be the displacement history at a node or internal state of an element in a transient analysis or the entire state of the model at each step in the solution procedure. Several Recorder objects are created to store what the user wants to examine. Runtime and Numerics : When working on advanced problems, fine-grained control over details such as the analysis runtime, parallelization, and numeric strategies becomes important. Numerics : when the computational cost of an analysis becomes prohibitive, selecting the right numeric strategy can be important. Refinements typically consist of choosing an appropriate linear or eigenvalue solver which appropriatly accounts for the structure of a linear system. Parallelization may also be considered.","title":"Getting Started\n"},{"location":"guides/02_runtime/","text":"Runtime record recorder printModel POST render . elastica ( model , displ ): ... MODLEING (MOVE TO LIBRARY?) remove setElementRayleighDampingFactors modalDamping ANALYSIS? def eig ( model , number , ** runtime ) -> ( freq , displ ): ... def rha ( model , pattern , ** runtime ) -> (): ... def rt . incr ( self , model , pattern , force | displ =< float > ) sdfResponse InitialStateAnalysis systemSize getLoadFactor testIter testNorm numFact numIter - loadConst ? setNumthread getNumthread Runtime [ getTime ] setTime setNodeCoord setNodeDisp setNodeVel setNodeAccel reactions setPrecision updateElementDomain updateMaterialStage reset wipe wipeAnalysis Utilities convertBinaryToText convertTextToBinary stripXML restore save database sectionForce sectionDeformation sectionStiffness sectionFlexibility sectionLocation sectionWeight getEleTags eleDynamicalForce eleForce eleNodes eleResponse basicDeformation basicForce basicStiffness getNodeTags nodeDisp nodeAccel nodeVel nodeBounds nodeCoord nodeEigenvector nodeDOFs nodeMass nodePressure nodeReaction nodeResponse nodeUnbalance printA printB printGID version logFile","title":"Runtime\n"},{"location":"guides/03_simulation/","text":"Basic Simulation Build the model model dimensions and degrees-of-freedom nodal coordinates nodal constraints, boundary conditions nodal masses elements and element connectivity recorders for output Define & apply gravity load nodal or element load static-analysis parameters (tolerances & load increments) analyze hold gravity loads constant reset time to zero Define and apply lateral load load pattern (nodal loads for static analysis, support ground motion for earthquake) lateral-analysis parameters (tolerances & displacement/time increments) Static Lateral-Load Analysis define the displacement increments and displacement path Dynamic Lateral-Load Analysis define the input motion and all associated parameters, such as scaling and input type define analysis duration and time increment define damping analyze","title":"Basic Simulation\n"},{"location":"guides/cli/","text":"Command Line Use","title":"Command Line Use\n"},{"location":"guides/object_oriented/","text":"Object oriented interfaces Object oriented interfaces are available for the following types: Element SectionForceDeformation UniaxialMaterial NdMaterial Node HystereticBackbone","title":"Object oriented interfaces\n"},{"location":"guides/BeamTheory/","text":"Beam-Column Elements in OpenSees This document provides a brief description of the interaction between a beam-column element and the SectionForceDeformation and CoordTransformation classes in OpenSees. Material and geometric nonlinearities are abstracted, or separated, from the element formulation by using the SectionForceDeformation and CoordTransformation classes. As a result, an element can be programmed in the \u201cbasic system\u201d to account for material nonlinearities, then use one of many transformation types to pick up geometric nonlinearities. A displacement based, distributed plasticity formulation is presented as an example of how a beam-column element is formulated in the basic system. Geometric Nonlinearity In general, the transformation of nodal displacements, \\(\\mathbf{u}\\) , in the global system to deformations, \\(\\mathbf{v}\\) , in the basic system is described by a nonlinear function, \\[%\\label{eq:v=v(u)} \\mathbf{v} = \\mathbf{v}(\\mathbf{u}).\\] In a similar manner, the transformation of basic forces, \\(\\mathbf{q}\\) , to forces \\(\\mathbf{p}\\) in the global frame of reference is given by \\[%\\label{eq:p=p(q,u)} \\mathbf{p} = \\mathbf{p}(\\mathbf{q}(\\mathbf{u}), \\mathbf{u}),\\] where \\(\\mathbf{p}\\) is implicitly a function of \\(\\mathbf{u}\\) via the basic forces, \\(\\mathbf{q}\\) , as well as an explicit function of \\(\\mathbf{u}\\) . The explicit dependence on \\(\\mathbf{u}\\) takes into account approximate geometric nonlinearities such as P- \\(\\Delta\\) . These transformations are shown schematically in figure @fig:Transformation . {#fig:Transformation} As seen in figure [fig:BeamClass$$ , a beam-column element acquires geometric nonlinearity from the CoordTransformation class, and material nonlinearity from the SectionForceDeformation class. Material Nonlinearity At every cross-section along the element length, a force-deformation relationship holds, providing section stress resultants, \\(\\mathbf{s}\\) , as a function of section deformations, \\(\\mathbf{e}\\) , \\[%\\label{eq:s=s(e)} \\mathbf{s}(x) = \\mathbf{s}(\\mathbf{e}(x)).\\] Linearizing the force-deformation relationship with respect to deformations reveals the section tangent stiffness, \\(\\mathbf{k}_s\\) , \\[\\begin{aligned} \\Delta\\mathbf{s} &= \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\Delta\\mathbf{e} \\\\ \\Delta\\mathbf{s} &= \\mathbf{k}_s \\Delta\\mathbf{e},\\end{aligned}\\] where \\(\\mathbf{k}_s = \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}}\\) , the partial derivative of the section stress resultants with respect to the section deformations. A beam-column element obtains material nonlinearity through use of the SectionForceDeformation class, as seen in figure [fig:BeamClass$$ . Class Hierarchy Figure [fig:BeamClass$$ shows the class interaction between a beam-column element and the CoordTransformation and SectionForceDeformation classes. An element can use any one of Linear, \\(P-\\Delta\\) , or Corotational transformations; and any one of ElasticSection or FiberSection constitutive models. When a new transformation or section class is added to the framework, the element can use the new class without modification. Displacement Based Element Formulation This section describes the formulation of a displacement based, distributed plasticity beam-column element. The governing compatibility and equilibrium equations are covered along with the consistent element stiffness. Bending deformations are assumed to be small, and shear deformations are neglected. Compatibility For displacement based elements, there is a strong form of compatibility between basic displacements, \\(\\mathbf{v}\\) , and section deformations \\(\\mathbf{e}\\) , satisfied pointwise along the element length, \\[%\\label{eq:e=av} \\mathbf{e}(x) = \\left[ \\begin{array}{c} \\varepsilon(x) \\\\ \\kappa(x) \\end{array} \\right] = \\mathbf{a}(x) \\mathbf{v},\\] where \\(\\mathbf{a}\\) is the strain-displacement matrix. The section deformations are the axial strain, \\(\\varepsilon\\) , and curvature, \\(\\kappa\\) . Assuming linear axial displacement and transverse displacement based on cubic Hermitian polynomials, the shape functions in the basic system are \\[%\\label{eq:N} \\mathbf{N}(x) = \\left[ \\begin{array}{c} N_1(x) \\\\ \\\\ N_2(x) \\\\ \\\\ N_3(x) \\end{array} \\right] = \\left[ \\begin{array}{c} \\frac{x}{L} \\\\ \\\\ L\\left( \\frac{x}{L} - 2\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\\\ \\\\ L\\left( -\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\end{array} \\right].\\] The strain-displacement matrix contains the shape function derivatives. Axial strain is the first derivative of the axial displacement, and curvature is the second derivative of the transverse displacement, \\[\\mathbf{a}(x) = \\left[ \\begin{array}{ccc} N_{1,x} & 0 & 0 \\\\ \\\\ 0 & N_{2,xx} & N_{3,xx} \\end{array} \\right].\\] Using the shape functions defined in equation [eq:N$$ , the strain-displacement matrix is then, \\[\\mathbf{a}(x) = \\frac{1}{L} \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ \\\\ 0 & -4+6\\frac{x}{L} & -2+6\\frac{x}{L} \\end{array} \\right].\\] The basic displacements, \\(\\mathbf{v}\\) , can be obtained by invoking the method getBasicTrialDisp() . After computing section deformations from basic displacements via equation @eq:e =av , the method setTrialSectionDeformation() may be invoked with the updated deformations, \\(\\mathbf{e}\\) . Equilibrium Using the principle of virtual displacements (virtual work), equilibrium between element end forces, \\(\\mathbf{q}\\) , and section stress resultants, \\(\\mathbf{s}\\) , is satisfied weakly, or in an average sense, along the element length, \\[%\\label{eq:q} \\mathbf{q} = \\int_0^L \\mathbf{a}(x)^T \\mathbf{s}(x) \\: dx,\\] where the section stress resultants are the axial force, \\(P\\) , and bending moment, \\(M\\) , \\[\\mathbf{s}(x) = \\left[ \\begin{array}{c} P(x) \\\\ M(x) \\end{array} \\right].\\] To obtain the current value of section stress resultants, \\(\\mathbf{s}\\) , the method getStressResultant() must be invoked. To perform the transformation from basic to global resisting force (equation [eq:p=p(q,u)$$ ), the method getGlobalResistingForce() should be invoked. Element Stiffness To solve the structural system of equations, the element stiffness must be assembled along with the resisting force. The element stiffness is obtained by taking the partial derivative of equation [eq:p=p(q,u)$$ with respect to displacements, \\(\\mathbf{u}\\) . \\[\\begin{aligned} \\mathbf{k} &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}}\\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ \\mathbf{k} &= %\\label{eq:stiff} \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\mathbf{k}_b \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q}\\end{aligned}\\] The basic element stiffness, \\(\\mathbf{k}_b\\) , is the partial derivative of the basic forces, \\(\\mathbf{q}\\) , with respect to the basic displacements, \\(\\mathbf{v}\\) . Differentiating equation [eq:q$$ gives, \\[\\begin{aligned} \\mathbf{k}_b &= \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{v}} \\: dx \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\frac{\\partial\\mathbf{e}}{\\partial\\mathbf{v}} \\: dx \\\\ \\mathbf{k}_b &= %\\label{eq:kb} \\boxed{ \\int_0^L \\mathbf{a}(x)^T \\mathbf{k}_s(x) \\mathbf{a}(x) \\: dx} \\end{aligned}\\] The section tangent stiffness matrix, \\(\\mathbf{k}_s\\) , is returned upon invoking the method getSectionTangent() . After computing the basic stiffness, \\(\\mathbf{k}_b\\) , the method getGlobalStiffMatrix() should be invoked to perform the transformation in equation [eq:stiff \\[ ](#eq:stiff){reference-type=\"ref\" reference=\"eq:stiff\"}. The remaining partial derivatives in equation [\\[eq:stiff\\] are computed by the getGlobalStiffMatrix() method. Numerical Quadrature In general, the element integrals, equations [eq:q \\[ ](#eq:q){reference-type=\"ref\" reference=\"eq:q\"} and [\\[eq:kb\\] , cannot be evaluated in closed form due to nonlinearities in the section constitutive model. These integrals must be approximately evaluated by numerical quadrature, \\[\\begin{aligned} %\\label{eq:qapprox} \\mathbf{q} &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{s}(x_i) \\: W_i \\\\ %\\label{eq:kbapprox} \\mathbf{k}_b &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{k}_s(x_i) \\mathbf{a}(x_i) \\: W_i ,\\end{aligned}\\] where \\(N_s\\) is the number of integration points, i.e., the number of section sample points along the element length. Integration points, \\(\\xi_i\\) , and weights, \\(\\omega_i\\) , are typically defined over a fixed domain such as \\(\\left[-1,1\\right]\\) or \\(\\left[0,1\\right]\\) , then mapped to the element domain \\(\\left[0,L\\right]\\) , where \\(L\\) is the element length. Assuming points and weights defined on \\(\\left[-1,1\\right]\\) , the following relationships hold, \\[\\begin{aligned} x_i &= \\frac{L}{2} \\left( \\xi_i+1 \\right) \\\\ W_i &= \\frac{L}{2} \\: \\omega_i .\\end{aligned}\\] After mapping the points and weights to the element domain, equations [eq:qapprox \\[ ](#eq:qapprox){reference-type=\"ref\" reference=\"eq:qapprox\"} and [\\[eq:kbapprox\\] can be evaluated. Michael H. Scott August 22, 2001 PEER, University of California, Berkeley","title":"Beam-Column Elements in OpenSees\n"},{"location":"library/1_Modeling/constraints/","text":"Constraints In OpenSees there are two types of constraints: Single Point constraints which prescribe the movement (typically 0) of a single dof at a node. There are a number of commands for defining single-point coonstraints: fix fixX fixY fixZ Multi-Point constraints which prescribe that the movement of certain dof at one node are defined by the movement of certain dof at another node. There again are a number of commands for defining multi-point constraints. equalDOF rigidDiaphragm rigidLink","title":"Constraints\n"},{"location":"library/1_Modeling/constraints/213-EqualDOF/","text":"EqualDOF This command is used to construct a multi-point constraint between nodes. equalDOF $rNodeTag $cNodeTag $dof1 $dof2 ... rNodeTag integer tag identifying the retained node (rNode) cNodeTag integer tag identifying the constrained node (cNode) $dof1 $dof2 \u2026 nodal degrees-of-freedom that are constrained at the cNode to be the same as those at the rNode Valid range is from 1 through ndf, the number of nodal degrees-of-freedom. Examples Impose the displacements at dof\u2019s 1,3 and 5 of node 3 to be the same as those of node 2: equalDOF 2 3 1 3 5 ; References Cook, R.D., Malkus, D.S., Plesha, M. E., and Witt, R. J., \u201cConcepts and Applications of Finite Element Analysis,\u201d 4th edition, John Wiley and Sons publishers, 2002. Code Developed by: fmk","title":"EqualDOF\n"},{"location":"library/1_Modeling/constraints/601-RigidDiaphragm/","text":"RigidDiaphragm This command is used to construct a number of Multi-Point Constraint ( MP_Constraint ) objects. These objects will constrain certain degrees-of-freedom at the listed constrained nodes to move as if in a rigid plane with the retained node. rigidDiaphragm $perpDirn $rNodeTag $cNodeTag1 $cNodeTag2... perpDirn direction perpendicular to the rigid plane (i.e. direction 3 corresponds to the 1-2 plane) rNodeTag integer tag identifying the retained node $cNodeTag1 $cNodeTag2 \u2026 integer tags identifying the constrained nodes NOTE: The constraint object is constructed assuming small rotations. NOTE: The rigidDiaphragm command works only for problems in three dimensions with six-degrees-of-freedom at the nodes (ndf = 6). Examples rigidDiaphragm 2 2 4 5 6; constrain nodes 4,5,6 to move as if in the same x-z plane as node 2. Code Developed by: fmk","title":"RigidDiaphragm\n"},{"location":"library/1_Modeling/constraints/602-RigidLink/","text":"RigidLink This command is used to construct a single MP_Constraint object. rigidLink $type $rNodeTag $cNodeTag type string-based argument for rigid-link type: bar only the translational degree-of-freedom will be constrained to be exactly the same as those at the retained node beam both the translational and rotational degrees of freedom are constrained. rNodeTag integer tag identifying the retained node cNodeTag integer tag identifying the constrained node NOTE: The constraint object constructed for the beam option assumes small rotations Examples connect node 3 to node 2 via a rigid link-beam. rigidLink beam 2 3 ; References Cook, R.D., Malkus, D.S., Plesha, M. E., and Witt, R. J., \u201cConcepts and Applications of Finite Element Analysis,\u201d 4th edition, John Wiley and Sons publishers, 2002. Code Developed by: fmk","title":"RigidLink\n"},{"location":"library/1_Modeling/constraints/658-Sp/","text":"Sp (Single-point) This command is used to construct a single-point constraint object and add it to the enclosing LoadPattern. sp $nodeTag $dofTag $dofValue nodeTag tag of node to which constraint is applied. dofTag the degree-of-freedom at the node to which constraint is applied (1 through ndf) dofValue reference constraint value. NOTES: The dofValue is a reference value, it is the time series that provides the load factor. The load factor times the reference value is the constraint that is actually applied to the node. Code Developed by: fmk","title":"Sp (Single-point)\n"},{"location":"library/1_Modeling/constraints/fix/","text":"Fix FixX command This command is used to construct multiple homogeneous single-point boundary constraints for all nodes whose x-coordinate lies within a specified distance from a specified coordinate. fixX $xCoordinate ( ndf $ConstrValues ) & lt ; -tol $tol & gt ; xCoordinate x-coordinate of nodes to be constrained constrValues ndf constraint values (0 or 1) corresponding to the ndf degrees-of-freedom. 0 unconstrained (or free) 1 constrained (or fixed) tol user-defined tolerance (optional, default = 1e-10) Examples fixX 0.0 1 1 1 1 1 1; # fully restrain all nodes in y-z plane at origin (x=0.0) FixY command This command is used to construct multiple homogeneous single-point boundary constraints for all nodes whose y-coordinate lies within a specified distance from a specified coordinate. fixY $yCoordinate ( ndf $ConstrValues ) & lt ; -tol $tol & gt ; yCoordinate y-coordinate of nodes to be constrained constrValues ndf constraint values (0 or 1) corresponding to the ndf degrees-of-freedom. 0 unconstrained (or free) 1 constrained (or fixed) tol user-defined tolerance (optional, default = 1e-10) Examples fixY 0.0 1 1 1 1 1 1; # fully restrain all nodes in x=z plane at origin (y=0.0) FixZ command This command is used to construct multiple homogeneous single-point boundary constraints for all nodes whose z-coordinate lies within a specified distance from a specified coordinate. fixZ $zCoordinate ( ndf $ConstrValues ) & lt ; -tol $tol & gt ; zCordinate z-coordinate of nodes to be constrained constrValues ndf constraint values (0 or 1) corresponding to the ndf degrees-of-freedom. 0 unconstrained (or free) 1 constrained (or fixed) tol user-defined tolerance (optional, default = 1e-10) Examples fixZ 0.0 1 1 1 1 1 1; # fully restrain all nodes in x-y plane at origin (z=0.0) Fix command This command is used to construct single-point homogeneous boundary constraints. fix $nodeTag ( ndf $constrValues ) nodeTag integer tag identifying the node to be constrained constrValues ndf constraint values (0 or 1) corresponding to the ndf degrees-of-freedom. 0 unconstrained (or free) 1 constrained (or fixed) Examples fix 1 1 1 1 1 1 1 ; # node 1: fully fixed fix 2 0 1 0 0 1 0 # node 2 : homogeneous constraints ( movement = 0 ) at dof 2 and 5 only. Code Developed by: fmk","title":"Fix\n"},{"location":"library/1_Modeling/ndmaterial/","text":"NDMaterial Library This command is used to construct an NDMaterial object which represents the stress-strain relationship at the gauss-point of a continuum element. The valid queries to any uniaxial material when creating an ElementRecorder are \"strain\" , and \"stress\" . Some materials have additional queries to which they will respond. These are documented in the NOTES section for those materials. Wrappers See Prof. Scott\u2019s post here InitStressNDMaterial BeamFiberMaterial PlateFromPlaneStressMaterial wrapper adding linear-elastic shear behavior to a plane stress material in order to get the plate fiber stress condition. Elastic Elastic Isotropic Material Elastic Orthotropic Material PlaneStress2D ElasticIsotropicPlaneStress2D PlaneStrain2D ElasticIsotropicPlaneStrain2D AxiSymmetric2D ElasticIsotropicAxiSymm ThreeDimensional ElasticIsotropicThreeDimensional PlateFiber ElasticIsotropicPlateFiber BeamFiber ElasticIsotropicBeamFiber BeamFiber2d ElasticIsotropicBeamFiber2d Other J2 Plasticity Drucker Prager Concrete Damage Model Plane Stress Material Plane Strain Material Multi Axial Cyclic Plasticity Bounding Surface Cam Clay Material Plate Fiber Plane Stress Concrete Materials FSAM - 2D RC Panel Constitutive Behavior Tsinghua Sand Models CycLiqCP Material (Cyclic ElasticPlasticity) CycLiqCPSP Manzari Dafalias Material J2CyclicBoundingSurface Material PM4Sand PM4Silt Material (Beta) Stress Density Materials for Modeling Concrete Walls PlaneStressUserMaterial PlateFromPlaneStress PlateRebar LayeredShell Contact Materials for 2D and 3D ContactMaterial2D ContactMaterial3D Wrapper material for Initial State Analysis InitialStateAnalysisWrapper UC San Diego soil models (Linear/Nonlinear, dry/drained/undrained soil response under general 2D/3D static/cyclic loading conditions (please visit UCSD for examples) PressureIndependMultiYield Material PressureDependMultiYield Material PressureDependMultiYield02 Material PressureDependMultiYield03 Material UC San Diego Saturated Undrained soil FluidSolidPorousMaterial Misc. AcousticMedium Steel & Reinforcing-Steel Materials UVCmultiaxial (Updated Voce-Chaboche) UVCplanestress (Updated Voce-Chaboche)","title":"NDMaterial Library\n"},{"location":"library/1_Modeling/ndmaterial/113-CycLiqCP%20Material%20%28Cyclic%20ElasticPlasticity%29/","text":"CycLiqCP Material (Cyclic ElasticPlasticity) This command is used to construct a multi-dimensional material object that that follows the constitutive behavior of a cyclic elastoplasticity model for large post- liquefaction deformation. nDmaterial CycLiqCP $matTag $G0 $kappa $h $Mfc $dre1 $Mdc $dre2 $rdr $alpha $dir $ein < $rho > CycLiqCP material is a cyclic elastoplasticity model for large post-liquefaction deformation, and is implemented using a cutting plane algorithm. The model is capable of reproducing small to large deformation in the pre- to post-liquefaction regime. The elastic moduli of the model are pressure dependent. The plasticity in the model is developed within the framework of bounding surface plasticity, with special consideration to the formulation of reversible and irreversible dilatancy. matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus Mfc Stress ratio at failure in triaxial compression dre1 Coefficient for reversible dilatancy generation Mdc Stress ratio at which the reversible dilatancy sign changes dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d . Notes The model does not take into consideration of the state of sand, and requires different parameters for sand under different densities and confining pressures. The surfaces (i.e. failure and maximum pre-stress) are considered as circles in the pi plane. The model has been validated against VELACS centrifuge model tests and has used on numerous simulations of liquefaction related problems. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be linear elastic, with the updateMaterialStage command: updateMaterialStage - material $matTag - stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage - material $matTag - stage 1 The elastic modulii are given by the following relations: CycLiqCp.GIF References Zhang J.M. and Wang G., 2012, \u201cLarge post-liquefaction deformation of sand, part I: physical mechanism, constitutive description and numerical algorithm\u201d, Acta Geotechnica. Code Developed by: Rui Wang, Tsinghua University","title":"CycLiqCP Material (Cyclic ElasticPlasticity)\n"},{"location":"library/1_Modeling/ndmaterial/120-Damage2p/","text":"Damage2p This command is used to construct a three-dimensional material object that has a Drucker-Prager plasticity model coupled with a two-parameter damage model. nDMaterial Damage2p $matTag $fcc <-fct $fct> <-E $E> <-ni $ni> <-Gt $Gt> <-Gc $Gc> <-rho_bar $rho_bar> <-H $H> <-theta $theta> <-tangent $tangent> matTag integer tag identifying material fcc concrete compressive strength fct optional concrete tensile strength E optional Young modulus ni optional Poisson coefficient Gt optional tension fracture energy density Gc optional compression fracture energy density rho_bar ptional parameter of plastic volume change H optional linear hardening parameter for plasticity theta optional ratio between isotropic and kinematic hardening tangent optional integer to choose the computational stiffness matrix The material formulations for the Damage2p object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d NOTES Admissible values: The input parameters vary as follows: fcc negative real value (positive input is changed in sign automatically) fct positive real value (for concrete like materials is less than $fcc) Gt positive real value (integral of the stress-strain envelope in tension) Gc positive real value (integral of the stress-strain envelope after the peak in compression) rhoBar positive real value 0=rhoBar<sqrt(2/3) H positive real value (usually less than \\(E)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">theta</code></td> <td><p>positive real value 0=\\) theta=1 (with: 0 hardening kinematic only and 1 hardening isotropic only tangent 0: computational tangent; 1: damaged secant stiffness (hint: in case of strong nonlinearities use it with Krylov-Newton algorithm) Default values: The Damage2p object hve the following defualt parameters: fct = 0.1*abs(fcc) E = 4750*sqrt(abs(fcc)) if abs(fcc)<2000 because fcc is assumed in MPa (see ACI 318) = 57000*sqrt(abs(fcc)) if abs(fcc)>2000 because fcc is assumed in psi (see ACI 318) ni \u2019 = 0.15 (from comparison with tests by Kupfer Hilsdorf Rusch 1969) \u2019 \\(Gt</strong></p></td> <td><p>= 1840*fct*fct/E (from comparison with tests by Gopalaratnam and Shah 1985)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Gc</code></td> <td><p>= 6250*fcc*fcc/E (from comparison with tests by Karsan and Jirsa 1969)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rhoBar</code></td> <td><p>= 0.2 (from comparison with tests by Kupfer Hilsdorf Rusch 1969)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">H</code></td> <td><p>= 0.25*E (from comparison with tests by Karsan and Jirsa 1969 and Gopalaratnam and Shah 1985)</p></td> </tr> <tr class=\"even\"> <td><p><strong>'\\) theta = 0.5 (from comparison with tests by Karsan and Jirsa 1969 and Gopalaratnam and Shah 1985) tangent = 0 Development Team This code has been Developed by: Leopoldo Tesser - Dept. DICEA - Univeristy of Padua - Italy , contact: leopoldo.tesser AT dicea.unipd.it References Tesser L.,\u201cEfficient 3-D plastic damage model for cyclic inelastic analysis of concrete structures\u201d, Report of the University of Padua, Italy, 2012. (soon available at paduareserach.cab.unipd.it) Petek K.A., \u201cDevelopment and application of mixed beam-solid models for analysis of soil-pile interaction problems\u201d, Ph.D. dissertation, Univerisity of Washington, USA, 2006","title":"Damage2p\n"},{"location":"library/1_Modeling/ndmaterial/160-Drucker%20Prager/","text":"DruckerPrager This command is used to construct an multi dimensional material object that has a Drucker-Prager yield criterium. nDMaterial DruckerPrager $matTag $k $G $sigmaY $rho $rhoBar $Kinf $Ko $delta1 $delta2 $H $theta $density & lt ; $atmPressure & gt ; matTag integer tag identifying material k bulk modulus G shear modulus sigmaY yield stress rho frictional strength parameter rhoBar controls evolution of plastic volume change, \\(0 \\le \\texttt{rhoBar} \\le \\texttt{rho}\\) Kinf nonlinear isotropic strain hardening parameter, \\(\\texttt{Kinf} \\ge 0\\) Ko nonlinear isotropic strain hardening parameter, $Ko &ge; 0 delta1 nonlinear isotropic strain hardening parameter, $delta1 &ge; 0 delta2 tension softening parameter, \\(\\texttt{delta2} \\ge 0\\) H linear strain hardening parameter, \\(\\texttt{H} \\ge 0\\) theta controls relative proportions of isotropic and kinematic hardening, \\(0 \\le \\texttt{theta} \\le 1\\) density mass density of the material atmPressure optional atmospheric pressure for update of elastic bulk and shear moduli (default = 101 kPa) The material formulations for the Drucker-Prager object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d Theory The yield condition for the Drucker-Prager model can be expressed as \\[f\\left(\\mathbf{\\sigma}, q^{iso}, \\mathbf{q}^{kin}\\right) = \\left\\| \\mathbf{s} + \\mathbf{q}^{kin} \\right\\| + \\rho I_1 + \\sqrt{\\frac{2}{3}} q^{iso} - \\sqrt{\\frac{2}{3}} \\sigma_Y^{} \\leq 0 \\] in which \\[ \\mathbf{s} = \\mathrm{dev} (\\mathbf{\\sigma}) = \\mathbf{\\sigma} - \\frac{1}{3} I_1 \\mathbf{1} \\] is the deviatoric stress tensor, \\[ I_1 = \\mathrm{tr}(\\mathbf{\\sigma}) \\] is the first invariant of the stress tensor, and the parameters \\(\\rho_{}^{}\\) and \\(\\sigma_Y^{}\\) are positive material constants. The isotropic hardening stress is defined as \\[ q^{iso} = \\theta H \\alpha^{iso} + (K_{\\infty} - K_o) \\exp(-\\delta_1 \\alpha^{iso}) \\] The kinematic hardening stress (or back-stress) is defined as \\[ \\mathbf{q}^{kin} = -(1 - \\theta) \\frac{2}{3} H \\mathbb{I}^{dev} : \\mathbf{\\alpha}^{kin} \\] The yield condition for the tension cutoff yield surface is defined as \\[ f_2(\\mathbf{\\sigma}, q^{ten}) = I_1 + q^{ten} \\leq 0 \\] where \\[ q^{ten} = T_o \\exp(-\\delta_2^{} \\alpha^{ten}) \\] and \\[ T_o = \\sqrt{\\frac{2}{3}} \\frac{\\sigma_Y}{\\rho} \\] Further, general, information on theory for the Drucker-Prager yield criterion can be found at wikipedia here Notes The valid queries to the Drucker-Prager material when creating an ElementRecorder are \u2018strain\u2019 and \u2018stress\u2019 (as with all nDmaterial) as well as \u2018state\u2019. The query \u2018state\u2019 records a vector of state variables during a particular analysis. The columns of this vector are as follows. (Note: If the option \u2018-time\u2019 is included in the creation of the recorder, the first column will be the time variable for each recorded point and the columns below are shifted accordingly.) Column 1 - First invariant of the stress tensor, \\(I_1 = \\mathrm{tr}(\\mathbf{\\sigma})\\) . Column 2 - The following tensor norm, \\(\\left\\| \\mathbf{s} + \\mathbf{q}^{kin} \\right\\|\\) , where \\(\\mathbf{s}\\) is the deviatoric stress tensor and \\(\\mathbf{q}^{kin}\\) is the back-stress tensor. Column 3 - First invariant of the plastic strain tensor, \\(\\mathrm{tr}(\\mathbf{\\varepsilon}^p)\\) . Column 4 - Norm of the deviatoric plastic strain tensor, \\(\\left\\| \\mathbf{e}^p \\right\\|\\) The Drucker-Prager strength parameters \\(\\rho\\) and \\(\\sigma_Y\\) can be related to the Mohr-Coulomb friction angle, \\(\\phi\\) , and cohesive intercept, \\(c\\) , by evaluating the yield surfaces in a deviatoric plane as described by Chen and Saleeb (1994). By relating the two yield surfaces in triaxial compression, the following expressions are determined \\[ \\rho = \\frac{2 \\sqrt{2} \\sin \\phi}{\\sqrt{3} (3 - \\sin\\phi)}\\] \\[ \\sigma_Y = \\frac{6 c \\cos \\phi}{\\sqrt{2} (3 - \\sin \\phi)}\\] Example This example provides the input file and corresponding results for a confined triaxial compression (CTC) test using a single 8-node brick element and the Drucker-Prager constitutive model. A schematic representation of this test is shown below, (a) depicts the application of hydrostatic pressure, and (b) depicts the application of the deviator stress. Also shown is the stress path resulting from this test plotted on the meridian plane. As shown, the element is loaded until failure, at which point the model can no longer converge, as this is a stress-controlled analysis. Example Tcl script # File is generated for the purposes of testing the # Drucker-Prager model -->; conventional triaxial # compression test # # Created: 03.16.2009 CRM # Updated: 12.02.2011 CRM #---> Basic units used are kN and meters ## # create the modelBuilder and build the model</li> wipe model BasicBuilder - ndm 3 - ndf 3 # --create the nodes</li> node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 # --triaxial test boundary conditions</li> fix 1 0 1 1 fix 2 0 0 1 fix 3 1 0 1 fix 4 1 1 1 fix 5 0 1 0 fix 6 0 0 0 fix 7 1 0 0 fix 8 1 1 0 # --define material parameters for the model</li> # ---bulk modulus</li> set k 27777.78 # ---shear modulus</li> set G 9259.26 # ---yield stress</li> set sigY 5.0 # ---failure surface and associativity</li> set rho 0.398 set rhoBar 0.398 # ---isotropic hardening</li> set Kinf 0.0 set Ko 0.0 set delta1 0.0 # ---kinematic hardening</li> set H 0.0 set theta 1.0 # ---tension softening</li> set delta2 0.0 # ---mass density</li> set mDen 1.7 # --material models # type tag k G sigY rho rhoBar Kinf Ko delta1 delta2 H theta density nDMaterial DruckerPrager 2 $k $G $sigY $rho $rhoBar $Kinf $Ko $delta1 \\ $delta2 $H $theta $mDen # --create the element # type tag nodes matID bforce1 bforce2 bforce3 element stdBrick 1 1 2 3 4 5 6 7 8 2 0.0 0.0 0.0 puts \"model Built...\" # # create the recorders # set step 0.1 # record nodal displacements recorder Node - file displacements1.out - time - dT $step - nodeRange 1 8 - dof 1 2 3 disp # record the element stress, strain, and state at one of the Gauss # points recorder Element - ele 1 - time - file stress1.out - dT $step material 2 stress recorder Element - ele 1 - time - file strain1.out - dT $step material 2 strain recorder Element - ele 1 - time - file state1.out - dT $step material 2 state puts \"recorders set...\" # create the loading # --pressure magnitude set p 10.0 set pNode [expr - $p / 4 ] # --loading object for hydrostatic pressure pattern Plain 1 { Series - time { 0 10 100 } - values { 0 1 1 } - factor 1 } { load 1 $pNode 0.0 0.0 load 2 $pNode $pNode 0.0 load 3 0.0 $pNode 0.0 load 5 $pNode 0.0 0.0 load 6 $pNode $pNode 0.0 load 7 0.0 $pNode 0.0 } # --loading object deviator stress pattern Plain 2 { Series - time { 0 10 100 } - values { 0 1 5 } - factor 1 } { load 5 0.0 0.0 $pNode load 6 0.0 0.0 $pNode load 7 0.0 0.0 $pNode load 8 0.0 0.0 $pNode } # create the analysis integrator LoadControl 0.1 numberer RCM system SparseGeneral constraints Transformation test NormDispIncr 1 e-5 10 1 algorithm Newton analysis Static puts \"starting the hydrostatic analysis...\" set startT [ clock seconds ] analyze 1000 set endT [ clock seconds ] puts \"triaxial shear application finished...\" puts \"loading analysis execution time: [expr $endT-$startT] seconds.\" wipe References Drucker, D. C. and Prager, W., \u201cSoil mechanics and plastic analysis for limit design.\u201d Quarterly of Applied Mathematics, vol. 10, no. 2, pp. 157-165, 1952. Chen, W. F. and Saleeb, A. F., Constitutive Equations for Engineering Materials Volume I: Elasticity and Modeling. Elsevier Science B.V., Amsterdam, 1994. Code developed by: Peter Mackenzie, U Washington and the great Pedro Arduino, U Washington","title":"DruckerPrager\n"},{"location":"library/1_Modeling/ndmaterial/235-FSAM%20-%202D%20RC%20Panel%20Constitutive%20Behavior/","text":"FSAM - 2D RC Panel Constitutive Behavior This command is used to construct a nDMaterial FSAM (Fixed-Strut-Angle-Model, Figure 1, Kolozvari et al., 2015), which is a plane-stress constitutive model for simulating the behavior of RC panel elements under generalized, in-plane, reversed-cyclic loading conditions (Ulugtekin, 2010; Orakcal et al., 2012). In the FSAM constitutive model, the strain fields acting on concrete and reinforcing steel components of a RC panel are assumed to be equal to each other, implying perfect bond assumption between concrete and reinforcing steel bars. While the reinforcing steel bars develop uniaxial stresses under strains in their longitudinal direction, the behavior of concrete is defined using stress-strain relationships in biaxial directions, the orientation of which is governed by the state of cracking in concrete. Although the concrete stress-strain relationship used in the FSAM is fundamentally uniaxial in nature, it also incorporates biaxial softening effects including compression softening and biaxial damage. For transfer of shear stresses across the cracks, a friction-based elasto-plastic shear aggregate interlock model is adopted, together with a linear elastic model for representing dowel action on the reinforcing steel bars (Kolozvari, 2013). Note that FSAM constitutive model is implemented to be used with Shear-Flexure Interaction model for RC walls ( SFI_MVLEM ), but it could be also used elsewhere. Source: /usr/local/cvs/OpenSees/SRC/material/nD/reinforcedConcretePlaneStress/ Figure 1. FSAM for Converting In-Plane Strains to In-Plane Smeared Stresses on a RC Panel Element Input Format: nDMaterial FSAM $mattag $rho $sX $sY $conc $rouX $rouY $nu $alfadow mattag Unique nDMaterial tag rho Material density sX Tag of uniaxialMaterial simulating horizontal (x) reinforcement sY Tag of uniaxialMaterial simulating vertical (y) reinforcement conc Tag of uniaxialMaterial<sup class=\u201csuperscript\u201d>1</sup> simulating concrete rouX Reinforcing ratio in horizontal (x) direction (rouX = A<sub class=\u201csubscript\u201d>s,x /A<sub class=\u201csubscript\u201d>gross,x ) rouY Reinforcing ratio in vertical (y) direction (rouY = A<sub class=\u201csubscript\u201d>s,y /A<sub class=\u201csubscript\u201d>gross,y ) nu Concrete friction coefficient (0.0 < nu < 1.5) alfadow Stiffness coefficient of reinforcement dowel action (0.0 < alfadow < 0.05) 1 nDMaterial FSAM shall be used with uniaxialMaterial ConcreteCM Recommended values for parameter of a shear resisting mechanism ( nu and alfadow , Figure 2) are provided above. Details about the sensitivity of analytical predictions using SFI_MVLEM element to changes in these parameters are presented by Kolozvari (2013). Material Recorders: The following output is available from the FSAM RC panel model: panel_strain Strains \u03b5 x , \u03b5 y , \u03b3 xy (Figure 1) panel_stress Resulting panel stresses \u03c3 x , \u03c3 y , \u03c4 xy (concrete and steel, Figure 1) panel_stress_concrete Resulting panel concrete stresses \u03c3 xc , \u03c3 yc , \u03c4 xyc (Figure 2b) panel_stress_steel Resulting panel steel stresses \u03c3 xs , \u03c3 ys , \u03c4 xys (Figure 2e) strain_stress_steelX Uniaxial strain and stress of horizontal reinforcement \u03b5 x , \u03c3 xxs (Figure 2f) strain_stress_steelY Uniaxial strain and stress of vertical reinforcement \u03b5 y , \u03c3 yys (Figure 2f) strain_stress_concrete1 Uniaxial strain and stress of concrete strut 1 \u03b5 c1 , \u03c3 c1 (Figure 2c) strain_stress_concrete2 Uniaxial strain and stress of concrete strut 2 \u03b5 c2 , \u03c3 c2 (Figure 2c) strain_stress_interlock1 Shear strain and stress in concrete along crack 1 \u03b5 cr1 , \u03c4 cr1 (Figure 2d) strain_stress_interlock2 Shear strain and stress in concrete along crack 2 \u03b5 cr2 , \u03c4 cr2 (Figure 2d) cracking_angles Orientation of concrete cracks Note that recorders for a RC panel (marco-fiber) are invoked as SFI_MVLEM element recorders using command RCPanel and one of the desired commands listed above. Currently, it is possible to output values only for one macro-fiber within one or multiple elements. Examples nDMaterial FSAM 1 0.0 1 2 4 0.0073 0.0606 0.1 0.01 recorder Element - file MVLEM_panel_strain.out - time - ele 1 RCPanel 1 panel_strain Figure 2. Behavior and Input/Output Parameters of the FSAM Constitutive Model References Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Kolozvari K. (2013). \u201cAnalytical Modeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls\u201d, PhD Dissertation, University of California, Los Angeles. Orakcal K., Massone L.M., and Ulugtekin D. (2012). \u201cConstitutive Modeling of Reinforced Concrete Panel Behavior under Cyclic Loading\u201d, Proceedings, 15th World Conference on Earthquake Engineering, Lisbon, Portugal. Ulugtekin D. (2010). \u201cAnalytical Modeling of Reinforced Concrete Panel Elements under Reversed Cyclic Loadings\u201d, M.S. Thesis, Bogazici University, Istanbul, Turkey. Code developed by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal , Bogazici University, Istanbul, Turkey Leonardo Massone , University of Chile, Santiago John Wallace , Univeristy of California, Los Angeles","title":"FSAM - 2D RC Panel Constitutive Behavior\n"},{"location":"library/1_Modeling/ndmaterial/378-Manzari%20Dafalias%20Material/","text":"Manzari Dafalias Material This command is used to construct a multi-dimensional Manzari-Dafalias(2004) material. nDmaterial ManzariDafalias $matTag $G0 $nu $e_init $Mc $c $lambda_c $e0 $ksi $P_atm $m $h0 $ch $nb $A0 $nd $z_max $cz $Den matTag integer tag identifying material G0 shear modulus constant nu poisson ratio e_init initial void ratio Mc critical state stress ratio c ratio of critical state stress ratio in extension and compression lambda_c critical state line constant e0 critical void ratio at p = 0 ksi critical state line constant P_atm atmospheric pressure m yield surface constant (radius of yield surface in stress ratio space) h0 constant parameter ch constant parameter nb bounding surface parameter, $nb &ge; 0 A0 dilatancy parameter nd dilatancy surface parameter $nd &ge; 0 z_max fabric-dilatancy tensor parameter cz fabric-dilatancy tensor parameter Den mass density of the material The material formulations for the Manzari-Dafalias object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d Notes Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for \\(\\mathbf{\\alpha}\\) fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for \\(\\mathbf{\\alpha_{in}}\\) For example: recorder Element - eleRange 1 $numElem - time - file stress.out stress Elastic or Elastoplastic response could be enforced by Elastic updateMaterialStage - material $matTag - stage 0 Elastoplastic updateMaterialStage - material $matTag - stage 1 Theory \\[p = \\frac{1}{3} \\mathrm{tr}(\\mathbf{\\sigma})\\] \\[\\mathbf{s} = \\mathrm{dev} (\\mathbf{\\sigma}) = \\mathbf{\\sigma} - \\frac{1}{3} p \\mathbf{1}\\] Elasticity Elastic moduli are considered to be functions of p and current void ratio: \\[ G = G_0 p_{atm}\\frac{\\left(2.97-e\\right)^2}{1+e}\\left(\\frac{p}{p_{atm}}\\right)^{1/2}\\] \\[K = \\frac{2(1+\\nu)}{3(1-2\\nu)} G\\] The elastic stress-strain relationship is: \\[ d\\mathbf{e}^\\mathrm{e} = \\frac{d\\mathbf{s}}{2G}\\] \\[ d\\varepsilon^\\mathrm{e}_v = \\frac{dp}{K}\\] Critical State Line A power relationship is assumed for the critical state line: \\[e_c = e_0 - \\lambda_c\\left(\\frac{p_c}{p_{atm}}\\right)^\\xi \\] where \\(e_0\\) is the void ratio at \\(p_c = 0\\) and \\(\\lambda_c\\) and \\(\\xi\\) constants. Yield Surface Yield surface is a stress-ratio dependent surface in this model and is defined as \\[ \\left\\| \\mathbf{s} - p \\mathbf{\\alpha} \\right\\| - \\sqrt\\frac{2}{3}pm = 0 \\] with \\(\\mathbf{\\alpha}\\) being the deviatoric back stress-ratio. Plastic Strain Increment The increment of the plastic strain tensor is given by \\[ d\\mathbf{\\varepsilon}^p = \\langle L \\rangle \\mathbf{R} \\] where \\[ \\mathbf{R} = \\mathbf{R'} + \\frac{1}{3} D \\mathbf{1}\\] therefore \\[ d\\mathbf{e}^p = \\langle L \\rangle \\mathbf{R'}\\] and \\(d\\varepsilon^p_v = \\langle L \\rangle D\\) . The hardening modulus in this model is defined as \\[ K_p = \\frac{2}{3} p h (\\mathbf{\\alpha}^b_{\\theta} - \\mathbf{\\alpha}): \\mathbf{n}\\] where \\(\\mathbf{n}\\) is the deviatoric part of the gradient to yield surface. \\[ \\mathbf{\\alpha}^b_{\\theta} = \\sqrt{\\frac{2}{3}} \\left[g(\\theta,c) M_c exp(-n^b\\Psi) - m\\right] \\mathbf{n}\\] , \\(\\Psi\\) being the state parameter. The hardening parameter, \\(h\\) , is defined as \\[ h = \\frac{b_0}{(\\mathbf{\\alpha}-\\mathbf{\\alpha_{in}}):\\mathbf{n}} \\] , \\(\\mathbf{\\alpha_{in}}\\!\\) is the value of \\(\\mathbf{\\alpha}\\!\\) at initiation of loading cycle. \\[b_0 = G_0 h_0 (1-c_h e) \\left(\\frac{p}{p_{atm}}\\right)^{-1/2}\\] Also the dilation parameters are defined as \\[ D = A_d (\\mathbf{\\alpha}^d_{\\theta}-\\mathbf{\\alpha}) : \\mathbf{n} \\] \\[ \\mathbf{\\alpha}^d_{\\theta} = \\sqrt{\\frac{2}{3}} \\left[g(\\theta,c) M_c exp(n^d\\Psi) - m\\right] \\mathbf{n} \\] \\[ A_d = A_0 (1+\\langle \\mathbf{z : n}\\rangle)\\] where \\(\\mathbf{z}\\) is the fabric tensor. The evolution of fabric and the back stress-ratio tensors are defined as \\[d\\mathbf{z} = - c_z \\langle -d\\varepsilon^p_v \\rangle (z_{max}\\mathbf{n}+\\mathbf{z}) \\] \\[ d\\mathbf{\\alpha} = \\langle L \\rangle (2/3) h (\\mathbf{\\alpha}^b_{\\theta} - \\mathbf{\\alpha}) \\] Examples This example, provides an undrained confined triaxial compression test using one 8-node SSPBrickUP element and ManzariDafalias material model. Tcl script # HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH # # 3D Undrained Conventional Triaxial Compression Test Using One Element # # University of Washington, Department of Civil and Environmental Eng # # Geotechnical Eng Group, A. Ghofrani, P. Arduino - Dec 2013 # # Basic units are m, Ton(metric), s # # HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH # wipe # ------------------------ # # Test Specific parameters # # ------------------------ # # Confinement Stress set pConf - 300.0 # Deviatoric strain set devDisp - 0.3 # Permeablity set perm 1.0 e-10 # Initial void ratio set vR 0.8 # Rayleigh damping parameter set damp 0.1 set omega1 0.0157 set omega2 64.123 set a1 [expr 2.0 * $damp / ( $omega1 + $omega2 )] set a0 [expr $a1 * $omega1 * $omega2 ] # HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH # HHHHHHHHHHHHHHHHHHHHHHHHHHHCreate ModelHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH # HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH # Create a 3D model with 4 Degrees of Freedom model BasicBuilder - ndm 3 - ndf 4 # Create nodes node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 # Create Fixities fix 1 0 1 1 1 fix 2 0 0 1 1 fix 3 1 0 1 1 fix 4 1 1 1 1 fix 5 0 1 0 1 fix 6 0 0 0 1 fix 7 1 0 0 1 fix 8 1 1 0 1 # Create material # ManzariDafalias tag G0 nu e_init Mc c lambda_c e0 ksi P_atm m h0 ch nb A0 nd z_max cz Den nDMaterial ManzariDafalias 1 125 0.05 $vR 1.25 0.712 0.019 0.934 0.7 100 0.01 7.05 0.968 1.1 0.704 3.5 4 600 1.42 # Create element # SSPbrickUP tag i j k l m n p q matTag fBulk fDen k1 k2 k3 void alpha <b1 b2 b3> element SSPbrickUP 1 1 2 3 4 5 6 7 8 1 2.2 e6 1.0 $perm $perm $perm $vR 1.5 e-9 # Create recorders recorder Node - file disp.out - time - nodeRange 1 8 - dof 1 2 3 disp recorder Node - file press.out - time - nodeRange 1 8 - dof 4 vel recorder Element - file stress.out - time stress recorder Element - file strain.out - time strain recorder Element - file alpha.out - time alpha recorder Element - file fabric.out - time fabric # Create analysis constraints Penalty 1.0 e18 1.0 e18 test NormDispIncr 1.0 e-5 20 1 algorithm Newton numberer RCM system BandGeneral integrator Newmark 0.5 0.25 rayleigh $a0 0 . $a1 0.0 analysis Transient # Apply confinement pressure set pNode [expr $pConf / 4.0 ] pattern Plain 1 { Series - time { 0 10000 1 e10 } - values { 0 1 1 } - factor 1 } { load 1 $pNode 0.0 0.0 0.0 load 2 $pNode $pNode 0.0 0.0 load 3 0.0 $pNode 0.0 0.0 load 4 0.0 0.0 0.0 0.0 load 5 $pNode 0.0 $pNode 0.0 load 6 $pNode $pNode $pNode 0.0 load 7 0.0 $pNode $pNode 0.0 load 8 0.0 0.0 $pNode 0.0 } analyze 100 100 # Let the model rest and waves damp out analyze 50 100 # Close drainage valves for {set x 1 } { $x < 9 } { incr x } { remove sp $x 4 } analyze 50 100 # Read vertical displacement of top plane set vertDisp [ nodeDisp 5 3 ] # Apply deviatoric strain set lValues [ list 1 [expr 1 + $devDisp / $vertDisp ] [expr 1 + $devDisp / $vertDisp ]] set ts \"{Series -time {20000 1020000 10020000} -values {$lValues} -factor 1}\" # loading object deviator stress eval \"pattern Plain 2 $ts { sp 5 3 $vertDisp sp 6 3 $vertDisp sp 7 3 $vertDisp sp 8 3 $vertDisp }\" # Set number and length of (pseudo)time steps set dT 100 set numStep 10000 # Analyze and use substepping if needed set remStep $numStep set success 0 proc subStepAnalyze { dT subStep } { if { $subStep > 10 } { return - 10 } for {set i 1 } { $i < 3 } { incr i } { puts \"Try dT = $dT\" set success [ analyze 1 $dT ] if { $success != 0 } { set success [ subStepAnalyze [expr $dT / 2.0 ] [expr $subStep + 1 ]] if { $success == -10 } { puts \"Did not converge.\" return success } } else { if { $i == 1 } { puts \"Substep $subStep : Left side converged with dT = $dT\" } else { puts \"Substep $subStep : Right side converged with dT = $dT\" } } } return success } puts \"Start analysis\" set startT [ clock seconds ] while { $success != -10 } { set subStep 0 set success [ analyze $remStep $dT ] if { $success == 0 } { puts \"Analysis Finished\" break } else { set curTime [ getTime ] puts \"Analysis failed at $curTime . Try substepping.\" set success [ subStepAnalyze [expr $dT / 2.0 ] [ incr subStep ]] set curStep [expr int (( $curTime-20000 ) / $dT + 1 )] set remStep [expr int ( $numStep-$curStep )] puts \"Current step: $curStep , Remaining steps: $remStep\" } } set endT [ clock seconds ] puts \"loading analysis execution time: [expr $endT-$startT] seconds.\" wipe References Dafalias YF, Manzari MT. \u201cSimple plasticity sand model accounting for fabric change effects\u201d. Journal of Engineering Mechanics 2004 Code Developed by: Alborz Ghofrani, Pedro Arduino, U Washington","title":"Manzari Dafalias Material\n"},{"location":"library/1_Modeling/ndmaterial/405-MultiYieldSurfaceClay/","text":"MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the updateMaterialStage command. This model does not support further discretization of the strain increment in each iteration. nDmaterial MultiYieldSurfaceClay $matTag $nd $rho $G $K $cohesion $peakShearStrain matTag unique material object integer tag nd number of dimensions, 2 for 2-D analysis (plane-strain), and 3 for 3-D analysis rho saturated soil mass density G reference low-strain shear modulus K reference bulk modulus cohesion peak shear (apparent cohesion at zero effective confinement) peakShearStrain strain at peak shear, i.e., the octahedral shear strain at which the maximum shear strength is reached Note: For this material class, the sensitivity parameters can be: G, K, cohesion. References Gu Q., Conte J.P., Elgamal A., Yang Z. (2009). \u201cFinite element response sensitivity analysis of multi-yield-surface J2 plasticity model by direct differentiation method.\u201d Computer Methods in Applied Mechanics and Engineering, 198(30-32):2272-2285.","title":"MultiYieldSurfaceClay\n"},{"location":"library/1_Modeling/ndmaterial/65-Bounding%20Cam%20Clay/","text":"Bounding Cam Clay This command is used to construct a multi-dimensional bounding surface Cam Clay material object after Borja et al. (2001). nDMaterial BoundingCamClay $matTag $massDensity $C $bulkMod $OCR $mu_o $alpha $lambda $h $m matTag integer tag identifying material massDensity mass density C ellipsoidal axis ratio (defines shape of ellipsoidal loading/bounding surfaces) bulkMod initial bulk modulus OCR overconsolidation ratio mu_o initial shear modulus alpha pressure-dependency parameter for modulii (greater than or equal to zero) lambda soil compressibility index for virgin loading h hardening parameter for plastic response inside of bounding surface (if h = 0, no hardening) m hardening parameter (exponent) for plastic response inside of bounding surface (if m = 0, only linear hardening) The material formulations for the BoundingCamClay object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d General Information This nDMaterial object provides the bounding surface plasticity model of Borja et al. (2001) in which the bounding surface model is represented using modified Cam-Clay theory (Schofield and Wroth 1968). In addition to the standard capabilities of the Cam-Clay family of models (e.g., pressure dependence, hardening with plastic volumetric contraction, softening with plastic dilation, and coupled deviatoric and volumetric plastic deformation), the Borja et al. (2001) model has been enhanced to include an anisotropic bounding surface formulation that allows for consideration of hysteretic behaviour under cyclic loading. This bounding surface Cam-Clay model is coupled with a nonlinear hyperelastic model that considered pressure-dependency in the bulk and shear modulus. The full theory of this model is discussed in great detail in Borja et al. (2001). Notes The ellipsoidal axis ratio parameter $C is defined such that the ellipsoidal surfaces are C times as wide in the deviatoric direction as they are along the hydrostatic axis. When $C = 1, the surfaces are spherical. The overconsolidation ratio (input parameter $OCR) defines the relationship between the loading surface and bounding surface. The radius of the bounding surface, R, is equal to the product of the OCR and the radius of the loading surface, r. When the soil is normally consolidated and $OCR = 1, the bounding and loading surfaces are coincident and virgin loading will occur. When the hyperelastic pressure-dependency parameter (input parameter $alpha) is set to zero, the elastic shear modulus will be constant with a value equal to the initial shear modulus (input parameter $mu_o) and the deviatoric and volumetric responses are uncoupled in the elastic regime. The virgin compressibility parameter (input parameter $lambda) describes the relationship between the specific volume v = 1 + e and the logarithm of the mean effective stress (where e is the void ratio). This is is related to the compression index \\(C_c\\) that describes the relationship between the void ratio and the logarithm of the mean effective stress in consolidation testing. Usage Examples The following usage example provides the input parameters used in the single element examples of Borja et al. (2001). The initial bulk modulus is determined from the initial mean stress desired in the test (in this case p = 100 kPa) divided by the recompressibilty index kappa = 0.018. The units of this analysis are kN and m, thus the prescribed initial shear modulus of 5.4 MPa is input as 5400 kPa. The hardening parameter $h has the same units as the moduli. set rho 1.8 set c 1.0 set bulk 5555.56 set OCR 1.5 set mu_o 5.4 e3 set alpha 0.0 set lambda 0.13 set h 5.0 e3 set m 1.5 nDMaterial BoundingCamClay 1 $rho $c $bulk $OCR $mu_o $alpha $lambda $h $m References Borja, R.I., Lin, C.-H., and Montans, F.J. (2001) \u2018Cam-Clay plasticity, Part IV: Implicit integration of anisotropic bounding surface model with nonlinear hyperelasticity and ellipsoidal loading function,\u2019 Computer Methods in Applied Mechanics and Engineering, 190(26), 3293-3323, doi: 10.1016/S0045-7825(00)00301-7. Schofield, A. and Wroth, P. (1968) Critical State Soil Mechanics, McGraw Hill, New York. Example Analysis Code developed by: Chris McGann & Pedro Arduino , at the University of Washington","title":"Bounding Cam Clay\n"},{"location":"library/1_Modeling/ndmaterial/contact/102-ContactMaterial2D/","text":"ContactMaterial2D This command is used to construct a ContactMaterial2D nDMaterial object. nDMaterial ContactMaterial2D $matTag $mu $G $c $t matTag unique integer tag identifying nDMaterial object mu interface frictional coefficient G interface stiffness parameter c interface cohesive intercept t interface tensile strength The ContactMaterial2D nDMaterial defines the constitutive behavior of a frictional interface between two bodies in contact. The interface defined by this material object allows for sticking, frictional slip, and separation between the two bodies in a two-dimensional analysis. A regularized Coulomb frictional law is assumed. Information on the theory behind this material can be found in, e.g. Wriggers (2002). NOTE: The ContactMaterial2D nDMaterial has been written to work with the SimpleContact2D and BeamContact2D element objects. There are no valid recorder queries for this material other than those which are listed with those elements. EXAMPLE: ContactMaterial2D nDmaterial with tag 1 nDMaterial ContactMaterial2D 1 0.1 1000.0 0.0 0.0 References Wriggers, P. (2002). Computational Contact Mechanics. John Wilely & Sons, Ltd, West Sussex, England. Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"ContactMaterial2D\n"},{"location":"library/1_Modeling/ndmaterial/contact/103-ContactMaterial3D/","text":"ContactMaterial3D This command is used to construct a ContactMaterial3D nDMaterial object. nDMaterial ContactMaterial3D $matTag $mu $G $c $t matTag unique integer tag identifying nDMaterial object mu interface frictional coefficient G interface stiffness parameter c interface cohesive intercept t interface tensile strength The ContactMaterial3D nDMaterial defines the constitutive behavior of a frictional interface between two bodies in contact. The interface defined by this material object allows for sticking, frictional slip, and separation between the two bodies in a three-dimensional analysis. A regularized Coulomb frictional law is assumed. Information on the theory behind this material can be found in, e.g. Wriggers (2002). NOTE: The ContactMaterial3D nDMaterial has been written to work with the SimpleContact3D and BeamContact3D element objects. There are no valid recorder queries for this material other than those which are listed with those elements. EXAMPLE: ContactMaterial3D nDmaterial with tag 1 nDMaterial ContactMaterial3D 1 0.1 1000.0 0.0 0.0 Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington References: Wriggers, P. (2002). Computational Contact Mechanics. John Wilely & Sons, Ltd, West Sussex, England.","title":"ContactMaterial3D\n"},{"location":"library/1_Modeling/ndmaterial/elastic/188-Elastic%20Isotropic%20Material/","text":"Elastic Isotropic Material This command is used to construct an ElasticIsotropic material object. nDMaterial ElasticIsotropic $matTag $E $v & lt ; $rho & gt ; matTag integer tag identifying material E elastic Modulus v Poisson\u2019s ratio rho mass density, optional default = 0.0. The material formulations for the ElasticIsotropic object are \u201cThreeDimensional,\u201d \u201cPlaneStrain,\u201d \u201cPlane Stress,\u201d \u201cAxiSymmetric,\u201d and \u201cPlateFiber.\u201d Code Developed by: Micheal Scott, Oregon State University","title":"Elastic Isotropic Material\n"},{"location":"library/1_Modeling/ndmaterial/elastic/191-Elastic%20Orthotropic%20Material/","text":"Elastic Orthotropic Material This command is used to construct an ElasticOrthotropic material object. nDMaterial ElasticOrthotropic $matTag $Ex $Ey $Ez $vxy $vyz $vzx $Gxy $Gyz $Gzx < $rho > matTag integer tag identifying material Ex, Ey, Ez elastic modulii in three mutually perpendicular directions ( \\(x\\) , \\(y\\) , and \\(z\\) ) vxy, vyz, vzx Poisson\u2019s ratios Gxy, Gyz, Gzx shear modulii rho mass density, optional default = 0.0. The material formulations for the ElasticOrthotropic object are - ThreeDimensional , - PlaneStrain , - Plane Stress , - AxiSymmetric , - BeamFiber , and - PlateFiber . Code Developed by: Micheal Scott, Oregon State University","title":"Elastic Orthotropic Material\n"},{"location":"library/1_Modeling/ndmaterial/metalic/348-J2%20Plasticity%20Material/","text":"J2 Plasticity Material This command is used to construct an multi dimensional material object that has a von Mises (J2) yield criterium and isotropic hardening. nDMaterial J2Plasticity $matTag $K $G $sig0 $sigInf $delta $H matTag integer tag identifying material K bulk modulus G shear modulus sig0 initial yield stress sigInf final saturation yield stress delta exponential hardening parameter H linear hardening parameter The material formulations for the J2 object are \"ThreeDimensional\" , \"PlaneStrain\" , \"Plane Stress\" , \"AxiSymmetric\" and \"PlateFiber\" . Theory The theory for the non hardening case can be found http://en.wikipedia.org/wiki/Von_Mises_yield_criterion J2 isotropic hardening material class Elastic Model \\[\\sigma = K*\\operatorname{trace}(\\epsilon_e) + (2*G)*\\operatorname{dev}(\\epsilon_e)\\] Yield Function \\[\\phi(\\sigma, q) = || \\operatorname{dev}(\\sigma) || - \\sqrt(\\tfrac{2}{3}*q(\\xi)\\] Saturation Isotropic Hardening with linear term \\[q(\\xi) = \\sigma_0 + (\\sigma_\\inf - \\sigma_0)*\\exp(-delta*\\xi) + H*\\xi \\] Flow Rules \\[\\dot {\\epsilon_p} = \\gamma * \\frac{\\partial \\phi}{\\partial \\sigma} \\] \\[\\dot \\xi = -\\gamma * \\frac{\\partial \\phi}{\\partial q}\\] Linear Viscosity \\[\\gamma = \\frac{\\phi}{\\eta}\\] ( if \\(\\phi \\gt 0\\) ) Backward Euler Integration Routine Yield condition enforced at time \\(n+1\\) set \\(\\eta = 0\\) for rate independent case Code developed by: Ed Love","title":"J2 Plasticity Material\n"},{"location":"library/1_Modeling/ndmaterial/metalic/727-UVCmultiaxial%20%28Updated%20Voce-Chaboche%29/","text":"UVCmultiaxial (Updated Voce-Chaboche) This command is used to construct an Updated Voce-Chaboche (UVC) material for general multiaxial stress states (e.g., for solid/brick elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The plane-stress (e.g., for quad/plate/shell elements) and uniaxial (e.g., for beam elements) versions are also available. The plane-stress and uniaxial implementations have the exact same hardening rules as this general multiaxial model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. nDMaterial UVCmultiaxial $matTag $E $nu $fy $QInf $b $DInf $a $N $C1 $gamma1 & lt ; $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 & gt ; matTag Integer tag identifying the material. E Elastic modulus of the steel material. nu Poisson\u2019s ratio for the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <$C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples, validation, and UVC model parameters For the user, the only practical difference between the uniaxial and multiaxial/plane-stress implementations is the specification of Poisson\u2019s ratio in the list of input parameters. Further information on the UVC model is centralized at the UVCuniaxial web page. On the UVCuniaxial page you will find examples validating the model, and UVC model parameters for common structural steels that are applicable for all stress states. References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cConstitutive Modeling of Structural Steels: A Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCmultiaxial (Updated Voce-Chaboche)\n"},{"location":"library/1_Modeling/ndmaterial/metalic/728-UVCplanestress%20%28Updated%20Voce-Chaboche%29/","text":"UVCplanestress (Updated Voce-Chaboche) This command is used to construct an Updated Voce-Chaboche (UVC) material for plane-stress stress states (e.g., for quad/plate/shell elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The multiaxial (e.g., for solid/brick elements) and uniaxial (e.g., for beam elements) versions are also available. The multiaxial and uniaxial implementations have the exact same hardening rules as this plane-stress model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. nDMaterial UVCplanestress $matTag $E $nu $fy $QInf $b $DInf $a $N $C1 $gamma1 & lt ; $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 & gt ; matTag Integer tag identifying the material. E Elastic modulus of the steel material. nu Poisson\u2019s ratio for the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <$C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples, validation, and UVC model parameters For the user, the only practical difference between the uniaxial and multiaxial/plane-stress implementations is the specification of Poisson\u2019s ratio in the list of input parameters. Further information on the UVC model is centralized at the UVCuniaxial web page. On the UVCuniaxial page you will find examples validating the model, and UVC model parameters for common structural steels that are applicable for all stress states. References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cConstitutive Modeling of Structural Steels: A Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCplanestress (Updated Voce-Chaboche)\n"},{"location":"library/1_Modeling/ndmaterial/soil/111-CycLiqCPSP%20Material/","text":"CycLiqCPSP This command is used to construct a multi-dimensional material object based on a unified plasticity model for large post-liquefaction shear deformation of sand. nDmaterial CycLiqCPSP $matTag $G0 $kappa $h $M $dre1 $dre2 $rdr $alpha $dir $lambdac $ksi $e0 $np $nd $ein & lt ; $rho & gt ; CycLiqCPSP material is a constitutive model for sand with special considerations for cyclic behaviour and accumulation of large post-liquefaction shear deformation, and is implemented using a cutting plane algorithm. The model: (1) achieves the simulation of post-liquefaction shear deformation based on its physics, allowing the unified description of pre- and post-liquefaction behavior of sand; (2) directly links the cyclic mobility of sand with reversible and irreversible dilatancy, enabling the unified description of monotonic and cyclic loading; (3) introduces critical state soil mechanics concepts to achieve unified modelling of sand under different states. The critical, maximum stress ratio and reversible dilatancy surfaces follow a rounded triangle in the pi plane similar to the Matsuoka-Nakai criterion. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be non-linear elastic, with the updateMaterialStage command: updateMaterialStage -material $matTag -stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage -material $matTag -stage 1 If a linear elastic stage is required, it can be achieved through: updateMaterialStage -material $matTag -stage 2 matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus M Critical state stress ratio dre1 Coefficient for reversible dilatancy generation dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential lambdac Critical state constant ksi Critical state constant e0 Void ratio at pc=0 np Material constant for peak mobilized stress ratio nd Material constant for reversible dilatancy generation stress ratio ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCPSP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d. REFERENCES: Wang R., Zhang J.M., Wang G., 2014. A unified plasticity model for large post-liquefaction shear deformation of sand. Computers and Geotechnics. 59, 54-66. Code Developed by: Rui Wang, Tsinghua University","title":"CycLiqCPSP\n"},{"location":"library/1_Modeling/ndmaterial/soil/117-Cyclic%20ElastocPlasticity/","text":"Cyclic ElastocPlasticity This command is used to construct a multi-dimensional material object that that follows the constitutive behavior of a cyclic elastoplasticity model for large post- liquefaction deformation. nDmaterial CycLiqCP $matTag $G0 $kappa $h $Mfc $dre1 $Mdc $dre2 $rdr $alpha $dir $ein & lt ; $rho & gt ; CycLiqCP material is a cyclic elastoplasticity model for large post-liquefaction deformation, and is implemented using a cutting plane algorithm. The model is capable of reproducing small to large deformation in the pre- to post-liquefaction regime. The elastic moduli of the model are pressure dependent. The plasticity in the model is developed within the framework of bounding surface plasticity, with special consideration to the formulation of reversible and irreversible dilatancy. The model has been validated against VELACS centrifuge model tests and has used on numerous simulations of liquefaction related problems. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be linear elastic, with the updateMaterialStage command: updateMaterialStage -material $matTag -stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage -material $matTag -stage 1 matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus Mfc Stress ratio at failure in triaxial compression dre1 Coefficient for reversible dilatancy generation Mdc Stress ratio at which the reversible dilatancy sign changes dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d. REFERENCES: Zhang J.M. and Wang G., 2012, \u201cLarge post-liquefaction deformation of sand, part I: physical mechanism, constitutive description and numerical algorithm\u201d, Acta Geotechnica. Code Developed by: Rui Wang, Tsinghua University","title":"Cyclic ElastocPlasticity\n"},{"location":"library/1_Modeling/ndmaterial/soil/487-PM4Sand%20Material/","text":"PM4Sand This page has been moved to the new OpenSees documentation site This command is used to construct a 2-dimensional PM4Sand material. nDmaterial PM4Sand $matTag $Dr $G0 $hpo $Den & lt ; $patm $h0 $emax $emin $nb $nd $Ado $zmax $cz $ce $phic $nu $cgd $cdr $ckaf $Q $R $m $Fsed_min $p_sedo & gt ; matTag integer tag identifying material Primary : Dr Relative density, in fraction G0 Shear modulus constant hpo Contraction rate parameter Den Mass density of the material Secondary : P_atm Optional , Atmospheric pressure h0 Optional , Variable that adjusts the ratio of plastic modulus to elastic modulus $emax and $emin Optional , Maximum and minimum void ratios nb Optional , Bounding surface parameter, $nb &ge; 0 nd Optional , Dilatancy surface parameter $nd &ge; 0 Ado Optional , Dilatancy parameter, will be computed at the time of initialization if input value is negative z_max Optional , Fabric-dilatancy tensor parameter cz Optional , Fabric-dilatancy tensor parameter ce Optional , Variable that adjusts the rate of strain accumulation in cyclic loading phic Optional , Critical state effective friction angle nu Optional , Poisson\u2019s ratio cgd Optional , Variable that adjusts degradation of elastic modulus with accumulation of fabric cdr Optional , Variable that controls the rotated dilatancy surface ckaf Optional , Variable that controls the effect that sustained static shear stresses have on plastic modulus Q Optional , Critical state line parameter R Optional , Critical state line parameter m Optional , Yield surface constant (radius of yield surface in stress ratio space) Fsed_min Optional , Variable that controls the minimum value the reduction factor of the elastic moduli can get during reconsolidation p_sedo Optional , Mean effective stress up to which reconsolidation strains are enhanced The material formulation for the PM4Sand object is \u201cPlaneStrain\u201d Code Developed by: Long Chen, Pedro Arduino, U Washington Notes This page has been moved to the new OpenSees documentation site Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for <math></math> fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for <math></math> e.g. recorder Element -eleRange 1 $numElem -time -file stress.out stress Elastic or Elastoplastic response could be enforced by {| |Elastic: ||updateMaterialStage -material $matTag -stage 0 |- |Elastoplastic: ||updateMaterialStage -material $matTag -stage 1 |} The program will use the default value of a secondary parameter if a negative input is assigned to that parameter, e.g. Ado = -1. However, FirstCall is mandatory when switching from elastic to elastoplastic if negative inputs are assigned to stress-dependent secondary parameters, e.g. Ado and zmax. FirstCall can be set as, setParameter -value 0 -ele $elementTag FirstCall $matTag Post-shake reconsolidation can be activated by setParameter -value 1 -ele $elementTag Postshake $matTag The user should check that the results are not sensitive to time step size. Example <table border=1 width=600> <tr> <td width=90> Example 1 </td> <td>2D undrained monotonic direct simple shear test using one element</td> </tr> <tr> <td> Example 2 </td> <td>2D undrained cyclic direct simple shear test using one element</td> </tr> </table> References R.W.Boulanger, K.Ziotopoulou. \u201cPM4Sand(Version 3.1): A Sand Plasticity Model for Earthquake Engineering Applications\u201d. Report No. UCD/CGM-17/01 2017","title":"PM4Sand\n"},{"location":"library/1_Modeling/ndmaterial/soil/488-PM4Silt%20Material%20%28Beta%29/","text":"PM4Silt Material (Beta) This page has been moved to the new OpenSees documentation site This command is used to construct a 2-dimensional PM4Silt material. nDMaterial PM4Silt $matTag $S_u $Su_Rat $G_o $h_po $Den & lt ; $Su_factor $Patm $nu $nG $h0 $eInit $lambda $phicv $nb_wet $nb_dry $nd $Ado $ru_max $zmax $cz $ce $Cgd $ckaf $m_m $CG_consol & gt ; matTag integer tag identifying material Primary : S_u Undrained shear strength Su_Rat Undrained shear strength ratio. If both S_u and Su_Rat values are specified, the value of S_u is used. G_o Shear modulus constant h_po Contraction rate parameter Den Mass density of the material Su_factor Optional , Undrained shear strength reduction factor P_atm Optional , Atmospheric pressure Secondary : nu Optional , Poisson\u2019s ratio. Default value is 0.3. nG Optional , Shear modulus exponent. Default value is 0.75. h0 Optional , Variable that adjusts the ratio of plastic modulus to elastic modulus. Default value is 0.5. eInit Optional , Initial void ratios. Default value is 0.90. lambda Optional , The slope of critical state line in e-ln(p) space. Default value is 0.060. phicv Optional , Critical state effective friction angle. Default value is 32 degrees. nb_wet Optional , Bounding surface parameter for loose of critical state conditions, 1.0 &ge; $nb_wet &ge; 0.01. Default value is 0.8. nb_dry Optional , Bounding surface parameter for dense of critical state conditions, $nb_dry &ge; 0. Default value is 0.5. nd Optional , Dilatancy surface parameter $nd &ge; 0. Default value is 0.3. Ado Optional , Dilatancy parameter. Default value is 0.8. ru_max Optional , Maximum pore pressure ratio based on p\u2019. z_max Optional , Fabric-dilatancy tensor parameter cz Optional , Fabric-dilatancy tensor parameter. Default value is 100.0. ce Optional , Variable that adjusts the rate of strain accumulation in cyclic loading cgd Optional , Variable that adjusts degradation of elastic modulus with accumulation of fabric. Default value is 3.0. ckaf Optional , Variable that controls the effect that sustained static shear stresses have on plastic modulus. Default value is 4.0. m_m Optional , Yield surface constant (radius of yield surface in stress ratio space). Default value is 0.01. CG_consol Optional , Reduction factor of elastic modulus for reconsolidation. $CG_consol &ge; 1. Default value is 2.0. The material formulation for the PM4Silt object is \u201cPlaneStrain\u201d Code Developed by: Long Chen, Pedro Arduino, U Washington Notes Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for <math></math> fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for <math></math> e.g. recorder Element -eleRange 1 $numElem -time -file stress.out stress Elastic or Elastoplastic response could be enforced by {| |Elastic: ||updateMaterialStage -material $matTag -stage 0 |- |Elastoplastic: ||updateMaterialStage -material $matTag -stage 1 |} If default values are used for secondary parameters, the model must be initialized after elastic gravity stage by setParameter -value 0 -ele $elementTag FirstCall $matTag Post-shake reconsolidation can be activated by setParameter -value 1 -ele $elementTag Postshake $matTag Example <table border=1 width=600> <tr> <td width=90> Example 1 </td> <td>2D undrained monotonic direct simple shear test using one element</td> </tr> <tr> <td> Example 2 </td> <td>2D undrained cyclic direct simple shear test using one element</td> </tr> </table> References R.W.Boulanger, K.Ziotopoulou. \u201cPM4Silt(Version 1): A Silt Plasticity Model for Earthquake Engineering Applications\u201d. Report No. UCD/CGM-18/01 2018","title":"PM4Silt Material (Beta)\n"},{"location":"library/1_Modeling/ndmaterial/soil/671-Stress%20Density%20Material/","text":"Stress Density Material This command is used to construct a multi-dimensional stress density material object for modeling sand behaviour following the work of Cubrinovski and Ishihara (1998a,b). Note that as of January 2020 this material is still undergoing verification testing for more complex loading and initial conditions. nDMaterial stressDensity $matTag $mDen $eNot $A $n $nu $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot $muCyc $sc $M $patm < $ssl1 $ssl2 $ssl3 $ssl4 $ssl5 $ssl6 $ssl7 $hsl $pmin > matTag integer tag identifying material mDen mass density eNot initial void ratio A constant for elastic shear modulus n pressure dependency exponent for elastic shear modulus nu Poisson\u2019s ratio a1 peak stress ratio coefficient (etaMax = a1 + b1*Is) b1 peak stress ratio coefficient (etaMax = a1 + b1*Is) a2 max shear modulus coefficient (Gn_max = a2 + b2*Is) b2 max shear modulus coefficient (Gn_max = a2 + b2*Is) a3 min shear modulus coefficient (Gn_min = a3 + b3*Is) b3 min shear modulus coefficient (Gn_min = a3 + b3*Is) fd degradation constant muNot dilatancy coefficient (monotonic loading) muCyc dilatancy coefficient (cyclic loading) sc dilatancy strain M critical state stress ratio patm atmospheric pressure (in appropriate units) Optional steady state line parameters (default values shown for each, be careful with units) ssl1 void ratio of quasi steady state (QSS-line) at pressure $pmin (default = 0.877) ssl2 void ratio of quasi steady state (QSS-line) at 10 kPa (default = 0.877) ssl3 void ratio of quasi steady state (QSS-line) at 30 kPa (default = 0.873) ssl4 void ratio of quasi steady state (QSS-line) at 50 kPa (default = 0.870) ssl5 void ratio of quasi steady state (QSS-line) at 100 kPa (default = 0.860) ssl6 void ratio of quasi steady state (QSS-line) at 200 kPa (default = 0.850) ssl7 void ratio of quasi steady state (QSS-line) at 400 kPa (default = 0.833) hsl void ratio of upper reference state (UR-line) for all pressures (default = 0.895) pmin pressure corresponding to $ssl1 (default = 1.0 kPa) The material formulations for the stressDensity object are \u201cPlaneStrain\u201d General Information This nDMaterial object provides the stress density model for sands under monotonic and cyclic loading as set forth by Cubrinovski and Ishihara (1998a,b). The original formulation for this model was applicable to plane strain conditions and this is the only currently available formulation. Notes Examples The following example provides the input parameters for dry pluviated Toyura sand (with initial void ratio e = 0.73) after Cubrinovski and Ishihara (1998b). The units of this analysis are Mg, kN, s, and m. # mass density set mDen 1.8 # atmospheric pressure set patm 98.1 # stress density model parameters set eNot 0.730 set A 250.0 set n 0.60 set a1 0.58 set b1 0.023 set a2 230.0 set b2 65.0 set a3 79.0 set b3 16.0 set fd 4.0 set muNot 0.22 set muCyc 0.0 set sc 0.0055 set M 0.607 nDMaterial stressDensity 1 $mDen \\ $eNot $A $n $nu $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot $ muCyc $sc $M $patm Example Analysis Element test with pure shear loading starting from isotropic initial state of stress. Tcl Script # intended number of cycles in the test set nCycles 120 # shear strain increment for the test set dg 0.0001 set wg [expr 2.0 * $dg ] # max number of steps set maxStep 20000 # initial confinement pressure (kPa) set pNot - 95.0 # max/min shear stress in the test (kPa) set CSR 0.2 set maxShear [expr - $CSR * $pNot ] wipe model BasicBuilder - ndm 2 - ndf 2 # Create nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # Create fixities fix 1 1 1 fix 2 1 1 fix 3 1 1 fix 4 1 1 # atmospheric pressure set patm 98.1 # mass density set mDen 1.8 # steady state line void ratio set ssl1 0.832 set ssl2 0.832 set ssl3 0.810 set ssl4 0.796 set ssl5 0.776 set ssl6 0.756 set ssl7 0.735 # hydrostatic state line void ratio set hsl 0.852 # reference pressures for state lines set p1 1.0 # stress density model parameters set A 250.0 set m 0.60 set nu 0.20 set a1 0.592 set b1 0.021 set a2 291.0 set b2 55.0 set a3 98.0 set b3 13.0 set fd 4.0 set muNot 0.15 set sc 0.0055 set M 0.607 # initial void ratio set emax 0.885 set emin 0.541 set Dr 0.54 set eNot [expr $emax - $Dr * ( $emax-$emin )] set muCyc 0.0 # Create material nDMaterial stressDensity 2 $mDen $eNot $A $m $nu \\ $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot $muCyc \\ $sc $M $patm $ssl1 $ssl2 $ssl3 $ssl4 $ssl5 $ssl6 $ssl7 $hsl $p1 nDMaterial InitStress 1 2 $pNot 2 # Create element element SSPquad 1 1 2 3 4 1 PlaneStrain 1.0 0.0 0.0 # Create recorders recorder Element - file stress.out - time stress recorder Element - file strain.out - time strain recorder Node - file disp.out - time - dof 1 2 disp set dt 0.1 # Create analysis constraints Penalty 1.0 e18 1.0 e18 algorithm Linear numberer RCM system ProfileSPD integrator LoadControl $dt analysis Static set dMax [expr 0.6 / $wg ] eval \"timeSeries Path 400 -time {0 0.1 0.2 300.2} -values {0 0 0 $dMax} -factor 1.0\" pattern Plain 400 400 { sp 3 1 $wg sp 4 1 $wg } analyze 1 setParameter - value 1 - ele 1 materialState analyze 1 # counter for max number of steps set count 0 set cCount 0 set cyc 1 puts \"Beginning of Cycle 1\" # loop through the total number of cycles for {set i 1 } { $i <= [expr 2 * $nCycles ]} { incr i } { if { $cCount == 2 } { set cyc [expr $cyc + 1 ] puts \"Beginning of Cycle $cyc\" set cCount 0 } # loop within each cycle for {set j 1 } { $j < 5000 } { incr j } { # abort if count is greater than max number of steps if { $count & gt ; = $maxStep } {break} # analyze single step and get the current stress analyze 1 set count [expr $count + 1 ] # get stress from element set stress [ eleResponse 1 stress ] # shear stress is component 2 set tau [ lindex $stress 2 ] # signal change in loading direction if needed if {[expr abs ( $tau )] >= $maxShear } { # get strain from element set strain [ eleResponse 1 strain ] set gamma [ lindex $strain 2 ] puts \"direction change required: tau = $tau; gamma = $gamma\" # get current displacements of shearing nodes set f [expr 2.0 * [ nodeDisp 3 1 ]] set b [expr 2.0 * [ nodeDisp 4 1 ]] # puts \"current displacement of front row is $f\" # puts \"current displacement of back row is $b\" # get number of steps required to reach current disp from zero set nStep [expr round ( abs ( $b / $wg ))] # puts \"there are $nStep steps needed to get back to neutral loading\" # get current time set cTime [ getTime ] # puts \"current time is $cTime\" # set an end time for the load patterns set zTime [expr $cTime + $nStep * $dt ] set eTime [expr $zTime + 100.0 * $nStep ] # puts \"end time for the new load pattern is $eTime\" remove loadPattern [expr 400 + $i-1 ] eval \"timeSeries Path [expr 400+$i] -time {$cTime $eTime 1e10} -values {1 -1000 -1000}\" pattern Plain [expr 400 + $i ] [expr 400 + $i ] { sp 3 1 $b sp 4 1 $b } set cCount [expr $cCount + 1 ] break } } } wipe References Cubrinovski, M. and Ishihara K. (1998a) \u2018Modelling of sand behaviour based on state concept,\u2019 Soils and Foundations, 38(3), 115-127. Cubrinovski, M. and Ishihara K. (1998b) \u2018State concept and modified elastoplasticity for sand modelling,\u2019 Soils and Foundations, 38(4), 213-225. Code developed by: Saumyashuchi Das , University of Canterbury. Maintained by: Chris McGann","title":"Stress Density Material\n"},{"location":"library/1_Modeling/ndmaterial/wrapper/338-InitialStateAnalysisWrapper/","text":"InitialStateAnalysisWrapper This command is used to construct an InitialStateAnalysisWrapper nDMaterial object. nDMaterial InitialStateAnalysisWrapper $matTag $nDMatTag $nDim eleTag unique integer tag identifying nDMaterial object nDMatTag the tag of the associated nDMaterial object nDim number of dimensions (2 for 2D, 3 for 3D) The InitialStateAnalysisWrapper nDMaterial allows for the use of the InitialStateAnalysis command for setting initial conditions. The InitialStateAnalysisWrapper can be used with any nDMaterial. This material wrapper allows for the development of an initial stress field while maintaining the original geometry of the problem. An example analysis is provided below to demonstrate the use of this material wrapper object. NOTES: There are no valid recorder queries for the InitialStateAnalysisWrapper. The InitialStateAnalysis off command removes all previously defined recorders. Two sets of recorders are needed if the results before and after this command are desired. See the example below for more. The InitialStateAnalysisWrapper material is somewhat tricky to use in dynamic analysis. Sometimes setting the displacement to zero appears to be interpreted as an initial displacement in subsequent steps, resulting in undesirable vibrations. EXAMPLES: InitialStateAnalysisWrapper definition with material tag 1, and associated nDMaterial tag 2 for a 2D analysis nDMaterial InitialStateAnalysisWrapper 1 2 2 Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington EXAMPLE ANALYSIS: The example input file below demonstrates an how the InitialStateAnalysis command can be used with the InitialStateAnalysisWrapper to generate a gravitational state of stress in a single element. As shown below, the use of the InitialStateAnalysis command necessitates the use of two sets of recorders, one to record results during the initial state analysis, and one for all subsequent steps. It is not required to record results during the initial state analysis, but the example below includes this data to demonstrate the effect of the InitialStateAnalysis command. At the end of the analysis, there should be non-zero stress and strain in the element with zero displacement. wipe </ p > < p > model BasicBuilder - ndm 3 - ndf 3 </ p > < ol > < li > create the nodes </ li > </ ol > < p > node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 </ p > < ol > < li > boundary conditions </ li > </ ol > < p > fix 1 1 1 1 fix 2 1 1 1 fix 3 1 1 1 fix 4 1 1 1 fix 5 1 1 0 fix 6 1 1 0 fix 7 1 1 0 fix 8 1 1 0 </ p > < ol > < li > define main material obeject </ li > </ ol > < p > nDMaterial ElasticIsotropic 1 25000 0.35 </ p > < ol > < li > define material wrapper </ li > </ ol > < p > nDMaterial InitialStateAnalysisWrapper 2 1 3 </ p > < ol > < li > create the element ( NOTE : the material tag associated with this element is that of the wrapper ) </ li > </ ol > < p > element SSPbrick 1 1 2 3 4 5 6 7 8 2 0.0 0.0 - 17.0 </ p > < ol > < li > create the pre-gravity recorders </ li > </ ol > < p > set step 0.1 </ p > < p > recorder Node - time - file Gdisp.out - dT $step - nodeRange 5 8 - dof 1 2 3 disp recorder Element - ele 1 - time - file Gstress.out - dT $step stress recorder Element - ele 1 - time - file Gstrain.out - dT $step strain </ p > < ol > < li > create the gravity analysis </ li > </ ol > < p > integrator LoadControl 0.5 numberer RCM system SparseGeneral constraints Transformation test NormDispIncr 1 e-5 40 1 algorithm Newton analysis Static </ p > < ol > < li > turn on the initial state analysis feature </ li > </ ol > < p > InitialStateAnalysis on </ p > < ol > < li > analyze four steps </ li > </ ol > < p > analyze 4 </ p > < ol > < li > turn off the initial state analysis feature </ li > </ ol > < p > InitialStateAnalysis off </ p > < ol > < li > create post-gravity recorders </ li > </ ol > < p > recorder Node - time - file disp.out - dT $step - nodeRange 5 8 - dof 1 2 3 disp recorder Element - ele 1 - time - file stress.out - dT $step stress recorder Element - ele 1 - time - file strain.out - dT $step strain </ p > < ol > < li > analyze for three steps, should have non-zero stress and strain with zero displacement </ li > </ ol > < p > analyze 3 </ p > < p > wipe","title":"InitialStateAnalysisWrapper\n"},{"location":"library/1_Modeling/ndmaterial/wrapper/511-Plane%20Strain%20Material/","text":"Plane Strain Material This command is used to construct a plane-stress material wrapper which converts any three-dimensional material into a plane strain material by imposing plain strain conditions on the three-dimensional material. nDMaterial PlaneStrain $matTag $threeDtag matTag integer tag identifying material threeDTag integer tag of previously defined 3d ndMaterial material The material formulations for the PlaneStrain object are \u201c\u201cPlane Strain\u201d Code Developed by: Antonios Vytiniotis, MIT","title":"Plane Strain Material\n"},{"location":"library/1_Modeling/ndmaterial/wrapper/513-Plane%20Stress%20Material/","text":"Plane Stress Material This command is used to construct a plane-stress material wrapper which converts any three-dimensional material into a plane stress material via static condensation. nDMaterial PlaneStress $matTag $threeDtag matTag integer tag identifying material otherTag tag of perviously defined 3d ndMaterial material The material formulations for the PlaneStress object are \u201c\u201cPlane Stress\u201d Code Developed by: Ed Love","title":"Plane Stress Material\n"},{"location":"library/1_Modeling/ndmaterial/wrapper/514-Plate%20Fiber%20Material/","text":"Plate Fiber Material This command is used to construct a plate-fiber material wrapper which converts any three-dimensional material into a plate fiber material (by static condensation) appropriate for shell analysis. nDMaterial PlateFiber $matTag $threeDTag matTag integer tag identifying material threeDTag material tag for a previously-defined three-dimensional material","title":"Plate Fiber Material\n"},{"location":"library/1_Modeling/section/","text":"Section Command <noinclude>This command is used to construct a SectionForceDeformation object, hereto referred to as Section, which represents force-deformation (or resultant stress-strain) relationships at beam-column and plate sample points. section secType ? secTag ? arg1 ? ... The type of section created and the additional arguments required depends on the secType? provided in the command. NOTE: The valid queries to any section when creating an ElementRecorder are \u2018force\u2019, and \u2018deformation\u2019. Some sections have additional queries to which they will respond. These are documented in the NOTES section for those sections. The following contain information about secType? and the args required for each of the available section types:</noinclude> Elastic Section Fiber Section NDFiber Section Wide Flange Section RC Section Parallel Section Section Aggregator Uniaxial Section Elastic Membrane Plate Section Plate Fiber Section Bidirectional Section Isolator2spring Section","title":"Section Command\n"},{"location":"library/1_Modeling/section/190-Elastic%20Membrane%20Plate%20Section/","text":"Elastic Membrane Plate Section This command allows the user to construct an ElasticMembranePlateSection object, which is an isotropic section appropriate for plate and shell analysis. section ElasticMembranePlateSection $secTag $E $nu $h $rho secTag unique section tag E Young\u2019s Modulus nu Poisson\u2019s Ratio h depth of section rho mass density Code Developed by: Edward \u201cEddie\u201d Love","title":"Elastic Membrane Plate Section\n"},{"location":"library/1_Modeling/section/192-Elastic%20Section/","text":"Elastic Section This command allows the user to construct an ElasticSection. The inclusion of shear deformations is optional. section Elastic $secTag $E $A \\(Iz &lt;\\) G $alphaY> section Elastic $secTag $E $A $Iz $Iy $G \\(J &lt;\\) alphaY $alphaZ> secTag unique section tag E Young\u2019s Modulus A cross-sectional area of section Iz second moment of area about the local z-axis Iy second moment of area about the local y-axis (required for 3D analysis) G Shear Modulus (optional for 2D analysis, required for 3D analysis) J torsional moment of inertia of section (required for 3D analysis) alphaY shear shape factor along the local y-axis (optional) alphaZ shear shape factor along the local z-axis (optional) NOTES: The elastic section can be used in the nonlinear beam column elements, which is useful in the initial stages of developing a complex model. Code Developed by: fmk ElasticSection3D #include <material/section/ElasticSection3D.h> class ElasticSection3D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation ElasticSection3D provides the implementation of a section which exhibits uncoupled elastic behavior in axial, moment, shear, and torsion response. Constructor Destructor // Public Methods // Public Methods for Output To construct an ElasticSection3D with an integer identifier tag , an elastic modulus of \\(E\\) , a second moment of area about the local z-axis, \\(I_z\\) , a second moment of area about the local y-axis, \\(I_y\\) , a polar moment of intertia of \\(J\\) , a section area of \\(A\\) , an elastic shear modulus of \\(G\\) , and a shape factor of \\(\\alpha\\) . The integers tag and MAT_TAG_ElasticSection3D, defined in <classTags.h> , are passed to the SectionForceDeformation class constructor. Constructs a blank ElasticSection3D object. Does nothing. Sets the value of the section deformation vector, \\(\\esec\\) to be def . The section deformation vector, \\(\\esec\\) , is defined by \\[\\esec := \\left[ \\begin{array}{c} \\epsilon_a \\\\ \\kappa_z \\\\ \\kappa_y \\\\ \\gamma_y \\\\ \\gamma_z \\\\ \\phi \\end{array} \\right]\\] where \\(\\epsilon_a\\) is the axial strain, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\gamma_y\\) is the shear strain along the local y-axis, \\(\\gamma_z\\) is the shear strain along the local z-axis, and \\(\\phi\\) is the angle of twist. Returns \\(0\\) . Returns the current value of the section deformation vector, \\(\\esec\\) . Returns the section stress resultants, \\(\\ssec\\) , the product of the section stiffness matrix, \\(\\ksec\\) , and the section deformation vector, \\(\\esec\\) , \\[\\ssec = \\ksec \\esec = \\left[ \\begin{array}{c} P \\\\ M_z \\\\ M_z \\\\ V_y \\\\ V_y \\\\ T \\end{array} \\right]\\] where \\(P\\) is the axial force, \\(M_z\\) is the bending moment about the local z-axis, \\(M_y\\) is the bending moment about the local y-axis, \\(V_y\\) is the shear force along the local y-axis, \\(V_z\\) is the shear force along the local z-axis, and \\(T\\) is the torque. Returns the value of \\(\\ssec\\) calculated at the previous state determination. Returns the section stiffness matrix, \\(\\ksec\\) , where \\[\\ksec = \\left[ \\begin{array}{cccccc} EA & 0 & 0 & 0 & 0 & 0 \\\\ 0 & EI_z & 0 & 0 & 0 & 0 \\\\ 0 & 0 & EI_y & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\alpha GA & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\alpha GA & 0 \\\\ 0 & 0 & 0 & 0 & 0 & GJ \\end{array} \\right]\\] Returns the section stiffness matrix, \\(\\ksec\\) . Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) , where \\[\\fsec = \\left[ \\begin{array}{cccccc} \\frac{1}{EA} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{1}{EI_z} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{1}{EI_y} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\frac{1}{GJ} \\end{array} \\right]\\] Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticSection3D object, constructed using the same values of tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the ordering of section response quantities. For this section, axial response is the first quantity, bending about the local z-axis is the second, bending about the local y-axis is the third, shear along the local y-axis is the fourth, shear along the local z-axis is the fifth, and torsion is the sixth. \\[code := \\left[ \\begin{array}{c} 2 \\\\ 1 \\\\ 4 \\\\ 3 \\\\ 5 \\\\ 6 \\end{array} \\right]\\] Returns 6. Creates a Vector of size \\(8\\) into which it places tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Invokes sendVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Returns \\(0\\) if successful, a warning message and a negative number are returned if the Channel object fails to send the Vector. Creates a Vector of size \\(8\\) . Invokes recvVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Using the data in the Vector to set its tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed and a negative number is returned if the Channel object fails to receive the Vector. Prints to the stream s the object\u2019s tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) values.","title":"Elastic Section\n"},{"location":"library/1_Modeling/section/243-Fiber%20Section/","text":"Fiber Section This commnand allows the user to construct a FiberSection object. Each FiberSection object is composed of Fibers, with each fiber containing a UniaxialMaterial, an area and a location (y,z). The command to generate FiberSection object contains in { } the commands to generate all the fibers in the object. To construct a FiberSection and populate it, the following command is used: section Fiber $secTag <-GJ $GJ> { fiber \u2026 patch \u2026 layer \u2026 \u2026 } secTag unique tag among sections GJ linear-elastic torsional stiffness assigned to the section (optional, default = no torsional stiffness) fiber \u2026 command to generate a single fiber patch \u2026 command to generate a number of fibers over a geometric cross-section layer \u2026 command to generate a row of fibers along a geometric-arc NOTES: The command to generate a FiberSection contains in { } the commands to generate all the fibers in the section. The patch and layer commands can be used to generate multiple fibers in a single command. In an element recorder you can ask a FiberSection for its \u2018deformations\u2019, \u2018forces\u2019, \u2018forceAndDeformation\u2019, \u2018fiber $fiberNum $matArg1 ..\u2019, \u2018fiber $yLoc $zLoc $matTag $matArg1\u2019 <uml> FiberSection o- Fiber </uml> Code Developed by: Michael H. Scott, Oregon State University","title":"Fiber Section\n"},{"location":"library/1_Modeling/section/407-NDFiber%20Section/","text":"NDFiber Section This commnand allows the user to construct an NDFiberSection object. Each NDFiberSection object is composed of NDFibers, with each fiber containing an NDMaterial, an area and a location (y,z). The NDFiberSection works for 2D and 3D frame elements and it queries the NDMaterial of each fiber for its axial and shear stresses. In 2D, stress components 11 and 12 are obtained from each fiber in order to provide stress resultants for axial force, bending moment, and shear (N, Mz, and Vy). Stress components 11, 12, and 13 lead to all six stress resultants in 3D (N, Mz, Vy, My, Vz, and T). The NDFiberSection works with any NDMaterial via wrapper classes that perform static condensation of the stress vector down to the 11, 12, and 13 components, or via concrete NDMaterial subclasses that implement the appropriate fiber stress conditions. The command to generate NDFiberSection object contains in { } the commands to generate all the fibers in the object. To construct an NDFiberSection and populate it, the following command is used: section NDFiber $secTag { fiber \u2026 patch \u2026 layer \u2026 \u2026 } secTag unique tag among all sections fiber \u2026 command to generate a single fiber. patch \u2026 command to generate a number of fibers over a geometric cross-section layer \u2026 command to generate a row of fibers along a geometric-arc NOTES: The command to generate an NDFiberSection contains in { } the commands to generate all the fibers in the section. The patch and layer commands can be used to generate multiple fibers in a single command. In an element recorder you can ask an NDFiberSection for its \u2018deformations\u2019, \u2018forces\u2019, \u2018forceAndDeformation\u2019, \u2018fiber $fiberNum $matArg1 ..\u2019, \u2018fiber $yLoc $zLoc $matTag $matArg1\u2019 <uml> NDFiberSection o- NDFiber </uml> Code Developed by: Michael H. Scott, Oregon State University","title":"NDFiber Section\n"},{"location":"library/1_Modeling/section/515-Plate%20Fiber%20Section/","text":"Plate Fiber Section This command allows the user to construct a MembranePlateFiberSection object, which is a section that numerically integrates through the plate thickness with \u201cfibers\u201d and is appropriate for plate and shell analysis. section PlateFiber $secTag $matTag $h secTag unique section tag matTag nDMaterial tag to be assigned to each fiber h plate thickness Code Developed by: Edward \u201cEddie\u201d Love","title":"Plate Fiber Section\n"},{"location":"library/1_Modeling/section/57-Bidirectional%20Section/","text":"Bidirectional Section This command allows the user to construct a Bidirectional section, which is a stress-resultant plasticity model of two coupled forces. The yield surface is circular and there is combined isotropic and kinematic hardening. section Bidirectional $secTag $E $Fy $Hiso $Hkin & lt ; $code1 $code2 & gt ; secTag unique section tag E elastic modulus Fy yield force Hiso isotropic hardening modulus Hkin kinematic hardening modulus code1 section force code for direction 1 (default = Vy) code2 section force code for direction 2 (default = P) NOTES: The implementation is a generalization of the uniaxial return map algorithm for rate independent plasticity (page 45, Simo and Hughes, 1998) with the same input parameters as the Hardening Material uniaxial material model. The bidirectional section is a suitable base isolator model and should be used in conjunction with a ZeroLengthSection element to this end. It can also be used in a nonlinear beam element to define stress resultant plasticity at an integration point. The optional code1 and code2 values correspond to the beam cross-section analogy with respect to the local axes of the calling element (P, Vy, and Vz = force along section local x, y, and z axes, respectively; T, My, and Mz = moment about section local x, y, and z axes, respectively) Code Developed by: Michael H. Scott","title":"Bidirectional Section\n"},{"location":"library/1_Modeling/section/619-Section%20Aggregator/","text":"Section Aggregator This command is used to construct a SectionAggregator object which aggregates groups previously-defined UniaxialMaterial objects into a single section force-deformation model. Each UniaxialMaterial object represents the section force-deformation response for a particular section degree-of-freedom (dof). There is no interaction between responses in different dof directions. The aggregation can include one previously defined section. section Aggregator $secTag $matTag1 $dof1 $matTag2 $dof2 ....... & lt ; -section $sectionTag & gt ; secTag unique section tag $matTag1 \\(matTag2 ...</strong></p></td> <td><p>tag of previously-defined UniaxialMaterial objects</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) dof1 $dof2 \u2026 the force-deformation quantity to be modeled by this section object. One of the following section dof may be used: P Axial force-deformation Mz Moment-curvature about section local z-axis Vy Shear force-deformation along section local y-axis My Moment-curvature about section local y-axis Vz Shear force-deformation along section local z-axis T Torsion Force-Deformation sectionTag tag of previously-defined Section object to which the UniaxialMaterial objects are aggregated as additional force-deformation relationships SectionAggregator.gif EXAMPLE section Aggregator 2 2 Vy -section 4; # create new section with IDtag 2, taking the existing material tag 2 to represent the shear and adding it to the existing section tag 4, which may be a fiber section where the interaction betweeen axial force and flexure is already considered. Theory Read if you\u2019re using moment-curvature in beamWithHinges element to represent moment-rotation, or vice versa http://earthquakespectra.org/doi/abs/10.1193/1.4000136 Code Developed by: Micheal H. Scott, Oregon State","title":"Section Aggregator\n"},{"location":"library/1_Modeling/section/738-Uniaxial%20Section/","text":"Uniaxial Section This command is used to construct a UniaxialSection object which uses a previously-defined UniaxialMaterial object to represent a single section force-deformation response quantity. section Uniaxial $secTag $matTag $quantity secTag unique section tag matTag tag of uniaxial material quantity the force-deformation quantity to be modeled by this section object. One of the following strings is used: P Axial force-deformation Mz Moment-curvature about section local z-axis Vy Shear force-deformation along section local y-axis My Moment-curvature about section local z-axis Vz Shear force-deformation along section local z-axis T Torsion Force-Deformation Code Developed by: Micheal H. Scott, Oregon State University","title":"Uniaxial Section\n"},{"location":"library/1_Modeling/section/GenericSection1D/","text":"GenericSection1D #include <material/section/GenericSection1D.h> class GenericSection1D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSection1D provides a wrapper around a UniaxialMaterial so that any UniaxialMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSection1D whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the UniaxialMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the UniaxialMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the UniaxialMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the UniaxialMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Sets the section flexibility matrix, \\(\\fsec\\) , to be the inverse of the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\fsec\\) . This function overrides the base class implementation. Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. This function overrides the base class implementation. Invokes commitState() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToStart() on the UniaxialMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSection1D, using the same tag, UniaxialMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantity returned by this instance of GenericSection1D. Returns 1. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the UniaxialMaterial using the same values of s and flag .","title":"GenericSection1D\n"},{"location":"library/1_Modeling/section/GenericSectionND/","text":"GenericSectionND #include <material/section/GenericSectionND.h> class GenericSectionND : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSectionND provides a wrapper around a NDMaterial so that any NDMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSectionND whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the NDMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the NDMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the NDMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the NDMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the NDMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Invokes commitState() on the NDMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the NDMaterial and returns the result of that invocation. Invokes revertToStart() on the NDMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSectionND, using the same tag, NDMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantities returned by this instance of GenericSectionND. Returns the result of invoking getOrder() on the NDMaterial. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the NDMaterial using the same values of s and flag .","title":"GenericSectionND\n"},{"location":"library/1_Modeling/uniaxialMaterial/","text":"UniaxialMaterial Library This command is used to construct a UniaxialMaterial object which represents uniaxial stress-strain (or force-deformation) relationships. The valid queries to any uniaxial material when creating an ElementRecorder are strain , stress , and tangent . Some materials have additional queries to which they will respond. These are documented in the NOTES section for those materials. General-Purpose Materials Elastic / Path-Independent Elastic Elastic-No Tension ElasticBilin ElasticMultiLinear PathIndependent Inelastic MultiLinear Elastic-Perfectly Plastic Gap Pinching4 Standard Rate-Independent Materials These models are formulated and implemented according to well-established principles and algorithms. ElasticPP Elastic-perfectly plastic Hardening Standard Rate-Dependent Materials Viscous ViscousDamper Metallic Steel01 Steel02 Giuffr\u00e9-Menegotto-Pinto Model with Isotropic Strain Hardening Steel4 Hysteretic ReinforcingSteel Dodd Restrepo A new model which allows the \u201csoftness\u201d of the Bauschinger curve, as determined by the area under the curve relative to the enclosing parallelogram, to be controlled. RambergOsgoodSteel SteelMPF Menegotto and Pinto (1973) model Extended by Filippou et al. (1983) UVCuniaxial Updated Voce-Chaboche Concrete Concrete01 Hognestad\u2019s concrete curve with zero tensile strength Concrete02 Concrete01 with linear tension softening Concrete04 Popovics concrete curve Concrete06 Concrete07 Chang & Mander\u2019s 1994 Concrete Model ConfinedConcrete01 ConcreteD ConcreteCM Complete Concrete Model by Chang and Mander (1994) FRPConfinedConcrete Bouc-Wen Models BoucWenOriginal DegradingPinchedBW BoucWenInfill BoucWen BWBN Pinching Hysteretic Bouc-Wen Material Pinch and Slip SAWS Pinching material for woodframed structures. Wrappers Parallel Series Initial Strain Initial Stress Fatigue MinMax SimpleFractureMaterial ContinuumUniaxial performs static condensation to impose a uniaxial state of stress on a three-dimensional NDMaterial Other Uniaxial Materials Concrete01WithSITC Concrete Material With Stuff in the Cracks ModIMKBilin Modified Ibarra-Medina-Krawinkler Deterioration Model with Bilinear Hysteretic Response (Bilin) ModIMKPeakOriented Modified Ibarra-Medina-Krawinkler Deterioration Model with Peak-Oriented Hysteretic Response ModIMKPinching Modified Ibarra-Medina-Krawinkler Deterioration Model with Pinched Hysteretic Response CastFuse BilinearOilDamper BARSLIP Bond_SP01 Strain Penetration Model for Fully Anchored Steel Reinforcing Bars Impact HyperbolicGap Engineered Cementitious Composites KikuchiAikenHDR KikuchiAikenLRB AxialSp AxialSpHD CFSWSWP Wood-Sheathed Cold-Formed Steel Shear Wall Panel CFSSSWP Steel-Sheathed Cold-formed Steel Shear Wall Panel SelfCentering uniaxial self-centering (flag-shaped) material object with optional non-recoverable slip behaviour and an optional stiffness increase at high strains (bearing behaviour). PyTzQz uniaxial soil materials for p-y, t-z and q-z elements for modeling soil-structure interaction through the piles in a structural foundation PySimple1 TzSimple1 QzSimple1 PyLiq1 TzLiq1 PySimple1Gen Command TzSimple1Gen Command Frameworks Limit State AlgebraicHysteresis","title":"UniaxialMaterial Library\n"},{"location":"library/1_Modeling/uniaxialMaterial/bouc/33-BWBN/","text":"BWBN This command is used to construct a uniaxial Bouc-Wen pinching hysteretic material object. This material model is an extension of the original Bouc-Wen model that includes pinching (Baber and Noori (1986) and Foliente (1995)). uniaxialMaterial BWBN $matTag $alpha $ko $n $gamma $beta $Ao $q $zetas $p $Shi $deltaShi $lambda $tol $maxIter matTag integer tag identifying material alpha ratio of post-yield stiffness to the initial elastic stiffenss ( \\(0 \\lt \\alpha \\lt 1\\) ) ko initial elastic stiffness n parameter that controls transition from linear to nonlinear range (as n increases the transition becomes sharper; n is usually grater or equal to 1) gamma beta parameters that control shape of hysteresis loop; depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated (look at the BoucWen Material ) Ao parameter that controls tangent stiffness q zetas p Shi deltaShi lambda parameters that control pinching tol tolerance maxIter maximum iterations BWBN_YSPD.jpg Fig. Cyclic force displacement relationship of the YSPDs generated using the BWBN material model PARAMETER ESTIMATION: BWBNParameterEstimation Examples docs/contrib/examples/31-BWBNExample.html References Hossain, M. R., Ashraf, M., & Padgett, J. E. (2013). \u201cRisk-based seismic performance assessment of Yielding Shear Panel Device.\u201d Engineering Structures, 56, 1570-1579. Hossain, M. R., & Ashraf, M. (2012). \u201cMathematical modelling of yielding shear panel device.\u201d Thin-Walled Structures, 59, 153-161. Baber, T. T., & Noori, M. N. (1986). \u201cModeling general hysteresis behavior and random vibration application.\u201d Journal of Vibration Acoustics Stress and Reliability in Design, 108, 411. Foliente, G. C. (1995). Hysteresis modeling of wood joints and structural systems. Journal of Structural Engineering, 121(6), 1013-1022. Developers Raquib Hossain , The University of Queensland (UQ), Australia & Bangladesh University of Engineering and Technology (BUET), Bangladesh.","title":"BWBN\n"},{"location":"library/1_Modeling/uniaxialMaterial/bouc/64-BoucWen/","text":"BoucWen This command is used to construct a uniaxial Bouc-Wen smooth hysteretic material object. This material model is an extension of the original Bouc-Wen model that includes stiffness and strength degradation (Baber and Noori (1985)). uniaxialMaterial BoucWen $matTag $alpha $ko $n $gamma $beta $Ao $deltaA $deltaNu $deltaEta matTag integer tag identifying material alpha ratio of post-yield stiffness to the initial elastic stiffenss (0< \\(\\alpha\\) <1) ko initial elastic stiffness n parameter that controls transition from linear to nonlinear range (as n increases the transition becomes sharper; n is usually grater or equal to 1) gamma beta parameters that control shape of hysteresis loop; depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated (look at the NOTES) Ao deltaA parameters that control tangent stiffness deltaNu deltaEta parameters that control material degradation NOTES: Parameter \\(\\gamma\\) is usually in the range from -1 to 1 and parameter \\(\\beta\\) is usually in the range from 0 to 1. Depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated. The hysteresis loop will exhibit softening for the following cases: \\(\\beta + \\gamma \\gt 0\\) and \\(\\beta - \\gamma \\gt 0\\) , \\(\\beta + \\gamma \\gt 0\\) and \\(\\beta - \\gamma \\lt 0\\) , and \\(\\beta + \\gamma \\gt 0\\) and \\(\\beta - \\gamma = 0\\) . The hysteresis loop will exhibit hardening if \\(\\beta + \\gamma \\lt 0\\) and \\(\\beta - \\gamma \\gt 0\\) , and quasi-linearity if $+ = 0 and \\(\\beta - \\gamma \\gt 0\\) . The material can only define stress-strain relationship. References Haukaas, T. and Der Kiureghian, A. (2003). \u201cFinite element reliability and sensitivity methods for performance-based earthquake engineering.\u201d REER report, PEER-2003/14 1 . Baber, T. T. and Noori, M. N. (1985). \u201cRandom vibration of degrading, pinching systems.\u201d Journal of Engineering Mechanics, 111(8), 1010-1026. Bouc, R. (1971). \u201cMathematical model for hysteresis.\u201d Report to the Centre de Recherches Physiques, pp16-25, Marseille, France. Wen, Y.-K. (1976). for random vibration of hysteretic systems.\u201d Journal of Engineering Mechanics Division, 102(EM2), 249-263.","title":"BoucWen\n"},{"location":"library/1_Modeling/uniaxialMaterial/bouc/BoucWenInfill/","text":"BoucWenInfill This command is used to construct the uniaxial BoucWenInfill material producing smooth hysteretic loops with stiffness and strength degradation and pinching effect. The pinching formulation is particularly suitable to simulate the behavior of infill panels and masonry walls. uniaxialMaterial BoucWenInfill matTag mass alpha beta0 eta0 n k xy deltak deltaf psi Zs As epsp tol maxIter Argument Type Description matTag integer integer tag identifying material. mass float mass of the system. alpha float ratio of post-yield stiffness to the initial elastic stiffness (0< alpha <1). beta0 eta0 float parameters that control the shape of the hysteresis loop (-1< eta0 <1). n float Parameter that controls the transition from linear to nonlinear range. k float Initial elastic stiffness. xy float yielding displacement of the system deltak deltaf float Parameters that control respectively stiffness and strength degradation. psi float Parameter that controls the rate of stiffness degradation. Zs float parameter that controls the extension of pinching along z-axis. As float parameter that controls the extension of pinching along x-axis. epsp float pinching activation energy. tol float tolerance in each integration step. maxIter float maximum number of iterations for each integration step. Notes The determination of constitutive parameters is supported by their physical meaning. In case of infill panels, empirical correlation laws between the model parameters and the geometrical and mechanical properties of infilled frames can be found in [SirottiEtAL2021] . The equations governing the BoucWenInfill behavior are described in [SirottiEtAl2021] . Other references can be found in [PelliciariEtAl2020] for stiffness and strength degradation and in [MadanEtAl1997] for the pinching formulation. The model may reproduce either force-displacement or stress-strain relationships. Parameters deltak , deltaf and psi regulate respectively stiffness, strength degradation and the rate of stiffness degradation. Parameters Zs , As and epsp control the amount and activation of the pinching effect: Example The following instruction builds a BoucWenInfill material with tag 1 , parameters reported in the table above, tolerance tol = \\(10^{-6}\\) and maximum number of iterations maxIter = \\(10^{6}\\) . Tcl Code uniaxialMaterial BoucWenInfill 1 1 0.06 0.25 0.1 1.2 65 1 0.005 0.005 0.001 0.01 5 10000 10 e-6 10 e6 References MadanEtAl1997 Madan, A., Reinhorn, A. M., Mander, J. B., & Valles, R. E. (1997). Modeling of masonry infill panels for structural analysis. Journal of structural engineering, 123(10), 1295-1302. DOI: https://doi.org/10.1061/(ASCE)0733-9445(1997)123:10(1295) . PelliciariEtAl2020 Pelliciari, M., Briseghella, B., Tondolo, F., Veneziano, L., Nuti, C., Greco, R., ... & Tarantino, A. M. (2020). A degrading Bouc\u2013Wen model for the hysteresis of reinforced concrete structural elements. Structure and Infrastructure Engineering, 16(7), 917-930. DOI: https://doi.org/10.1080/15732479.2019.1674893 . SirottiEtAL2021 Sirotti, S., Pelliciari, M., Di Trapani, F., Briseghella, B., Carlo Marano, G., Nuti, C., & Tarantino, A. M. (2021). Development and validation of new Bouc\u2013Wen data-driven hysteresis model for masonry infilled RC frames. Journal of Engineering Mechanics, 147(11), 04021092. DOI: https://doi.org/10.1061/(ASCE)EM.1943-7889.0002001 . Code developed by: Stefano Sirotti , University of Modena and Reggio Emilia, Italy, stefano.sirotti@unimore.it","title":"BoucWenInfill\n"},{"location":"library/1_Modeling/uniaxialMaterial/bouc/DegradingPinchedBW/","text":"DegradingPinchedBW User University of Modena and Reggio Emilia Matteo Pelliciari, Phd (University of Modena and Reggio Emilia, Dept. of Engineering \u201cEnzo Ferrari\u201d, Modena) Professor Davide Lavorato (Roma Tre University, Dept. of Architecture, Rome). Parameter Role \\(\\alpha\\) Ratio of linear to non-linear response \\(k\\) Elastic stiffness \\(\\beta_{0}\\) Hysteresis shape control \\(\\eta_{0}\\) Hysteresis shape control \\(n\\) Hysteresis shape control \\(\\rho_{x}\\) Max. displacement degradation \\(\\rho_{\\epsilon}\\) Energy degradation \\(\\delta_{k}\\) Stiffness degradation \\(\\delta_{f}\\) Strength degradation \\(\\psi\\) Stiffness degradation rate control \\(\\sigma\\) Pinching width \\(u\\) Pinching slope \\(\\rho_{p}\\) Pinching severity \\(\\epsilon_{p}\\) Pinching activation energy int Tag, double p_m, double p_Fy, double p_xu, double p_alpha, double p_ko, double p_n, double p_eta, double p_beta, double p_rhoeps, double p_rhox, double p_phi, double p_deltak, double p_deltaf, double p_sigma, double p_u, double p_epsp, double p_rhop, double ptolerance, int pMaxNumIter) https://github.com/OpenSees/OpenSees/pull/335 \\[ \\begin{aligned} \\dot{z} &=A\\left(d_{i}\\right) \\dot{x}-\\beta\\left(d_{i}\\right)\\left(|\\dot{x}||z|^{n-1} z+\\eta_{0} \\dot{x}|z|^{n}\\right) \\\\ &=e^{-\\delta_{k} d_{i} p_{k}\\left(d_{i}\\right)} \\dot{x}-\\beta_{0} e^{-\\left[\\delta_{k} p_{k}\\left(d_{i}\\right)-n \\delta_{f}\\right] d_{i}}\\left(|\\dot{x}||z|^{n-1} z+\\eta_{0} \\dot{x}|z|^{n}\\right) \\end{aligned} \\] References \u201cA degrading Bouc-Wen model for the hysteresis of reinforced concrete structural elements\u201d, by Pelliciari M. et al. (Structure and Infrastructure Engineering, 2019, 1-14). https://doi.org/10.1080/15732479.2019.1674893","title":"DegradingPinchedBW\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/177-Elastic-No%20Tension/","text":"Elastic-No Tension This command is used to construct a uniaxial elastic-no tension material object. uniaxialMaterial ENT $matTag $E matTag integer tag identifying material E tangent ENT.gif Code Developed by: fmk","title":"Elastic-No Tension\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/179-Elastic-Perfectly%20Plastic/","text":"Elastic-Perfectly Plastic This command is used to construct an elastic perfectly-plastic uniaxial material object. uniaxialMaterial ElasticPP $matTag $E $epsyP < $epsyN $eps0 > matTag integer tag identifying material E tangent epsyP strain or deformation at which material reaches plastic state in tension epsyN strain or deformation at which material reaches plastic state in compression. (optional, default is tension value) eps0 initial strain (optional, default: zero) ElasticPP.gif Code Developed by: fmk","title":"Elastic-Perfectly Plastic\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/180-ElasticBilin/","text":"ElasticBilin This command is used to construct an elastic bilinear uniaxial material object. Unlike all other bilinear materials, the unloading curve follows the loading curve exactly. uniaxialMaterial ElasticBilin $matTag $EP1 $EP2 $epsP2 < $EN1 $EN2 $epsN2 > matTag integer tag identifying material EP1 tangent in tension for stains: 0 <= strains <= epsP2 EP2 tangent when material in tension with strains epsP2 epsP2 strain at which material changes tangent in tension. EN1 optional, default = EP1 . tangent in compression for stains: 0 < strains <= epsN2 EN2 optional, default = EP2 . tangent in compression with strains < $epsN2 epsN2 optional, default = -epsP2. strain at which material changes tangent in compression. ElasticPP.gif NOTE: eps0 can not be controlled. It is always zero. Code Developed by: fmk","title":"ElasticBilin\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/181-ElasticMultiLinear/","text":"ElasticMultiLinear This command is used to construct a multi-linear elastic uniaxial material object. The nonlinear stress-strain relationship is given by a multi-linear curve that is define by a set of points. The behavior is nonlinear but it is elastic. This means that the material loads and unloads along the same curve, and no energy is dissipated. The slope given by the last two specified points on the positive strain axis is extrapolated to infinite positive strain. Similarly, the slope given by the last two specified points on the negative strain axis is extrapolated to infinite negative strain. The number of provided strain points needs to be equal to the number of provided stress points. uniaxialMaterial ElasticMultiLinear $matTag < $eta > -strain $strainPoints - stress $stressPoints matTag integer tag identifying material eta damping tangent (optional, default=0.0) strainPoints array of strain points along stress-strain curve stressPoints array of stress points along stress-strain curve ElasticMultiLinear.png Examples uniaxialMaterial ElasticMultiLinear 1 -strain -0.045 -0.04 -0.02 0.0 0.02 0.04 0.045 -stress 10 -100 -10 0 50 55 100 Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"ElasticMultiLinear\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/195-Elastic%20Uniaxial/","text":"Elastic This command is used to construct an elastic uniaxial material object. uniaxialMaterial Elastic $matTag $E < $eta > < $Eneg > matTag integer tag identifying material E tangent eta damping tangent (optional, default=0.0) Eneg tangent in compression (optional, default=E) Code Developed by: fmk","title":"Elastic\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/322-Hardening/","text":"Hardening This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. The model includes optional visco-plasticity using a Perzyna formulation. uniaxialMaterial Hardening $matTag $E $sigmaY $H_iso $H_kin < $eta > matTag integer tag identifying material E tangent stiffness sigmaY yield stress or force H_iso isotropic hardening Modulus H_kin kinematic hardening Modulus eta visco-plastic coefficient (optional, default=0.0) HardeningMaterial.gif Code Developed by: Micheal H. Scott, Oregon State University Image Developed by: Silvia Mazzoni","title":"Hardening\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/381-Maxwell/","text":"Maxwell This command is used to construct a ViscousDamper material, which represents the Maxwell Model (linear spring and nonlinear dashpot in series). The ViscousDamper material simulates the hysteretic response of nonlinear viscous dampers. An adaptive iterative algorithm has been implemented and validated to solve numerically the constitutive equations within a nonlinear viscous damper with a high-precision accuracy. uniaxialMaterial ViscousDamper $matTag $K $Cd $alpha < $LGap > < $NM $RelTol $AbsTol $MaxHalf > matTag integer tag identifying material K Elastic stiffness of linear spring to model the axial flexibility of a viscous damper (e.g. combined stiffness of the supporting brace and internal damper portion) Cd Damping coefficient alpha Velocity exponent LGap Gap length to simulate the gap length due to the pin tolerance NM Employed adaptive numerical algorithm (default value NM = 1; 1 = Dormand-Prince54, 2=6th order Adams-Bashforth-Moulton, 3=modified Rosenbrock Triple) RelTol Tolerance for absolute relative error control of the adaptive iterative algorithm (default value 10^-6) AbsTol Tolerance for absolute error control of adaptive iterative algorithm (default value 10^-10) MaxHalf Maximum number of sub-step iterations within an integration step (default value 15) Examples: 1. Input parameters: Assume a viscous damper with axial stiffness K=300.0kN/mm, damping coefficient Cd=280.3kN(s/mm)<sup>0.3</sup>, and exponent a=0.30. The input parameters for the material should be as follows: uniaxialMaterial ViscousDamper 1 300 280.3 0.30 Using these properties, Figure 1 shows the hysteretic response of this damper for sinusoidal displacement increments of 12, 24 and 36mm and a frequency f = 0.5Hz. The sensitivity of the viscous damper with respect to its velocity exponent is shown in Figures 2 to 4 for the following set of parameters: Viscous Damper with various input parameter variations 2. Single story single bay frame with viscous damper References : [1] Akcelyan, S., Lignos, D. G., Hikino, T., and Nakashima, M. (2016). \u201cEvaluation of simplified and state-of-the-art analysis procedures for steel frame buildings equipped with supplemental damping devices based on E-Defense full-scale shake table tests.\u201d Journal of Structural Engineering, 142(6), 04016024. 1 [2] Oohara, K., and Kasai, K. (2002), \u201cTime-History Analysis Models for Nonlinear Viscous Dampers\u201d, Proc. Structural Engineers World Congress (SEWC), Yokohama, JAPAN, CD-ROM, T2-2-b-3 (in Japanese). [3] Kasai K, Oohara K. \u201cAlgorithm and Computer Code To Simulate Response of Nonlinear Viscous Damper\u201d Passively Controlled Structure Symposium 2001, Yokohama, Japan (in Japanese). Code developed by : Sarven Akcelyan & Prof. Dimitrios G. Lignos , (McGill University)","title":"Maxwell\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/748-ViscousDamper/","text":"ViscousDamper This command is used to construct a ViscousDamper material, which represents the Maxwell Model (linear spring and nonlinear dashpot in series). The ViscousDamper material simulates the hysteretic response of nonlinear viscous dampers. An adaptive iterative algorithm has been implemented and validated to solve numerically the constitutive equations within a nonlinear viscous damper with a high-precision accuracy. uniaxialMaterial ViscousDamper $matTag $K $Cd $alpha < $LGap > < $NM $RelTol $AbsTol $MaxHalf > matTag integer tag identifying material K Elastic stiffness of linear spring to model the axial flexibility of a viscous damper (e.g. combined stiffness of the supporting brace and internal damper portion) Cd Damping coefficient alpha Velocity exponent LGap Gap length to simulate the gap length due to the pin tolerance NM Employed adaptive numerical algorithm (default value NM = 1; 1 = Dormand-Prince54, 2=6th order Adams-Bashforth-Moulton, 3=modified Rosenbrock Triple) RelTol Tolerance for absolute relative error control of the adaptive iterative algorithm (default value 10^-6) AbsTol Tolerance for absolute error control of adaptive iterative algorithm (default value 10^-10) MaxHalf Maximum number of sub-step iterations within an integration step (default value 15) Examples Input parameters: Assume a viscous damper with axial stiffness K=300.0kN/mm, damping coefficient Cd=280.3kN (s/mm) 0.3 , and exponent \\(a=0.30\\) . The input parameters for the material should be as follows: uniaxialMaterial ViscousDamper 1 300 280.3 0.30 Using these properties, Figure 1 shows the hysteretic response of this damper for sinusoidal displacement increments of 12, 24 and 36mm and a frequency \\(f = 0.5\\) Hz. The sensitivity of the viscous damper with respect to its velocity exponent is shown in Figures 2 to 4 for the following set of parameters: Viscous Damper with various input parameter variations Single story single bay frame with viscous damper docs/contrib/examples/163-Dynamic Analyses of 1-Story Moment Frame with Viscous Dampers.html References [1] Akcelyan, S., Lignos, D. G., Hikino, T., and Nakashima, M. (2016). \u201cEvaluation of simplified and state-of-the-art analysis procedures for steel frame buildings equipped with supplemental damping devices based on E-Defense full-scale shake table tests.\u201d Journal of Structural Engineering, 142(6), 04016024. 1 [2] Akcelyan, S., Lignos, D. G., Hikino, T. (2018). \u201cAdaptive Numerical Method Algorithms for Nonlinear Viscous and Bilinear Oil Damper Models Subjected to Dynamic Loading.\u201d Soil Dynamics and Earthquake Engineering, 113, 488-502. 2 . [3] Akcelyan, S. (2017). \u201cSeismic retrofit of existing steel tall buildings with supplemental damping devices.\u201d Ph.D. Dissertation, McGill University, Canada. [4] Oohara, K., and Kasai, K. (2002), \u201cTime-History Analysis Models for Nonlinear Viscous Dampers\u201d, Proc. Structural Engineers World Congress (SEWC), Yokohama, JAPAN, CD-ROM, T2-2-b-3 (in Japanese). [5] Kasai K, Oohara K. \u201cAlgorithm and Computer Code To Simulate Response of Nonlinear Viscous Damper\u201d Passively Controlled Structure Symposium 2001, Yokohama, Japan (in Japanese). Code developed by : Sarven Akcelyan & Prof. Dimitrios G. Lignos , (McGill University)","title":"ViscousDamper\n"},{"location":"library/1_Modeling/uniaxialMaterial/classical/749-Viscous/","text":"Viscous This command is used to construct a uniaxial viscous material object. stress =C(strain-rate)^alpha uniaxialMaterial Viscous $matTag $C $alpha matTag integer tag identifying material C damping coeficient alpha power factor (=1 means linear damping) Notes: This material can only be assigned to truss and zeroLength elements. This material can not be combined in parallel/series with other materials. When defined in parallel with other materials it is ignored. References See Eqn 9 in G. Pekcan, J.B.Mander abd S.S. Chen, \u201cFundamental Considerations for the Design of Non-Linear Viscous Dampers\u201d, Earthqauke Engineering & Structural Dynamics 28,1405-1425 (1999) Code Developed by: Mehrdad Sasani, NEU","title":"Viscous\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/158-DoddRestrepo/","text":"DoddRestrepo This command is used to construct a Dodd-Restrepo steel material Dodd_Restrepo (name, \u2003\u2003\u2003Fy, \u2003\u2003\u2003Fsu, \u2003\u2003\u2003esh, \u2003\u2003\u2003esu, \u2003\u2003\u2003elastic_modulus, \u2003\u2003\u2003eshI, \u2003\u2003\u2003fshI, \u2003\u2003\u2003OmegaFac, \u2003\u2003\u2003**kwds) Fy Num(float) Yield strength Fsu Num(float) Ultimate tensile strength (UTS) esh Num(float) Tensile strain at initiation of strain hardening esu Num(float) Tensile strain at the UTS E Num(float) Young\u2019s modulus of elasticity eshI Num(float) Tensile strain for a point on strain hardening curve, recommended range of values for eshI: [ (ESU 5esh)/6, (ESU 3esh)/4] fshI Num(float) Tensile stress at point on strain hardening curve corresponding to eshI OmegaFac Num(float) Roundedness factor for Bauschinger curve in cycle reversals from the strain hardening curve. Range: [0.75, 1.15]. Largest value tends to near a bilinear Bauschinger curve. Default = 1.0. Note: Stresses and strains are defined in engineering terms, as they are reported in a tensile test. Examples: References Dodd, L. L. and Restrepo-Posada, J. I. (1995). Model for Predicting Cyclic Behaviour of Reinforcing Steel. ASCE Journal of Structural Engineering, V.121, No 3, pp. 433-445. Code developed by: L.L. Dodd & J.I. Restrepo","title":"DoddRestrepo\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/569-RambergOsgoodSteel/","text":"RambergOsgoodSteel This command is used to construct a Ramberg-Osgood steel material object. RambergOsgoodSteel (name, elastic_modulus, fy, a, n, **kwds) E Num(float) Young\u2019s modulus of elasticity fy Num(float) yield strength a Num(float) yield offset parameter n Num(float) Introduction to the Ramberg-Osgood\u2019s Material Model: In earthquake engineering, Ramberg-Osgood functions are often used to model the behavior of structural steel materials and components. These functions are obtained when the power is normalized to an arbitrary strain, \u03b50, for which the plastic component of the strain, \u03b5plastic, is not zero. Generally the yield strain, \u03b5y, provides a good choice for normalization of strain, the Ramberg-Osgood function is expressed as [1]: \\[ \\varepsilon=\\frac{\\sigma}{E_{0}}+a\\left(\\frac{\\sigma}{\\sigma_{0}}\\right)^{n} \\] Where E0 is the initial elastic modulus and \u03c30 is equal to E\u03b50. More explanation about parameter \u201ca\u201d (yielding offset) The value \u201ca\u201d which is equal to \u03b1\u03c3/E_0 can be seen as a yield offset, as shown in Fig.1. This comes from the fact that \\[ \\epsilon=\\dfrac{(1+\\alpha) \\sigma_{0}}{E} \\] when \u03c3=\u03c30. Accordingly (see Fig.1): RambergOsgoodSteel03.png Values for \u03b1 can also be found by means of fitting to experimental data, although for some materials, it can be fixed in order to have the yield offset equal to the accepted value of strain of 0.2%, which means [2]: \\(\\alpha \\frac{\\sigma}{E_{0}}=0.002\\) . Fig. 1: Generic representation of the Stress-Strain curve by means of the Ramberg-Osgood equation. Strain corresponding to the yield point is the sum of the elastic and plastic components. Fig. 2: RambergOsgoodSteel Material \u2013 Hysteretic Behavior of Model References Michel Bruneau, Chia-Ming Uang Andrew Whittaker. \u201cDuctile Design of Steel Structures\u201d McGraw-Hill Professional, 1997, ISBN: 0070085803 - 978-0070085800 Ramberg, W., & Osgood, W. R. (1943). \u201cDescription of stress-strain curves by three parameters.\u201d Technical Note No. 902, National Advisory Committee For Aeronautics, Washington DC. Contact Authors: Reza Rahimi, Graduate Research Assistant of Structural Engineering, Dalhousie University, reza.rahimi@dal.ca Reza Sepasdar, Graduate Research Assistant of Structural Engineering, Dalhousie University, reza.sepasdar@dal.ca Mohammad Reza Banan, Associate Professor of Civil Engineering, Department of Civil and Environmental Engineering, Shiraz University, Shiraz, Iran, banan@shirazu.ac.ir","title":"RambergOsgoodSteel\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/587-Reinforcing%20Steel/","text":"ReinforcingSteel This command is used to construct a ReinforcingSteel uniaxial material object. This object is intended to be used in a reinforced concrete fiber section as the steel reinforcing material. ReinforcingSteel (matTag, \u2003\u2003\u2003fy, \u2003\u2003\u2003fu, \u2003\u2003\u2003Es, \u2003\u2003\u2003Esh, \u2003\u2003\u2003esh, \u2003\u2003\u2003eult, \u2003\u2003\u2003GABuck, \u2003\u2003\u2003gamma, \u2003\u2003\u2003DMBuck, \u2003\u2003\u2003CMFatigue, \u2003\u2003\u2003IsoHard, \u2003\u2003\u2003MPCurveParams, \u2003\u2003\u2003**kwds) matTag Num(float) unique material object integer tag fy Num(float) Yield stress in tension (see Figure 1) fu Num(float) Ultimate stress in tension Es Num(float) Initial elastic tangent Esh Num(float) Tangent at initial strain hardening esh Num(float) Strain corresponding to initial strain hardening eult Num(float) Strain at peak stress GABuck [lsr,beta,r] , Buckling Model Based on Gomes and Appleton (1997) lsr Num(float) Slenderness Ratio (see Figure 2) beta Num(float) Amplification factor for the buckled stress strain curve. (see Figure 3) r Num(float) Buckling reduction factor r can be a real number between [0.0 and 1.0] r=1.0 full reduction (no buckling) r=0.0 no reduction 0.0<r<1.0 linear interpolation between buckled and unbuckled curves gamma Num(float) Buckling constant (see Figures 3 and 4) DMBuck [lsr,alpha] , Buckling model based on Dhakal and Maekawa (2002) lsr Num(float) Slenderness Ratio (see Figure 2) alpha = 1.0 Num(float) Adjustment Constant usually between 0.75 and 1.0 CMFatigue [Cf,alpha,Cd] , Coffin-Manson Fatigue and Strength Reduction Cf Num(float) Coffin-Manson constant C (see Figure 5) alpha Num(float) Coffin-Manson constant a (see Figure 5) Cd Num(float) Cyclic strength reduction constant (see Figure 6 and Equation 3) IsoHard [a1,limit] , Isotropic Hardening / Diminishing Yield Plateau a1 = 4.3 Num(float) Hardening constant limit = 0.01 Num(float) Limit for the reduction of the yield plateau. % of original plateau length to remain (0.01 < limit < 1.0 ). If limit = 1.0, then no reduction takes place MPCurveParams [R1,R2,R3] , Menegotto and Pinto Curve Parameters see Fig 6b R1 = 0.333 Num(float) R2 = 18 Num(float) R3 = 4 Num(float) uniaxialMaterial ReinforcingSteel $matTag $fy $fu $Es $Esh $esh $eult < - GABuck $lsr $beta $r $gama > < -DMBuck $lsr < $alpha > > < -CMFatigue $Cf $alpha $Cd > < - IsoHard < $a1 < $limit > > > matTag Material tag. fy yield stress. fu Es Esh esh eult -GABuck lsr Slenderness Ratio (see Figure 2) beta Amplification factor for the buckled stress strain curve. (see Figure 3) r Buckling reduction factor r can be a real number between [0.0 and 1.0] r=1.0 full reduction (no buckling) r=0.0 no reduction 0.0<r<1.0 linear interpolation between buckled and unbuckled curves gamma Buckling constant (see Figures 3 and 4) -DMBuck Buckling model based on Dhakal and Maekawa (2002) lsr Slenderness Ratio (see Figure 2) alpha Adjustment Constant usually between 0.75 and 1.0 Default: alpha=1.0, this parameter is optional. -CMFatigue Coffin-Manson Fatigue and Strength Reduction Cf Coffin-Manson constant C (see Figure 5) alpha Coffin-Manson constant a (see Figure 5) $C d Cyclic strength reduction constant (see Figure 6 and Equation 3) -IsoHard Isotropic Hardening / Diminishing Yield Plateau a1 Hardening constant (default = 4.3) limit Limit for the reduction of the yield plateau. % of original plateau length to remain (0.01 < limit < 1.0 ) Limit =1.0, then no reduction takes place (default =0.01) -MPCurveParams Menegotto and Pinto Curve Parameters see Fig 6b R1 (default = 0.333) R2 (default = 18) R3 (default = 4) ::: NOTE: This simulation is based on the Chang and Mander(1994) uniaxial steel model. The simulation has incorporated additional reversal memory locations to better control stress overshooting (default is 10 branches but this can be easily modified by changing the variable \u201c LastRule_RS \u201d within the header file \u201c ReinforcingSteel.h \u201d). The cycle counting method implemented in the routine achieves the same result as rainflow counting. Fatigue parameters are based on the Coffin-Manson equation for plastic strain amplitude as indicated in Figure 6a. The buckling simulations incorporated consist of a variation on Gomes and Appleton (1997) and Dhakal and Maekawa (2002). The buckling and fatigue portions of this simulation are still being further enhanced and refined. Additional buckling and fatigue options should be available in the near future. Figure 1: Material Constants Backbone curve The backbone curve shown in Figure 1 is used as a bounding surface for the reinforcing bar simulation. This backbone curve is shifted as described by Chang and Mander (1994) to account for Isotropic hardening. This backbone can be obtained by utilizing simple tension test data. Within the material class, the backbone curve is transformed from engineering stress space to natural stress space (accounting for change in area as the bar is stressed.) This allows the single backbone to represent both tensile and compressive stress-strain relations. The tension and compression backbone curves are not the same in engineering stress space for this model! This transformation assumes small strain relations described by Dodd and Restrepo-Posada (1995) The softening region (strain greater than eult ), shown in Figure 1, is a localization effect due to necking and is a function of the gage length used during measurement. This geometric effect is ignored in this simulation. In this simulation, it is assumed that there is no softening in natural stress space. Because the simulation always converts back to engineering stress space, you will observe some softening in the tension response due to the reduction in area, however this will be much smaller than that shown in the original backbone curve proposed by Chang and Mander. Diminishing yield plateau It has been observed that when a reinforcing bar is subjected to plastic strain reversals within the yield plateau, strain hardening will initiate at a lower strain that that of the same bar loaded monotonically. Additionally, isotropic hardening can result from repeated strain reversals and is commonly related to accumulated plastic strain. These two aspects of the stress-strain behavior of steel bars are somewhat related and that by shortening the yield plateau as a function of accumulated plastic strain, the model will have some capability to simulate both the diminishing yield plateau and isotropic hardening. The Chang and Mander model, on which this formulation is based, models only anisotropic hardening by shifting the backbone curves and by targeting previous reversal points on the backbone curves. By adding a component of isotropic hardening, the model has additional capabilities and is able to more accurately simulate test data. Accumulated plastic strain is tracked within the material model for each branch, plateau adjustments are made only in the outer branches for simplicity. The plastic strain due to the backbone curve is ignored so that a monotonically loaded sample can be calibrated to a monotonic test sample more easily. Buckling Models Figure 2: Slenderness Defined Figure 3: Buckling Parameters Gomes and Appleton buckled curve Figure 3 describes the use of the buckling parameters modified from Gomes and Appleton (1997). \\(\\beta\\) is an amplification factor that allows the user to scale the buckling curve. This is useful to adjust the location of the bifurcation point. The \\(r\\) factor is used to adjust the curve between the buckled curve and the unbuckled curve. The variable \\(r\\) can only be a real number between \\(0.0\\) and \\(1.0\\) . The \\(\\gamma\\) factor is the positive stress location about which the buckling factor is initiated. This factor was introduced to avoid kinks in the reloading branch. The implementation of the \\(\\gamma\\) factor is shown in Figure 3. The basic idea is that the stress strain curves are reduced toward the positive stress \\(\\gamma f_{su}\\) . The value \\(\\gamma\\) should be between \\(0.0\\) and \\(1.0\\) . A \\(\\gamma\\) of \\(0.0\\) will factor to the zero stress axis. This will usually produce a kink in the reloading curve at the zero stress location. Good results have been obtained using the following values for the buckling constants. or Figure 4 displays the buckling behavior due to the variation of the different constants. The response shown on the upper left is the unbuckled case. In each of the other cases, buckling behavior is defined by the constants shown. Figure 4: Effect of Sample Parameters in the Gomes and Appleton Buckling Model Dhakal and Maekawa buckled curve The buckling model described in this section is based on Dhakal and Maekawa (2002). This model takes two terms, \\(\\ell_{sr}\\) and \\(a\\) . \\(\\ell_{sr}\\) is the slenderness ratio as described in Figure 2 and \\(a\\) is an amplification factor. Dhakal and Maekawa suggest a value of \\(a =1.0\\) for linear strain hardening and \\(a =0.75\\) for elastic perfectly plastic material behavior. The material model in this implementation is neither linear strain hardening nor elastic perfectly plastic. However, since the material model does include strain hardening \\(a=1.0\\) has been assumed as the default value. Figure 5 shows the unbuckled vs buckled stress strain response curves. Figure 5: Effect of Suggested Parameters in the Dhakal and Maekawa Buckling Model Cyclic Degradation \\(C_f\\) and \\(a\\) are factors used to relate the number of half cycles to fracture to the half cycle plastic strain amplitude (Figure 6a). Plastic strain half cycle amplitude is defined by Equation 1. The total half cycle strain amplitude,, is shown in Figure 6b as the change in strain from reversal A to reversal B. \\(C_f\\) and a are used to define a cumulative damage factor, \\(D\\) , as described in Equation 2. Figure 6a: Coffin-Manson Constants Figure 6b: Half Cycle Terms Defined (1) (2) The cumulative damage factor is zero at no damage and \\(1.0\\) at fracture. Once a bar has been determined to have fractured, the strength is rapidly degraded to zero. Figure 7: Strength Reduction A degrade constant, \\(K_1\\) , is used to describe loss in strength due to damage or other phenomenon resulting in softening due to plastic reversals. The degradation is currently assumed to have a simple linear relationship with \\(D\\) . This is used to correlate strength degradation to the cumulative damage factor. This linear relationship is shown in Equation 3. \\[ \\phi_{S R}=K_{1} D \\] (3) Alternately this simple linear equation can be rewritten in a way that makes the strength degradation independent of the number of half cycles to failure. Keeping the failure and degradation terms independent is convenient for calibration. Equation 3 is rewritten below utilizing the strength degradation constant \\(C_d\\) . (4) The constants K 1 , and \\(C_d\\) can be related as shown in Equation 5. (5) Suggested starting values have been obtained from data reported by Brown and Kunnath (2000) for bars with a slenderness of \\(6\\) . Keep in mind that this experimental data is limited and additional calibration may be necessary to capture realistic behavior in a reinforcing bar embedded in concrete and influenced by other factors such as confinement. \\(a\\) \\(0.506\\) \\(C_f\\) \\(0.260\\) \\(C_d\\) \\(0.389\\) Sample Simulations of Degradation behavior \\(a\\) is best obtained from calibration of test results. \\(a\\) is used to relate damage from one strain range to an equivalent damage at another strain range. This is usually constant for a material type. \\(C_f\\) is the ductility constant used to adjust the number of cycles to failure. A higher value for \\(C_f\\) will result in a lower damage for each cycle. A higher value \\(C_f\\) translates to a larger number of cycles to failure. \\(C_d\\) is the strength reduction constant. A larger value for \\(C_d\\) will result in a lower reduction of strength for each cycle. The four charts shown in Figure 8 demonstrate the effect that some of the variables have on the cyclic response. Figure 8: Fatigue and Degradation Parameter Examples In Figure 8, the upper left response contains no strength degradation by setting the \\(C_d\\) variable to 0.0. The upper right response shows strength degradation due to the suggested values of \\(C_f\\) , \\(a\\) , and \\(C_d\\) . The response shown on the lower left demonstrates the change in the response when the suggested values of \\(C_f\\) and \\(a\\) are used with \\(C_d=0.6\\) . Making the value of \\(C_d\\) larger results in less strength reduction due to damage. The response on the lower right once again returns to the suggested values but \\(C_f\\) is changed to 0.15. This results in a more rapid accumulation of damage causing the bar to fail sooner. Note however that the strength degradation is unaffected by the more rapid accumulation of damage. The strength reduction and failure are not interdependent making the model easier to calibrate. References Chang, G. and Mander, J. (1994). \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I - Evaluation of Seismic Capacity.\u201d NCEER Technical Report 94-0006. Dodd, L. and Restrepo-Posada, J. (1995). \u201cModel for Predicting Cyclic Behavior of Reinforcing Steel\u201d J. Struct. Eng., 121(3), 433-445. Gomes, A., and Appleton, J. (1997). \u201cNonlinear Cyclic Stress-Strain Relationship of Reinforcing Bars Including Buckling.\u201d Eng. Struct., 19(10), 822-826. Brown, J. and Kunnath, S.K. (2000). \u201cLow Cycle Fatigue Behavior of Longitudinal Reinforcement in Reinforced Concrete Bridge Columns.\u201d NCEER Technical Report 00-0007. Dhakal, R. and Maekawa, K. (2002). \u201cModeling for Postyield Buckled of Reinforcement\u201d J. Struct. Eng., 128(9), 1139-1147. Code developed by: Jon Mohle M.S., P.E. Sashi Kunnath: http://cee.engr.ucdvis.edu/faculty/kunnath/kunnath.htm","title":"ReinforcingSteel\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/664-Steel01/","text":"Steel01 This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (REF: Fedeas). uniaxialMaterial Steel01 $matTag $Fy $E0 $b < $a1 $a2 $a3 $a4 > matTag integer tag identifying material Fy yield strength E0 initial elastic tangent b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent) a1 isotropic hardening parameter, increase of compression yield envelope as proportion of yield strength after a plastic strain of \\(a2*(\\) Fy/E0). (optional) a2 isotropic hardening parameter (see explanation under $a1). (optional). a3 isotropic hardening parameter, increase of tension yield envelope as proportion of yield strength after a plastic strain of \\(a4*(\\) Fy/E0). (optional) a4 isotropic hardening parameter (see explanation under $a3). (optional) Steel01.gif Steel01 Material \u2013 Hysteretic Behavior of Model w/o Isotropic Hardening Steel01HystereticA.jpg Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Compression Steel01HystereticB.jpg Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Tension Steel01HystereticC.jpg NOTES: If strain-hardening ratio is zero and you do not expect softening of your system use BandSPD solver. Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Steel01\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/666-Steel02/","text":"Steel02 This command is used to construct a uniaxial Giuffre-Menegotto-Pinto steel material object with isotropic strain hardening. Steel02 (name, Fy, E0, b, R0, cR1, cR2, a, **kwds) Fy Num(float) yield strength E0 Num(float) initial elastic tangent b Num(float) strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent R0 Num(float) cR1 = 0.925 Num(float) cR2 = 0.15 Num(float) a [a1,a2,a3,a4,sigInit] , isotropic hardening parameters a1 Num(float) increase of compression yield envelope as proportion of yield strength after a plastic strain of a2\u2217(Fy/E0) a2 = 1.0 Num(float) see explanation under a1 . a3 Num(float) increase of tension yield envelope as proportion of yield strength after a plastic strain of a4\u2217(Fy/E0) a4 = 1.0 Num(float) see explanation under a3 . sigInit Num(float) initial stress more on OpenSees uniaxialMaterial Arguments \u2013 Steel02 Steel02 Material \u2013 Material Parameters of Monotonic Envelope Steel02Monotonic.jpg Steel02 Material \u2013 Hysteretic Behavior of Model w/o Isotropic Hardening Steel02HystereticA.jpg Steel02 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Compression Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Tension Steel02HystereticC.jpg References Filippou, F. C., Popov, E. P., Bertero, V. V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints\u201d. Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Steel02\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/667-Steel4/","text":"Steel4 img { transition:transform 0.25s ease; } img:hover { -webkit-transform:scale(1.5); /* or some other value */ transform:scale(1.5); } This command is used to construct a general uniaxial material with combined kinematic and isotropic hardening and optional non-symmetric behavior. uniaxialMaterial Steel4 $matTag $f_y $E_0 < - asym > < -kin $b_k $R_0 $r_1 $r_2 < $b_kc $R_0c $r_1c $r_2c > > < -iso $b_i $rho_i $b_l $R_i $l_yp < $b_ic $rho_ic $b_lc $R_ic > > < -ult $f_u $R_u < $f_uc $R_uc > > < - init $sig_init > < - mem $cycNum > Parameters matTag unique material object integer tag f_y yield strength (assumed identical in tension and compression) E_0 initial stiffness (Young\u2019s modulus) optional features: -kin apply kinematic hardening Kinematic hardening is based on the Menegotto-Pinto model. The parameters and their use is identical to those of the Steel02 material. b_k hardening ratio (E_k/E_0) R_0 control the exponential transition from linear elastic to hardening asymptote recommended values: R_0 = 20 , r_1 = 0.90 , r_2 = 0.15 r_1 r_2 -iso apply isotropic hardening Isotropic hardening increases the yield strength of the material. The applied increase is calculated as a function of the accumulated plastic strain. The following parameters control that function. b_i initial hardening ratio (E_i/E_0) b_l saturated hardening ratio (E_is/E_0) rho_i specifies the position of the intersection point between initial and saturated hardening asymptotes R_i control the exponential transition from initial to saturated asymptote l_yp length of the yield plateau in eps_y0 = f_y / E_0 units -ult apply an ultimate strength limit The ultimate strength limit serves as an upper limit of material resistance. After the limit is reached the material behaves in a perfectly plastic manner. Exponential transition is provided from the kinematic hardening to the perfectly plastic asymptote. Note that isotropic hardening is also limited by the ultimate strength, but the transition from the isotropic hardening to the perfectly plastic asymptote is instantaneous. f_u ultimate strength R_u control the exponential transition from kinematic hardening to perfectly plastic asymptote -asym assume non-symmetric behavior If non-symmetric behavior is assumed, material response under tension and compression will be controlled by two different parameter sets. The normal parameters control behavior under tension. Additional parameters shall be specified to describe behavior under compression. The following parameters are expected after the normal parameters when the options below are used. -kin b_kc R_0c r_1c r_2c -iso b_ic rho_ic b_lc R_ic -ult f_uc R_uc -init apply initial stress Initial stress is assumed at 0 strain at the beginning of the loading process. The absolute value of the initial stress is assumed to be less than the yield strength of the material. sig_init initial stress value -mem configure the load history memory The load history memory is a database of preceding load cycles. It is updated at every load reversal point during the loading process. It is turned on by default. Turning it off will reduce the memory consumption of Steel4. The available data on preceding cycles is currently used to correct a typical error in the Steel02 material. The error stems from the formulation of the Menegotto-Pinto kinematic hardening model. It leads to overestimation of the stress response after small unloading-reloading cycles. This phenomenon is important, because the seismic response of structures typically includes a large number of such small cycles. The error is avoided by forcing the kinematic hardening component of the response to converge to previous load cycles. The load history memory can be used in the future to describe other characteristics of the response that depend on preceding load cycles. cycNum expected number of half-cycles during the loading process Efficiency of the material can be slightly increased by correctly setting this value. The default value is cycNum = 50 Load history memory can be turned off by setting cycNum = 0 . Examples Coming soon\u2026 Code developed by: Adam Zsarn\u00f3czay, zsarnoczay@vbt.bme.hu","title":"Steel4\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/668-SteelMPF/","text":"SteelMPF This command is used to construct a uniaxialMaterial SteelMPF (Kolozvari et al., 2015), which represents the well-known uniaxial constitutive nonlinear hysteretic material model for steel proposed by Menegotto and Pinto (1973), and extended by Filippou et al. (1983) to include isotropic strain hardening effects. uniaxialMaterial SteelMPF $mattag $fyp $fyn $E0 $bp $bn $R0 $cR1 $cR2 < $a1 $a2 $a3 $a4 > mattag Unique uniaxialMaterial tag fyp Yield strength in tension (positive loading direction) fyn Yield strength in compression (negative loading direction) E0 Initial tangent modulus bp Strain hardening ratio in tension (positive loading direction) bn Strain hardening ratio in compression (negative loading direction) R0 Initial value of the curvature parameter R (R0 = 20 recommended) cR1 Curvature degradation parameter (a1 = 0.925 recommended) cR2 Curvature degradation parameter (a2 = 0.15 or 0.0015 recommended) a1 Isotropic hardening in compression parameter (optional, default = 0.0). Shifts compression yield envelope by a proportion of compressive yield strength after a maximum plastic tensile strain of \\(a2(\\) fyp/$E0) a2 Isotropic hardening in compression parameter (optional, default = 1.0). See explanation of a1. a3 Isotropic hardening in tension parameter (optional, default = 0.0). Shifts tension yield envelope by a proportion of tensile yield strength after a maximum plastic compressive strain of \\(a3(\\) fyn/$E0). a4 Isotropic hardening in tension parameter (optional, default = 1.0). See explanation of a3. The relationship is in the form of curved transitions (Figure 1), each from a straight-line asymptote with slope E 0 (modulus of elasticity) to another straight-line asymptote with slope E 1 = bE 0 (yield modulus) where b is the strain hardening ratio. The curvature of the transition curve between the two asymptotes is governed by a cyclic curvature parameter R , which permits the Bauschinger effect to be represented, and is dependent on the absolute strain difference between the current asymptote intersection point and the previous maximum or minimum strain reversal point depending on whether the current strain is increasing or decreasing, respectively. The strain and stress pairs (\u03b5 r ,\u03c3 r ) and (\u03b5 0 ,\u03c3 0 ) shown on Figure 1 are updated after each strain reversal. The model allows calibration of isotropic hardening parameters in both compression and tension through optional input variables a 1 and a 2 for isotropic strain hardening in compression, and a 3 and a 4 for isotropic strain hardening tension, and uses default values of a 1 = a 3 = 0.0 and a 2 = a 4 = 1.0 that yield no isotropic strain hardening for either compression or tension. To incorporate isotropic strain hardening in compression, the recommended parameters are a 1 = 0.01 and a 2 = 7.0. To incorporate isotropic strain hardening in tension, the recommended parameters are a 3 = 0.01 and a 4 = 7.0. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Figure 1. Constitutive Model for Steel (Menegotto and Pinto, 1973) Input Format: Example: uniaxialMaterial SteelMPF 1 60 60 29000 0.02 0.02 20.0 0.925 0.15 Discussion: Although the Menegotto-Pinto model is already available in OpenSees (e.g., [ Steel02 ]), the formulation of SteelMPF introduces several distinctive features compared to existing models. For example, the model allows definition of different yield stress values and strain hardening ratios for tension and compression, and it considers degradation of cyclic curvature parameter R for strain reversals in both pre- and post- yielding regions, which could produce more accurate predictions of yield capacity for some RC wall specimens ( element MVLEM , Example 1), whereas Steel02 considers the degradation in post-yielding region only. Strain-stress relationships obtained using SteelMPF and Steel02 are compared in Figure 2 for a strain history that includes strain reversals at strain values equal to one-half of the yield strain (i.e., \u03b5 r = \u00b10.001 = \u03b5 y /2). Figure 2. Comparing the degradation of cyclic curvature in the pre-yielding region for Steel02 and SteelMPF Furthermore, it has been observed from the strain-stress relationships obtained from quasi-static or dynamic analyses using existing steel models in OpenSees (e.g., Steel02 ) that after partial unloading occurs in a model element caused by dynamic loading or stress re-distribution under quasi-static loading due to concrete cracking or crushing, the Menegotto-Pinto formulation produces stress overshooting in the cyclic stress-strain behavior of reinforcing steel. This overshooting effect is not behavioral and causes non-physical hardening in the stress-strain behavior, upon reloading from the partial unloading loop. This phenomenon is illustrated in Figure 3 for the Steel02 model in OpenSees. This anomaly results in overestimation of steel stresses predicted by the Steel02 model upon return from partial unloading, yielding strain-stress curve that may not represent the physical constitutive behavior of reinforcing steel under cyclic loading. This limitation in the Menegotto-Pinto model formulation has also been acknowledged by Filippou et al. (1983). The overshooting effect observed in the existing OpenSees material model for reinforcing steel (e.g., Steel02 ) has been remedied in SteelMPF , via manipulating the model formulation so that reloading behavior after partial unloading cannot overshoot the previous loading loop in the cyclic stress-strain behavior. The comparison between strain-stress relationships obtained using SteelMPF and Steel02 for a strain history that includes low-amplitude unloading followed by reloading is presented in Figure 3. Figure 3. Comparing the stress overshooting upon reloading from low-amplitude unloading for Steel02 and SteelMPF References Filippou F.C., Popov, E.P., and Bertero, V.V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints\u201d. Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Menegotto, M., and Pinto, P.E. (1973). Method of analysis of cyclically loaded RC plane frames including changes in geometry and non-elastic behavior of elements under normal force and bending. Preliminary Report IABSE, vol 13. Code developed by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal , Bogazici University, Istanbul, Turkey John Wallace , Univeristy of California, Los Angeles","title":"SteelMPF\n"},{"location":"library/1_Modeling/uniaxialMaterial/metalic/730-UVCuniaxial/","text":"UVCuniaxial This command is used to construct an Updated Voce-Chaboche (UVC) material for uniaxial stress states (e.g., beam elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The multiaxial (e.g., for solid/brick elements) and plane-stress (e.g., for quad/plate/shell elements) versions are also available. The multiaxial and plane-stress implementations have the exact same hardening rules as this uniaxial model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. uniaxialMaterial UVCuniaxial $matTag $E $fy $QInf $b $DInf $a $N $C1 $gamma1 < $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 > matTag Integer tag identifying the material. E Elastic modulus of the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <C2 gamma2 C3 gamma3 \u2026 C8 gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples 1. Validation with Abaqus: This first example compares the response of the UVC model with the built-in nonlinear isotropic/kinematic material model in Abaqus v6.14. For this validation the model updates are neglected by simply setting DInf = 0.0 and a = 1.0. The model parameters are: E = 179800 MPa, fy = 318.5 MPa, QInf = 100.7 MPa, b = 8.0, DInf = 0.0 MPa, a = 1.0, C1 = 11608.2 MPa, gamma1 = 145.2, C2 = 1026.3 MPa, gamma2 = 4.7 Figure 1 shows that the UVC implementation in OpenSees agrees with the built-in Abaqus model to the level of machine precision. Therefore, you can use the UVC model in place of the nonlinear isotropic/kinematic hardening material model provided in Abaqus and many other finite element simulation platforms. The finite element models used to validate the Abaqus and OpenSees responses can be found at https://github.com/ahartloper/UVC_MatMod . Figure 1. Validation of UVC model with built-in nonlinear isotropic/kinematic material in Abaqus. 2. Comparison with structural steels: The applicability of the UVC material model for structural steels is demonstrated through two comparisons with experimental data from uniaxial coupon tests. A comparison with a North American steel, A992 Gr. 50 (nominal fy = 345 MPa), is shown in Figure 2. A comparison with a European steel, S355J2+N (nominal fy = 355 MPa), is shown in Figure 3. In both cases the UVC model is able to represent well the initial yield stress as well as the material behavior in later loading cycles. The parameters used for the A992 Gr. 50 and S355J2+N steels, along with other common structural steels, are provided and discussed in the next section. Figure 2. Comparison of UVC model with uniaxial coupon test data from the A992 Gr. 50 W14X82 flange data set. Figure 3. Comparison of UVC model with uniaxial coupon test data from the S355J2+N 25 mm plate data set. UVC model parameters for structural steels Below is a list of UVC model parameters for twelve structural steels from Reference [1] using two backstresses. These parameters are applicable for all implementations of the UVC model (uniaxial, plane-stress, multiaxial). References [1,3] contain detailed information on the calibration procedure used to obtain the model parameters. All of the parameters provided in the table below were obtained by minimizing the total squared-strain energy across at least five uniaxial coupon tests of distinct strain histories subject to the constraint that the material response is non-softening. Therefore, the UVC material model parameters should be representative of steel material behavior for arbitrarily imposed strains. Note that although the parameters in this table are considered representative of a specific sample of each material, significant variations can exist between different samples of the same material. All the parameters in the table are obtained through the UVC model calibration procedure implemented in the open-source Python package RESSPyLab . The RESSPyLab package can be used to generate UVC model parameters for other steel materials if the data is available. Details and examples on the calibration are provided on the RESSPyLab web page. Note that the parameters provided in the table below were calibrated using the true stress-strain definition, i.e., e_true = ln(1+(L-L_0)/L_0) and s_true = F/A_0 * (1 + (L-L_0)/L_0). UVC Material Parameters Material E f y Q Inf b D Inf a C 1 gamma 1 C 2 gamma 2 - [GPa] [MPa] [MPa] - [MPa] - [MPa] - [MPa] S355J2+N (25 mm plate) 197.41 338.80 134.34 14.71 133.75 229.25 26242.00 199.04 2445.30 11.66 S355J2+N (50 mm plate) 185.97 332.18 120.48 8.14 93.15 261.75 21102.00 173.60 2300.60 10.42 S355J2+N (HEB500 flange) 192.13 315.04 138.01 11.36 96.16 223.66 18587.84 257.31 1351.98 6.52 S355J2+N (HEB500 web) 199.68 334.94 139.32 14.07 120.33 274.73 28528.03 315.17 2569.45 24.68 S460NL (25 mm plate) 187.61 439.20 97.35 14.02 136.64 226.40 26691.00 188.75 2892.40 10.44 S690QL (25 mm plate) 188.63 685.39 0.11 0.11 132.30 285.15 34575.00 185.16 3154.20 20.14 A992 Gr. 50 (W14X82 web) 210.74 378.83 122.63 19.74 143.49 248.14 31638.00 277.32 1548.60 9.04 A992 Gr. 50 (W14X82 flange) 191.02 373.72 141.47 15.20 135.95 211.16 25621.00 235.12 942.18 3.16 A500 Gr. B (HSS305X16) 191.21 324.09 228.02 0.11 50.41 270.40 17707.00 207.18 1526.20 6.22 BCP325 (22 mm plate) 178.61 368.03 112.25 10.78 105.95 221.92 20104.00 200.43 2203.00 11.76 BCR295 (HSS350X22) 178.74 412.21 0.09 0.09 103.30 212.83 20750.59 225.26 1245.04 2.09 HYP400 (27mm plate) 189.36 454.46 62.63 16.57 109.28 145.74 13860.00 141.61 1031.10 3.53 References Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. \u201cConstitutive Modeling of Structural Steels: Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCuniaxial\n"},{"location":"library/1_Modeling/uniaxialMaterial/pytzqz/556-PyLiq1/","text":"PyLiq1 This command constructs a uniaxial p-y material that incorporates liquefaction effects. This p y material is used with a zeroLength element to connect a pile (beam-column element) to a 2 D plane-strain FE mesh or displacement boundary condition. The p-y material obtains the average mean effective stress (which decreases with increasing excess pore pressure) either from two specified soil elements, or from a time series. Currently, the implementation requires that the specified soil elements consist of FluidSolidPorousMaterials in FourNodeQuad elements, or PressureDependMultiYield or PressureDependMultiYield02 materials in FourNodeQuadUP or NineFourQuadUP elements. There are two possible forms: uniaxialMaterial PyLiq1 $matTag $soilType $pult $Y50 $Cd $c $pRes $ele1 $ele2 OR uniaxialMaterial PyLiq1 $matTag $soilType $pult $Y50 $Cd $c $pRes -timeSeries $tag matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects pRes sets the minimum (or residual) peak resistance that the material retains as the adjacent solid soil elements liquefy ele1 ele2 are the eleTag (element numbers) for the two solid elements from which PyLiq1 will obtain mean effective stresses and excess pore pressures seriesTag Alternatively, mean effective stress can be supplied by a time series by specifying the text string -timeSeries and the tag of the seriesm $seriesTag. NOTES: To model the effects of liquefaction with PyLiq1 , it is necessary to use the material stage updating command: updateMaterialStage - material matNum - stage sNum where the argument matNum is the material number (for PyLiq1) and the argument sNum is the desired stage (valid values are 0 & 1 ). With sNum = 0 , the PyLiq1 behavior will be independent of any pore pressure in the specified solidElem\u2019s. When updateMaterialStage first sets sNum=1 , PyLiq1 will obtain the average mean effective stress in the two solidElem\u2019s and treat it as the initial consolidation stress prior to undrained loading. Thereafter, the behavior of PyLiq1 will depend on the mean effective stresses (and hence excess pore pressures) in the solidElem\u2019s. The default value of sNum is 0 (i.e., sNum = 0 if updateMaterialStage is not called). Note that the updateMaterialStage command is used with some soil material models, and that sNum = 0 generally corresponds to the application of gravity loads (e.g., elastic behavior with no excess pore pressure development) and sNum = 1 generally corresponds to undrained loading (e.g., plastic behavior with excess pore pressure development). The analysis for gravity loading cannot use the \u201calgorithm Linear\u201d command because the relevant soil materials do not currently work properly with this command. Instead, the \u201calgorithm Newton\u201d or some other option must be used. EQUATIONS and EXAMPLE RESPONSES: The PyLiq1 material inherits the PySimple1 material, and behaves identically to the PySimple1 material if there is no excess pore water pressure (i.e., sNum = 0). The constitutive equations for the PySimple1 material are given in separate documentation and not repeated here. The PyLiq1 material modifies the p-y behavior in response to the average mean effective stress (p\u2032), as affected by the excess pore water pressures, in two specified solid soil elements. The PyLiq1 material is used within a zeroLength element, and that zeroLength element generally shares a node with some solid soil elements (e.g., most commonly 1, 2, or 4 solid elements in a 2D mesh). Specifying two solid soil elements allows the PyLiq1 material to depend on pore pressures above and below its nodal position (essentially covering its full tributary length). The mean effective stress is affected by changes in mean total stress and excess pore pressure. For modeling purposes, an excess pore water pressure ratio is calculated as \\(ru = 1-\\frac{p^\\prime}/{p_c^\\prime}\\) , where \\(p_c^\\prime\\) is the mean effective consolidation stress prior to undrained loading. The average value of ru is obtained from the specified solid soil elements and used within PyLiq1. The constitutive response of PyLiq1 is then taken as the constitutive response of PySimple1 scaled in proportion to the mean effective stress within the specified solid soil elements. This means that the ultimate capacity (pult) and tangent modulus are scaled by a factor of \\((1-r_u)\\) . Two additional constraints are then placed on the constitutive response. The first is that the scaled ultimate capacity cannot fall below the specified residual capacity of the material (i.e., pRes). The second constraint applies to the situation where the mean effective stress in the adjacent solid soil elements is incrementally increasing [e.g., the pore pressures decrease as the soils are incrementally dilatant (phase transformation)]. In this \u201chardening\u201d situation, the loading path from the p-y relation at time \u201ci\u201d to time \u201ci+1\u201d is bounded by the material\u2019 elastic stiffness (i.e., the unload/reloading stiffness); e.g., the incremental loading path cannot be steeper than the elastic stiffness. Note that the above approach only provides a first-order approximation for the softening effects of liquefaction on \\(p-y\\) behavior. Two simple examples of PyLiq1 behavior are presented in the following figures. In these examples, there is a single FourNodeQuad element containing a FluidSolidPorousMaterial with a PressureDependMultiYield soil material. This solid element is connected to an elastic pile via a single \u201cp-y\u201d element (i.e., a zeroLength element containing a PyLiq1 material). The solid element is an order of magnitude stiffer than the \\(p-y\\) element, and is subjected to transient cyclic simple shear loading. In the first example (first Figure), the adjacent soil element is subjected to uniform cyclic loading that produces triggering of liquefaction (ru = 100%) in about 7 cycles. The cyclic shear stress ratio (CSR), excess pore water pressure ratio (ru), and shear strain (\u03b3) versus cycle number for the solid soil element are plotted on the left side of the Figure. The soil element experiences uniform cyclic deformations; e.g., lateral spreading does not develop because the horizontal cyclic loading has no static bias in either direction. The pile is set as relatively rigid. Two different cases are then presented for the \\(p-y\\) element response. In the first case, sNum = 0 such that the \\(p-y\\) element is independent of changes in mean effective stress (or excess pore pressure) in the soil element. The resulting behavior is shown in the upper right-hand plot of the Figure. In the second case, sNum was set to 1 prior to cyclic loading, and thus the resulting behavior is dependent on the excess pore pressure in the soil element (lower right-hand plot of the Figure). The \\(p-y\\) element exhibits the overall softening that is expected when the adjacent soil element liquefies, and also shows temporary stiffening (hardening) when the adjacent soil goes through phase transformation (with its associated drop in excess pore pressure). In these plots, the \u201cp\u201d is normalized by the \\(p_{ult}\\) for drained monotonic loading. In the second example (second Figure), the adjacent soil element is subjected to a static shear load plus uniform cyclic loading such that triggering of liquefaction is accompanied by progressive lateral deformation in the direction of the static load bias (i.e., lateral spreading). Again, the left side of the Figure shows the CSR, ru and \u03b3 versus cycle number for the solid soil element. sNum was set to 1 prior to cyclic loading such that the \\(p-y\\) behavior is dependent on the excess pore pressure in the soil element. The residual capacity ( \\(p_{res}\\) ) of the \\(p-y\\) material is 10% of the drained ultimate capacity. Two different cases are then presented. In the first case, the pile is set as relatively rigid. The resulting behavior is shown in the upper right-hand plot of the Figure. The peak \u201cp\u201d occurs just as triggering of liquefaction occurs in the soil element, and is about 0.49 times the drained monotonic capacity pult. Subsequent peaks in \u201cp\u201d drop a bit to about 0.46 times pult. In the second case, the pile has a finite elastic stiffness such that it\u2019s peak elastic deflection in this example is equal in magnitude to about 10 times the \\(y_{50}\\) value for the \\(p-y\\) element. The resulting behavior is shown in the lower right-hand plot of the Figure. Again, the peak \u201cp\u201d occurs just as triggering of liquefaction occurs in the soil element, being about 0.18pult in this case. Subsequent peaks in \u201cp\u201d drop by about 20% to about 0.14pult. The inclusion of pile flexibility reduced, by a factor of about 3, the peak values of \u201cp\u201d that developed in the \\(p-y\\) element as the soil progressively spread past the pile. During each cycle of loading, the soil element cyclically ratchets in the direction of the static load bias and alternates between being extremely soft (ru = 100%) and then stiffening when it goes through phase transformation (ru drops). As the soil stiffens, the \\(p-y\\) element gains strength, transferring load onto the pile and causing the pile to elastically deform in the direction of loading. Then when the soil is unloaded and ru becomes 100% again, the \\(p-y\\) element loses strength, unloading the pile and allowing the pile to elastically return closer to its undeformed position. In each cycle of loading and progressive spreading of the soil, the magnitude of \u201cp\u201d that develops against the pile depends on the pile\u2019s flexibility relative to the displacement range over which the soil goes through phase transformation. PyLiq1NoSpreading.png PyLiq1WithSpreading.png Examples model basic - ndm 2 - ndf 2 node 1 0.0 0.0 node 2 0.0 0.0 fix 2 1 1 fix 1 0 1 timeSeries Path 1 - fileTime time.txt - filePath meanStress.txt - factor - 1.0 uniaxialMaterial PyLiq1 1 2 1.0 0.0001 10.0 0.0 0.10 - timeSeries 1 element zeroLength 1 1 2 - mat 1 - dir 1 uniaxialMaterial TzLiq1 2 1 1.0 0.0001 0.0 - timeSeries 1 element zeroLength 2 1 2 - mat 2 - dir 1 updateMaterialStage - material 1 - stage 1 updateMaterialStage - material 2 - stage 1 recorder Element - file PY1.txt - time - ele 1 force recorder Element - file TZ1.txt - time - ele 2 force recorder Node - file NodalDisps1.txt - time - node 1 - dof 1 2 disp pattern Plain 1 \"Sine 0.0 10.0 1.0 -factor 1.0\" { sp 1 1 0.001 } system ProfileSPD test NormDispIncr 1.0 E-8 25 0 constraints Penalty 1 .e18 1 .e18 algorithm Newton numberer RCM integrator Newmark 0.6 0.30 analysis VariableTransient analyze 1000 0.01 0.0001 0.01 15 References \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.w., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Journal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis This command is used to construct a PySimple1 uniaxial material object:","title":"PyLiq1\n"},{"location":"library/1_Modeling/uniaxialMaterial/pytzqz/557-PySimple1/","text":"PySimple1 This command is used to construct a PySimple1 uniaxial material object: uniaxialMaterial PySimple1 $matTag $soilType $pult $Y50 $Cd & lt ; $c & gt ; matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects NOTES: In general the HHT algorithm is preferred over a Newmark algorithm when using this material. This is due to the numerical oscillations that can develop with viscous damping forces under transient loading with certain solution algorithms and damping ratios. EQUATIONS and EXAMPLE RESPONSES: The equations describing PySimple1 behavior are described in Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Only minor changes have been made in its implementation for OpenSees. The nonlinear \\(p-y\\) behavior is conceptualized as consisting of elastic (p-ye), plastic (p-yp), and gap \\((p-y^g)\\) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component \\((p-ye)\\) of the displacement rate. The gap component consists of a nonlinear closure spring (pc-yg) in parallel with a nonlinear drag spring \\((p^d-y^g)\\) . Note that \\(y = y^e + y^p + y^g\\) , and that \\(p = p^d + p^c\\) . The plastic component has an initial range of rigid behavior between \\[-C_r p_\\text{ult} &lt; p &lt; C_r p_\\text{ult}\\] with \\(C_r\\) = the ratio of $p/p_ $ when plastic yielding first occurs in virgin loading. The rigid range of \\(p\\) , which is initially \\(2 C_r p_\\text{ult}\\) , translates with plastic yielding (kinematic hardening). The rigid range of \\(p\\) can be constrained to maintain a minimum size on both the positive and negative loading sides (e.g., 25% of \\(p\\text{ult}\\) ), and this is accomplished by allowing the rigid range to expand or contract as necessary. Beyond the rigid range, loading of the plastic \\((p-y^p)\\) component is described by: \\[p = p_{\\text{ult}} - (p_{\\text{ult}} - p_o) \\left [\\frac{c y_{50}}{c y_{50} + | z_p - z^p_0|} \\right ]^n \\] where \\(p_\\text{ult}\\) = the ultimate resistance of the \\(p-y\\) material in the current loading direction, \\(p_o = p\\) at the start of the current plastic loading cycle, \\(y^p_o = y_p\\) at the start of the current plastic loading cycle, \\(c\\) = constant to control the tangent modulus at the start of plastic yielding, and n = an exponent to control sharpness of the \\(p-y^p\\) curve. The closure \\((p^c-y^g)\\) spring is described by: \\[p^c = 1.8 p_{\\text{ult}} \\left [\\frac{y_{50}}{y_{50} + 50(y_o^\\text{+} - y^g)} - \\frac{y_{50}}{y_{50} + 50(y_o^\\text{-} - y^g)} \\right ] \\] where \\(y_o^+\\) = memory term for the positive side of the gap, \\(y_o^-\\) = memory term for the negative side of the gap. The initial values of \\(y_o^+\\) and \\(y_o^-\\) were set as \\(y_{50}/100\\) and <math>- y_{50}/100</math>, respectively. The factor of 1.8 brings \\(p^c\\) up to \\(p_\\text{ult}\\) during virgin loading to \\(y_o^+\\) (or \\(y_o^-\\) ). Gap enlargement follows logic similar to that of Matlock et al. (1978). The gap grows on the positive side when the plastic deformation occurs on the negative loading side. Consequently, the \\(y_o^+\\) value equals the opposite value of the largest past negative value of, <math>y^p + y^g + 1.5 y_{50}</math> where the \\(1.5y_{50}\\) represents some rebounding of the gap. Similarly, the \\(y_o^-\\) value equals the opposite value of the largest past positive value of \\(y^p+y^g-1.5y_{50}\\) . This closure spring allows for a smooth transition in the load displacement behavior as the gap opens or closes. The nonlinear drag \\((p^d-y^g)\\) spring is described by: \\[p^d = C_d p_{\\text{ult}} - (C_d p_{\\text{ult}} - p^d_o) \\left [\\frac{y_{50}}{y_{50} + 2| y^g - y^g_o|} \\right ]^n \\] where \\(C_d =\\) ratio of the maximum drag force to the ultimate resistance of the p-y material, <math>d^p_o =p^d</math> at the start of the current loading cycle, and \\(y^g_o = y^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different p-y backbone relations. Matlock\u2019s (1970) recommended backbone for soft clay is closely approximated using <math>c = 10</math>, \\(n = 5\\) , and \\(C_r = 0.35\\) . API\u2019s (1993) recommended backbone for drained sand is closely approximated using \\(c = 0.5\\) , \\(n = 2\\) , and \\(C_r = 0.2\\) . PySimple1 is currently implemented to allow use of these two default sets of values. Values of \\(p_\\text{ult}\\) , \\(y_{50}\\) , and \\(C_d\\) must then be specified to define the \\(p-y\\) material behavior. Viscous damping on the far-field (elastic) component of the p-y material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap. In addition, the total force across the p-y material is restricted to pult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like PySimple1. PySimple1A.gif PySimple1B.gif Examples References \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.w., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis This command is used to construct a PySimple1 uniaxial material object:","title":"PySimple1\n"},{"location":"library/1_Modeling/uniaxialMaterial/pytzqz/565-QzSimple1/","text":"QzSimple1 This command is used to construct a QzSimple1 uniaxial material. uniaxialMaterial QzSimple1 $matTag $qzType $qult $Z50 < $suction $c > matTag integer tag identifying material qzType qzType = 1 Backbone of q-z curve approximates Reese and O\u2019Neill\u2019s (1987) relation for drilled shafts in clay. qzType = 2 Backbone of q-z curve approximates Vijayvergiya\u2019s (1977) relation for piles in sand. qult Ultimate capacity of the q-z material. SEE NOTE 1. Z50 Displacement at which 50% of qult is mobilized in monotonic loading. SEE NOTE 2. suction Uplift resistance is equal to suction qult. Default = 0.0. The value of suction must be 0.0 to 0.1. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). Default = 0.0. Nonzero c values are used to represent radiation damping effects.* NOTES: qult : Ultimate capacity of the \\(q\\) - \\(z\\) material. Note that \u201cq\u201d or \u201cqult\u201d are stresses [force per unit area of pile tip] in common design equations, but are both loads for this uniaxialMaterial [i.e., stress times tip area]. Y50 : Displacement at which 50% of pult is mobilized in monotonic loading. Note that Vijayvergiya\u2019s relation ( qzType=2 ) refers to a \u201ccritical\u201d displacement ( zcrit ) at which qult is fully mobilized, and that the corresponding z50 would be 0. 125zcrit. optional args $suction and $c must either both be omitted or both provided. EQUATIONS and EXAMPLE RESPONSES: The equations describing QzSimple1 behavior are similar to those for \\(p\\) - \\(y\\) materials by Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Modifications were required for representing the different responses of a \\(q-z\\) material in compression versus uplift. The nonlinear \\(q\\) - \\(z\\) behavior is conceptualized as consisting of elastic ( \\(q\\) - \\(z^e\\) ), plastic \\(z^e\\) ) \\(z^e\\) ) ( \\(q\\) - \\(z^p\\) ), and gap ( \\(q-z^g\\) ) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component ( \\(q-z^e\\) ) of the displacement rate. The gap component consists of a bilinear closure spring ( \\(q^c-z^g\\) ) in parallel with a nonlinear drag \\(q^c-z^g\\) ) spring ( \\(q^d-z^g\\) ). Note that \\(z = z^e + z^p + z^g\\) , and that \\(q = q^d + q^c\\) . The plastic component has an initial range of rigid behavior between \\[-C_r q_\\text{ult} < q < C_r q_\\text{ult}\\] with \\(C_r\\) = the ratio of \\(\\frac{q}{q_{\\text{ult}}}\\) when plastic yielding first occurs in virgin loading. The rigid range of \\(q\\) , which is initially \\(2 C_r q_\\text{ult}\\) , translates and grows with plastic yielding. The rigid range of \\(q\\) is constrained to a maximum size of \\(0.7q_{\\text{ult}}\\) . Beyond the rigid range, loading of the plastic ( \\(q-z^p\\) ) component is described by: \\[q = q_{\\text{ult}} - (q_{\\text{ult}} - q_0) \\left [\\frac{c * z_{50}}{c * z_{50} + | z_p - z^p_0|} \\right ]\\] where \\(q_\\textrm{ult}\\) = the ultimate resistance of the \\(q-z\\) material in the current loading direction, \\(q_o = q\\) at the start of the current plastic loading cycle, p \\(z^p_o = z^p\\) at the start of the current plastic loading cycle, and c and n are constants that control the shape of \\(q-z^p\\) curve. The closure ( \\(q^c-z^g\\) ) component is simply a bilinear elastic spring, which is relatively rigid in compression and extremely flexible in tension (uplift). The nonlinear drag ( \\(q^d-z^g\\) ) component is used to allow thethe specification of some minimum \u201csuction\u201d on the pile tip during uplift. It is described by: \\[q^d = C_d q_\\text{ult} - (C_d q_{\\text{ult}} - q^d_0) \\left [\\frac{z_{50}}{z_{50} + 2| z^g - z^g_0|} \\right ] \\] where \\(C_d\\) = ratio of the maximum drag (suction) force to the ultimate resistance of the \\(q-z\\) material, \\(q^d_o = q^d\\) at the start of the current loading cycle, and \\(z^g_o = z^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different q-z backbone relations. Reese and O\u2019Neill\u2019s (1987) recommended backbone for drilled shafts in clay is closely approximated using \\(c = 0.35\\) , \\(n = 1.2\\) , and \\(C_r = 0.2\\) . Vijayvergiya\u2019s (1977) recommended backbone for piles in sand is closely approximated using \\(c = 12.3\\) , \\(n = 5.5\\) , and \\(C_r = 0.3\\) . QzSimple1 is currently implemented to allow use of these two default sets of values. Values of \\(q_\\text{ult}\\) , \\(z_50\\) , and suction (i.e., \\(C_d\\) ) must then be specified to define the \\(q-z\\) material behavior. Viscous damping on the far-field (elastic) component of the \\(q-z\\) material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap in uplift. In addition, the total force across the \\(q-z\\) material is restricted to \\(q_\\text{ult}\\) in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like QzSimple1. Examples of the monotonic backbones and cyclic loading response of QzSimple1 are given in the following plots. QzSimple1A.gif QzSimple1B.gif Examples References \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis","title":"QzSimple1\n"},{"location":"library/1_Modeling/uniaxialMaterial/pytzqz/722-TzLiq1/","text":"TzLiq1 The command constructs a uniaxial t-z material that incorporates liquefaction effects. This t z material is used with a zeroLength element to connect a pile (beam-column element) to a 2 D plane-strain FE mesh. The t-z material obtains the average mean effective stress (which decreases with increasing excess pore pressure) from two specified soil elements. Currently, the implementation requires that the specified soil elements consist of FluidSolidPorousMaterials in FourNodeQuad elements. uniaxialMaterial TzLiq1 $matTag $tzType $tult $z50 $c $ele1 $ele2 OR uniaxialMaterial TzLiq1 $matTag $tzType $tult $z50 $c -timeSeries $seriesTag matTag integer tag identifying material soilType soilType = 1 Backbone of t-z curve approximates Reese and O\u2019Neill (1987). soilType = 2 Backbone of t-z curve approximates Mosher (1984) relation. tult Ultimate capacity of the t-z material. SEE NOTE 1. Z50 Displacement at which 50% of tult is mobilized in monotonic loading. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). ele1 ele2 are the eleTag (element numbers) for the two solid elements from which PyLiq1 will obtain mean effective stresses and excess pore pressures seriesTag Alternatively, mean effective stress can be supplied by a time series by specifying the text string -timeSeries and the tag of the seriesm $seriesTag. NOTES: The argument tult is the ultimate capacity of the t-z material. Note that \u201ct\u201d or \u201ctult\u201d are shear stresses [force per unit area of pile surface] in common design equations, but are both loads for this uniaxialMaterial [i.e., shear stress times the tributary area of the pile]. Nonzero c values are used to represent radiation damping effects To model the effects of liquefaction with TzLiq1, it is necessary to use the material stage updating command: <pre> updateMaterialStage -material matNum -stage sNum </pre> where the argument matNum is the material number (for TzLiq1) and the argument sNum is the desired stage (valid values are 0 & 1). With sNum=0, the TzLiq1 behavior will be independent of any pore pressure in the specified solidElem\u2019s. When updateMaterialStage first sets sNum=1, TzLiq1 will obtain the average mean effective stress in the two solidElem\u2019s and treat it as the initial consolidation stress prior to undrained loading. Thereafter, the behavior of TzLiq1 will depend on the mean effective stress (and hence excess pore pressures) in the solidElem\u2019s. The default value of sNum is 0 (i.e., sNum=0 if updateMaterialStage is not called). Note that the updateMaterialStage command is used with some soil material models, and that sNum=0 generally corresponds to the application of gravity loads (e.g., elastic behavior with no excess pore pressure development) and sNum=1 generally corresponds to undrained loading (e.g., plastic behavior with excess pore pressures development). The analysis for gravity loading cannot use the \u201calgorithm Linear\u201d command because the relevant soil materials do not currently work properly with this command. Instead, the \u201calgorithm Newton\u201d or some other option must be used. TzLiq1 inherits TzSimple1 and modifies its response based on the mean effective stresses (and hence excess pore pressures) in the specified solid soil elements. The logic and implementation are the same as for how PyLiq1 inherits and modifies PySimple1. Therefore, the reader is referred to the documentation of PyLiq1 for details. Examples References \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis","title":"TzLiq1\n"},{"location":"library/1_Modeling/uniaxialMaterial/pytzqz/723-TzSimple1/","text":"TzSimple1 This command is used to construct a TzSimple1 uniaxial material object: uniaxialMaterial TzSimple1 $matTag $tzType $tult $z50 < $c > matTag integer tag identifying material soilType soilType = 1 Backbone of t-z curve approximates Reese and O\u2019Neill (1987). soilType = 2 Backbone of t-z curve approximates Mosher (1984) relation. tult Ultimate capacity of the t-z material. SEE NOTE 1. Z50 Displacement at which 50% of tult is mobilized in monotonic loading. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). See NOTE 2. NOTES: The argument tult is the ultimate capacity of the t-z material. Note that \u201ct\u201d or \u201ctult\u201d are shear stresses [force per unit area of pile surface] in common design equations, but are both loads for this uniaxialMaterial [i.e., shear stress times the tributary area of the pile]. Nonzero c values are used to represent radiation damping effects EQUATIONS and EXAMPLE RESPONSES: The equations describing PySimple1 behavior are described in Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Only minor changes have been made in its implementation for OpenSees. The nonlinear t-z behavior is conceptualized as consisting of elastic ( \\(t-z^e\\) ) and plastic ( \\(t-z^p\\) ) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component ( \\(t-z^e\\) ) of the displacement rate. Note that \\(z = z^e + z^p\\) , and that \\(t = t^e = t^p\\) . The plastic component is described by: \\[t^p = t_{\\text{ult}} - (t_{\\text{ult}} - t^p_0) \\left [\\frac{c z_{50}}{c z_{50} + | z_p - z^p_0|} \\right ] \\] where $t_{ult} = $ the ultimate resistance of the t-z material in the current loading direction, \\(t^p_o = t^p\\) at the start of the current plastic loading cycle, \\(z^p_0 = z^P\\) at the start of the current plastic loading cycle, and c = a constant and n = an exponent that define the shape of the \\(t-z^p\\) curve. The elastic component can be conveniently expressed as: \\[t^e = C_e \\frac{t_{\\text{ult}}}{z_{50}} z^e\\] where \\(C_e\\) = a constant that defines the normalized elastic stiffness. The value of \\(C_e\\) is not an independent parameter, but rather depends on the constants c & n (along with the fact that \\(t = 0.5 t_{\\text{ult}}\\) at \\(z = z_{50}\\) ). The flexibility of the above equations can be used to approximate different t-z backbone relations. Reese and O\u2019Neill\u2019s (1987) recommended backbone for drilled shafts is closely approximated using c = 0.5, n = 1.5, and Ce = 0.708. Mosher\u2019s (1984) recommended backbone for axially loaded piles in sand is closely approximated using c = 0.6, n = 0.85, and Ce = 2.05. TzSimple1 is currently implemented to allow use of these two default sets of values. Values of tult and z50 must then be specified to define the t-z material behavior. Viscous damping on the far-field (elastic) component of the t-z material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (displacement rate) that developed in the far-field elastic component of the material. In addition, the total force across the t-z material is restricted to tult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like TzSimple1. Examples of the cyclic loading response of TzSimple1 are given in the following plots. Note that the response for tzType = 2 has greater nonlinearity at smaller displacements (and hence greater hysteretic damping) and that it approaches tult more gradually (such that t/tult is still well below TzSimple1.gif Examples References \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis","title":"TzSimple1\n"},{"location":"library/1_Modeling/uniaxialMaterial/walls/609-SAWS/","text":"SAWS This file contains the class definition for SAWSMaterial. SAWSMaterial provides the implementation of a one-dimensional hysteretic model develeped as part of the CUREe Caltech wood frame project. uniaxialMaterial SAWS $tag $F0 $FI $DU $S0 $R1 $R2 $R3 $R4 $alph $beta matTag integer tag identifying material F0 Intercept strength of the shear wall spring element for the asymtotic line to the envelope curve F0 > FI > 0 FI Intercept strength of the spring element for the pinching branch of the hysteretic curve. (FI > 0). DU Spring element displacement at ultimate load. (DU > 0). S0 Initial stiffness of the shear wall spring element (S0 > 0). R1 Stiffness ratio of the asymptotic line to the spring element envelope curve. The slope of this line is R1 S0. (0 < R1 < 1.0). R2 Stiffness ratio of the descending branch of the spring element envelope curve. The slope of this line is R2 S0. ( R2 < 0). R3 Stiffness ratio of the unloading branch off the spring element envelope curve. The slope of this line is R3 S0. ( R3 1). R4 Stiffness ratio of the pinching branch for the spring element. The slope of this line is R4 S0. ( R4 > 0). alpha Stiffness degradation parameter for the shear wall spring element. (ALPHA > 0). beta Stiffness degradation parameter for the spring element. (BETA > 0). Notes: Refer to the figure below for more information, and the reference provided at the end of this page for complete details about modeling assumptions. FolzFigure.gif Example Files: Click to download files Media:Test.tcl Media:SAWSZeroLength.tcl Example: Hysteresis TestHysteresis.jpg References Reference: Folz, B. and Filiatrault, A. (2001). \u201cSAWS - Version 1.0, A Computer Program for the Seismic Analysis of Woodframe Structures\u201d, Structural Systems Research Project Report No. SSRP-2001/09, Dept. of Structural Engineering, UCSD, La Jolla, CA . Code Developed by: Patxi Uriz, Exponent (Converted from FORTRAN code originally written by Bryan Folz)","title":"SAWS\n"},{"location":"library/1_Modeling/uniaxialMaterial/walls/69-CFSSSWP/","text":"CFSSSWP This command is used to construct a uniaxialMaterial model that simulates the hysteresis response (Shear strength-lateral Displacement) of a Steel-Sheathed Cold-Formed Steel Shear Wall Panel (CFS-SWP). The hysteresis model has smooth curves and takes into account the strength and stiffness degradation, as well as pinching effect. This uniaxialMaterial gives results in Newton and Meter units, for strength and displacement, respectively. NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. uniaxialMaterial CFSSSWP $tag $height $width $fuf $fyf $tf $Af $fus $fys $ts $np $ds $Vs $sc $dt $openingArea $openingLength matTag Integer identifier used to tag the material model height SWP\u2019s height (mm) width SWP\u2019s width (mm) fuf Tensile strength of framing members (MPa) fyf Yield strength of framing members (MPa) tf Framing thickness (mm) Af Framing cross section area (mm\u00b2) fus Tensile strength of steel sheet sheathing (MPa) fys Yield strength of steel sheet sheathing (MPa) ts Sheathing thickness (mm) np Sheathing number (one or two sides sheathed) ds Screws diameter (mm) Vs Screws shear strength (N) sc Screw spacing on the SWP perimeter (mm) dt Anchor bolt\u2019s diameter (mm) openingArea Total area of openings (mm\u00b2) openingLength Cumulative length of openings (mm) DESCRIPTION: The uniaxial hysteresis model of Cold-Formed Steel Shear Wall Panel (CFS-SWP) consists of three parts: backbone curves of the hysteresis loops (states 1 and 2), hysteresis criteria (unloading-reloading path: states 3 and 4) (Fig.2) and deterioration criteria. The following paragraphs will respectively introduce the terms of the three parts. Maximum lateral shear strength and the associated displacement are assessed using an analytical method for steel sheathed CFS SWP proposed by Yanari N and Yu C (2013) which takes into account a wide range of factors that affect the behaviour and strength of a CFS SWP, namely: material properties, thickness and geometry of sheathing and framing, spacing of studs, construction details such as size and spacing of sheathing-to-framing connections. The associated displacement is evaluated using the equation C2.1-1 given by AISI S213-07 code. In addition to the envelope curve, the proposed hysteresis model requires the introduction of parameters that define the strength and stiffness deterioration, as well as the pinching effect under cyclic loading. Compared to the monotonic test result, the hysteresis response of CFS SWP exhibits strength deterioration; even if the displacement associated to peak strength has not been reached yet. The stiffness deterioration of the proposed model is positively related to strength degraded degree, and is defined in a same way as the strength deterioration. In order to account for the overall lateral stiffness and strength of the SWP, an equivalent simple non-linear zeroLength element connected to rigid truss elements which transmit the force to the boundary studs that resist the uniaxial tension and compression stress is used (Fig.3). This modeling tip leads to a considerable reduction in terms of elements number constituting the CFS SWP. The boundary members form a mechanism and the lateral stiffness and strength are derived directly from the zeroLength element. The CFS SWP details, as well as a schematic representation of the finite element model are illustrated in Fig.3. Fig. 3: Cold-Formed Steel Shear Wall Panel details and equivalent OpenSees finite element model EXAMPLES: Cold-Formed Steel Steel Sheathed Shear Wall Panel examples References Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022 . Smail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014. Smail Kechidi and N Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- OPD 2014, 3-4 July 2014, Porto, Portugal. L.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003. Yanagi N, Yu C. Effective strip method for the design of cold-formed steel framed shear wall with steel sheet sheathing. Journal of Structural Engineering, ASCE 2014; 140(4). Nisreen Balh, Development of seismic design provisions for steel sheathed shear walls, Master Thesis, McGill University, Canada, 2010. Code Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact: Smail Kechidi , PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com Nouredine Bourahla , Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz","title":"CFSSSWP\n"},{"location":"library/1_Modeling/uniaxialMaterial/walls/70-CFSWSWP/","text":"CFSWSWP This command is used to construct a uniaxialMaterial model that simulates the hysteresis response (Shear strength-Lateral displacement) of a wood-sheathed cold-formed steel shear wall panel (CFS-SWP). The hysteresis model has smooth curves and takes into account the strength and stiffness degradation, as well as pinching effect. This uniaxialMaterial gives results in Newton and Meter units, for strength and displacement, respectively. NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. uniaxialMaterial CFSWSWP $tag $height $width $fut $tf $Ife $Ifi $ts $np $ds $Vs $sc $nc $type $openingArea $openingLength matTag Integer identifier used to tag the material model height SWP\u2019s height (mm) width SWP\u2019s width (mm) fuf Tensile strength of framing members (MPa) tf Framing thickness (mm) Ife Moment of inertia of the double end-stud (mm4) Ifi Moment of inertia of the intermediate stud (mm4) ts Sheathing thickness (mm) np Sheathing number (one or two sides sheathed) ds Screws diameter (mm) Vs Screws shear strength (N) sc Screw spacing on the SWP perimeter (mm) nc Total number of screws located on the SWP perimeter type Integer identifier used to define wood sheathing type (DFP=1, OSB=2, CSP=3) openingArea Total area of openings (mm\u00b2) openingLength Cumulative length of openings (mm) DESCRIPTION: The uniaxial hysteresis model of Cold-Formed Steel Shear Wall Panel (CFS-SWP) consists of three parts: backbone curves of the hysteresis loops (states 1 and 2), hysteresis criteria (unloading-reloading path: states 3 and 4) (Fig.2) and deterioration criteria. The following paragraphs will respectively introduce the terms of the three parts. Maximum lateral shear strength and the associated displacement are assessed using an analytical method for wood sheathed CFS SWP proposed by Xu L and Martinez J (2007) which takes into account a wide range of factors that affect the behaviour and strength of a CFS SWP, namely: material properties, thickness and geometry of sheathing and framing, spacing of studs, construction details such as size and spacing of sheathing-to-framing connections. In addition to the envelope curve, the proposed hysteresis model requires the introduction of parameters that define the strength and stiffness deterioration, as well as the pinching effect under cyclic loading. Compared to the monotonic test result, the hysteresis response of CFS SWP exhibits strength deterioration; even if the displacement associated to peak strength has not been reached yet. The stiffness deterioration of the proposed model is positively related to strength degraded degree, and is defined in a same way as the strength deterioration. In order to account for the overall lateral stiffness and strength of the SWP, an equivalent simple non-linear zeroLength element connected to rigid truss elements which transmit the force to the boundary studs that resist the uniaxial tension and compression stress is used (Fig.3). This modeling tip leads to a considerable reduction in terms of elements number constituting the CFS SWP. The boundary members form a mechanism and the lateral stiffness and strength are derived directly from the zeroLength element. The CFS SWP details, as well as a schematic representation of the finite element model are illustrated in Fig.3. Fig. 3: Cold-Formed Steel Shear Wall Panel details and equivalent OpenSees finite element model. EXAMPLES: Cold-Formed Steel Wood Sheathed Shear Wall Panel examples References Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022 . Smail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014. Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- Workshop on Multi-Hazard Analysis of Structures using OpenSees, Porto 3-4, Portugal, July 2014. L.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003. A.E. Branston, Y.C. Chen, F.A. Boudreault and C.A. Rogers, Testing of light-gauge steel frame wood structural panel shear walls, Canadian Journal of Civil Engineering, 33(9):561-572, 2006. J. Martinez and L. Xu, Strength and stiffness determination of shear wall panels in cold-formed steel framing, Thin-Walled Structures, 44(10):1084-1095, 2006. Code Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact: Smail Kechidi , PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com Nouredine Bourahla , Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz","title":"CFSWSWP\n"},{"location":"library/1_Modeling/uniaxialMaterial/walls/96-ConcretewBeta/","text":"ConcretewBeta \u2003\u2003This command is used to construct a uniaxial concrete material object that explicitly considers for the effect of normal (to the axis where the material object is used) strain to the behavior of the concrete in compression. The compressive stress-strain envelope, up to the peak compressive strength(unconfined or confined) is based on the Fujii concrete model (Hoshikuma et al. 1997). The material has two options regarding the strength degradation in tension: (a) tri-linear or (b) nonlinear [based on the tension stiffening relation of Stevens et al (1991)]. The softening behavior in compression is tri-linear. \u2003\u2003The model accounts for the effect of normal tensile strains on the concrete compressive behavior when used with the Truss2 or CorotTruss2 elements. See the Truss2 Element for description of how the normal strain is computed. The instantaneous stress is \\(\\beta f\\) where \\(f\\) is the computed stress and \\(\\beta\\) is the compressive stress reduction factor which depends on the normal tensile strain, \\(\\epsilon_n\\) . The relation between \\(\\epsilon_n\\) and \\(\\beta\\) (see the Biaxial Behavior Section ) is tri-linear. Default values result in \\(\\beta\\) = 1. See the Examples Section for the use of this material model in truss models for planar RC walls and a beam-truss model for a non-planar wall loaded biaxially. Reinforced concrete wall with a C-shaped section subject to multi-axial loading, described in the examples . uniaxialMaterial ConcretewBeta $matTag $fpc $ec0 $fcint $ecint $fcres $ecres $ft $ftint $etint $ftres $etres < -lambda $lambda > < - alpha $alpha > < - beta $bint $ebint $bres $ebres > < - M $M > < - E $Ec > < -conf $fcc $ecc > matTag integer tag identifying material fpc peak unconfined concrete compressive strength* ec0 compressive strain corresponding to unconfined concrete compressive strength* fcint, ecint intermediate stress-strain point for compression post-peak envelope* fcres, ecres residual stress-strain point for compression post-peak envelope* ftint tensile strength of concrete ftint, etint intermediate stress-strain point for tension softening envelope ftres, etres residual stress-strain point for tension softening envelope Optional: lambda controls the path of unloading from compression strain (default 0.5) alpha controls the path of unloading from tensile strain (default 1) bint ebint intermediate \\(\\beta\\) -strain point for for biaxial effect (default 1 and 0, respectively) bres ebres residual \u03b2-strain point for for biaxial effect (default 1 and 0, respectively) M factor for Stevens et al. (1991) tension stiffening (default 0; see Note 2) Ec initial stiffness (default 2* fpc / ec0 ; see Note 3) fcc ecc confined concrete peak compressive stress and corresponding strain* (see Eq. 1) Notes Parameters of concrete in compression should be specified as negative values. For non-zero M , the tension stiffening behavior will govern the post-peak tension envelope. Tri-linear tension softening parameters ftint, etint, ftres, etres will have no effect, but dummy values must be specified. Value of Ec must be between fpc / ec0 and 2* fpc / ec0 otherwise the closest value will be assigned. Implementation thumb|upright=2.5|Equation 1. \\[ \\boldsymbol{E} \\boldsymbol{u}= \\texttt{ lambda } \\cdot\\left(\\frac{f}{\\varepsilon}\\right)+(1- \\texttt{ lambda }) \\cdot \\texttt{Ec} \\] thumb|upright=1.8|Equation 3. Uniaxial Behavior \u2003\u2003Figure 1 shows the compression and tension envelopes and the input parameters. The confined concrete envelope is defined by Equation 1 up to strain ecc . The default values of fcc and ecc are equal to fpc and ec0 , respectively, for an an unconfined behavior. Following this region, the compression envelope is tri-linear and passes through the points ( ecint , fcint ) and ( ecres , fcres ) in that order. For compression strains larger than ecres , the residual stress is fcres . \u2003\u2003For compression strain, the slope of the unloading branch is defined by Equation 2. After reaching zero stress, the material reloads linearly to the point with the largest tensile strain that occurred before. \u2003\u2003The tension envelope is linear until it reaches ft . If the tension stiffening parameter M is not specified, the tension envelope after reaching ft is tri-linear and passes through the points ( etint , ftint ) and ( etres , ftres ) in that order. For tensile strains larger than etres , the residual stress is fcres . \u2003\u2003If M is specified, the nonlinear tension stiffening behavior defined by Equation 3. It is suggested that M = (75 mm)* \\(\\rho_\\ell\\) / d b where \\(\\rho_\\ell\\) is the steel ratio in the direction parallel to the material direction and d b is the bar diameter in mm. \u2003\u2003The material unloads from tension strain using a slope of Ec . After reaching zero stress, the material targets the point (0, - alpha ft ). Thereafter, the material loads linearly to the point where the peak compressive strain previously occurred. In the case where the slope leading to this target point is less than that for the point (0, - alpha ft ), the material reloads directly to the point where peak compressive strain occurred. thumb|center|upright=4.0|alt=ConcretewBeta Figure 1 |Figure 1. ConcretewBeta material model behavior based on specified input parameters thumb|upright=2.0|alt=ConcretewBeta Figure 2 |Figure 2. Relation between the concrete compressive stress reduction factor, \\(\\beta\\) , and normal tensile strain, \\(\\epsilon_n\\) Biaxial Behavior \u2003\u2003The ConcretewBeta material model accounts for the biaxial strain field on the concrete compressive behavior when used in conjunction with the Truss2 element. The Truss2 element computes the strain normal to the direction of the element (see Truss2 Element ). \u2003\u2003Figure 2 shows the relationship between concrete compressive stress reduction factor, \\(\\beta\\) , and the normal tensile strain, \\(\\epsilon_n\\) . For compressive stresses, the instantaneous stress value computed by the material is \\(\\beta f_c\\) where \\(f_c\\) is the compressive stress given by the uniaxial behavior described above. For positive (tensile) stress, \\(\\beta = 1\\) . For compressive stress, the \\(\\beta - \\epsilon_n\\) relationship is tri-linear and passes through the points (0,1), ( ebint , bint ), and ( ebres , bres ) in that order. For normal tensile strains larger than ebres , \\(\\beta\\) = bres . Examples 20-story RC core wall buildings: conventional fixed-base ( video ), rocking wall ( video ), and base isolation with rocking wall ( video ) 1200px |alt=20-story core walls 5-story coupled wall specimen with diagonal tension failure, see: Video of the simulation 5story_samplePic.png See: Truss Model - Mestyanek (1986) Squat RC Wall and Video of the simulation Mestyanek_resultsPlot2.png See: Beam-truss Model - Beyer et al. (2008) RC Wall and Video of the simulation BeyerWall_fig2.png See: Truss Model - Massone Sanchez (2005) Squat RC Wall and Video of the simulation MassoneWall_displ1a.jpg References Lu, Y., Panagiotou, M, and Koutromanos, I. (2014). \u201cThree-dimensional beam-truss model for reinforced concrete walls and slabs subjected to cyclic static or dynamic loading.\u201d Report PEER 2014/18, Pacific Earthquake Engineering Research Center, University of California, Berkeley, Berkeley, CA. Lu, Y. and Panagiotou, M. (2014). \u201cEarthquake Damage Resistant Multistory Buildings at Near Fault Regions using Base Isolation and Rocking Core Walls.\u201d 1st Huixian International Forum on Earthquake Engineering for Young Researchers, August 16-19, Harbin, China. Lu, Y., and Panagiotou, M. (2014). \u201cThree-Dimensional Nonlinear Cyclic Beam-Truss Model for Reinforced Concrete Non-Planar Walls.\u201d Journal of Structural Engineering, 140 (3), DOI: 10.1061/(ASCE)ST.1943-541X.0000852. Panagiotou, M., Restrepo, J.I., Schoettler, M., and Kim G. (2012). \u201cNonlinear cyclic truss model for reinforced concrete walls.\u201d ACI Structural Journal, 109(2), 205-214. Beyer, K., Dazio, A., and Priestley, M. J. N.(2008). \u201cQuasi-Static Cyclic Tests of Two U-Shaped Reinforced Concrete Walls.\u201d Journal of Earthquake Engineering, 12:7, 1023-1053. Hoshikuma, J., Kawashima, K., Nagaya, K., and Taylor, A. W. (1997). \u201cStress-strain model for confined reinforced concrete in bridge piers.\u201d Journal of Structural Engineering, 123(5), 624-633. Massone Sanchez, L. M. (2006). \u201cRC Wall Shear\u2014Flexure Interaction: Analytical and Experimental Responses.\u201d PhD thesis, University of California, Los Angeles, Los Angeles, CA, 398 pp. Mestyanek, J. M. (1986). \u201cThe earthquake resistance of reinforced concrete structural walls of limited ductility.\u201d ME thesis. University of Canterbury. Stevens, N. J., Uzumeri, S. M., Collins, M. P., and Will, T. G. (1991). \u201cConstitutive model for reinforced concrete finite element analysis.\u201d ACI Structural Journal, 88(1), 49-59. Code Developed by: Yuan Lu, UC Berkeley and Marios Panagiotou, UC Berkeley","title":"ConcretewBeta\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/239-Fatigue/","text":"Fatigue The fatigue material uses a modified rainflow cycle counting algorithm to accumulate damage in a material using Miner\u2019s Rule. Element stress/strain relationships become zero when fatigue life is exhausted. uniaxialMaterial Fatigue $matTag $tag < - E0 $E0 > < -m $m > < - min $min > < - max $max > matTag integer tag identifying material tag Unique material object integer tag for the material that is being wrapped E0 Value of strain at which one cycle will cause failure (default 0.191) m Slope of Coffin-Manson curve in log-log space (default -0.458) min Global minimum value for strain or deformation (default -1e16) max Global maximum value for strain or deformation (default 1e16) Description This material model accounts for the effects of low cycle fatigue. A modified rainflow cycle counter has been implemented to track strain amplitudes. This cycle counter is used in concert with a linear strain accumulation model (i.e. Miner\u2019s Rule), based on Coffin-Manson log-log relationships describing low cycle fatigue failure. This material wraps around another material and does not influence the stress-strain (or force-deformation) relationship of the parent material. Once the Fatigue material model reaches a damage level of 1.0, the force (or stress) of the parent material becomes zero (1.0x10-8 times the call to the material). If failure is triggered in compression, the material stress is dropped at the next zero-force crossing (i.e. compression force never drops to zero). The Fatigue material assumes that each point is the last point of the history, and tracks damage with this assumption. If failure is not triggered, this pseudo-peak is discarded. The material also has the ability to trigger failure based on a maximum or minimum strain (i.e. not related to fatigue). The default for these values is set to very large numbers. The default values are calibrated parameters from low cycle fatigue tests of European steel sections Ballio and Castiglioni (1995), for more information about how material was calibrated, the user is directed to Uriz (2005). Valid recorder objects for the material are \u2018stress\u2019,\u2019tangent\u2019, \u2018strain\u2019, \u2018stressStrain\u2019, and \u2018damage\u2019. The stress, strain, and tangent recorder options must be available in the material that you are wrapping. NOTE: Here you can find more information of how to create \u2018damage\u2019 recorders: link Example: Click to Download Media:FatigueExample.tcl Media:RandomStrainHstory.tcl DamageExample.jpg References: Uriz, Patxi (2005) \u201cTowards Earthquake Resistant Design of Concentrically Braced Steel Structures,\u201d Doctoral Dissertation, Structural Engineering, Mechanics, and Materials, Department of Civil and Environmental Engineering, University of California, Berkeley, December 2005 Ballio, G., and Castiglioni, C. A. (1995). \u201cA Unified Approach for the Design of Steel Structures under Low and/or High Cycle Fatigue.\u201d Journal of Constructional Steel Research, 34, 75-101. Code Developed by: Patxi Uriz, Exponent","title":"Fatigue\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/339-Initial%20Strain/","text":"InitialStrainMaterial This command is used to construct an Initial Strain material object. The stress-strain behaviour for this material is defined by another material. Initial Strain Material enables definition of initial strains for the material under consideration. The stress that corresponds to the initial strain will be calculated from the other material. uniaxialMaterial InitStrainMaterial $matTag $otherTag $initStrain matTag integer tag identifying material otherTag tag of the other material initStrain initial strain","title":"InitialStrainMaterial\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/340-Initial%20Stress/","text":"Initial Stress Material This command is used to construct an Initial Stress material object. The stress-strain behaviour for this material is defined by another material. Initial Stress Material enables definition of initial stress for the material under consideration. The strian that corresponds to the initial stress will be calculated from the other material. uniaxialMaterial InitStressMaterial $matTag $otherTag $initStress matTag integer tag identifying material otherTag tag of the other material initStress initial stress","title":"Initial Stress Material\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/386-MinMax/","text":"MinMax This command is used to construct a MinMax material object. This stress-strain behaviour for this material is provided by another material. If however the strain ever falls below or above certain threshold values, the other material is assumed to have failed. From that point on, values of 0.0 are returned for the tangent and stress. uniaxialMaterial MinMax $matTag $otherTag < - min $minStrain > < - max $maxStrain > matTag integer tag identifying material otherTag tag of the other material minStrain minimum value of strain. optional default = -1.0e16. maxStrain max value of strain. optional default = 1.0e16. Code Developed by: Micheal Scott, Oregon State.","title":"MinMax\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/489-Parallel/","text":"Parallel This command is used to construct a parallel material object made up of an arbitrary number of previously-constructed UniaxialMaterial objects. uniaxialMaterial Parallel $matTag $tag1 $tag2 ... < -factors $fact1 $fact2 ... > matTag integer tag identifying material tag1 tag2 \u2026 identification tags of materials making up the material model fact1 fact2 \u2026 factors to create a linear combination of the specified materials. Factors can be negative to subtract one material from an other. (optional, default = 1.0) The parallel material is represented graphically: In a parallel model, strains are equal and stresses and stiffnesses are additive: Code Developed by: fmk Images Developed by: Silvia Mazzoni","title":"Parallel\n"},{"location":"library/1_Modeling/uniaxialMaterial/wrapper/632-Series/","text":"Series This command is used to construct a series material object made up of an arbitrary number of previously-constructed UniaxialMaterial objects. uniaxialMaterial Series $matTag $tag1 $tag2... matTag integer tag identifying material tag1 tag2 \u2026 identification tags of materials making up the material model The series material is represented graphically: In a series model, stresses are equal and strains and flexibilities are additive: Code Developed by: Micheal Scott, Oregon State University Images Developed by: Silvia Mazzoni","title":"Series\n"},{"location":"library/2_Analysis/","text":"Analysis Capabilities Linear equation solvers, time integration schemes, and solution algorithms are the core of the OpenSees computational framework. The components of a solution strategy are interchangeable, allowing analysts to find sets suited to their particular problem. Outlined here are the available solution strategies. New parts of the solution strategy may be seamlessly plugged in to the existing framework. Static Integrators Determing the next time step for an analysis is done by the following schemes Load Control \u2013 Specifies the incremental load factor to be applied to the loads in the domain Displacement Control \u2013 Specifies the incremental displacement at a specified DOF in the domain Minimum Unbalanced Displacement Norm \u2013 Specifies the incremental load factor such that the residual displacement norm in minimized Arc Length \u2013 Specifies the incremental arc-length of the load-displacement path Transient Integrators Determing the next time step for an analysis including inertial effects is done by the following schemes Newmark \u2013 The two parameter time-stepping method developed by Newmark HHT \u2013 The three parameter Hilbert-Hughes-Taylor time-stepping method Generalized Alpha \u2013 Generalization of the HHT algorithm with improved numerical damping Central Difference \u2013 Approximates velocity and acceleration by centered finite differences of displacement Eigenvalue Solvers The following methods provide the solution of the generalized eigenvalue problem \\(Kv = MvL\\) Symmetric Arpack \u2013 Arpack solver for symmetric matrices Band Arpack \u2013 Arpack solver for banded matrices","title":"Analysis Capabilities\n"},{"location":"library/2_Analysis/Eigen_Analysis/ArpackSolver/","text":"ArpackSolver This is the solver that works on the ArpackSOE. It uses the LinearSOE in the SOE to perform the solve() operation if required. It uses the ARPACK library to perform the eigenvalue analysis. ARPACK is an eigen analysis package which was developed by R.B.Lehoucq, D.C.Sorensen and C.Yang at Rice University. ARPACK is a collection of FORTRAN77 subroutines designed to solve large scale eigen problems. ARPACK is capable of solving large scale non-Hermitian standard and generalized eigen problems. When the matrix K is symmetric, the method is a variant of the Lanczos process called Implicitly Restarted Lanczos Method (IRLM). It is based on previous work of Jun Peng(Stanford) Written : fmk Created : 05.09","title":"ArpackSolver\n"},{"location":"library/2_Analysis/Eigen_Analysis/EigenAlgorithm/","text":"/* ****************************************************************** OpenSees - Open System for Earthquake Engineering Simulation Pacific Earthquake Engineering Research Center (C) Copyright 1999, The Regents of the University of California All Rights Reserved. Commercial use of this program without express permission of the University of California, Berkeley, is strictly prohibited. See file \u2018COPYRIGHT\u2019 in main directory for information on usage and redistribution, and for a DISCLAIMER OF ALL WARRANTIES. Developed by: Frank McKenna (fmckenna@ce.berkeley.edu) Gregory L. Fenves (fenves@ce.berkeley.edu) Filip C. Filippou (filippou@ce.berkeley.edu) ****************************************************************** */ // $Revision: 1.2 $ // $Date: 2003-02-14 23:00:41 $ // $Source: /usr/local/cvs/OpenSees/SRC/analysis/algorithm/eigenAlgo/EigenAlgorithm.h,v $ // File: ~/analysis/algorithm/eigenAlgo/EigenAlgorithm.h // // Written: Jun Peng // Created: Wed Jan 27, 1999 // Revision: A // // Description: This file contains the class definition of EigenAlgorithm. // EigenAlgorithm is a class which performs a eigen solution algorithm // to solve the equations. // // This class is inheritanted from the base class of SolutionAlgorithm // which was created by fmk (Frank). #ifndef EigenAlgorithm_h #define EigenAlgorithm_h #include <SolutionAlgorithm.h> #include <OPS_Globals.h> class AnalysisModel; class EigenSOE; class EigenIntegrator; class EigenAlgorithm : public SolutionAlgorithm { public: EigenAlgorithm(int classTag); virtual ~EigenAlgorithm(); // public functions defined for subclasses virtual void setLinks ( AnalysisModel & theModel , EigenIntegrator & theIntegrator , EigenSOE & theSOE ); // pure virtual functions virtual int solveCurrentStep ( int numModes ) = 0 ; virtual void Print ( OPS_Stream & s , int flag = 0 ) = 0 ; virtual AnalysisModel * getAnalysisModelPtr () const ; virtual EigenIntegrator * getEigenIntegratorPtr () const ; virtual EigenSOE * getEigenSOEptr () const ; protected: private: AnalysisModel theModel; EigenIntegrator theIntegrator; EigenSOE *theSOE; }; #endif","title":""},{"location":"library/2_Analysis/Eigen_Analysis/FrequencyAlgo/","text":"FrequencyAlgo // $Revision: 1.2 $ // $Date: 2003-02-14 23:00:41 $ // $Source: /usr/local/cvs/OpenSees/SRC/analysis/algorithm/eigenAlgo/FrequencyAlgo.h,v $ // File: ~/analysis/algorithm/eigenAlgo/FrequencyAlgo.h // // Written: Jun Peng // Created: Wed Feb. 8, 1999 // Revision: A FrequencyAlgo is a class which performs a eigen solution algorithm to solve the Generalized eigen equations. It is not expected that this class will have subclasses. This class is inheritanted from the base class of SolutionAlgorithm which was created by fmk (Frank). #include <EigenAlgorithm.h> class FrequencyAlgo : public EigenAlgorithm { public : FrequencyAlgo (); virtual ~ FrequencyAlgo (); virtual int solveCurrentStep ( int numModes ); virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag = 0 ); protected : private : };","title":"FrequencyAlgo\n"},{"location":"library/2_Analysis/Eigen_Analysis/StandardEigenAlgo/","text":"StandardEigenAlgo // $Revision: 1.2 $ // $Date: 2003-02-14 23:00:41 $ // $Source: /usr/local/cvs/OpenSees/SRC/analysis/algorithm/eigenAlgo/StandardEigenAlgo.h,v $ // Written: MHS // Created: Oct 2001 // StandardEigenAlgo is a class which performs a eigen solution algorithm to solve standard eigenvalue equations. It is not expected that this class will have subclasses. #include <EigenAlgorithm.h> class StandardEigenAlgo : public EigenAlgorithm { public : StandardEigenAlgo (); virtual ~ StandardEigenAlgo (); virtual int solveCurrentStep ( int numModes ); virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag = 0 ); protected : private : };","title":"StandardEigenAlgo\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/154-Displacement%20Control/","text":"Displacement Control This command is used to construct a DisplacementControl integrator object. In an analysis step with Displacement Control we seek to determine the time step that will result in a displacement increment for a particular degree-of-freedom at a node to be a prescribed value. integrator DisplacementControl $node $dof $incr < $numIter $ \\(\\Delta U \\text{min}\\) $ \\(\\Delta U \\text{max}\\) node node whose response controls solution dof degree of freedom at the node, valid options: 1 through ndf at node. incr first displacement increment U_{} numIter the number of iterations the user would like to occur in the solution algorithm. Optional, default = 1.0. \\(\\Delta U\\text{min}\\) the min stepsize the user will allow. optional, defualt = \\(\\Delta U_{min} = \\Delta U_0\\) \\(\\Delta U \\text{max}\\) the max stepsize the user will allow. optional, default = \\(\\Delta U_{max} = \\Delta U_0\\) Examples displacement control algorithm seking constant increment of 0.1 at node 1 at 2\u2019nd dof. integrator DisplacementControl 1 2 0.1 ; Theory If we write the governing finite element equation at t + t! as: \\[ R(U_{t+\\Delta t}, \\lambda_{t+\\Delta t}) = \\lambda_{t+\\Delta t} F^{ext} - F(U_{t+\\Delta t}) \\!\\] where F(U_{t+t})! are the internal forces which are a function of the displacements U_{t+ t}! , F^{ext}! is the set of reference loads and ! is the load multiplier. Linearizing the equation results in: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = \\left( \\lambda^i_{t+\\Delta t} + \\Delta \\lambda^i \\right) F^{ext} - F(U_{t+\\Delta t})\\] This equation represents \\(n\\) equations in \\(n+1\\) unknowns, and so an additional equation is needed to solve the equation. For displacement control, we introduce a new constraint equation in which in each analysis step we set to ensure that the displacement increment for the degree-of-freedom \\(\\text{dof}\\) at the specified node is: \\[ \\Delta U_\\text{dof} = \\text{incr}\\!\\] MORE TO COME: In Displacement Control the \\(\\Delta_U\\text{dof}\\) set to \\(t + \\lambda_{t+1}\\) where, \\[\\Delta U_\\text{dof}^{t+1} = \\max \\left( \\Delta U_{min}, \\min \\left( \\Delta U_\\text{max}, \\frac{\\text{numIter}}{\\text{lastNumIter}} \\Delta U_\\text{dof}^{t} \\right) \\right) \\] Code Developed by: fmk","title":"Displacement Control\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/24-Arc-Length%20Control/","text":"Arc-Length Control This command is used to construct an ArcLength integrator object. In an analysis step with ArcLength we seek to determine the time step that will result in our constraint equation being satisfied. integrator ArcLength $s $alpha s \\(s\\) the arcLength. alpha \\(\\alpha\\) a scaling factor on the reference loads. Examples integrator ArcLength 1.0 0.1; Theory If we write the governing finite element equation at <math>t + t!</math>as: \\[ R(U_{t+\\Delta t}, \\lambda_{t+\\Delta t}) = \\lambda_{t+\\Delta t} F^{ext} - F(U_{t+\\Delta t}) \\!\\] where <math>F(U_{t+t})!</math> are the internal forces which are a function of the displacements <math>U_{t+ t}!</math>, <math>F^{ext}!</math> is the set of reference loads and <math>!</math> is the load multiplier. Linearizing the equation results in: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = \\left ( \\lambda^i_{t+\\Delta t} + \\Delta \\lambda^i \\right ) F^{ext} - F(U_{t+\\Delta t})\\] This equation represents n equations in \\(n+1\\) unknowns, and so an additional equation is needed to solve the equation. For displacement control, we introduce a new constraint equation in which in each analysis step we set to ensure that the displacement increment for the degree-of-freedom \\(\\text{dof}\\) at the specified node is: \\[ \\!\\] MORE TO COME: Code Developed by: fmk","title":"Arc-Length Control\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/372-Load%20Control/","text":"Load Control This command is used to construct a LoadControl integrator object. integrator LoadControl $lambda & lt ; $numIter $minLambda $maxLambda & gt ; lambda the load factor increment <math></math> numIter the number of iterations the user would like to occur in the solution algorithm. Optional, default = 1.0. minLambda the min stepsize the user will allow. optional, defualt = \\(\\lambda_{min} = \\lambda\\) maxLambda the max stepsize the user will allow. optional, default = \\(\\lambda_{max} = \\lambda\\) NOTES: The change in applied loads that this causes depends on the active load patterns (those load patterns not set constant) and the loads in the load patterns. If the only active loads acting on the domain are in load patterns with a Linear time series with a factor of 1.0, this integrator is the same as the classical load control method. The optional arguments are supplied to speed up the step size in cases where convergence is too fast and slow down the step size in cases where convergence is too slow. Examples integrator LoadControl 0.1; Theory In Load Control the time in the domain is set to \\(t + \\lambda_{t+1}\\) where, \\[\\lambda_{t+1} = \\max \\left ( \\lambda_{min}, \\min \\left ( \\lambda_{max}, \\frac{\\text{numIter}}{\\text{lastNumIter}} \\lambda_{t} \\right ) \\right ) \\] Code Developed by: fmk LoadControl #include <analysis/integrator/LoadControl.h> class LoadControl: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadControl is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the load control method. In the load control method, the following constraint equation is added to equation [staticFormTaylor$$ of the StaticIntegrator class: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = \\delta \\lambda_n\\] where \\(\\delta \\lambda_n\\) depends on \\(\\delta \\lambda_{n-1}\\) , the load increment at the previous time step, \\(J_{n-1}\\) , the number of iterations required to achieve convergence in the previous load step, and \\(Jd\\) , the desired number of iteraions. \\(\\delta \\lambda_n\\) is bounded by \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] Knowing \\(\\lambda_n^{(i)}\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor$$ , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadControl}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadControl (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. \\(\\delta \\lambda_1\\) is the load factor used in the first step. The arguments \\(Jd\\) , \\(\\delta \\lambda_{min}\\) , and \\(\\delta \\lambda_{max}\\) are used in the determination of the increment in the load factor at each step. Does nothing. int newStep ( void ); The object obtains the current value of \\(\\lambda\\) from the AnalysisModel object. It increments this by \\(\\delta \\lambda_n\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] It will then invoke applyLoadDomain ( 0.0 , $ \\lambda $ ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. Sets the value of the load increment in newStep() to be \\(\\delta \\lambda\\) . Returns \\(0\\) . int sendSelf(int commitTag, Channel &theChannel); Places in a vector if size 5 the value of \\(\\delta \\lambda_{n-1}\\) , \\(Jd\\) , \\(J_{n-1}\\) , \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) ) and then sends the Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 5 the data that was sent in sendSelf() . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"Load Control\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/387-Minimum%20Unbalanced%20Displacement%20Norm/","text":"Minimum Unbalanced Displacement Norm This command is used to construct a StaticIntegrator object of type MinUnbalDispNorm. integrator MinUnbalDispNorm $dlambda1 & lt ; $Jd $minLambda $maxLambda & gt ; dlambda1 first load increment (pseudo-time step) at the first iteration in the next invocation of the analysis command. Jd factor relating first load increment at subsequent time steps (optional, default: 1.0) $minLambda, $maxLambda arguments used to bound the load increment (optional, default: $dLambda1 for both) Examples integrator MinUnbalDispNorm 0.1; Theory The load increment at iteration i, \\(d\\lambda_{1,i}\\) , is related to the load increment at (i-1), \\(d\\lambda_{1,i-1}\\) , and the number of iterations at (i-1), \\(J_{i-1}\\) , by the following: \\[d\\lambda_{1,i} = d\\lambda_{1,i-1}\\frac{J_d}{J_{i-1}}\\] Code Developed by: fmk","title":"Minimum Unbalanced Displacement Norm\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/EQPath/","text":"EQPath integrator EQPath $arc_length $type References Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 849 - 878 DOI: https://doi.org/10.12989/sem.2013.48.6.849 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part I : Formulation and characteristics of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/264146397_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_I_Formulation_and_characteristics_of_the_methods Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 879 - 914 DOI: https://doi.org/10.12989/sem.2013.48.6.879 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part II : Comparing efficiencies of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/263361974_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_II_Comparing_efficiencies_of_the_methods Code developed by: M. Salehi opensees.net@gmail.com Created: 02/19","title":"EQPath\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/HSConstraint/","text":"HSConstraint","title":"HSConstraint\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/LoadPath/","text":"LoadPath #include <analysis/integrator/LoadPath.h> class LoadPath: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadPath is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a user specified load path. The load path is specified in a Vector, path , to the objects constructor and at each step in the analysis: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = path(n) - path(n-1)\\] Knowing \\(\\lambda_n^{(i)} = path(n)\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor$$ , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadPath}\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. A vector object path is created which is a copy of loadPath and an index into this vector is set to \\(0\\) . The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. No vector object is created. Provided for the FEM_ObjectBroker to create a blank object, recvSelf() should be invoked on this object. Invokes the destructor on the vector path . The object obtains the current value of \\(\\lambda\\) from the path vector using the current index. The index is then incremented by \\(1\\) . If the index is greater than the size of path , \\(\\lambda\\) is set to \\(0\\) and an error message is printed. It will then invoke applyLoadDomain(0.0, \\(\\lambda\\) ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int sendSelf(int commitTag, Channel &theChannel); Places the size if path and the index in an ID of size 2 and send this ID. Then sends the Vector path . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the ID or the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a ID of size 2 the size of the vector and current index. Creates a new Vector and receives the Vector from the Channel. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to receive the Vector or the ID. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) .","title":"LoadPath\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/ParkLMS3/","text":"ParkLMS3","title":"ParkLMS3\n"},{"location":"library/2_Analysis/Static_Analysis/integrator/StagedLoadControl/","text":"StagedLoadControl","title":"StagedLoadControl\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/231-Explicit%20Difference/","text":"Explicit Difference This command is used to construct a Explicit Difference integrator object. integrator Explicitdifference Examples integrator Explicitdifference Notes When using Rayleigh damping, the damping ratio of high vibration modes is overrated, and the critical time step size will be much smaller. Hence Modal damping is more suitable for this method. There should be no zero element on the diagonal of the mass matrix when using this method. Diagonal solver should be used when lumped mass matrix is used because the equations are uncoupled. For stability, \\(\\Delta t \\leq\\left(\\sqrt{\\zeta^{2}+1}-\\zeta\\right) \\frac{2}{\\omega}\\) Theory The Explicit Difference Integrator is based on the Leap-frog method. The basic formula of Leap-frog method is shown as below: \\[ \\begin{aligned} &\\hat{\\ddot{u}}_{t}=M^{-1}\\left(F-K u_{t}-C \\dot{u}_{t-\\frac{1}{2} \\Delta t}\\right) \\\\ &\\hat{\\dot{u}}_{t+\\frac{1}{2} \\Delta t}=\\dot{u}_{t-\\frac{1}{2} \\Delta t}+\\ddot{\\hat{u}}_{t} \\Delta t \\\\ &u_{t+\\Delta t}=u_{t}+\\dot{\\hat{u}}_{t+\\frac{1}{2} \\Delta t} \\Delta t \\end{aligned} \\] As mass matrix M is a diagonal matrix, the equations can be uncoupled, then the solution procedure will be very efficient. Code Developed by: Shuhao Zhang, Tsinghua University, and Prof. Xinzheng Lu, Tsinghua University","title":"Explicit Difference\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/277-Generalized%20Alpha%20Method/","text":"Generalized Alpha Method This command is used to construct a Generalized \\(\\alpha\\) integration object. This is an implicit method that like the HHT method allows for high frequency energy dissipation and second order accuracy, i.e. \\(\\Delta t^2\\) . Depending on choices of input parameters, the method can be unconditionally stable. integrator GeneralizedAlpha $alphaM $alphaF < $gamma $beta > alphaM \\(\\alpha_M\\) factor alphaF \\(\\alpha_F\\) factor gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator GeneralizedAlpha 1.0 0.8 NOTES: \\(\\alpha_F\\) and \\(\\alpha_M\\) are defined differently that in the paper, we use \\(\\alpha_F = (1-\\alpha_f)\\) and \\(\\alpha_M=(1-\\gamma_m)\\) where \\(\\alpha_f\\) and \\(\\alpha_m\\) are those used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha_M = 1.0, \\alpha_F = 1.0\\) produces the Newmark Method. \\(\\alpha_M = 1.0\\) corresponds to the HHT method. The method is second-order accurate provided \\(\\gamma = \\tfrac{1}{2} + \\alpha_M - \\alpha_F\\) The method is unconditionally stable provided \\(\\alpha_M >= \\alpha_F &gt;= \\tfrac{1}{2}, \\beta>=\\tfrac{1}{4} +\\tfrac{1}{2}(\\gamma_M - \\gamma_F)\\) \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is unconditionally stable, second order accurate and high frequency dissipation is maximized. The defaults are: \\[\\gamma = \\tfrac{1}{2} + \\gamma_M - \\gamma_F\\] and \\[\\beta = \\tfrac{1}{4}(1 + \\gamma_M - \\gamma_F)^2\\] References J. Chung, G.M.Hubert. \u201cA Time Integration Algorithm for Structural Dynamics with Improved Numerical Dissipation: The Generalized- \\(\\alpha\\) Method\u201d ASME Journal of Applied Mechanics, 60, 371:375, 1993. Theory The Generalized \\(\\alpha\\) method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. In the HHT method, the same Newmark approximations are used: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[R_{t + \\alpha_M \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\alpha_M \\Delta t} - C \\dot U_{t+\\alpha_F \\Delta t} - F^{int}(U_{t + \\alpha_F \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[U_{t+ \\alpha_F \\Delta t} = (1 - \\alpha_F) U_t + \\alpha_F U_{t + \\Delta t}\\] \\[\\dot U_{t+\\alpha_F \\Delta t} = (1-\\alpha_F) \\dot U_t + \\alpha_F \\dot U_{t + \\Delta t}\\] \\[\\ddot U_{t+\\alpha_M \\Delta t} = (1-\\alpha_M) \\ddot U_t + \\alpha_M \\ddot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, linearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = \\alpha_F K_t + \\frac{\\alpha_F \\gamma}{\\beta \\Delta t} C_t + \\frac{\\alpha_M}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\alpha F \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\alpha F \\Delta t}^{i-1} - M \\ddot U_{t+ \\alpha M \\Delta t}^{i-1}\\] The linear equations are used to solve for \\[U_{t+\\alpha F \\Delta t}, \\dot U_{t + \\alpha F \\Delta t} \\ddot U_{t+ \\alpha M \\Delta t}\\] Once convergence has been achieved the displacements, velocities and accelerations at time \\(t + \\Delta t\\) can be computed. Code Developed by: fmk","title":"Generalized Alpha Method\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/326-Hilber-Hughes-Taylor%20Method/","text":"Hilber-Hughes-Taylor This command is used to construct a Hilber-Hughes-Taylor (HHT) integrator. This is an implicit method that allows for energy dissipation and second order accuracy (which is not possible with the regular Newmark method). Depending on choices of input parameters, the method can be unconditionally stable. integrator HHT $alpha < $gamma $beta > alpha \\(\\alpha\\) factor gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator HHT 0.9 NOTES: \\(\\alpha\\) is defined differently that in the paper, we use \\(\\alpha = (\\alpha_{HHT} - 1})\\) where \\(\\alpha_{HHT}\\) is that used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha = 1.0\\) corresponds to the Newmark method. \\(\\alpha\\) should be between \\(0.67\\) and \\(1.0\\) . The smaller the \\(\\alpha\\) the greater the numerical damping. \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is second order accurate and unconditionally stable when \\(\\alpha\\) is \\(\\tfrac{2}{3} \\le \\alpha \\le 1.0\\) . The defaults are: \\[\\beta = \\frac{(2 - \\alpha)^2}{4}\\] and \\[\\gamma = \\frac{3}{2} - \\alpha\\] References Hilber, H.M, Hughes,T.J.R and Talor, R.L. \u201cImproved Numerical Dissipation for Time Integration Algorithms in Structural Dynamics\u201d Earthquake Engineering and Structural Dynamics, 5:282-292, 1977. Theory The HHT method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. In the HHT method, the same Newmark approximations are used: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[ R_{t + \\alpha \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\Delta t} - C \\dot U_{t+\\alpha \\Delta t} - F^{int}(U_{t + \\alpha \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[U_{t+ \\alpha \\Delta t} = (1 - \\alpha) U_t + \\alpha U_{t + \\Delta t}\\] \\[\\dot U_{t+\\alpha \\Delta t} = (1-\\alpha) \\dot U_t + \\alpha \\dot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, loinearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = \\alpha K_t + \\frac{\\alpha \\gamma}{\\beta \\Delta t} C_t + \\frac{1}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\alpha \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\alpha \\Delta t}^{i-1} - M \\ddot U_{t+ \\Delta t}^{i-1}\\] The linear equations are used to solve for \\(U_{t+\\alpha \\Delta t}, \\dot U_{t + \\alpha \\Delta t} \\ddot U_{t+\\Delta t}\\) . Once convergence has been achieved the displacements and velocities at time \\(t + \\Delta t\\) can be computed. Code developed by: fmk","title":"Hilber-Hughes-Taylor\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/416-Newmark%20Method/","text":"Newmark Method This command is used to construct a Newmark integrator object. integrator Newmark $gamma $beta gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator Newmark 0.5 0.25 NOTES: If the accelerations are chosen as the unknowns and \\(\\beta\\) is chosen as 0, the formulation results in the fast but conditionally stable explicit Central Difference method. Otherwise the method is implicit and requires an iterative solution process. Two common sets of choices are Average Acceleration Method ( \\(\\gamma=\\tfrac{1}{2}, \\beta = \\tfrac{1}{4}\\) Linear Acceleration Method ( \\(\\gamma=\\tfrac{1}{2}, \\beta = \\tfrac{1}{6}\\) \\(\\gamma &gt; \\tfrac{1}{2}\\) results in numerical damping proportional to <math> - </math> The method is second order accurate if and only if <math>=</math> The method is conditionally stable for <math> >= >= </math> References Newmark, N.M. \u201cA Method of Computation for Structural Dynamics\u201d ASCE Journal of Engineering Mechanics Division, Vol 85. No EM3, 1959. Theory The Newmark method is a one step implicit method for solving the transient problem, represented by the residual for the momentum equation: \\[R_{t + \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\Delta t} - C \\dot U_{t + \\Delta t} + F(U_{t + \\Delta t})^{int}\\] Using the Taylor series approximation of <math>U_{t+ t}</math> and \\(\\dot U_{t+\\Delta t}\\) : \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + \\tfrac{\\Delta t^2}{2} \\ddot U_t + \\tfrac{\\Delta t^3}{6} \\dot \\ddot U_t + \\cdots \\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + \\Delta t \\ddot U_t + \\tfrac{\\Delta t^2}{2} \\dot \\ddot U_t + \\cdots \\] Newton truncated these using the following: \\[U_{t+\\Delta t} = u_t + \\Delta t \\dot U_t + \\tfrac{\\Delta t^2}{2} \\ddot U + \\beta {\\Delta t^3} \\dot \\ddot U \\] \\[\\dot U_{t + \\Delta t} = \\dot U_t + \\Delta t \\ddot U_t + \\gamma \\Delta t^2 \\dot \\ddot U \\] in which he assumed linear acceleration within a time step, i.e. \\[\\dot \\ddot U = \\frac{{\\ddot U_{t+\\Delta t}} - \\ddot U_t}{\\Delta t} \\] which results in the following expressions: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] The variables \\(\\beta\\) and \\(\\gamma\\) are numerical parameters that control both the stability of the method and the amount of numerical damping introduced into the system by the method. For \\(\\gamma=\\tfrac{1}{2}\\) there is no numerical damping; for \\(\\gamma&gt;=\\tfrac{1}{2}\\) numerical damping is introduced. Two well known and commonly used cases are: Average Acceleration Method ( \\(\\gamma=\\tfrac{1}{2}, \\beta = \\tfrac{1}{4}\\) Constant Acceleration Method ( \\(\\gamma=\\tfrac{1}{2}, \\beta = \\tfrac{1}{6}\\) The linearization of the Newmark equations gives: \\[dU_{t+\\Delta t}^{i+1} = \\beta \\Delta t^2 d \\ddot U_{t+\\Delta t}^{i+1}\\] \\[d \\dot U_{t+\\Delta t}^{i+1} = \\gamma \\Delta t \\ddot U_{t+\\Delta t}^{i+1}\\] which gives the update formula when displacement increment is used as unknown in the linearized system as: \\[U_{t+\\Delta t}^{i+1} = U_{t+\\Delta t}^i + dU_{t+\\Delta t}^{i+1}\\] \\[\\dot U_{t+\\Delta t}^{i+1} = \\dot U_{t+\\Delta t}^i + \\frac{\\gamma}{\\beta \\Delta t}dU_{t+\\Delta t}^{i+1}\\] \\[\\ddot U_{t+\\Delta t}^{i+1} = \\ddot U_{t+\\Delta t}^i + \\frac{1}{\\beta \\Delta t^2}dU_{t+\\Delta t}^{i+1}\\] The linearization of the momentum equation using the displacements as the unknowns leads to the following linear equation: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = K_t + \\frac{\\gamma}{\\beta \\Delta t} C_t + \\frac{1}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\Delta t}^{i-1} - M \\ddot U_{t+ \\Delta t}^{i-1}\\] Code Developed by: fmk","title":"Newmark Method\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/675-TRBDF2/","text":"TRBDF2 This command is used to construct a TRBDF2 integrator object. The TRBDF2 integrator is a composite scheme that alternates between the Trapezoidal scheme and a 3 point backward Euler scheme. It does this in an attempt to conserve energy and momentum, something newmark does not always do. integrator TRBDF2 NOTES: As opposed to dividing the time-step in 2 as outlined in the papers, we just switch alternate between the 2 integration strategies,i.e. the time step in our implementation is double that described in the papers. Examples integrator TRBDF2 References Bank, R.E., Coughran W.M., Fichter W., Grosse E.H., Rose, D.J., and Smith R.K. \u201cTransient Simulations of Silicon Devices and Circuits\u201d, IEE Trans CAD, Vol(4), 436-451, 1985. Bathe, K.J. \u201cConserving Energy and Momentum in Nonlinear Dynamics: A Simple Impicit Time Integration Scheme\u201d, Computers and Structures, Vol(85), 437-445, 2007. doi:10.1016/j.compstruc.2006.09.004 Theory COMING SOON. LOOK AT BATHE\u2019S PAPER FOR NOW. Code Developed by: fmk","title":"TRBDF2\n"},{"location":"library/2_Analysis/Transient_Analysis/integrator/81-Central%20Difference/","text":"Central Difference This command is used to construct a Central Difference integrator object. integrator CentralDifference Examples integrator CentralDifference NOTES: The calculation of \\(U_{t+\\Delta t}\\) , as shown below, is based on using the equilibrium equation at time t. For this reason the method is called an explicit integration method . If there is no rayleigh damping and the C matrix is 0, for a diagonal mass matrix a diagonal solver may and should be used. For stability, <math> < </math> References Theory The Central difference approximations for velocity and acceleration: \\[v_n = \\frac{d_{n+1} - d_{n-1}}{2 \\Delta t}\\] \\[a_n = \\frac{d_{n+1} - 2 d_n + d_{n-1}}{\\Delta t^2}\\] In the Central Difference method we determine the displacement solution at time \\(t+\\delta t\\) by considering the the eqilibrium equation for the finite element system in motion at time t: \\[M \\ddot U_t + C \\dot U_t + K U_t = R_t\\] which when using the above two expressions of becomes: \\[\\left ( \\frac{1}{\\Delta t^2} M + \\frac{1}{2 \\Delta t} C \\right ) U_{t+\\Delta t} = R_t - \\left (K - \\frac{2}{\\Delta t^2}M \\right )U_t - \\left (\\frac{1}{\\Delta t^2}M - \\frac{1}{2 \\Delta t} C \\right) U_{t-\\Delta t} \\] Code Developed by: fmk","title":"Central Difference\n"},{"location":"library/4_Utilities/units/","text":"units meter [\u2018m\u2019] milimeter [\u2018mm\u2019] inch [\u2018inch\u2019, \u2018in\u2019] international_foot [\u2018foot\u2019, \u2018ft\u2019] us_survey_foot [\u2018s_foot\u2019, \u2018s_ft\u2019] international_yard [\u2018yard\u2019, \u2018yd\u2019] kilogram [\u2018kg\u2019] pound_mass [\u2018lb\u2019] newton [\u2018N\u2019] pound_force [\u2018lbf\u2019] kip [\u2018kip\u2019] hertz [\u2018Hz\u2019] radian [\u2018radian\u2019, \u2018rad\u2019] arc_degree [\u2018deg\u2019]","title":"units\n"},{"location":"library/4_Utilities/recorders/159-Drift%20Recorder/","text":"Drift Recorder The Drift type records the displacement drift between two nodes. The drift is taken as the ratio between the prescribed relative displacement and the specified distance between the nodes. The command to create a drift recorder is: recorder Drift <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-time> -iNode $inode1 $inode2 \u2026 -jNode $jnode1 $jnode2 \u2026 -dof $dof1 $dof2 \u2026 -perpDirn $perpDirn1 \\(perpDirn2 ...</em></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">fileName</code></p></td> <td><p>name of file to which output is sent. Each line of the file contains the result for a committed state of the domain file output is either in xml format (-xml option), textual (-file option) or binary (-binary option)</p></td> </tr> <tr class=\"even\"> <td><p><strong>inetAddr</strong></p></td> <td><p>ip address, \"xx.xx.xx.xx\", of remote machine to which data is sent</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">port</code></p></td> <td><p>port on remote machine awaiting tcp</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">nSD</code></p></td> <td><p>number of significant digits (optional, default is 6)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-time</code></p></td> <td><p>using this option places domain time in first entry of each data line (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) inode1 \\(inode2 ...</strong></p></td> <td><p>tags of set of i nodes for which drift is being recorded</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) jnode1 \\(jnode2 ...</strong></p></td> <td><p>tags of set of j nodes for which drift is being recorded</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dof1 dof2 \u2026 set of nodal degrees of freedom for which drift is being recorded. Valid range is from 1 through ndf (the number of nodal degrees of freedom). $perpDirn1 $perpDirn2 \u2026 set of perpendicular global directions (1=X, 2=Y, 3=Z). This input is needed to calculate the length between the nodes whose drift is calculated. NOTES Only one of -file, -xml, -binary, -tcp will be used. If multiple specified last option is used. -tcp option only available for version 2.2.1 and higher. Does not work in OpenSeesSP. EXAMPLE recorder Drift -file drift.out -time -iNode 1 2 -jNode 3 4 -dof 1 -perpDirn 2 Code Developed by: fmk","title":"Drift Recorder\n"},{"location":"library/4_Utilities/recorders/205-ElementEnvelopeRecorder/","text":"ElementEnvelopeRecorder The Envelope Element recorder type records the response of a number of elements at every converged step. The response recorded is element-dependent and also depends on the arguments which are passed to the setResponse() element method. When the object is terminated, through the use of a wipe , exit , or remove the object will output the min, max and absolute max values on 3 seperate lines of the output file for each quantity. recorder EnvelopeElement <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision \\(nSD&gt; &lt;-time&gt; &lt;-closeOnWrite&gt; &lt;-ele (\\) ele1 $ele2 \u2026)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 \\(arg2 ...</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">fileName</code></p></td> <td><p>name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">nSD</code></p></td> <td><p>number of significant digits (optional, default is 6)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-time</code></p></td> <td><p>(optional using this option places domain time in first entry of each data line, default is to have time ommitted)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-flag\">-closeOnWrite</code></p></td> <td><p>optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) ele1 \\(ele2 ..</strong></p></td> <td><p>tags of elements whose response is being recorded -- selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) startEle \\(endEle ..</strong></p></td> <td><p>tag for start and end elements whose response is being recorded -- range of selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">regTag</code></p></td> <td><p>previously-defined tag of region of elements whose response is being recorded -- region of elements in domain (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) arg1 $arg2 \u2026 arguments which are passed to the setResponse() element method RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTE: The setResponse() element method is dependent on the element type, and is described with the Element Command . EXAMPLE Examples recorder Element -file Element1.out -time -ele 1 3 section 1 fiber 0.10 0.10 stressStrain Code Developed by: fmk","title":"ElementEnvelopeRecorder\n"},{"location":"library/4_Utilities/recorders/208-Element%20Recorder/","text":"Element Recorder The Element recorder type records the response of a number of elements at every converged step. The response recorded is element-dependent and also depends on the arguments which are passed to the setResponse() element method. The command to create an element recorder is: recorder Element < - file $fileName > < - xml $fileName > < - binary $fileName > < - precision $nSD > < - time > < - closeOnWrite > < - dT $deltaT > < - ele ( $ele1 $ele2 ... ) > < - eleRange $startEle $endEle > < - region $regTag > $arg1 $arg2 ... fileName name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option) nSD number of significant digits (optional, default is 6) -time (optional using this option places domain time in first entry of each data line, default is to have time ommitted) -closeOnWrite optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis. deltaT time interval for recording. will record when next step is deltaT greater than last recorder step. (optional, default: records at every time step) ele1 ele2 \u2026 tags of elements whose response is being recorded \u2013 selected elements in domain (optional, default: omitted) startEle endEle .. tag for start and end elements whose response is being recorded \u2013 range of selected elements in domain (optional, default: omitted) regTag previously-defined tag of region of elements whose response is being recorded \u2013 region of elements in domain (optional) arg1 arg2 \u2026 arguments which are passed to the setResponse() element method RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTE: The setResponse() element method is dependent on the element type, and is described with the Element Command . EXAMPLE Examples recorder Element - file Element1.out - time - ele 1 3 - section 1 - fiber 0.10 0.10 stressStrain Code Developed by: fmk","title":"Element Recorder\n"},{"location":"library/4_Utilities/recorders/430-Node%20Envelope%20Recorder/","text":"Node Envelope Recorder The EnvelopeNode recorder type records the min, max and absolute max of a number of nodal response quantaties. The command to create a node envelope recorder is: recorder EnvelopeNode < - file $fileName > < - xml $fileName > < - precision $nSD > < - time > < - closeOnWrite > < - timeSeries $tsTag > < - node $node1 $node2 ... > < - nodeRange $startNode $endNode > < - region $regionTag > - dof ( $dof1 $dof2 ... ) $respType fileName name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option) nSD number of significant digits (optional, default is 6) -time (optional using this option places domain time in first entry of each data line, default is to have time ommitted) -closeOnWrite optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis. tsTag the tag of a previously constructed TimeSeries, results from node at each time step are added to load factor from series node1 node2 .. tags of nodes whose response is being recorded (optional, default: omitted) startNode endNode .. tag for start and end nodes whose response is being recorded (optional, default: omitted) regionTag a region tag; to specify all nodes in the previously defined region. (optional) dof1 dof2 \u2026 the specified dof at the nodes whose response is requested. respType a string indicating response required. Response types are given in table below. disp displacement* vel velocity* accel acceleration* incrDisp incremental displacement \u201ceigen i\u201d eigenvector for mode i reaction nodal reaction RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. EXAMPLE recorder EnvelopeNode -file nodesD.out -time -node 1 2 3 4 -dof 1 2 disp recorder EnvelopeNode -file nodesA.out -time -timeSeries 1 -node 1 2 3 4 -dof 1 accel Code Developed by: fmk","title":"Node Envelope Recorder\n"},{"location":"library/4_Utilities/recorders/431-Node%20Recorder/","text":"Node The Node recorder type records the response of a number of nodes at every converged step. The command to create a node recorder is: recorder Node < - file $fileName > < - xml $fileName > < -binary $fileName > < - tcp $inetAddress $port > < - precision $nSD > < - timeSeries $tsTag > < - time > < - dT $deltaT > < -closeOnWrite > < - node $node1 $node2 ... > < - nodeRange $startNode $endNode > < - region $regionTag > - dof ( $dof1 $dof2 ... ) $respType fileName name of file to which output is sent. file output is either in xml format ( -xml option), plain text ( -file option) or binary ( -binary option). inetAddr ip address, xx.xx.xx.xx , of remote machine to which data is sent port port on remote machine awaiting tcp nSD number of significant digits (optional, default is 6) -time optional, using this option places domain time in first entry of each data line, default is to have time ommitted -closeOnWrite optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis. deltaT time interval for recording. will record when next step is deltaT greater than last recorder step. (optional, default: records at every time step) tsTag the tag of a previously constructed TimeSeries, results from node at each time step are added to load factor from series node1 node2 .. tags of nodes whose response is being recorded (optional, default: omitted) startNode endNode .. tag for start and end nodes whose response is being recorded (optional, default: omitted) regionTag a region tag; to specify all nodes in the previously defined region. (optional) dof1 dof2 \u2026 the specified dof at the nodes whose response is requested. respType a string indicating response required. Response types are given in table below. disp displacement* vel velocity* accel acceleration* incrDisp incremental displacement \u201ceigen i\u201d eigenvector for mode i reaction nodal reaction rayleighForces damping forces RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTES Only one of -file , -xml , -binary , -tcp will be used. If multiple specified last option is used. -tcp option only available for version 2.2.1 and higher. In case you want to remove a recorder you need to know the tag for that recorder. Here is an example on how to get the tag of a recorder: set tagRc [recorder Node -file nodesD.out -time -node 1 2 3 4 -dof 1 2 disp] EXAMPLES Generates output file nodesD.out that contains relative displacements in \\(x\\) and \\(y\\) direction at nodes 1, 2, 3, and 4. The output file will contain 9 columns (time, disp. in x at node 1, disp. in y at node 1, \u2026 , disp. in y at node 4)) recorder Node - file nodesD.out - time - node 1 2 3 4 - dof 1 2 disp ; For a UniformExcitation analysis, this command generates output file nodesA.out that contains absolute accelerations (ground motion acceleration + relative acceleration) in x direction for nodes 1, 2, 3, and 4. NOTE that if no TimeSeries is provided and a uniform excitation analysis is performed, the relative accelerations are recorded. recorder Node - file nodesA.out - timeSeries 1 - time - node 1 2 3 4 - dof 1 accel ; Code Developed by: fmk","title":"Node\n"},{"location":"library/4_Utilities/recorders/517-Plot%20Recorder/","text":"Plot Recorder This recorder type opens a graphical window for the plotting of the contents of the prescribed file. The prescribed file can be the output of an other recorder. recorder plot $fileName $windowTitle $xLoc $yLoc $xPixels $yPixels -columns $xCol0 $yCol0 & lt ; -columns $xCol1 $yCol1 & gt ; ... fileName name of file from which data will be read windowTitle title of window to be opened xLoc yLoc $xLoc, \\(yLoc specifies location on screen of top left corner of window</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">xPixels yPixels</code></p></td> <td><p>\\) xPixels, \\(yPixels specifies width and height in pixels of window to open</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) xCol $yCol \u2026 integers specifying which columns to plot for x and y axis. NOTES At least one set of columns must be specified, additional ones may be specified. the only way to save the image is a screen capture. EXAMPLE Examples recorder Plot node.out \u201cNodal Displacement\u201d 10 10 400 400 -columns 1 2 Code Developed by: fmk","title":"Plot Recorder\n"},{"location":"library/4_Utilities/sections/patch/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } patch A patch is used to generate a number of fibers over a cross-sectional area. Currently there are three types of patches that fibers can be generated over: quadrilateral, rectangular and circular. All patches have the following attributes: area Total area of the patch. moic Second moment of area matrix of the patch about its centroidal axis ixc Second moment of inertia of the patch about its \\(x\\) axis iyc Second moment of inertia of the patch about its \\(y\\) axis fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). Fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). rect (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num quad (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num circ (material, \u2003\u2003\u2003divs, \u2003\u2003\u2003center, \u2003\u2003\u2003intRad, \u2003\u2003\u2003extRad, \u2003\u2003\u2003startAng, \u2003\u2003\u2003endAng, \u2003\u2003\u2003**kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [circ,rad] circ Int number of subdivisions (fibers) in the circumferential direction (number of wedges) rad Int number of subdivisions (fibers) in the radial direction (number of rings) center = [0.0, 0.0] [y,z] \\(y\\) & \\(z\\) -coordinates of the center of the circle y Num z Num intRad Num internal radius extRad Num external radius startAng Num starting angle endAng = 6.283185307179586 Num ending angle line (material, divs, fiber_area, vertices, **kwds) material Ref(Material) Reference to previously created material ( UniaxialMaterial for a FiberSection or NDMaterial for use in an NDFiberSection ) divs Int number of fibers along line area Num area of each fiber vertices [[y,z],[y,z]] start [y,z] \\(y\\) and \\(z\\) -coordinates of first fiber in line (local coordinate system) y Num z Num end [y,z] \\(y\\) and \\(z\\) -coordinates of last fiber in line (local coordinate system) y Num z Num","title":"patch\n"},{"location":"library/5_Packages/","text":"Misc background mesh remesh Hfiber generateInterfacePoints multipleNormalSpring PyGen, Scott J. Brandenberg PySimple1Gen TzSimple1Gen UCSD, Prishati Raychowdhury ShallowFoundationGen Reliability parameter addToParameter updateParameter element [] uniaxialMaterial [] force/displBeamColumn beamIntegration UpdatedLagrangianBeamColumn by Rohit Kaul (rkaul@stanford.edu), Greg Deierlein (ggd@stanford.edu) element UpdatedLagrangianBeamColumn element element2dYS03 (Uses YieldSurface objects) cyclicModel FrictionBearing frictionModel element TripleFrictionPendulum element RJWatsonEqsBearing element flatSliderBearing element singleFPBearing element MultiFP2d CompGeoMech nDmaterial Template3Dep Altoonash / SNAP element Joint2D uniaxialMaterial SNAP* damageModel YieldSurface section YS_Section* yieldSurface_BC ysEvolutionModel plasticMaterial LimitState Material uniaxialMaterial LimitState\u2026 limitCurve AlgebraicHystereis uniaxialMaterial OOHysteretic\u2026 unloadingRule strengthDegradation stiffnessDegradation hystereticBackbone","title":""},{"location":"library/5_Packages/AlgebraicHysteresis/","text":"AlgebraicHysteretic This package provides an infrastructure for constructing algebraic univariate hysteretic models. uniaxialMaterial OOHysteretic tag ? bkbn +? unlRul +? stfDeg +? strDeg +? < bkbn- ? unlRul- ? stfDeg- ? strDeg- ?> < pinchX ? pinchY ?> HystereticBackbone hystereticBackbone ReeseSoftClay tag ? pu ? y50 ? n ? hystereticBackbone ReeseSand tag ? kx ? ym ? pm ? yu ? pu ? hystereticBackbone ReeseStiffClayBelowWS tag ? Esi ? y50 ? As ? Pc ? hystereticBackbone Raynor tag ? Es ? fy ? fsu ? Epsilonsh ? Epsilonsm ? C1 ? Ey ? hystereticBackbone Capped tag ? hystereticBackboneTag ? capTag ? hystereticBackbone LinearCapped tag ? backboneTag ? eCap ? E ? sRes ? hystereticBackbone Material tag ? matTag ? UnloadingRule unloadingRule type ? tag ? < specific unloadingRule args > StiffnessDegradation StrengthDegradation strengthDegradation type ? tag ? < specific strengthDegradation args >","title":"AlgebraicHysteretic\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } backbone Mander (name, **kwds) name Tag ReeseSoftClay (name, pu, y50, n, **kwds) name Tag pu Num y50 Num n Num ReeseSand (name, kx, ym, pm, yu, pu, **kwds) name Tag kx Num ym Num pm Num yu Num pu Num ReeseStiffClayBelowWS (name, Esi, y50, As, Pc, **kwds) name Tag Esi Num y50 Num As Num Pc Num Raynor (name, Es, fy, fsu, Epsilonsh, Epsilonsm, C1, Ey, **kwds) name Tag Es Num fy Num fsu Num Epsilonsh Num Epsilonsm Num C1 Num Ey Num LinearCapped (name, backbone, eCap, E, sRes, **kwds) name Tag backbone Ref(backbone) eCap Num E Num sRes Num","title":"backbone\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ArctangentBackbone/","text":"Arctangent This file contains the implementation of ArctangentBackbone, which is a continuous function given by \\(K_1 \\operatorname{atan}(K_2*\\texttt{strain})\\) as developed by Ranzo and Petrangeli (1998) Code developed by: MHS Created: Aug 2000 class ArctangentBackbone : public HystereticBackbone { public : ArctangentBackbone ( int tag , double K1 , double gammaY , double alpha ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double K1 ; double K2 ; double gammaY ; double alpha ; };","title":"Arctangent\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/CappedBackbone/","text":"Capped This file contains the implementation of CappedBackbone, which overlays two backbone curves. Code developed by: MHS Created: Aug 2000 class CappedBackbone : public HystereticBackbone { public : CappedBackbone ( int tag , HystereticBackbone & backbone , HystereticBackbone & cap ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : HystereticBackbone * theBackbone ; HystereticBackbone * theCap ; double eCap ; };","title":"Capped\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/CementedSoil/","text":"CementedSoil the Evans and Duncan (1982) SILT model at http://www.findapile.com/p-y-curves/p-y-curves-models class CementedSoil : public HystereticBackbone { public : CementedSoil ( int tag , double pM , double pU , double Kpy , double z , double b ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double pm ; double pu ; double kpy ; double depth ; double diameter ; };","title":"CementedSoil\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/LinearCappedBackbone/","text":"LinearCapped This file contains the implementation of LinearCappedBackbone, which is a linear cap given by a cap deformation and a slope imposed on a hysteretic backbone. LinearCapped (name, backbone, eCap, E, sRes, **kwds) backbone Ref(backbone) eCap Num(float) E Num(float) sRes Num(float) Code developed by: MHS Created: Aug 2000 class LinearCappedBackbone : public HystereticBackbone { public : LinearCappedBackbone ( int tag , HystereticBackbone & backbone , double def , double slope , double resStrength ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : HystereticBackbone * theBackbone ; double eCap ; double sCap ; double E ; double eRes ; double sRes ; };","title":"LinearCapped\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/LiquefiedSand/","text":"LiquefiedSand source class LiquefiedSand : public HystereticBackbone { public : LiquefiedSand ( int tag , double x , double d , double kn , double m ); private : double X ; double D ; double kN ; double meter ; double yu ; };","title":"LiquefiedSand\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ManderBackbone/","text":"Mander This file contains the implementation of ManderBackbone, which the concrete backbone function given by Mander, Priestly, and Park (1988) Mander (name, fc, epsc, Ec, **kwds) fc Num(float) epsc Num(float) Ec Num(float) Code developed by: MHS Created: Mar 2001 class ManderBackbone : public HystereticBackbone { public : ManderBackbone ( int tag , double fc , double epsc , double Ec ); private : double fpc ; double epsc ; double Ec ; };","title":"Mander\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/MaterialBackbone/","text":"Material Description: This file contains the implementation of MaterialBackbone, which treats a uniaxial material as a hysteretic backbone by removing path dependency, i.e. commitState is never called on the uniaxial material. Code developed by: MHS Created: Aug 2000 C++ Interface class MaterialBackbone : public HystereticBackbone { public : MaterialBackbone ( int tag , UniaxialMaterial & material ); private : UniaxialMaterial * theMaterial ; };","title":"Material\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/MultilinearBackbone/","text":"Multilinear MultilinearBackbone is a backbone defined by many points. C++ Interface class MultilinearBackbone : public HystereticBackbone { public : MultilinearBackbone ( int tag , int numPoints , const Vector & e , const Vector & s ); private : double * E ; double * e ; double * s ; double * c ; int numPoints ; }; Code developed by: MHS Created: Aug 2000","title":"Multilinear\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/RaynorBackbone/","text":"Raynor Raynor (name, Es, fy, fsu, Epsilonsh, Epsilonsm, C1, Ey, **kwds) Es Num(float) fy Num(float) fsu Num(float) Epsilonsh Num(float) Epsilonsm Num(float) C1 Num(float) Ey Num(float) References Raynor, D. J., Lehman, D. L., and Stanton, J. F. 2002. \u201cBond-slip response of reinforcing bars grouted in ducts.\u201d ACI Struct. J., 995, 568\u2013576. C++ Interface class RaynorBackbone : public HystereticBackbone { public : RaynorBackbone ( int tag , double es , double f1 , double f2 , double epsh , double epsm , double c1 , double ey ); private : double Es ; double fy ; double fsu ; double Epsilonsh ; double Epsilonsm ; double C1 ; double Ey ; };","title":"Raynor\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ReeseSandBackbone/","text":"ReeseSand class ReeseSandBackbone : public HystereticBackbone { public : ReeseSandBackbone ( int tag , double kx , double ym , double pm , double yu , double pu ); private : double kx ; double ym ; double pm ; double yu ; double pu ; }; Code developed by: MHS Created: Aug 2000","title":"ReeseSand\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ReeseSoftClayBackbone/","text":"ReeseSoftClay Description: This file contains the implementation of ReeseSoftClayBackbone. class ReeseSoftClayBackbone : public HystereticBackbone { public : ReeseSoftClayBackbone ( int tag , double pu , double y50 , double n ); private : double pu ; double y50 ; double n ; }; Code developed by: MHS Created: Aug 2000","title":"ReeseSoftClay\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ReeseStiffClayAboveWS/","text":"ReeseStiffClayAboveWS Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 336 C++ Interface class ReeseStiffClayAboveWS : public HystereticBackbone { public : ReeseStiffClayAboveWS ( int tag , double pu , double y50 ); ReeseStiffClayAboveWS (); ~ ReeseStiffClayAboveWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double pu ; double y50 ; double hl ; };","title":"ReeseStiffClayAboveWS\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/ReeseStiffClayBelowWS/","text":"ReeseStiffClayBelowWS Response of Stiff Clay below the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 328 class ReeseStiffClayBelowWS : public HystereticBackbone { public : ReeseStiffClayBelowWS ( int tag , double esi , double y , double as , double pc ); ReeseStiffClayBelowWS (); ~ ReeseStiffClayBelowWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Esi ; double y50 ; double As ; double Pc ; };","title":"ReeseStiffClayBelowWS\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/TrilinearBackbone/","text":"Trilinear This file contains the implementation of TrilinearBackbone, which is a trilinear backbone Code developed by: MHS Created: Aug 2000 class TrilinearBackbone : public HystereticBackbone { public : TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 , double e3 , double s3 ); TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 ); TrilinearBackbone (); ~ TrilinearBackbone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double E1 , E2 , E3 ; double e1 , e2 , e3 ; double s1 , s2 , s3 ; };","title":"Trilinear\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/VuggyLimestone/","text":"VuggyLimestone Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 348 class VuggyLimestone : public HystereticBackbone { public : VuggyLimestone ( int tag , double b , double su ); VuggyLimestone (); ~ VuggyLimestone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double diameter ; double shearStrength ; };","title":"VuggyLimestone\n"},{"location":"library/5_Packages/AlgebraicHysteresis/backbone/WeakRock/","text":"WeakRock on page 56 of this manual https://www.dropbox.com/s/h3s9qvvz3pb4tlf/Weak%20Rock%20Reference%20Book.pdf?dl=0 class WeakRock : public HystereticBackbone { public : WeakRock ( int tag , double kir , double pur , double yrm ); WeakRock (); ~ WeakRock (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Kir ; double pur ; double yrm ; };","title":"WeakRock\n"},{"location":"library/5_Packages/FrictionBearings/","text":"FrictionModel Library The frictionModel command is used to construct a friction model object, which specifies the behavior of the coefficient of friction in terms of the absolute sliding velocity and the pressure on the contact area. The command has at least one argument, the friction model type. Each type is outlined below. frictionModel frnMdlType ? arg1 ? ... The type of friction model created and the additional arguments required depend on the frnMdlType? provided in the command. The following contain information about frnMdlType? and the args required for each of the available friction model types: Coulomb Friction Velocity Dependent Friction Velocity and Normal Force Dependent Friction Velocity and Pressure Dependent Friction Multi-Linear Velocity Dependent Friction The following friction model response quantities can be recorded through the ElementRecorder object, as long as the element has a friction model associated with it: normalForce , velocity , frictionForce , COF Examples recorder Element - file Elmt.out - time - ele 1 frictionModel normalForce","title":"FrictionModel Library\n"},{"location":"library/5_Packages/FrictionBearings/108-Coulomb%20Friction/","text":"Coulomb Friction This command is used to construct a friction\u201d model object. Coulomb\u2019s Law of Friction states that kinetic friction is independent of the sliding velocity. frictionModel Coulomb $frnTag $mu frnTag unique friction model object tag mu coefficient of friction CoulombFriction.png Examples frictionModel Coulomb 1 0.163 RELATED TO: Flat Slider Bearing Element Single Friction Pendulum Bearing Element Triple Friction Pendulum Bearing Element Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Coulomb Friction\n"},{"location":"library/5_Packages/FrictionBearings/401-Multi-Linear%20Velocity%20Dependent%20Friction/","text":"Multi-Linear Velocity Dependent Friction This command is used to construct a VelDepMultiLinear friction model object. The friction-velocity relationship is given by a multi-linear curve that is define by a set of points. The slope given by the last two specified points on the positive velocity axis is extrapolated to infinite positive velocities. Velocity and friction points need to be equal or larger than zero (no negative values should be defined). The number of provided velocity points needs to be equal to the number of provided friction points. frictionModel VelDepMultiLinear $frnTag - vel $velocityPoints -frn $frictionPoints frnTag unique friction model object tag velocityPoints array of velocity points along friction-velocity curve frictionPoints array of friction points along friction-velocity curve VelDepMultiLinear.png Examples frictionModel VelDepMultiLinear 1 -vel 0.0 0.1 2.0 8.0 10.0 -frn 0.163 0.085 0.150 0.163 0.163 RELATED TO: Flat Slider Bearing Element Single Friction Pendulum Bearing Element Triple Friction Pendulum Bearing Element Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Multi-Linear Velocity Dependent Friction\n"},{"location":"library/5_Packages/FrictionBearings/744-Velocity%20Dependent%20Friction/","text":"Velocity Dependent Friction This command is used to construct a VelDependent friction model object. It is useful for modeling the behavior of [ http://en.wikipedia.org/wiki/Polytetrafluoroethylene\u201dPTFE \u201d] or PTFE-like materials sliding on a stainless steel surface. For a detailed presentation on the velocity dependence of such interfaces please refer to Constantinou et al. (1999). frictionModel VelDependent $frnTag $muSlow $muFast $transRate frnTag unique friction model object tag muSlow coefficient of friction at low velocity muFast coefficient of friction at high velocity transRate transition rate from low to high velocity <math> \u03bc \u2004=\u2004 \u03bc f a s t \u2005\u2212\u2005( \u03bc f a s t \u2212 \u03bc s l o w )\u2005\u22c5\u2005 e \u2212 t r a n s R a t e \u2006\u22c5\u2006| v | </math> VDependentFriction01.png VDependentFrictionCurveFit.png Examples frictionModel VelDependent 1 0.05 0.163 0.615 REFERENCE: Constantinou, M.C., Tsopelas, P., Kasalanati, A., and Wolff, E.D. (1999). \u201cProperty modification factors for seismic isolation bearings\u201d. Report MCEER-99-0012, Multidisciplinary Center for Earthquake Engineering Research, State University of New York. RELATED TO: Flat Slider Bearing Element Single Friction Pendulum Bearing Element Triple Friction Pendulum Bearing Element Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Velocity Dependent Friction\n"},{"location":"library/5_Packages/FrictionBearings/745-Velocity%20and%20Normal%20Force%20Dependent%20Friction/","text":"Velocity and Normal Force Dependent Friction This command is used to construct a VelNormalFrcDep friction model object. frictionModel VelNormalFrcDep $frnTag $aSlow $nSlow $aFast $nFast $alpha0 $alpha1 $alpha2 $maxMuFact frnTag unique friction model object tag aSlow constant for coefficient of friction at low velocity nSlow exponent for coefficient of friction at low velocity aFast constant for coefficient of friction at high velocity nFast exponent for coefficient of friction at high velocity alpha0 constant rate parameter coefficient alpha1 linear rate parameter coefficient alpha2 quadratic rate parameter coefficient maxMuFact factor for determining the maximum coefficient of friction. This value prevents the friction coefficient from exceeding an unrealistic maximum value when the normal force becomes very small. The maximum friction coefficient is determined from \u03bcFast, for example \u03bc \u2264 $maxMuFac*\u03bcFast. Theory Define the friction coefficient at slow (\u03bcSlow) and fast (\u03bcFast) velocity [1] (Figure 3): \u03bcSlow = aSlow*N^(nSlow-1) \u03bcFast = aFast*N^(nFast-1) where aSlow , aFast , nSlow \u2264 1, nFast \u2264 1 are constants that determine the friction coefficient models. As the friction coefficients \u03bcSlow and \u03bcFast are unitless, the user must be careful to define the constants to coincide with the units of the model input data. The friction coefficient as a function of velocity is [2]: \u03bc = \u03bcFast - (\u03bcFast-\u03bcSlow ) exp(-a udot) where udot is the velocity at the sliding interface and a is a rate parameter. In this friction model, a is assumed to be dependent on axial force \\(N\\) through: \\[ a = \\alpha_0 + \\alpha_1 N + \\alpha_2 N^2 \\] where \\(\\alpha_0\\) , \\(\\alpha_1\\) and \\(\\alpha_2\\) are constants, with units of Time/Length, Time/Length/Force and Time/Length/Force 2 respectively. TPB_Nhan_Fig3.jpg SPECIAL CASES: Constant friction coefficient: \u03bc = const: nSlow = nFast = 1.0; aSlow = $aFast = \u03bc; all other constants defining \u03bc are arbitrary. Friction coefficient varies with velocity but is independent of vertical force: \u03bc is independent of vertical force: $nSlow = $nFast = 1.0; $alpha0 = a (rate parameter); $alpha1 = $alpha2 = 0. Friction coefficient varies with vertical force but is independent of velocity: \u03bc is independent of velocity: $nSlow = $nFast; $aSlow = $aFast; all other constants defining \u03bc are arbitrary. Examples set muSlow 0.12 set muFast 0.18 set nSlow 0.8 set nFast 0.7 set alpha0 25.0 set alpha1 0.0 set alpha2 0.0 frictionModel VelNormalFrcDep 1 [expr $muSlow / pow ( $W , $nSlow-1.0 )] \\ $nSlow [expr $muFast / pow ( $W , $nFast-1.0 )] $nFast $alpha0 $alpha1 $alpha2 3.0 References [1] Bowden F.P., Tabor D. (1964). \u201cThe friction and lubrication of solids - part II.\u201d Oxford University Press, London, Great Britain, 1964. [2] Constantinou M.C., Mokha A., Reinhorn A. (1990). \u201cTeflon bearings in base isolation. II: Modeling.\u201d Journal of Structural Engineering (ASCE) 1990; 116(2): 455-474 RELATED TO: Flat Slider Bearing Element Single Friction Pendulum Bearing Element Triple Friction Pendulum Bearing Element Code Developed by: Nhan D. Dao, University of Nevada - Reno. E-mail: nhan.unr@gmail.com","title":"Velocity and Normal Force Dependent Friction\n"},{"location":"library/5_Packages/FrictionBearings/746-Velocity%20and%20Pressure%20Dependent%20Friction/","text":"Velocity and Pressure Dependent Friction This command is used to construct a VelPressureDep friction model object. frictionModel VelPressureDep $frnTag $muSlow $muFast0 $A $deltaMu $alpha $transRate frnTag unique friction model object tag muSlow coefficient of friction at low velocity muFast0 initial coefficient of friction at high velocity A nominal contact area deltaMu pressure parameter calibrated from experimental data alpha pressure parameter calibrated from experimental data transRate transition rate from low to high velocity Examples frictionModel VelPressureDep 1 0.085 0.163 7.0686 0.05 0.08 0.77 References [1] Tsopelas P., and Constantinou M. C. (1996). \u201cExperimental Study of FPS System in Bridge Seismic Isolation.\u201d Earthquake Eng. and Structural Dynamics, VOL. 25, 65-78. [2] Constantinou M. C., Tsopelas P., Kasalanati A., and Wolff E. D. (1999). Property Modification Factors for Seismic Isolation Bearings. Technical Report MCEER-99-0012, University of Buffalo, Buffalo, New York. RELATED TO: Flat Slider Bearing Element Single Friction Pendulum Bearing Element Triple Friction Pendulum Bearing Element Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Velocity and Pressure Dependent Friction\n"},{"location":"library/5_Packages/NonlinearBeamColumn/BeamIntegration/","text":"BeamIntegration // $Revision: 1.7 $ // $Date: 2006-09-05 22:57:11 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/BeamIntegration.h,v $ #ifndef BeamIntegration_h #define BeamIntegration_h #include <OPS_Globals.h> #include <MovableObject.h> #include <TaggedObject.h> #include <ID.h> class Matrix ; class ElementalLoad ; class Information ; class BeamIntegration : public MovableObject { public : BeamIntegration ( int classTag ); virtual ~ BeamIntegration (); virtual void getSectionLocations ( int nIP , double L , double * xi ) = 0 ; virtual void getSectionWeights ( int nIP , double L , double * wt ) = 0 ; virtual void addElasticDeformations ( ElementalLoad * theLoad , double loadFactor , double L , double * v0 ) { return ;} // Return 0 if there is no elastic interior, -1 otherwise virtual int addElasticFlexibility ( double L , Matrix & fe ) { return 0 ;} virtual double getTangentDriftI ( double L , double LI , double q2 , double q3 , bool yAxis = false ) { return 0.0 ;} virtual double getTangentDriftJ ( double L , double LI , double q2 , double q3 , bool yAxis = false ) { return 0.0 ;} virtual BeamIntegration * getCopy ( void ) = 0 ; virtual void getLocationsDeriv ( int nIP , double L , double dLdh , double * dptsdh ); virtual void getWeightsDeriv ( int nIP , double L , double dLdh , double * dwtsdh ); // Return 0 if there is no elastic interior, -1 otherwise virtual int addElasticFlexDeriv ( double L , Matrix & dfedh , double dLdh = 0.0 ) { return 0 ;} virtual void Print ( OPS_Stream & s , int flag = 0 ) = 0 ; }; // a BeamIntegrationRule store BeamIntegration and section tags class BeamIntegrationRule : public TaggedObject { public : BeamIntegrationRule ( int tag , BeamIntegration * bi , const ID & stags ) : TaggedObject ( tag ), theInt ( bi ), secTags ( stags ){} ~ BeamIntegrationRule (){ if ( theInt != 0 ) delete theInt ; } BeamIntegration * getBeamIntegration (){ return theInt ;} const ID & getSectionTags () const { return secTags ;} void Print ( OPS_Stream & s , int flag ){ theInt -> Print ( s );} private : BeamIntegration * theInt ; ID secTags ; }; bool OPS_addBeamIntegrationRule ( BeamIntegrationRule * newComponent ); BeamIntegrationRule * OPS_getBeamIntegrationRule ( int tag ); void OPS_clearAllBeamIntegrationRule ( void ); #endif","title":"BeamIntegration\n"},{"location":"library/5_Packages/NonlinearBeamColumn/Cell/","text":"Cell // Written by Remo M. de Souza // December 1998 // $Date: 2003/02/14 23:01:36 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/repres/cell/Cell.h,v $ // File: Cell.h // #ifndef Cell_h #define Cell_h #include <OPS_Globals.h> class Vector ; class Cell { public : Cell (); virtual ~ Cell (); // edition functions // reinforcing bar inquiring functions virtual double getArea ( void ) const = 0 ; virtual double getdValue ( void ) const = 0 ; virtual const Vector & getCentroidPosition ( void ) = 0 ; virtual void Print ( OPS_Stream & s , int flag = 0 ) const = 0 ; friend OPS_Stream & operator << ( OPS_Stream & s , const Cell & Cell ); protected : private : }; #endif","title":"Cell\n"},{"location":"library/5_Packages/NonlinearBeamColumn/DistHingeIntegration/","text":"DistHingeIntegration // $Revision: 1.2 $ // $Date: 2006-09-05 22:57:36 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/DistHingeIntegration.h,v $ #include <BeamIntegration.h> class Matrix ; class ElementalLoad ; class Channel ; class FEM_ObjectBroker ; class DistHingeIntegration : public BeamIntegration { public : DistHingeIntegration ( double lpI , double lpJ , BeamIntegration & bi ); DistHingeIntegration (); ~ DistHingeIntegration (); void getSectionLocations ( int numSections , double L , double * xi ); void getSectionWeights ( int numSections , double L , double * wt ); BeamIntegration * getCopy ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int setParameter ( const char ** argv , int argc , Parameter & param ); int updateParameter ( int parameterID , Information & info ); int activateParameter ( int parameterID ); void Print ( OPS_Stream & s , int flag = 0 ); void getLocationsDeriv ( int nIP , double L , double dLdh , double * dptsdh ); void getWeightsDeriv ( int nIP , double L , double dLdh , double * dwtsdh ); private : double lpI ; double lpJ ; BeamIntegration * beamInt ; int parameterID ; };","title":"DistHingeIntegration\n"},{"location":"library/5_Packages/NonlinearBeamColumn/ElasticForceBeamColumn2d/","text":"ElasticForceBeamColumn2d References State Determination Algorithm Neuenhofer, A. and F. C. Filippou (1997). \u201cEvaluation of Nonlinear Frame Finite Element Models.\u201d Journal of Structural Engineering, 123(7):958-966. Spacone, E., V. Ciampi, and F. C. Filippou (1996). \u201cMixed Formulation of Nonlinear Beam Finite Element.\u201d Computers and Structures, 58(1):71-83. Plastic Hinge Integration Scott, M. H. and G. L. Fenves (2006). \u201cPlastic Hinge Integration Methods for Force-Based Beam-Column Elements.\u201d Journal of Structural Engineering, 132(2):244-252. Analytical Response Sensitivity (DDM) Scott, M. H., P. Franchin, G. L. Fenves, and F. C. Filippou (2004). \u201cResponse Sensitivity for Nonlinear Beam-Column Elements.\u201d Journal of Structural Engineering, 130(9):1281-1288. Software Design Scott, M. H., G. L. Fenves, F. T. McKenna, and F. C. Filippou (2007). \u201cSoftware Patterns for Nonlinear Beam-Column Models.\u201d Journal of Structural Engineering, Approved for publication, February 2007. // $Revision: 1.1 $ // $Date: 2007-10-13 01:21:43 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/ElasticForceBeamColumn2d.h,v $ #include <Element.h> #include <Node.h> #include <Matrix.h> #include <Vector.h> #include <Channel.h> #include <BeamIntegration.h> #include <SectionForceDeformation.h> #include <CrdTransf.h> class Response ; class ElementalLoad ; class ElasticForceBeamColumn2d : public Element { public : ElasticForceBeamColumn2d (); ElasticForceBeamColumn2d ( int tag , int nodeI , int nodeJ , int numSections , SectionForceDeformation ** sec , BeamIntegration & beamIntegr , CrdTransf & coordTransf , double rho = 0.0 ); ~ ElasticForceBeamColumn2d (); const char * getClassType ( void ) const { return \"ElasticForceBeamColumn2d\" ;}; int getNumExternalNodes ( void ) const ; const ID & getExternalNodes ( void ); Node ** getNodePtrs ( void ); int getNumDOF ( void ); void setDomain ( Domain * theDomain ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); int update ( void ); const Matrix & getTangentStiff ( void ); const Matrix & getInitialStiff ( void ); const Matrix & getMass ( void ); void zeroLoad ( void ); int addLoad ( ElementalLoad * theLoad , double loadFactor ); int addInertiaLoadToUnbalance ( const Vector & accel ); const Vector & getResistingForce ( void ); const Vector & getResistingForceIncInertia ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int displaySelf ( Renderer & theViewer , int displayMode , float fact , const char ** displayModes = 0 , int numModes = 0 ); friend OPS_Stream & operator << ( OPS_Stream & s , ElasticForceBeamColumn2d & E ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); int getResponse ( int responseID , Information & eleInformation ); int setParameter ( const char ** argv , int argc , Parameter & param ); int updateParameter ( int parameterID , Information & info ); int activateParameter ( int parameterID ); protected : int getInitialFlexibility ( Matrix & fe ); private : void compSectionDisplacements ( Vector sectionCoords [], Vector sectionDispls []) const ; // Reactions of basic system due to element loads void computeReactions ( double * p0 ); // Section forces due to element loads void computeSectionForces ( Vector & sp , int isec ); void computeBasicForces ( Vector & q ); // internal data ID connectedExternalNodes ; // tags of the end nodes enum { maxNumSections = 20 }; enum { maxSectionOrder = 5 }; BeamIntegration * beamIntegr ; int numSections ; SectionForceDeformation * sections [ maxNumSections ]; // array of pointers to sections CrdTransf * crdTransf ; // pointer to coordinate transformation object // (performs the transformation between the global and basic system) double rho ; // mass density per unit length int initialFlag ; // indicates if the element has been initialized Node * theNodes [ 2 ]; // pointers to the nodes enum { maxNumEleLoads = 100 }; enum { NDM = 2 }; // dimension of the problem (2d) enum { NND = 3 }; // number of nodal dof's enum { NEGD = 6 }; // number of element global dof's enum { NEBD = 3 }; // number of element dof's in the basic system int numEleLoads ; // Number of element load objects int sizeEleLoads ; ElementalLoad ** eleLoads ; double * eleLoadFactors ; static Matrix theMatrix ; static Vector theVector ; static double workArea []; int parameterID ; };","title":"ElasticForceBeamColumn2d\n"},{"location":"library/5_Packages/NonlinearBeamColumn/ElasticForceBeamColumn3d/","text":"ElasticForceBeamColumn3d State Determination Algorithm Neuenhofer, A. and F. C. Filippou (1997). \u201cEvaluation of Nonlinear Frame Finite Element Models.\u201d Journal of Structural Engineering, 123(7):958-966. Spacone, E., V. Ciampi, and F. C. Filippou (1996). \u201cMixed Formulation of Nonlinear Beam Finite Element.\u201d Computers and Structures, 58(1):71-83. Plastic Hinge Integration Scott, M. H. and G. L. Fenves (2006). \u201cPlastic Hinge Integration Methods for Force-Based Beam-Column Elements.\u201d Journal of Structural Engineering, 132(2):244-252. Analytical Response Sensitivity (DDM) Scott, M. H., P. Franchin, G. L. Fenves, and F. C. Filippou (2004). \u201cResponse Sensitivity for Nonlinear Beam-Column Elements.\u201d Journal of Structural Engineering, 130(9):1281-1288. Software Design Scott, M. H., G. L. Fenves, F. T. McKenna, and F. C. Filippou (2007). \u201cSoftware Patterns for Nonlinear Beam-Column Models.\u201d Journal of Structural Engineering, Approved for publication, February 2007. // $Revision: 1.1 $ // $Date: 2007-10-13 01:21:43 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/ElasticForceBeamColumn3d.h,v $ #include <Element.h> #include <Node.h> #include <Matrix.h> #include <Vector.h> #include <Channel.h> #include <BeamIntegration.h> #include <SectionForceDeformation.h> #include <CrdTransf.h> class Response ; class ElementalLoad ; class ElasticForceBeamColumn3d : public Element { public : ElasticForceBeamColumn3d (); ElasticForceBeamColumn3d ( int tag , int nodeI , int nodeJ , int numSections , SectionForceDeformation ** sec , BeamIntegration & beamIntegr , CrdTransf & coordTransf , double rho = 0.0 ); ~ ElasticForceBeamColumn3d (); const char * getClassType ( void ) const { return \"ElasticForceBeamColumn3d\" ;}; int getNumExternalNodes ( void ) const ; const ID & getExternalNodes ( void ); Node ** getNodePtrs ( void ); int getNumDOF ( void ); void setDomain ( Domain * theDomain ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); int update ( void ); const Matrix & getTangentStiff ( void ); const Matrix & getInitialStiff ( void ); const Matrix & getMass ( void ); void zeroLoad ( void ); int addLoad ( ElementalLoad * theLoad , double loadFactor ); int addInertiaLoadToUnbalance ( const Vector & accel ); const Vector & getResistingForce ( void ); const Vector & getResistingForceIncInertia ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int displaySelf ( Renderer & theViewer , int displayMode , float fact , const char ** displayModes = 0 , int numModes = 0 ); friend OPS_Stream & operator << ( OPS_Stream & s , ElasticForceBeamColumn3d & E ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); int getResponse ( int responseID , Information & eleInformation ); int setParameter ( const char ** argv , int argc , Parameter & param ); int updateParameter ( int parameterID , Information & info ); int activateParameter ( int parameterID ); protected : int getInitialFlexibility ( Matrix & fe ); private : void compSectionDisplacements ( Vector sectionCoords [], Vector sectionDispls []) const ; // Reactions of basic system due to element loads void computeReactions ( double * p0 ); // Section forces due to element loads void computeSectionForces ( Vector & sp , int isec ); void computeBasicForces ( Vector & q ); // internal data ID connectedExternalNodes ; // tags of the end nodes enum { maxNumSections = 20 }; enum { maxSectionOrder = 10 }; BeamIntegration * beamIntegr ; int numSections ; SectionForceDeformation * sections [ maxNumSections ]; // array of pointers to sections CrdTransf * crdTransf ; // pointer to coordinate transformation object // (performs the transformation between the global and basic system) double rho ; // mass density per unit length int initialFlag ; // indicates if the element has been initialized Node * theNodes [ 2 ]; // pointers to the nodes Vector Se ; // element resisting forces in the basic system enum { maxNumEleLoads = 100 }; enum { NDM = 3 }; // dimension of the problem (2d) enum { NND = 6 }; // number of nodal dof's enum { NEGD = 12 }; // number of element global dof's enum { NEBD = 6 }; // number of element dof's in the basic system int numEleLoads ; // Number of element load objects int sizeEleLoads ; ElementalLoad ** eleLoads ; double * eleLoadFactors ; static Matrix theMatrix ; static Vector theVector ; static double workArea []; int parameterID ; }; #endif","title":"ElasticForceBeamColumn3d\n"},{"location":"library/5_Packages/NonlinearBeamColumn/FiberSectionRepr/","text":"FiberSectionRepr // $Revision: 1.5 $ // $Date: 2007-11-19 22:34:15 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/repres/section/FiberSectionRepr.h,v $ // File: FiberSectionRepr.h // Written by Remo M. de Souza (November 1998) // modified by rms (July 1999) - doesn't prespecify number of patches and reinf. layers // rms (August 1999) - add fibers to section for the analysis #include <SectionRepres.h> class Patch ; class ReinfLayer ; class Fiber ; #define SEC_TAG_FiberSection 1 class FiberSectionRepr : public SectionRepres { public : // constructor and destructor FiberSectionRepr ( int sectionID ); FiberSectionRepr ( int sectionID , int maxNumPatches , int maxNumReinfLayers ); FiberSectionRepr ( int sectionID , int numPatches , Patch ** patches , int numReinfLayers , ReinfLayer ** reinfLayers ); ~ FiberSectionRepr (); // edition functions void setNumPatches ( int numPatches ); int setPatches ( Patch ** patches ); void setNumReinfLayers ( int numReinfLayers ); int setReinfLayers ( ReinfLayer ** reinfLayers ); int addPatch ( const Patch & aPatch ); int addReinfLayer ( const ReinfLayer & aReinfLayer ); int addFiber ( Fiber & theFiber ); int addHFiber ( Fiber & theFiber ); // inquiring functions int getType ( void ) const ; int getNumPatches ( void ) const ; int getNumReinfLayers ( void ) const ; int getNumFibers ( void ) const ; int getNumHFibers ( void ) const ; Patch ** getPatches ( void ) const ; ReinfLayer ** getReinfLayers ( void ) const ; Fiber ** getFibers ( void ) const ; Fiber ** getHFibers ( void ) const ; void Print ( OPS_Stream & s , int flag = 0 ); friend OPS_Stream & operator << ( OPS_Stream & s , FiberSectionRepr & fiberSectionRepr ); protected : private : int sectID ; int maxNPatches ; // maximum number of patches that can be stored int maxNReinfLayers ; // maximum number of reinforcing layers that can be stored Patch ** patch ; // patch array (change to linked list later!!!!) ReinfLayer ** reinfLayer ; // reinforcing bar array (change to linked // list later!!!!!!!!) int nPatches ; // current number of patches int nReinfLayers ; // current number of reinforcing layers int numFibers ; // number of fibers in the section Fiber ** theFibers ; // array of pointers to fibers // that form the section int sizeFibers ; // size of the fibers array int numHFibers ; // number of fibers in the section Fiber ** theHFibers ; // array of pointers to fibers // that form the section int sizeHFibers ; // size of the fibers array };","title":"FiberSectionRepr\n"},{"location":"library/5_Packages/NonlinearBeamColumn/ForceBeamColumnWarping2d/","text":"ForceBeamColumnWarping References State Determination Algorithm Neuenhofer, A. and F. C. Filippou (1997). \u201cEvaluation of Nonlinear Frame Finite Element Models.\u201d Journal of Structural Engineering, 123(7):958-966. Spacone, E., V. Ciampi, and F. C. Filippou (1996). \u201cMixed Formulation of Nonlinear Beam Finite Element.\u201d Computers and Structures, 58(1):71-83. Plastic Hinge Integration Scott, M. H. and G. L. Fenves (2006). \u201cPlastic Hinge Integration Methods for Force-Based Beam-Column Elements.\u201d Journal of Structural Engineering, 132(2):244-252. Analytical Response Sensitivity (DDM) Scott, M. H., P. Franchin, G. L. Fenves, and F. C. Filippou (2004). \u201cResponse Sensitivity for Nonlinear Beam-Column Elements.\u201d Journal of Structural Engineering, 130(9):1281-1288. Software Design Scott, M. H., G. L. Fenves, F. T. McKenna, and F. C. Filippou (2007). \u201cSoftware Patterns for Nonlinear Beam-Column Models.\u201d Journal of Structural Engineering, Approved for publication, February 2007. // $Revision: 1.13 $ // $Date: 2009-02-05 16:28:20 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/ForceBeamColumnWarping2d.h,v $ #include <Element.h> #include <Node.h> #include <Matrix.h> #include <Vector.h> #include <Channel.h> #include <BeamIntegration.h> #include <SectionForceDeformation.h> #include <CrdTransf.h> class Response ; class ElementalLoad ; class ForceBeamColumnWarping2d : public Element { public : ForceBeamColumnWarping2d (); ForceBeamColumnWarping2d ( int tag , int nodeI , int nodeJ , int numSections , SectionForceDeformation ** sec , BeamIntegration & beamIntegr , CrdTransf & coordTransf , double rho = 0.0 , int maxNumIters = 10 , double tolerance = 1.0e-12 ); ~ ForceBeamColumnWarping2d (); const char * getClassType ( void ) const { return \"ForceBeamColumnWarping2d\" ;}; int getNumExternalNodes ( void ) const ; const ID & getExternalNodes ( void ); Node ** getNodePtrs ( void ); int getNumDOF ( void ); void setDomain ( Domain * theDomain ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); int update ( void ); const Matrix & getTangentStiff ( void ); const Matrix & getInitialStiff ( void ); const Matrix & getMass ( void ); void zeroLoad ( void ); int addLoad ( ElementalLoad * theLoad , double loadFactor ); int addInertiaLoadToUnbalance ( const Vector & accel ); const Vector & getResistingForce ( void ); const Vector & getResistingForceIncInertia ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int displaySelf ( Renderer & theViewer , int displayMode , float fact , const char ** displayModes = 0 , int numModes = 0 ); friend OPS_Stream & operator << ( OPS_Stream & s , ForceBeamColumnWarping2d & E ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); int getResponse ( int responseID , Information & eleInformation ); int getResponseSensitivity ( int responseID , int gradNumber , Information & eleInformation ); // AddingSensitivity:BEGIN ////////////////////////////////////////// int setParameter ( const char ** argv , int argc , Parameter & param ); int updateParameter ( int parameterID , Information & info ); int activateParameter ( int parameterID ); const Vector & getResistingForceSensitivity ( int gradNumber ); const Matrix & getKiSensitivity ( int gradNumber ); const Matrix & getMassSensitivity ( int gradNumber ); int commitSensitivity ( int gradNumber , int numGrads ); // AddingSensitivity:END /////////////////////////////////////////// protected : void setSectionPointers ( int numSections , SectionForceDeformation ** secPtrs ); int getInitialFlexibility ( Matrix & fe ); int getInitialDeformations ( Vector & v0 ); private : void getForceInterpolatMatrix ( double xi , Matrix & b , const ID & code , int isec ); void getDistrLoadInterpolatMatrix ( double xi , Matrix & bp , const ID & code ); void compSectionDisplacements ( Vector sectionCoords [], Vector sectionDispls []) const ; void initializeSectionHistoryVariables ( void ); // Reactions of basic system due to element loads void computeReactions ( double * p0 ); // Section forces due to element loads void computeSectionForces ( Vector & sp , int isec ); // internal data ID connectedExternalNodes ; // tags of the end nodes BeamIntegration * beamIntegr ; int numSections ; SectionForceDeformation ** sections ; // array of pointers to sections CrdTransf * crdTransf ; // pointer to coordinate transformation object // (performs the transformation between the global and basic system) double rho ; // mass density per unit length int maxIters ; // maximum number of local iterations double tol ; // tolerance for relative energy norm for local iterations int initialFlag ; // indicates if the element has been initialized Node * theNodes [ 2 ]; // pointers to the nodes Matrix kv ; // stiffness matrix in the basic system Vector Se ; // element resisting forces in the basic system Matrix kvcommit ; // committed stiffness matrix in the basic system Vector Secommit ; // committed element end forces in the basic system Matrix * fs ; // array of section flexibility matrices Vector * vs ; // array of section deformation vectors Vector * Ssr ; // array of section resisting force vectors Vector * vscommit ; // array of committed section deformation vectors enum { maxNumEleLoads = 100 }; enum { NDM = 2 }; // dimension of the problem (2d) enum { NND = 4 }; // number of nodal dof's enum { NEGD = 8 }; // number of element global dof's enum { NEBD = 5 }; // number of element dof's in the basic system int numEleLoads ; // Number of element load objects int sizeEleLoads ; ElementalLoad ** eleLoads ; double * eleLoadFactors ; Matrix * Ki ; static Matrix theMatrix ; static Vector theVector ; static double workArea []; enum { maxNumSections = 20 }; enum { maxSectionOrder = 5 }; // following are added for subdivision of displacement increment int maxSubdivisions ; // maximum number of subdivisons of dv for local iterations static Vector vsSubdivide []; static Vector SsrSubdivide []; static Matrix fsSubdivide []; //static int maxNumSections; // AddingSensitivity:BEGIN ////////////////////////////////////////// int parameterID ; const Vector & computedqdh ( int gradNumber ); const Matrix & computedfedh ( int gradNumber ); void computeReactionSensitivity ( double * dp0dh , int gradNumber ); void computeSectionForceSensitivity ( Vector & dspdh , int isec , int gradNumber ); // AddingSensitivity:END /////////////////////////////////////////// };","title":"ForceBeamColumnWarping\n"},{"location":"library/5_Packages/NonlinearBeamColumn/Patch/","text":"Patch Written by Remo M. de Souza December 1998 // $Revision: 1.2 $ // $Date: 2003-02-14 23:01:36 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/repres/patch/Patch.h,v $ // File: Patch.h #ifndef Patch_h #define Patch_h #include <OPS_Globals.h> class Cell ; class Patch { public : Patch (); virtual ~ Patch (); // edition functions virtual void setMaterialID ( int materialID ) = 0 ; // inquiring functions virtual int getMaterialID ( void ) const = 0 ; virtual int getNumCells ( void ) const = 0 ; virtual Cell ** getCells ( void ) const = 0 ; virtual Patch * getCopy ( void ) const = 0 ; virtual void Print ( OPS_Stream & s , int flag = 0 ) const = 0 ; friend OPS_Stream & operator << ( OPS_Stream & s , const Patch & patch ); protected : private : }; #endif","title":"Patch\n"},{"location":"library/5_Packages/NonlinearBeamColumn/ReinfBar/","text":"ReinfBar // $Revision: 1.2 $ // $Date: 2003-02-14 23:01:37 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/repres/reinfBar/ReinfBar.h,v $ // File: ReinfBar.h // // Written by Remo M. de Souza // November 1998 #include <OPS_Globals.h> class Vector ; class ReinfBar { public : ReinfBar (); ReinfBar ( double barArea , int materialID , const Vector & position ); virtual ~ ReinfBar (); // edition functions void setDiameter ( double barDiameter ); void setArea ( double barArea ); void setMaterial ( int materialID ); void setPosition ( const Vector & position ); // reinforcing bar inquiring functions double getDiameter ( void ) const ; double getArea ( void ) const ; int getMaterial ( void ) const ; const Vector & getPosition ( void ) const ; virtual void Print ( OPS_Stream & s , int flag = 0 ) const ; friend OPS_Stream & operator << ( OPS_Stream & s , const ReinfBar & reinfBar ); protected : private : int matID ; double diameter ; double area ; Vector posit ; }; #endif","title":"ReinfBar\n"},{"location":"library/5_Packages/NonlinearBeamColumn/ReinfLayer/","text":"ReinfLayer // $Revision: 1.3 $ // $Date: 2003-02-14 23:01:37 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/repres/reinfLayer/ReinfLayer.h,v $ // File: ReinfLayer.h // Written by Remo M. de Souza // December 1998 #include <OPS_Globals.h> class ReinfBar ; class ReinfLayer { public : ReinfLayer (); virtual ~ ReinfLayer (); // edition functions virtual void setNumReinfBars ( int numReinfBars ) = 0 ; virtual void setMaterialID ( int materialID ) = 0 ; virtual void setReinfBarDiameter ( double reinfBarDiemater ) = 0 ; virtual void setReinfBarArea ( double reinfBarArea ) = 0 ; // reinforcing layer inquiring functions virtual int getNumReinfBars ( void ) const = 0 ; virtual int getMaterialID ( void ) const = 0 ; virtual double getReinfBarDiameter ( void ) const = 0 ; virtual double getReinfBarArea ( void ) const = 0 ; virtual ReinfLayer * getCopy ( void ) const = 0 ; virtual ReinfBar * getReinfBars ( void ) const = 0 ; virtual void Print ( OPS_Stream & s , int flag = 0 ) const = 0 ; friend OPS_Stream & operator << ( OPS_Stream & s , const ReinfLayer & ReinfLayer ); protected : private : }; #endif","title":"ReinfLayer\n"},{"location":"library/5_Packages/NonlinearBeamColumn/SectionForceDeformation/","text":"SectionForceDeformation SectionForceDeformation is an abstract base class and thus no objects of it\u2019s type can be instantiated. It has pure virtual functions which must be implemented in it\u2019s derived classes. // $Revision: 1.14 $ // $Date: 2008-08-26 16:45:44 $ // $Source: /usr/local/cvs/OpenSees/SRC/material/section/SectionForceDeformation.h,v $ #ifndef SectionForceDeformation_h #define SectionForceDeformation_h // Written: MHS // Created: Feb 2000 // Revision: A // What: \"@(#) SectionForceDeformation.h, revA\" #include <Material.h> #include <Matrix.h> #include <Vector.h> #include <ID.h> class Information ; class Response ; #define MAX_SECTION_RESPONSE_ID 10000 #define SECTION_RESPONSE_MZ 1 #define SECTION_RESPONSE_P 2 #define SECTION_RESPONSE_VY 3 #define SECTION_RESPONSE_MY 4 #define SECTION_RESPONSE_VZ 5 #define SECTION_RESPONSE_T 6 #define SECTION_RESPONSE_R 7 #define SECTION_RESPONSE_Q 8 #define SECTION_RESPONSE_B 9 // Bi-moment (FiberSectionWarping3d) #define SECTION_RESPONSE_W 10 // (FiberSectionWarping3d) // section responses for shells #define SECTION_RESPONSE_FXX 11 // membrane xx #define SECTION_RESPONSE_FYY 12 // membrane yy #define SECTION_RESPONSE_FXY 13 // membrane xy #define SECTION_RESPONSE_MXX 14 // bending xx #define SECTION_RESPONSE_MYY 15 // bending yy #define SECTION_RESPONSE_MXY 16 // bending xy #define SECTION_RESPONSE_VXZ 17 // bending yy #define SECTION_RESPONSE_VYZ 18 // bending xy class SectionForceDeformation : public Material { public : SectionForceDeformation ( int tag , int classTag ); SectionForceDeformation (); virtual ~ SectionForceDeformation (); //virtual int setTrialSectionDeformation (const Vector&) = 0; virtual int setTrialSectionDeformation ( const Vector & ) ; //the default valuoe 0 is removeed byJZ ,UoE virtual const Vector & getSectionDeformation ( void ) = 0 ; virtual const Vector & getStressResultant ( void ) = 0 ; virtual const Matrix & getSectionTangent ( void ) = 0 ; virtual const Matrix & getInitialTangent ( void ) = 0 ; virtual const Matrix & getSectionFlexibility ( void ); virtual const Matrix & getInitialFlexibility ( void ); virtual double getRho ( void ); virtual int commitState ( void ) = 0 ; virtual int revertToLastCommit ( void ) = 0 ; virtual int revertToStart ( void ) = 0 ; virtual SectionForceDeformation * getCopy ( void ) = 0 ; virtual const ID & getType ( void ) = 0 ; virtual int getOrder ( void ) const = 0 ; virtual Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); virtual int getResponse ( int responseID , Information & info ); virtual int getResponseSensitivity ( int responseID , int gradIndex , Information & info ); // AddingSensitivity:BEGIN ////////////////////////////////////////// virtual const Vector & getStressResultantSensitivity ( int gradIndex , bool conditional ); virtual const Vector & getSectionDeformationSensitivity ( int gradIndex ); virtual const Matrix & getSectionTangentSensitivity ( int gradIndex ); virtual const Matrix & getSectionFlexibilitySensitivity ( int gradIndex ); virtual const Matrix & getInitialTangentSensitivity ( int gradIndex ); virtual const Matrix & getInitialFlexibilitySensitivity ( int gradIndex ); virtual double getRhoSensitivity ( int gradIndex ); virtual int commitSensitivity ( const Vector & sectionDeformationGradient , int gradIndex , int numGrads ); // AddingSensitivity:END /////////////////////////////////////////// //--- Adding Thermal Materials:[BEGIN] by UoE OpenSees Group ----// virtual int setTrialSectionDeformation ( const Vector & , const Vector & ); //JZ virtual const Vector & getTemperatureStress ( const Vector & tData ); //27 is for 'FireLoadPattern' //--- Adding Thermal Functions:[END] by UoE OpenSees Group ----// virtual const Vector & getThermalElong ( void ); virtual double getEnergy () const { return 0 ; }; //by SAJalali protected : Matrix * fDefault ; // Default flexibility matrix Vector * sDefault ; private : }; extern bool OPS_addSectionForceDeformation ( SectionForceDeformation * newComponent ); extern SectionForceDeformation * OPS_getSectionForceDeformation ( int tag ); extern bool OPS_removeSectionForceDeformation ( int tag ); extern void OPS_clearAllSectionForceDeformation ( void ); extern void OPS_printSectionForceDeformation ( OPS_Stream & s , int flag = 0 ); #endif","title":"SectionForceDeformation\n"},{"location":"library/5_Packages/NonlinearBeamColumn/SectionRepres/","text":"SectionRepres SectionRepres is an abstract base class and thus no objects of it\u2019s type can be instantiated. It has pure virtual functions which must be implemented in it\u2019s derived classes. // Written by Remo M. de Souza // November 1998 // $Revision: 1.2 $ // $Date: 2003-02-14 23:01:37 $ // File: SectionRepres.h #include <TaggedObject.h> class SectionRepres : public TaggedObject { public : // Section creation functions SectionRepres ( int tag ); // Section edition functions virtual ~ SectionRepres (); // Section inquiring functions virtual int getType ( void ) const = 0 ; friend OPS_Stream & operator << ( OPS_Stream & s , const SectionRepres & sectionRepres ); protected : private : }; bool OPS_addSectionRepres ( SectionRepres * newComponent ); SectionRepres * OPS_getSectionRepres ( int tag ); void OPS_clearAllSectionRepres ( void ); #endif","title":"SectionRepres\n"},{"location":"library/5_Packages/NonlinearBeamColumn/UserDefinedBeamIntegration/","text":"UserDefinedBeamIntegration // $Revision: 1.2 $ // $Date: 2003-06-10 00:36:09 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/UserDefinedBeamIntegration.h,v $ #ifndef UserDefinedBeamIntegration_h #define UserDefinedBeamIntegration_h #include <BeamIntegration.h> #include <Vector.h> class Channel ; class FEM_ObjectBroker ; class UserDefinedBeamIntegration : public BeamIntegration { public : UserDefinedBeamIntegration ( int nIP , const Vector & pt , const Vector & wt ); UserDefinedBeamIntegration (); ~ UserDefinedBeamIntegration (); void getSectionLocations ( int numSections , double L , double * xi ); void getSectionWeights ( int numSections , double L , double * wt ); BeamIntegration * getCopy ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int setParameter ( const char ** argv , int argc , Parameter & param ); int updateParameter ( int parameterID , Information & info ); void Print ( OPS_Stream & s , int flag = 0 ); private : Vector pts ; Vector wts ; }; #endif","title":"UserDefinedBeamIntegration\n"},{"location":"library/5_Packages/NonlinearBeamColumn/UserDefinedHingeIntegration/","text":"UserDefinedHingeIntegration // $Revision: 1.1 $ // $Date: 2006-01-18 21:58:24 $ // $Source: /usr/local/cvs/OpenSees/SRC/element/forceBeamColumn/UserDefinedHingeIntegration.h,v $ #ifndef UserDefinedHingeIntegration_h #define UserDefinedHingeIntegration_h #include <BeamIntegration.h> #include <Vector.h> class Channel ; class FEM_ObjectBroker ; class UserDefinedHingeIntegration : public BeamIntegration { public : UserDefinedHingeIntegration ( int npL , const Vector & ptL , const Vector & wtL , int npR , const Vector & ptR , const Vector & wtR ); UserDefinedHingeIntegration (); ~ UserDefinedHingeIntegration (); void getSectionLocations ( int numSections , double L , double * xi ); void getSectionWeights ( int numSections , double L , double * wt ); BeamIntegration * getCopy ( void ); int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); void Print ( OPS_Stream & s , int flag = 0 ); private : Vector ptsL ; Vector wtsL ; Vector ptsR ; Vector wtsR ; }; #endif","title":"UserDefinedHingeIntegration\n"},{"location":"library/5_Packages/NonlinearBeamColumn/geometry/","text":"Geometric Transformation Command The geometric-transformation command is used to construct a coordinate-transformation (CrdTransf) object, which transforms beam element stiffness and resisting force from the basic system to the global-coordinate system. The command has at least one argument, the transformation type. Each type is outlined below. geomTransf transfType ? arg1 ? ... The type of transformation created and the additional arguments required depends on the transfType? provided in the command. The following contain information about transfType? and the args required for each of the available geometric transformation types: Linear Transformation PDelta Transformation Corotational Transformation","title":"Geometric Transformation Command\n"},{"location":"library/5_Packages/NonlinearBeamColumn/geometry/106-Corotational%20Transformation/","text":"Corotational This command is used to construct a corotational coordinate transformation ( CorotCrdTransf ) object. The corotational transformation can be used in large displacement-small strain problems. NOTE: Currently the transformation does not deal with element loads and will ignore any that are applied to the element. For a two-dimensional problem: geomTransf Corotational $transfTag < - jntOffset $dXi $dYi $dXj $dYj > For a three-dimensional problem: geomTransf Corotational $transfTag $vecxzX $vecxzY $vecxzZ transfTag integer tag identifying transformation vecxzX vecxzY vecxzZ X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. dXi dYi joint offset values \u2013 absolute offsets specified with respect to the global coordinate system for element-end node i (optional) dXj dYj joint offset values \u2013 absolute offsets specified with respect to the global coordinate system for element-end node j (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane \u2013 vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking cross product of x and new y. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif Examples ElementCrossSection.png ElementOrientation.png ElementVectors.png Element 1 : tag 1 : vecxZ = zaxis geomTransf Corotational 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf Corotational 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Corotational\n"},{"location":"library/5_Packages/NonlinearBeamColumn/geometry/370-Linear%20Transformation/","text":"Linear This command is used to construct a linear coordinate transformation (LinearCrdTransf) object, which performs a linear geometric transformation of beam stiffness and resisting force from the basic system to the global-coordinate system. For a two-dimensional problem: geomTransf Linear $transfTag < - jntOffset $dXi $dYi $dXj $dYj > For a three-dimensional problem: geomTransf Linear $transfTag $vecxzX $vecxzY $vecxzZ < -jntOffset $dXi $dYi $dZi $dXj $dYj $dZj > transfTag integer tag identifying transformation vecxzX vecxzY vecxzZ \\(X\\) , \\(Y\\) , and \\(Z\\) components of vecxz , the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system \\(X\\) , \\(Y\\) , \\(Z\\) and define a vector that is in a plane parallel to the \\(x-z\\) plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. dXi dYi dZi joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node i (optional, the number of arguments depends on the dimensions of the current model). dXj dYj dZj joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node j (optional, the number of arguments depends on the dimensions of the current model). A refresher on Euclidean Geometry and Coordinate Systems: A single vector may be defined by two points. It has length, direction, and location in space. When this vector is used to define a coordinate axis, only its direction is important. Now any 2 vectors, \\(V_r\\) and \\(V_s\\) , not parallel, define a plane that is parallel to them both. The cross-product of these vectors define a third vector, \\(V_t\\) , that is perpendicular to both \\(V_r\\) and \\(V_s\\) and hence normal to the plane: \\(V_t = V_r \\times V_s\\) . The element coordinate system is specified as follows: The x-axis is a vector given by the two element nodes; The vector vecxz is a vector the user specifies that must not be parallel to the x-axis. The x-axis along with the vecxz Vector define the xz plane. The local y-axis is defined by taking the cross product of the x-axis vector and the vecxz vector ( \\(V_y = V_{xz} \\times V_x\\) ). The local z-axis is then found simply by taking the cross product of the y-axis and x-axis vectors ( \\(V_z = V_x \\times V_y\\) ). The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif NOTE: When in 2D, local x and y axes are in the X-Y plane, where X and Y are global axes. Local x axis is the axis connecting the two element nodes, and local y and z axes follow the right-hand rule (e.g., if the element is aligned with the positive Y axis, the local y axis is aligned with the negative X axis, and if the element is aligned with the positive X axis, the local y axis is aligned with the positive Y axis). Orientation of local y and z axes is important for definition of the fiber section. Examples Element cross section Element orientation Element vectors # Element 1 : tag 1 : vecxZ = zaxis geomTransf Linear 1 0 0 - 1 # Element 2 : tag 2 : vecxZ = y axis geomTransf Linear 2 0 1 0 # If there was a rigid offset at the top of element 1: geomTransf Linear 1 0 0 - 1 - jntOffset 0.0 0.0 0.0 0.0 - $Offset 0.0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Linear\n"},{"location":"library/5_Packages/NonlinearBeamColumn/geometry/480-PDelta%20Transformation/","text":"PDelta This command is used to construct the P-Delta Coordinate Transformation (PDeltaCrdTransf) object, which performs a linear geometric transformation of beam stiffness and resisting force from the basic system to the global coordinate system, considering second-order P-Delta effects. NOTE: \\(P\\) - \\(\\Delta\\) effects do not include \\(P\\) - \\(\\delta\\) effects. For a two-dimensional problem: geomTransf PDelta $transfTag < - jntOffset $dXi $dY $dXj $dYj > For a three-dimensional problem: geomTransf PDelta $transfTag $vecxzX $vecxzY $vecxzZ < -jntOffset $dXi $dYi $dZi $dXj $dYj $dZj > transfTag integer tag identifying transformation vecxzX vecxzY vecxzZ X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. dXi dYi dZi joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node i (the number of arguments depends on the dimensions of the current model). The offset vector is oriented from node i to node j as shown in a figure below. (optional) dXj dYj dZj joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node j (the number of arguments depends on the dimensions of the current model). The offset vector is oriented from node j to node i as shown in a figure below. (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane \u2013 vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking the cross-product of x and y vectors. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif Examples ElementCrossSection.png ElementOrientation.png ElementVectors.png # Element 1 : tag 1 : vecxZ = zaxis geomTransf PDelta 1 0 0 - 1 </ p > # Element 2 : tag 2 : vecxZ = y axis geomTransf PDelta 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"PDelta\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/","text":"UCSD CompGeoMech Library NDMaterials UC San Diego soil models (Linear/Nonlinear, dry/drained/undrained soil response under general 2D/3D static/cyclic loading conditions (please visit for examples) PressureDependMultiYield Material PressureDependMultiYield02 Material PressureDependMultiYield03 Material PressureIndependMultiYield Material UC San Diego Saturated Undrained soil FluidSolidPorousMaterial Elements UC San Diego u-p element (saturated soil) Four Node Quad u-p Element Brick u-p Element bbarQuad u-p Element bbarBrick u-p Element Nine Four Node Quad u-p Element Twenty Eight Node Brick u-p Element References \u201cComputational Model for Cyclic Mobility and Associated Shear Deformation,\u201d (2003), Z. Yang, A. Elgamal and E. Parra, J. Geotechnical and Geoenvironmental Engineering, ASCE, 129(12), 1119-1127. http://dx.doi.org/10.1061/(ASCE)1090-0241(2003)129:12(1119) link \u201cModeling of Cyclic Mobility in Saturated Cohesionless Soils,\u201d (2003), A. Elgamal, Z. Yang, E. Parra and A. Ragheb, Int. J. Plasticity, 19, (6), 883-905. http://dx.doi.org/10.1016/S0749-6419(02)00010-4 link \u201cInfluence of Permeability on Liquefaction-Induced Shear Deformation,\u201d (2002), Z. Yang and A. Elgamal, J. Engineering Mechanics, ASCE, 128(7), 720-729. http://dx.doi.org/10.1061/(ASCE)0733-9399(2002)128:7(720) link \u201cComputational Modeling of Cyclic Mobility and Post-Liquefaction Site Response,\u201d (2002), A. Elgamal, Z. Yang and E. Parra, Soil Dynamics and Earthquake Engineering, 22(4), 259-271. http://dx.doi.org/10.1016/S0267-7261(02)00022-2 link \u201cA 3D model for earthquake-induced liquefaction triggering and post-liquefaction response,\u201d (2018), Khosravifar, A., Elgamal, A., Lu, J., and Li, J., Soil Dynamics and Earthquake Engineering, 110, 43-52. https://doi.org/10.1016/j.soildyn.2018.04.008 link \u201cNumerical Modeling of Earthquake Site Response Including Dilation and Liquefaction,\u201d (2000), Zhaohui Yang, PhD Thesis, Dept. of Civil Engineering and Engineering Mechanics, Columbia University, NY, New York. \u201cNumerical Modeling of Liquefaction and Lateral Ground Deformation Including Cyclic Mobility and Dilation Response in Soil Systems,\u201d (1996), Ender Parra, PhD Thesis, Dept. of Civil Engineering, Rensselaer Polytechnic Institute, Troy, NY. More References: \u201cNumerical Analysis of Seismically Induced Deformations In Saturated Granular Soil Strata,\u201d (1994), Ahmed M. Ragheb, PhD Thesis, Dept. of Civil Engineering, Rensselaer Polytechnic Institute, Troy, NY. \u201cIdentification and Modeling of Earthquake Ground Response,\u201d (1995), A. -W. Elgamal, M. Zeghal, and E. Parra, First International Conference on Earthquake Geotechnical Engineering, IS-TOKYO\u201995, Vol. 3, 1369-1406, Ishihara, K., Ed., Balkema, Tokyo, Japan, Nov. 14-16. (Invited Theme Lecture). \u201cPrediction of Seismically-Induced Lateral Deformation During Soil Liquefaction,\u201d (1995), T. Abdoun and A. -W. Elgamal, Eleventh African Regional Conference on Soil Mechanics and Foundation Engineering, International Society for Soil Mechanics and Foundation Engineering, Cairo, Egypt, Dec. 11-15. \u201cLiquefaction of Reclaimed Island in Kobe, Japan,\u201d (1996), A. -W. Elgamal, M. Zeghal, and E. Parra, Journal of Geotechnical Engineering, ASCE, Vol. 122, No. 1, 39-49, January. \u201cAnalyses and Modeling of Site Liquefaction Using Centrifuge Tests,\u201d (1996), E. Parra, K. Adalier, A. -W. Elgamal, M. Zeghal, and A. Ragheb, Eleventh World Conference on Earthquake Engineering, Acapulco, Mexico, June 23-28. \u201cIdentification and Modeling of Earthquake Ground Response II: Site Liquefaction,\u201d (1996), M. Zeghal, A. -W. Elgamal, and E. Parra, Soil Dynamics and Earthquake Engineering, Vol. 15, 523-547, Elsevier Science Ltd. \u201cSoil Dilation and Shear Deformations During Liquefaction,\u201d (1998a), A.-W. Elgamal, R. Dobry, E. Parra, and Z. Yang, , Proc. 4th Intl. Conf. on Case Histories in Geotechnical Engineering, S. Prakash, Ed., St. Louis, MO, March 8-15, pp1238-1259. \u201cLiquefaction Constitutive Model,\u201d (1998b), A.-W. Elgamal, E. Parra, Z. Yang, R. Dobry and M. Zeghal, Proc. Intl. Workshop on The Physics and Mechanics of Soil Liquefaction, Lade, P., Ed., Sept. 10-11, Baltimore, MD, Balkema. \u201cModeling of Liquefaction-Induced Shear Deformations,\u201d (1999), A. Elgamal, Z. Yang, E. Parra and R. Dobry, Second International Conference on Earthquake Geotechnical Engineering, Lisbon, Portugal, 21-25 June, Balkema. \u201cDynamic Soil Properties, Seismic Downhole Arrays and Applications in Practice,\u201d (2001), A.-W. Elgamal, T. Lai, Z. Yang and L. He, 4th International Conference on Recent Advances in Geotechnical Earthquake Engineering and Soil Dynamics, S. Prakash, Ed., San Diego, California, USA, March 26-31. \u201cNumerical Analysis of Embankment Foundation Liquefaction Countermeasures,\u201d (2002), A. Elgamal, E. Parra, Z. Yang, and K. Adalier, J. Earthquake Engineering, 6(4), 447-471. \u201cApplication of unconstrained optimization and sensitivity analysis to calibration of a soil constitutive model ,\u201d (2003), Z. Yang and A. Elgamal, Int. J for Numerical and Analytical Methods in Geomechanics, 27 (15), 1255-1316. \u201cA Web-based Platform for Live Internet Computation of Seismic Ground Response,\u201d (2004), Z. Yang, J. Lu, and A. Elgamal, Advances in Engineering Software, 35, 249-259. \u201cEarth Dams on Liquefiable Foundation: Numerical Prediction of Centrifuge Experiments,\u201d (2004), Z. Yang, A. Elgamal, K. Adalier, and M. Sharp, J. Engineering Mechanics, ASCE, 130(10), 1168-1176. \u201cDynamic Response of Saturated Dense Sand in Laminated Centrifuge Container,\u201d (2005), A. Elgamal, Z. Yang, T. Lai, B.L. Kutter, and D. Wilson, J. Geotechnical and Geoenvironmental Engineering, ASCE, 131(5), 598-609. \u201cModeling Soil Liquefaction Hazards for Performance-Based Earthquake Engineering,\u201d (2001), \u201cS. Kramer, and A. Elgamal, Pacific Earthquake Engineering Research (PEER) Center Report No. 2001/13, Berkeley, CA.","title":"UCSD CompGeoMech Library\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/254-FluidSolidPorousMaterial/","text":"FluidSolidPorousMaterial FluidSolidPorousMaterial couples the responses of two phases: fluid and solid. The fluid phase response is only volumetric and linear elastic. The solid phase can be any NDMaterial. This material is developed to simulate the response of saturated porous media under fully undrained condition. OUTPUT INTERFACE: The following information may be extracted for this material at given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001): \u201cstress\u201d , \u201cstrain\u201d , \u201ctangent\u201d , or \u201cpressure\u201d . The \u201cpressure\u201d option records excess pore pressure and excess pore pressure ratio at a given material integration point. nDMaterial FluidSolidPorousMaterial $tag $nd $soilMatTag $combinedBulkModul < $pa = 101 > Tag A positive integer uniquely identifying the element among all elements nd Number of dimensions, 2 for plane-strain, and 3 for general 3D analysis. soilMatTag The material number for the solid phase material (previously defined). combinBulkModul Combined undrained bulk modulus B c relating changes in pore pressure and volumetric strain, may be approximated by: B c &asymp; B f /n where B f is the bulk modulus of fluid phase (2.2x10 6 kPa (or 3.191x10 5 psi) for water), and n the initial porosity. p a Optional atmospheric pressure for normalization (typically 101 kPa in SI units, or 14.65 psi in English units) Notes Buoyant unit weight (total unit weight - fluid unit weight) should be used in definition of the finite elements composed of a FluidSolidPorousMaterial . During the application of gravity (elastic) load, the fluid phase does not contribute to the material response. Fluid Solid Porous Material Examples: Pressure Dependent Material in saturated, undrained elastic-plastic state (coupled with FluidSolidPorous Material) Example 1 Single quadrilateral element, subjected to sinusoidal base shaking Example 2 Single quadrilateral element, subjected to monotonic pushover Example 3 Single quadrilateral element (inclined by 4 degrees), subjected to msinusoidal base shaking Example 4 Single 3D BbarBrick element, subjected to sinusoidal base shaking Example 5 Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking Example 6 A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking Code developed by: UC San Diego (Dr. Zhaohui Yang) :","title":"FluidSolidPorousMaterial\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/Brick/","text":"Brick?N The Eight Node Brick Element element Brick8N eletag? node1? node2? node3? node4? node5? node6? node7? node8? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, eight nodes ordered according to Figure 1 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick8N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cpqall\u201d, \u201cgausspoint\u201d, \u201cplastic\u201d or \u201cplasticGPC\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. If the stress states at all gauss points need to be printed, use the query \u201cpqall\u201d. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. But the coordinates have to be output separated. If one needs to output the gauss point coordinates together with the plastic strain, the query \u201cplasticGPC\u201d needs to be used. {#8node width=\u201c9.0cm\u201d} The Twenty Node Brick Element element Brick20N eletag? node1? node2? node3? node4? node5? node6? node7? node8? node9? node10? node11? node12? node13? node14? node15? node16? node17? node18? node19? node20? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, twenty nodes ordered according to Figure 2 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick20N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cgausspoint\u201d, or \u201cplastic\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. {#20node width=\u201c9cm\u201d}","title":"Brick?N\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/Template3Dep/","text":"Template Elasto-Plastic Framework Yield Surface Command set ys \"-YieldSurfaceType <parameter list>\" This command sets the yield surface variable ys to be the specified type. A list of paramaters can be passed to define the yield surface and the number of parameters depend on the type of yield surface. Valid strings for YieldSurfaceType are DP , VM , CC , and RMC01 , which are described in the following subsections. Drucker-Prager Yield Surface set ys \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Yield Surface set ys \"-VM\" VM stands for von Mises type, i.e. cylinder shaped yield surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Yield Surface set ys \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped yield surface. For CC type yield surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Yield Surface set ys \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager yield surface. Potential Surface Command set ps \"-PotentialSurfaceType <parameter list>\" This command sets the potential surface variable ps to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for PotentialSurfaceType are DP , VM , and CC , which are described in the following subsections. Drucker-Prager Potential Surface set ps \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped potential surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Potential Surface set ps \"-VM\" VM stands for von Mises type, i.e. cylinder shaped potential surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Potential Surface set ps \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped potential surface. For CC type potential surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Potential Surface set ps \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped Potential surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager Potential surface. Evolution Law Command set el \"-EvolutionLawType <parameter list>\" This command sets the evolution law variable el to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for EvolutionLawType are Leq , NLp , and ``, which are described in the following subsections. Linear Scalar Evolution Law set el \"-Leq a?\" Leq stands for Linear Scalar Evolution Law. This hardening rule is based on the equivalent deviatoric plastic strain \\(\\epsilon_q^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any scalar internal variable, such as the slope of Drucker\u2013Prager yield surface, the diameter of von Mises yield surface, and so on. Nonlinear Scalar Evolution Law set el \"-NLp e0? lambda? kappa? \" NLp stands for Nonlinear Scalar Evolution Law. This hardening rule is based on the volumetic plastic strain \\(\\epsilon_p^{pl}\\) . In this case, parameters including void ration e0 , lambda and kappa need to be supplied. This hardening rule is primarily for the evolution of the tip stress \\(p^{'}_{o}\\) in Cam-Clay model. Linear Tensorial Evolution Law set et \"-LEij a?\" LEij stands for Linear Tensorial Evolution Law. This hardening rule is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. Nonlinear Tensorial Evolution Law (Armstrong-Frederick model ) set et \"-NLEij ha? Cr?\" NLEij stands for Nonlinear Tensorial Evolution Law from Armstrong\u2013Frederick nonlinear model. This kinematic hardening law is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, nonlinear hardening coefficients ha and Cr need to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. EPState Command < set sts \"Sxx? Sxy? Sxz? Syx? Syy? Syz? Szx? Szy? Szz?\" > set eps \"<-NOD nt?> -NOS ns? sc1? sc2? ... <-stressp sts>\" First statement sets the initial stress tensor to variable sts (if it is not stated here, no initial stress by default). Second statement assigns to the Elasto-Plastic state variable eps the specified state parameters, including number of tensorial internal variables nt (if it is not stated here, \\(nt=0\\) by default), number of scalar internal variables ns and corresponding initial values sc1 , sc2 , ..., and initial stresses defined in $sts (if it has been previously defined). Template Elasto-Plastic Material Command nDMaterial Template3Dep mTag ? - YS $ ys ? - PS $ ps ? - EPS $ eps ? <- ELS1 $ el ?> <$- ELT1 et ?> A template elasto-plastic material is constructed using nDMaterial command. The argument mTag is used to uniquely identify this nDMaterial object among nDMaterial objects in the BasicBuilder object. The other parameters include previously defined yield surface object ys , potential surface object ps , elasto-plastic state object eps , scalar evolution law object el , and tensorial evolution law object et . Examples von Mises Model # Yield surface set ys \"-VM\" # Potential surface set ps \"-VM\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # EPState #______________k=f(Cu) set EPS \"-NOD 0 -NOS 1 20\"# # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 -YS $ys -PS $ps -EPS $EPS -ELS1 $ES1 Drucker\u2013Prager Model # Yield surface set ys \"-DP\" # Potential surface set ps \"-DP 0.1\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" # EPState #______________alpha___k set EPS \"-NOD 0 -NOS 2 0.2 0.0 -stressp $sts\" # # where #alpha = 2 sin(phi) / (3^0.5) / (3-sin(phi) ), phi is the friction angle # and k is the cohesion # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 - YS $ys - PS $ps - EPS $EPS - ELS1 $ES1 Cam-clay Model # Yield surface M = 1.2 set ys \"-CC 1.2\" # Potential surface M = 1.2 set ps \"-CC 1.2\" # Scalar evolution law___void ratio___Lamda___Kappa set ES1 \"-NLp 0.85 0.19 0.06\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" #________________po set EPS \"-NOS 1 200.1 -stressp $sts\" # nDMaterial Template3Dep 1 - YS $ys - PS $ps - EPS $EPS - ELS1 $ES1","title":"Template Elasto-Plastic Framework\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/","text":"PressureDependMultiYield PressureDependMultiYield material is an elastic-plastic material for simulating the essential response characteristics of pressure sensitive soil materials under general loading conditions. Such characteristics include dilatancy (shear-induced volume contraction or dilation) and non-flow liquefaction (cyclic mobility), typically exhibited in sands or silts during monotonic or cyclic loading. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. To simulate soil response under fully undrained condition, this material may be either embedded in a FluidSolidPorousMaterial , or used with one of the solid-fluid fully coupled elements ( Four Node Quad u-p Element , Nine Four Node Quad u-p Element , Brick u-p Element , Twenty Eight Node Brick u-p Element ) with very low permeability. To simulate partially drained soil response, this material should be used with a solid-fluid fully coupled element with proper permeability values. During the application of gravity load (and static loads if any), material behavior is linear elastic. In the subsequent dynamic (fast) loading phase(s), the stress-strain response is elastic-plastic (see updateMaterialStage ). Plasticity is formulated based on the multi-surface (nested surfaces) concept, with a non-associative flow rule to reproduce dilatancy effect. The yield surfaces are of the Drucker-Prager type. OUTPUT INTERFACE: The following information may be extracted for this material at a given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001) \u00ae : \u201c stress \u201d, \u201c strain \u201d, \u201c backbone \u201d, or \u201c tangent \u201d. For 2D problems, the stress output follows this order: \u03c3 xx , \u03c3 yy , \u03c3 zz , \u03c3 xy , \u03b7 r , where \u03b7 r is the ratio between the shear (deviatoric) stress and peak shear strength at the current confinement (0<=\u03b7 r <=1.0). The strain output follows this order: \u03b5 xx , \u03b5 yy , \u03b3 xy . For 3D problems, the stress output follows this order: \u03c3 xx , \u03c3 yy , \u03c3 zz , \u03c3 xy , \u03c3 yz , \u03c3 zx , \u03b7 r , and the strain output follows this order: \u03b5 xx , \u03b5 yy , \u03b5 zz , \u03b3 xy , \u03b3 yz , \u03b3 zx . The \u201c backbone \u201d option records (secant) shear modulus reduction curves at one or more given confinements. The specific recorder command is as follows: recorder Element - ele $eleNum - file $fName - dT $deltaT material $GaussNum backbone $p1 < $p2 \u2026 > where p1, p2, \u2026 are the confinements at which modulus reduction curves are recorded. In the output file, corresponding to each given confinement there are two columns: shear strain \u03b3 and secant modulus G s . The number of rows equals the number of yield surfaces. nDMaterial PressureDependMultiYield $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $contrac $dilat1 $dilat2 $liquefac1 $liquefac2 $liquefac3 < $noYieldSurf = 20 < $r1 $Gs1 \u2026 > $e = 0.6 $cs1 = 0.9 $cs2 = 0.02 $cs3 = 0.7 $pa = 101 < $c = 0.3 > > PreDep_ss.png tag A positive integer uniquely identifying the material among all nDMaterials. nd Number of dimensions, 2 for plane-strain, and 3 for 3D analysis. rho Saturated soil mass density. refShearModul (G r ) Reference low-strain shear modulus, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). refBulkModul (B r ) Reference bulk modulus, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). frictionAng (\u03a6) Friction angle at peak shear strength, in degrees. peakShearStra (\u03b3 max ) An octahedral shear strain at which the maximum shear strength is reached, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). Octahedral shear strain is defined as: PreDep_OctGamma.png\u200e refPress (p\u2019 r ) Reference mean effective confining pressure at which Gr, Br, and \u03b3 max are defined. pressDependCoe (d) A positive constant defining variations of G and B as a function of instantaneous effective confinement p\u2019: PreDep_pressDepCoe.png PTAng (\u03a6 PT ) Phase transformation angle, in degrees. contrac A non-negative constant defining the rate of shear-induced volume decrease (contraction) or pore pressure buildup. A larger value corresponds to faster contraction rate. dilat1 , dilat2 Non-negative constants defining the rate of shear-induced volume increase (dilation). Larger values correspond to stronger dilation rate. liquefac1 , liquefac2 , liquefac3 Parameters controlling the mechanism of liquefaction-induced perfectly plastic shear strain accumulation, i.e., cyclic mobility. Set liquefac1 = 0 to deactivate this mechanism altogether. liquefac1 defines the effective confining pressure (e.g., 10 kPa in SI units or 1.45 psi in English units) below which the mechanism is in effect. Smaller values should be assigned to denser sands. Liquefac2 defines the maximum amount of perfectly plastic shear strain developed at zero effective confinement during each loading phase. Smaller values should be assigned to denser sands. Liquefac3 defines the maximum amount of biased perfectly plastic shear strain \u03b3 b accumulated at each loading phase under biased shear loading conditions, as \u03b3 b =liquefac2 x liquefac3. Typically, liquefac3 takes a value between 0.0 and 3.0. Smaller values should be assigned to denser sands. See the references listed at the end of this chapter for more information. noYieldSurf Number of yield surfaces, optional (must be less than 40, default is 20). The surfaces are generated based on the hyperbolic relation defined in Note 2 below. r , Gs Instead of automatic surfaces generation (Note 2), you can define yield surfaces directly based on desired shear modulus reduction curve. To do so, add a minus sign in front of noYieldSurf, then provide noYieldSurf pairs of shear strain (\u03b3) and modulus ratio (G s ) values. For example, to define 10 surfaces: \u2026 -10\u03b3 1 G s1 \u2026 \u03b3 10 G s10 \u2026 See Note 3 below for some important notes. e Initial void ratio, optional (default is 0.6). cs1 , cs2 , cs3 , pa Parameters defining a straight critical-state line e c in e-p\u2019 space. If cs3=0 , e c = cs1-cs2 log(p\u2019/p a ) else (Li and Wang, JGGE, 124(12)), e c = cs1-cs2(p\u2019/p a ) cs3 where p a is atmospheric pressure for normalization (typically 101 kPa in SI units, or 14.65 psi in English units). All four constants are optional (default values: cs1=0.9, cs2=0.02, cs3=0.7, p a =101 kPa). c Numerical constant (default value = 0.3 kPa) NOTE: The friction angle \u03a6 defines the variation of peak (octahedral) shear strength \u03c4 f as a function of current effective confinement p\u2019: Octahedral shear stress is defined as: (Automatic surface generation) At a constant confinement p\u2019, the shear stress \u03c4(octahedral) - shear strain \u03b3 (octahedral) nonlinearity is defined by a hyperbolic curve (backbone curve): where \u03b3 r satisfies the following equation at p\u2019 r : (User defined surfaces) The user specified friction angle \u03a6 is ignored. Instead, \u03a6 is defined as follows: where \u03c3 m is the product of the last modulus and strain pair in the modulus reduction curve. Therefore, it is important to adjust the backbone curve so as to render an appropriate \u03a6. If the resulting \u03a6 is smaller than the phase transformation angle \u03a6 PT , \u03a6 PT is set equal to \u03a6. Also remember that improper modulus reduction curves can result in strain softening response (negative tangent shear modulus), which is not allowed in the current model formulation. Finally, note that the backbone curve varies with confinement, although the variations are small within commonly interested confinement ranges. Backbone curves at different confinements can be obtained using the OpenSees element recorder facility (see OUTPUT INTERFACE above). The last five optional parameters are needed when critical-state response (flow liquefaction) is anticipated. Upon reaching the critical-state line, material dilatancy is set to zero. SUGGESTED PARAMETER VALUES For user convenience, a table is provided below as a quick reference for selecting parameter values. However, use of this table should be of great caution, and other information should be incorporated wherever possible. Parameters Loose Sand (15%-35%) Medium Sand (35%-65%) Medium-dense Sand (65%-85%) Dense Sand (85%-100%) rho 1.7 ton/m 3 or 1.59x10 -4 (lbf)(s 2 )/in 4 1.9 ton/m 3 or 1.778x10 -4 (lbf)(s 2 )/in 4 2.0 ton/m 3 or 1.872x10 -4 (lbf)(s 2 )/in 4 2.1 ton/m 3 or 1.965x10 -4 (lbf)(s 2 )/in 4 refShearModul (at p\u2019 r =80 kPa or 11.6 psi) 5.5x10 4 kPa or 7.977x10 3 psi 7.5x10 4 kPa or 1.088x10 4 psi 1.0x10 5 kPa or 1.45x10 4 psi 1.3x10 5 kPa or 1.885x10 4 psi refBulkModu (at p\u2019 r =80 kPa or 11.6 psi) 1.5x10 5 kPa or 2.176x10 4 psi 2.0x10 5 kPa or 2.9x10 4 psi 3.0x10 5 kPa or 4.351x10 4 psi 3.9x10 5 kPa or 5.656x10 4 psi frictionAng 29 33 37 40 peakShearStra (at p\u2019 r =80 kPa or 11.6 psi) 0.1 0.1 0.1 0.1 refPress (p\u2019 r ) 80 kPa or 11.6 psi 80 kPa or 11.6 psi 80 kPa or 11.6 psi 80 kPa or 11.6 psi pressDependCoe 0.5 0.5 0.5 0.5 PTAng 29 27 27 27 contrac 0.21 0.07 0.05 0.03 dilat1 0. 0.4 0.6 0.8 dilat2 0 2 3 5 liquefac1 10 kPa or 1.45 psi 10 kPa or 1.45 psi 5 kPa or 0.725 psi 0 liquefac2 0.02 0.01 0.003 0 liquefac3 1 1 1 0 e 0.85 0.7 0.55 0.45 Pressure Dependent Material Examples: Material in elastic, drained (or dry) state Example 1 Single quadrilateral element, subjected to sinusoidal base shaking Example 2 Single quadrilateral element, subjected to monotonic pushover ( English units version ) Material in drained (or dry), elastic-plastic state Example 3 Single quadrilateral element, subjected to sinusoidal base shaking Example 4 Single quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking Example 5 Single quadrilateral element, subjected to monotonic pushover Example 6 Single 3D BbarBrick element, subjected to sinusoidal base shaking Example 7 Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking Material in saturated, undrained elastic-plastic state (coupled with FluidSolidPorous Material) Example 8 Single quadrilateral element, subjected to sinusoidal base shaking Example 9 Single quadrilateral element, subjected to monotonic pushover Example 10 Single quadrilateral element (inclined by 4 degrees), subjected to msinusoidal base shaking Example 11 Single 3D BbarBrick element, subjected to sinusoidal base shaking Example 12 Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking Example 13 A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking Material in saturated, undrained elastic-plastic state (with user defined modulus reduction curve) Example 14 A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking Solid-Fluid fully coupled elements - quadUP element Example 15 A column (2D plane strain quadUP element) of saturated, undrained Pressure Dependent material (inclined by 4 degrees), subjected to sinusoidal base shaking Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/519-PressureDependMultiYield--Example%2013/","text":"PressureDependMultiYield\u2013Example 13 <center> Inclined (4 degrees), saturated, undrained soil column with pressure dependent material </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # # plane strain, shear-beam type mesh with single material, # dynamic analysis, SI units (m, s, KN, ton) # input motion may be from a file, or a sinusoidal wave. # wipe # # some user defined variables # < p > set matOpt 1 ; # 1 = drained, pressure depend; 2 = undrained, pressure depend ; </ p > < dl > < dt > # 3 = undrained, pressure independ ; 4 = elastic </ dt > </ dl > < p > set mass 2.0 ; # saturated mass density set fmass 1.0 ;# fluid mass density set G 6 .e4 ; set B 2.4 e5 ; set press 0 . ; # isotropic consolidation pressure on quad element ( s ) set accMul 2 . ; # acc. multiplier ( m / s / s ) set accNam myACC ; # acc. file name if imposed motion is read from file </ p > < dl > < dt > # - YOU MUST CHANGE IT TO THE RIGHT NAME </ dt > </ dl > < p > set accDt 0.0166 ; # dt for input acc. set loadBias .07 ;# Static shear load, in percentage of gravity load ( = sin ( inclination )) set period 1.0 ; # Period if imposed motion is Sine wave set deltaT 0.01 ;# time step for analysis, does not have to be the same as accDt. set numSteps 2000 ; # number of time steps set gamma 0.6 ;# Newmark integration parameter </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.002 ; </ p > < p > set numXele 1 ; # number of elements in x (H) direction set numYele 10 ; # number of elements in y (V) direction set xSize 1.0 ;# x direction element size set ySize 1.0 ; # y direction element size</p> < li >< ol > # </ ol ></ li > # BUILD MODEL # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > switch $matOpt { 1 { nDMaterial PressureDependMultiYield 1 2 $mass $G $B 31.4 .1 80 0.5 \\ 26.5 0.17 0.4 10 10 0.015 1.0 updateMaterialStage -material 1 - stage 0 </ p > < p > set gravY [expr - 9.81 * $mass ] ; #gravity set gravX [expr -$gravY*$loadBias] } 2 { nDMaterial PressureDependMultiYield 1 2 $mass $G $B 31.4 .1 80 0.5 \\ 26.5 0.17 0.4 10 10 0.015 1.0 nDMaterial FluidSolidPorous 2 2 1 2.2 e6 </ p > < p > set gravY [expr - 9.81 * ( $mass-$fmass )] ; # buoyant unit weight set gravX [expr - $gravY * $loadBias ] } 3 { nDMaterial PressureIndependMultiYield 1 2 $mass 4 .e4 2 .e5 20 .1 nDMaterial FluidSolidPorous 3 2 1 2.2 e6 </ p > < p > updateMaterialStage - material 1 - stage 0 updateMaterialStage -material 3 - stage 0 </ p > < p > set gravY [expr - 9.81 * ( $mass-fmass )] ; # buoyant unit weight set gravX [expr -$gravY*$loadBias] } 4 { nDMaterial ElasticIsotropic 4 2000 0.3 $mass set gravY [expr - 9.81 * $mass ] ; #gravity set gravX [expr -$gravY*$loadBias] } }</p> # define the nodes set numXnode [expr $numXele + 1 ] set numYnode [expr $numYele + 1 ] < p > for {set i 1 } { $i & lt ; = $numXnode } { incr i 1 } { for {set j 1 } { $j & lt ; = $numYnode } { incr j 1 } { set xdim [expr ( $i-1 ) * $xSize ] set ydim [expr ( $j-1 ) * $ySize ] set nodeNum [expr $i + ( $j-1 ) * $numXnode ] node $nodeNum $xdim $ydim } } </ p > # define elements < p > for {set i 1 } { $i & lt ; = $numXele } { incr i 1 } { for {set j 1 } { $j & lt ; = $numYele } { incr j 1 } { set eleNum [expr $i + ( $j-1 ) * $numXele ] set n1 [expr $i + ( $j-1 ) * $numXnode ] set n2 [expr $i + ( $j-1 ) * $numXnode + 1 ] set n4 [expr $i + $j * $numXnode + 1 ] set n3 [expr $i + $j * $numXnode ] </ p > # thick material maTag press density gravity < p > element quad $eleNum $n1 $n2 $n4 $n3 1.0 \"PlaneStrain\" $matOpt $press 0.0 $gravX $gravY } } </ p > < p > updateMaterialStage - material 1 - stage 0 updateMaterialStage -material 2 - stage 0 </ p > # fix the base < p > for {set i 1 } { $i & lt ; = $numXnode } { incr i 1 } { fix $i 1 1 } </ p > # tie two lateral sides < p > for {set i 1 } { $i & lt ; $numYnode } { incr i 1 } { set nodeNum1 [expr $i * $numXnode + 1 ] set nodeNum2 [expr ( $i + 1 ) * $numXnode ] equalDOF $nodeNum1 $nodeNum2 1 2 } </ p > < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-5 10 0 algorithm ModifiedNewton constraints Transformation integrator LoadControl 1 1 1 1 numberer RCM </ p > # create the Analysis analysis Static analyze 2 # switch material stage from elastic (gravity) to plastic < p > switch $matOpt { 1 { updateMaterialStage - material 1 - stage 1 updateMaterials - material 1 bulkModulus [expr $G * 2 / 3 . ] } 2 { updateMaterialStage - material 1 - stage 1 updateMaterialStage - material 2 -stage 1 updateMaterials - material 1 bulkModulus [expr $G * 2 / 3 . ] } 3 { updateMaterialStage - material 1 - stage 1 updateMaterialStage - material 3 -stage 1 } 4 ; # do nothing }</p> < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 wipeAnalysis # # Sinusoidal motion, comment next line if using input motion file < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 $period -factor $accMul\" </ p > # decomment next line if using input motion file < li > pattern UniformExcitation 1 1 - accel \"Series -factor $accMul -filePath $accNam -dt $accDt\" </ li > # recorder for nodal displacement along the vertical center line. < p > set nodeList {} for {set i 0 } { $i & lt ; $numYnode } { incr i 1 } { lappend nodeList [expr $numXnode / 2 + $i * $numXnode ] } eval \"recorder Node -file disp -time -node $nodeList -dof 1 2 -dT $deltaT disp\" eval \"recorder Node -file acc -time -node $nodeList -dof 1 2 -dT $deltaT accel\" </ p > # recorder for element output along the vertical center line. < p > set name1 \"stress\" ; set name2 \"strain\" ; set name3 \"press\" for {set i 1 } { $i & lt ; $numYnode } { incr i 1 } { set ele [expr $numXele-$numXele / 2 + ( $i-1 ) * $numXele ] set name11 [ join [ list $name1 $i ] {}] set name22 [ join [ list $name2 $i ] {}] set name33 [ join [ list $name3 $i ] {}] recorder Element - ele $ele - time - file $name11 material 1 stress recorder Element - ele $ele - time - file $name22 material 1 strain if { $matOpt == 2 || $matOpt == 3 } { ; #excess pore pressure ouput recorder Element - ele $ele - time - file $name33 material 1 pressure } } </ p > < p > constraints Transformation test NormDispIncr 1 .e-4 10 0 numberer RCM algorithm Newton system ProfileSPD rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 5 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > < p > wipe # flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acc' ); d1 = load ( 'disp' ); p1 = load ( 'press1' ); s1 = load ( 'stress1' ); e1 = load ( 'strain1' ); p6 = load ( 'press6' ); s5 = load ( 'stress5' ); e5 = load ( 'strain5' ); p10 = load ( 'press10' ); s9 = load ( 'stress9' ); e9 = load ( 'strain9' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 1 ); close 1 ; figure ( 1 ); %integration point 1 stress-strain subplot ( 2 , 1 , 1 ), plot ( e1 (:, 4 ), s1 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 10 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 10 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_10m' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 5 ); close 5 ; figure ( 5 ); %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 6 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 6 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_6m' , 'jpg' ); </ p > < p > %integration point 9 p-q po=(s9(:,2)+s9(:,3)+s9(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s9 ( i , 2 ) - s9 ( i , 3 )) ^ 2 + ( s9 ( i , 3 ) - s9 ( i , 4 )) ^ 2 + ( s9 ( i , 2 ) - s9 ( i , 4 )) ^ 2 + 6.0 * s9 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s9 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 6 ); close 6 ; figure ( 6 ); %integration point 9 stress-strain subplot ( 2 , 1 , 1 ), plot ( e9 (:, 4 ), s9 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 2 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 2 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_2m' , 'jpg' ); </ p > < p > figure ( 2 ); close 2 ; figure ( 2 ); %node 3 displacement relative to node 1 subplot(2,1,1),a=plot(d1(:,1),d1(:,8),'r') ; hold on subplot ( 2 , 1 , 1 ), b = plot ( d1 (:, 1 ), d1 (:, 14 ), 'g' ); hold on subplot ( 2 , 1 , 1 ), c = plot ( d1 (:, 1 ), d1 (:, 22 ), 'b' ); title ( 'Lateral displacement wrt base' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); legend ([ a , b , c ], '8m depth' , '4m depth' , 'Surface' , 2 ) set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'Disp' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); close 3 ; figure ( 3 ); %node acceleration subplot ( 3 , 1 , 1 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 22 ), 'r' ); legend ( a , 'at surface' , 4 ); title ( 'Lateral acceleration' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); subplot ( 3 , 1 , 2 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 14 ), 'r' ); legend ( a , '4 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); subplot ( 3 , 1 , 3 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 8 ), 'r' ); legend ( a , '8 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'Acc' , 'jpg' ); </ p > < p > figure ( 4 ); close 4 ; figure ( 4 ); %integration point 1 excess pore water pressure subplot(3,1,1),a=plot(p10(:,1),-p10(:,2),'r') ; legend ( a , '1 m depth' , 4 ); title ( 'Excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); subplot ( 3 , 1 , 2 ), a = plot ( p6 (:, 1 ), - p6 (:, 2 ), 'r' ); legend ( a , '5 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); subplot ( 3 , 1 , 3 ), a = plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); legend ( a , '10 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex20Disp.jpg Stress-Strain Output File (2 m depth) PD_Ex20SS_PQ2m.jpg Stress-Strain Output File (6 m depth) PD_Ex20SS_PQ6m.jpg Stress-Strain Output File (10 m depth) PD_Ex20SS_PQ10m.jpg Excess Pore Pressure Output File PD_Ex20EPP.jpg Acceleration Output File PD_Ex20Accel.jpg Return to:","title":"PressureDependMultiYield--Example 13\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/520-PressureDependMultiYield-Example%201/","text":"PressureDependMultiYield-Example 1 <center> Elastic Pressure Dependent Dry Level Dynamic </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # elastic pressure dependent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 9.81 ; set massDen 2 . ; # mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.4 ; #friction angle set ptangle 26.5 ;#phase transformation angle set E1 90000.0 ; #Young's modulus set poisson1 0.40 ; set G [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set press 0 ; # isotropic consolidation pressure on quad element(s) set period 1 ; # Period of applied sinusoidal load set deltaT 0.01 ;# time step for analysis set numSteps 2000 ; # Number of analysis steps set gamma 0.5 ; # Newmark integration parameter set unitWeightX 0.0 ;#unit weight in X direction set unitWeightY [expr - 9.81 * ( $massDen )] ; #unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 10 0.015 1.0 nDMaterial FluidSolidPorous 1 2 2 2.2 e6 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to elastic pressure dependent updateMaterialStage - material 2 - stage 2 # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 wipeAnalysis equalDOF 3 4 1 2 ; #tie nodes 3 and 4 < p > pattern UniformExcitation 1 1 - accel \"Sine 0 2000 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Penalty 1.0 e18 1.0 e18 ; # Transformation; # test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # create the recorder < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > < p > wipe # flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 9.81 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 40 * pi ); s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 1 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex8Disp.png Stress-Strain Output File (Integration Point 1) PD_Ex8SS_PQ1.png Stress-Strain Output File (Integration Point 3) PD_Ex8SS_PQ3.png Acceleration Output File PD_Ex8Accel.png Return to:","title":"PressureDependMultiYield-Example 1\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/521-PressureDependMultiYield-Example%2010/","text":"PressureDependMultiYield-Example 10 <center> Plastic Pressure Dependent Wet Inclined Dynamic </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # plastic pressure dependent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 2 ; # acceleration multiplier set massDen 2.00 ;# solid mass density set fluidDen 1.0 ; # fluid mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ;#phase transformation angle set E 90000.0 ; #shear modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element(s) set deltaT 0.010 ; # time step for analysis set numSteps 2000 ;# Number of analysis steps set gamma 0.600 ; # Newmark integration parameter set period 1 ; # Period of applied sinusoidal load set pi 3.1415926535 ; set inclination 4 ; set unitWeightX [expr ( $massDen-$fluidDen ) * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - ( $massDen-$fluidDen ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 10 0.015 1.0 nDMaterial FluidSolidPorous 1 2 2 2.2 D + 6 </ p > # define the nodes < p > node 1 0.0 D0 0.0 D0 node 2 1.0 D0 0.0 D0 node 3 1.0 D0 1.0 D0 node 4 0.0 D0 1.0D0 </ p > # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 1 $press 0.0 $unitWeightX $unitWeightY </ p > < p > updateMaterialStage - material 1 - stage 0 updateMaterialStage -material 2 - stage 0 </ p > # fix the base fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 1 - stage 1 updateMaterialStage -material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0D0 wipeAnalysis < p > pattern UniformExcitation 1 1 - accel \"Sine 0 1000 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Transformation ; test NormDispIncr 1 .D-6 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain recorder Element - ele 1 - time - file press1.out - dT 0.01 material 1 pressure recorder Element - ele 1 - time -file press3.out - dT 0.01 material 3 pressure </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > < p > wipe # flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); p1 = load ( 'press1.out' ); p3 = load ( 'press3.out' ); </ p > < p > fs =[ 0. , 0.2 , 4 , 6 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ) * 100 , 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (cm)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 40 * pi ); s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 1 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > figure ( 5 ); clf ; %integration point 1 excess pore water pressure subplot ( 2 , 1 , 1 ), plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); title ( 'Integration point 1 excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( p1 (:, 1 ), p1 (:, 3 ), 'r' ); title ( 'Integration point 1 excess pore pressure ratio' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure ratio' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); Displacement Output File PD_Ex17Disp.png Stress-Strain Output File (Integration Point 1 & Integration Point 3) PD_EEx17SS_PQ13.png Excess Pore Pressure Output File PD_EEx17EPP.png Acceleration Output File PD_EEx17Accel.png Return to:","title":"PressureDependMultiYield-Example 10\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/522-PressureDependMultiYield-Example%2011/","text":"PressureDependMultiYield-Example 11 <center> Saturated, undrained single BbarBrick element with pressure dependent material </center> Input File < li > saturated, undrained single BbarBrick element with pressure dependent material. </ li > # subjected to 1D sinusoidal base shaking < p > wipe set friction 31.40 ; #friction angle set phaseTransform 26.50 ; #phase transformation angle set E1 93178.4 ;#Young's modulus set poisson1 0.40 ; set G1 [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B1 [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set gamma 0.600 ; # Newmark integration parameter </ p > < p > set dt 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 1600 ; # number of time steps set rhoS 1.973 ;# saturated mass density set rhoF 1.00 ; # fluid mass density set densityMult 1 . ; # density multiplier</p> < p > set Bfluid 2.2 e6 ; # fluid shear modulus set fluid1 1 ;# fluid material tag set solid1 10 ; # solid material tag</p> < p > set accMul 2 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 0 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.001 ; </ p > < p > set bUnitWeightX [expr ( $rhoS-$rhoF ) * 9.81 * sin ( $inclination / 180.0 * $pi ) * $densityMult ] ; # buoyant unit weight in X direction set bUnitWeightY 0.0 ; # buoyant unit weight in Y direction set bUnitWeightZ [expr - ( $rhoS-$rhoF ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in Z direction set ndm 3 ; # space dimension</p> model BasicBuilder - ndm $ndm - ndf $ndm < p > nDMaterial PressureDependMultiYield $solid1 $ndm [expr $rhoS * $densityMult ] $G1 $B1 $friction 0.1 80 0.5 \\ $phaseTransform 0.17 0.4 10 10 0.015 1.0 ; # 27 0.6 0 0 0 101 0.630510273 nDMaterial FluidSolidPorous $fluid1 $ndm $solid1 $Bfluid </ p > < p > node 1 0.00000 0.0000 0.00000 node 2 0.00000 0.0000 1.00000 node 3 0.00000 1.0000 0.00000 node 4 0.00000 1.0000 1.00000 node 5 1.00000 0.0000 0.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 0.00000 node 8 1.00000 1.0000 1.00000 < p > element bbarBrick 1 1 5 7 3 2 6 8 4 $fluid1 $bUnitWeightX $bUnitWeightY $bUnitWeightZ </ p > < p > updateMaterialStage - material $solid1 - stage 0 updateMaterialStage -material $fluid1 - stage 0 </ p > < p > fix 1 1 1 1 0 0 0 fix 2 0 1 0 0 0 0 fix 3 1 1 1 0 0 0 fix 4 0 1 0 0 0 0 fix 5 1 1 1 0 0 0 fix 6 0 1 0 0 0 0 fix 7 1 1 1 0 0 0 fix 8 0 1 0 0 0 0 </ p > # equalDOF # tied nodes around equalDOF 2 4 1 3 equalDOF 2 6 1 3 equalDOF 2 8 1 3 < p > set nodeList {} for {set i 1 } { $i & lt ; = 8 } { incr i 1 } { lappend nodeList $i } </ p > < p > set elementList {} for {set i 1 } { $i & lt ; = 1 } { incr i 1 } { lappend elementList $i } </ p > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-10 25 2 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static analyze 2 </ p > # switch the material to plastic < p > updateMaterialStage - material $fluid1 - stage 1 updateMaterialStage -material $solid1 - stage 1 updateMaterials - material $solid1 bulkModulus [expr $G1 * 2 / 3 . ]; </ p > analyze 2 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > < li >< ol > < li > create recorders ############################## </ li > </ ol ></ li > < p > eval \"recorder Node -file allNodesDisp.out -time -node $nodeList -dof 1 2 3 -dT 0.01 disp\" eval \"recorder Node -file allNodesAcce.out -time -node $nodeList -dof 1 2 3 -dT 0.01 accel\" eval \"recorder Element -ele $elementList -time -file stress1.out -dT 0.01 material 1 stress\" eval \"recorder Element -ele $elementList -time -file strain1.out -dT 0.01 material 1 strain\" eval \"recorder Element -ele $elementList -time -file press1.out -dT 0.01 material 1 pressure\" eval \"recorder Element -ele $elementList -time -file stress5.out -dT 0.01 material 5 stress\" eval \"recorder Element -ele $elementList -time -file strain5.out -dT 0.01 material 5 strain\" eval \"recorder Element -ele $elementList -time -file press5.out -dT 0.01 material 5 pressure\" eval \"recorder Element -ele $elementList -file backbone.out -dT 1000 material 1 backbone 80 100 200 300\" </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-5 25 0 ; # can't combine with constraints Lagrange</p> < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm ModifiedNewton ; # tengent is updated at the begining of each time step not each iteration system ProfileSPD ; # Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient</p> < li >< ol > < li > perform the Analysis and record time used ############# </ li > </ ol ></ li > < p > set startT [ clock seconds ] analyze $numSteps $dt [expr $dt / 64 ] $dt 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'allNodesAcce.out' ); d1 = load ( 'allNodesDisp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress5.out' ); e5 = load ( 'strain5.out' ); p1 = load ( 'press1.out' ); p5 = load ( 'press5.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 2 ; %integration point 1 p-q po =( s1 (:, 2 ) + s1 (:, 3 ) + s1 (:, 4 )) / 3 ; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 + 6.0 * s1 ( i , 6 ) ^ 2 + 6.0 * s1 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,7),s1(:,7),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 + 6.0 * s5 ( i , 6 ) ^ 2 + 6.0 * s5 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 5 stress-strain subplot(2,1,1), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'Integration point 5 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 5 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 5 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > figure ( 5 ); clf ; %integration point 1 excess pore water pressure subplot ( 2 , 1 , 1 ), plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); title ( 'Integration point 1 excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( p1 (:, 1 ), p1 (:, 3 ), 'r' ); title ( 'Integration point 1 excess pore pressure ratio' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure ratio' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex18Displ.png Stress-Strain Output File (Integration Point 1 & Integration Point 3) PD_Ex18SS_PQ13.png Excess Pore Pressure Output File PD_Ex18EPP.png Acceleration Output File PD_Ex18Accel.png Return to:","title":"PressureDependMultiYield-Example 11\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/523-PressureDependMultiYield-Example%2012/","text":"PressureDependMultiYield-Example 12 <center> Inclined (4 degrees), saturated, undrained single BbarBrick element with pressure dependent material </center> Input File < li > Inclined ( 4 degrees ) saturated, undrained single BbarBrick element with pressure dependent material. </ li > # subjected to 1D sinusoidal base shaking < p > wipe set friction 31.40 ; #friction angle set phaseTransform 26.50 ; #phase transformation angle set E1 93178.4 ;#Young's modulus set poisson1 0.40 ; set G1 [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B1 [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set gamma 0.600 ; # Newmark integration parameter </ p > < p > set dt 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 1600 ; # number of time steps set rhoS 2.00 ;# saturated mass density set rhoF 1.00 ; # fluid mass density set densityMult 1 . ; # density multiplier</p> < p > set Bfluid 2.2 e6 ; # fluid shear modulus set fluid1 1 ;# fluid material tag set solid1 10 ; # solid material tag</p> < p > set shakeTime velacs1horizontal.time ; # acceleration time file (s) set shakeAcce velacs1horizontal.acc ; # acceleration value file set accMul 2 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 4 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.002 ; </ p > < p > set bUnitWeightX [expr ( $rhoS-$rhoF ) * 9.81 * sin ( $inclination / 180.0 * $pi ) * $densityMult ] ; # buoyant unit weight in X direction set bUnitWeightY 0.0 ; # buoyant unit weight in Y direction set bUnitWeightZ [expr - ( $rhoS-$rhoF ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in Z direction set ndm 3 ; # space dimension</p> model BasicBuilder - ndm $ndm - ndf $ndm < p > nDMaterial PressureDependMultiYield $solid1 $ndm [expr $rhoS * $densityMult ] $G1 $B1 $friction 0.1 80 0.5 \\ $phaseTransform 0.17 0.4 10 10 0.015 1.0 ; # 27 0.6 0 0 0 101 0.630510273 nDMaterial FluidSolidPorous $fluid1 $ndm $solid1 $Bfluid </ p > < p > node 1 0.00000 0.0000 0.00000 node 2 0.00000 0.0000 1.00000 node 3 0.00000 1.0000 0.00000 node 4 0.00000 1.0000 1.00000 node 5 1.00000 0.0000 0.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 0.00000 node 8 1.00000 1.0000 1.00000 < p > element bbarBrick 1 1 5 7 3 2 6 8 4 $fluid1 $bUnitWeightX $bUnitWeightY $bUnitWeightZ </ p > < p > updateMaterialStage - material $solid1 - stage 0 updateMaterialStage -material $fluid1 - stage 0 </ p > < p > fix 1 1 1 1 0 0 0 fix 2 0 1 0 0 0 0 fix 3 1 1 1 0 0 0 fix 4 0 1 0 0 0 0 fix 5 1 1 1 0 0 0 fix 6 0 1 0 0 0 0 fix 7 1 1 1 0 0 0 fix 8 0 1 0 0 0 0 </ p > # equalDOF # tied nodes around equalDOF 2 4 1 3 equalDOF 2 6 1 3 equalDOF 2 8 1 3 < p > set nodeList {} for {set i 1 } { $i & lt ; = 8 } { incr i 1 } { lappend nodeList $i } </ p > < p > set elementList {} for {set i 1 } { $i & lt ; = 1 } { incr i 1 } { lappend elementList $i } </ p > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-10 25 2 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static analyze 2 </ p > # switch the material to plastic < p > updateMaterialStage - material $fluid1 - stage 1 updateMaterialStage -material $solid1 - stage 1 updateMaterials - material $solid1 bulkModulus [expr $G1 * 2 / 3 . ]; </ p > analyze 2 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > < li >< ol > < li > create recorders ############################## </ li > </ ol ></ li > < p > eval \"recorder Node -file allNodesDisp.out -time -node $nodeList -dof 1 2 3 -dT 0.01 disp\" eval \"recorder Node -file allNodesAcce.out -time -node $nodeList -dof 1 2 3 -dT 0.01 accel\" eval \"recorder Element -ele $elementList -time -file stress1.out -dT 0.01 material 1 stress\" eval \"recorder Element -ele $elementList -time -file strain1.out -dT 0.01 material 1 strain\" eval \"recorder Element -ele $elementList -time -file press1.out -dT 0.01 material 1 pressure\" eval \"recorder Element -ele $elementList -time -file stress5.out -dT 0.01 material 5 stress\" eval \"recorder Element -ele $elementList -time -file strain5.out -dT 0.01 material 5 strain\" eval \"recorder Element -ele $elementList -time -file press5.out -dT 0.01 material 5 pressure\" eval \"recorder Element -ele $elementList -file backbone.out -dT 1000 material 1 backbone 80 100 200 300\" </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-5 25 0 ; # can't combine with constraints Lagrange</p> < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm ModifiedNewton ; # tengent is updated at the begining of each time step not each iteration system ProfileSPD ; # Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient</p> < li >< ol > < li > perform the Analysis and record time used ############# </ li > </ ol ></ li > < p > set startT [ clock seconds ] analyze $numSteps $dt [expr $dt / 64 ] $dt 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'allNodesAcce.out' ); d1 = load ( 'allNodesDisp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress5.out' ); e5 = load ( 'strain5.out' ); p1 = load ( 'press1.out' ); p5 = load ( 'press5.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 + 6.0 * s1 ( i , 6 ) ^ 2 + 6.0 * s1 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,7),s1(:,7),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 + 6.0 * s5 ( i , 6 ) ^ 2 + 6.0 * s5 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 5 stress-strain subplot(2,1,1), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'Integration point 5 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 5 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 5 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > figure ( 5 ); clf ; %integration point 1 excess pore water pressure subplot ( 2 , 1 , 1 ), plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); title ( 'Integration point 1 excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( p1 (:, 1 ), p1 (:, 3 ), 'r' ); title ( 'Integration point 1 excess pore pressure ratio' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure ratio' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex19Disp.jpg Stress-Strain Output File (Integration Point 1 & Integration Point 3) PD_Ex19SS_PQ13.jpg Excess Pore Pressure Output File PD_Ex19EPP.jpg Acceleration Output File PD_Ex19Accel.jpg Return to:","title":"PressureDependMultiYield-Example 12\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/524-PressureDependMultiYield-Example%2014/","text":"PressureDependMultiYield-Example 14 <center> Inclined (4 degrees), saturated, undrained soil column (user defined modulus reduction curve) with pressure dependent material </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # # plane strain, shear-beam type mesh with single material, # dynamic analysis, SI units (m, s, KN, ton) # input motion may be from a file, or a sinusoidal wave. # # USER DEFINED YIELD SURFACES # wipe # # some user defined variables # < p > set matOpt 2 ; # 1 = drained, pressure depend; 2 = undrained, pressure depend ; </ p > < dl > < dt > # 3 = undrained, pressure independ ; 4 = elastic </ dt > </ dl > < p > set mass 2.0 ; # saturated mass density set fmass 1.0 ;# fluid mass density set G 6 .e4 ; set B 2.4 e5 ; set press 0 . ; # isotropic consolidation pressure on quad element ( s ) set accMul 2 . ; # acc. multiplier ( m / s / s ) set accNam myACC ; # acc. file name if imposed motion is read from file </ p > < dl > < dt > # - YOU MUST CHANGE IT TO THE RIGHT NAME </ dt > </ dl > < p > set accDt 0.0166 ; # dt for input acc. set loadBias .07 ;# Static shear load, in percentage of gravity load ( = sin ( inclination angle )) set period 1.0 ; # Period if imposed motion is Sine wave set deltaT 0.01 ;# time step for analysis, does not have to be the same as accDt. set numSteps 2000 ; # number of time steps set gamma 0.6 ;# Newmark integration parameter </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.002 ; </ p > < p > set numXele 1 ; # number of elements in x (H) direction set numYele 10 ; # number of elements in y (V) direction set xSize 1.0 ;# x direction element size set ySize 1.0 ; # y direction element size</p> < li >< ol > # </ ol ></ li > # BUILD MODEL # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > switch $matOpt { 1 { nDMaterial PressureDependMultiYield 1 2 $mass $G $B 31.4 .1 80 0.5 \\ 26.5 0.1 0.4 10 10 0.015 1.0 - 11 \\ 1e-6 0.999 3 e-6 0.995 1 e-5 0.99 3 e-5 0.96 1 e-4 0.85 3 e-4 0.64 \\ 1e-3 0.37 3 e-3 0.18 1 e-2 0.08 3 e-2 0.03 1 e-1 0.01 </ p > < p > set gravY [expr - 9.81 * $mass ] ; #gravity set gravX [expr -$gravY*$loadBias] } 2 { nDMaterial PressureDependMultiYield 1 2 $mass $G $B 31.4 .1 80 0.5 \\ 26.5 0.1 0.4 10 10 0.015 1.0 - 11 \\ 1e-6 0.999 3 e-6 0.995 1 e-5 0.99 3 e-5 0.96 1 e-4 0.85 3 e-4 0.64 \\ 1e-3 0.37 3 e-3 0.18 1 e-2 0.08 3 e-2 0.03 1 e-1 0.01 nDMaterial FluidSolidPorous 2 2 1 2.2 e6 </ p > < p > set gravY [expr - 9.81 * ( $mass-$fmass )] ; # buoyant unit weight set gravX [expr - $gravY * $loadBias ] } 3 { nDMaterial PressureIndependMultiYield 1 2 $mass 4 .e4 2 .e5 20 .1 0 100 0 . - 11 \\ 1e-6 0.999 3 e-6 0.995 1 e-5 0.99 3 e-5 0.96 1 e-4 0.85 3 e-4 0.64 \\ 1e-3 0.37 3e-3 0.18 1 e-2 0.08 3 e-2 0.03 1 e-1 0.01 nDMaterial FluidSolidPorous 3 2 1 2.2 e6 </ p > < p > set gravY [expr - 9.81 * ( $mass-$fmass )] ; # buoyant unit weight set gravX [expr - $gravY * $loadBias ] } 4 { nDMaterial ElasticIsotropic 4 2000 0.3 $mass set gravY [expr - 9.81 * $mass ] ; #gravity set gravX [expr -$gravY*$loadBias] } }</p> # define the nodes set numXnode [expr $numXele + 1 ] set numYnode [expr $numYele + 1 ] < p > for {set i 1 } { $i & lt ; = $numXnode } { incr i 1 } { for {set j 1 } { $j & lt ; = $numYnode } { incr j 1 } { set xdim [expr ( $i-1 ) * $xSize ] set ydim [expr ( $j-1 ) * $ySize ] set nodeNum [expr $i + ( $j-1 ) * $numXnode ] node $nodeNum $xdim $ydim } } </ p > # define elements < p > for {set i 1 } { $i & lt ; = $numXele } { incr i 1 } { for {set j 1 } { $j & lt ; = $numYele } { incr j 1 } { set eleNum [expr $i + ( $j-1 ) * $numXele ] set n1 [expr $i + ( $j-1 ) * $numXnode ] set n2 [expr $i + ( $j-1 ) * $numXnode + 1 ] set n4 [expr $i + $j * $numXnode + 1 ] set n3 [expr $i + $j * $numXnode ] </ p > # thick material maTag press density gravity < p > element quad $eleNum $n1 $n2 $n4 $n3 1.0 \"PlaneStrain\" $matOpt $press 0.0 $gravX $gravY } } </ p > < p > updateMaterialStage - material 1 - stage 0 updateMaterialStage -material 2 - stage 0 updateMaterialStage - material 3 - stage 0 </ p > # fix the base < p > for {set i 1 } { $i & lt ; = $numXnode } { incr i 1 } { fix $i 1 1 } </ p > # tie two lateral sides < p > for {set i 1 } { $i & lt ; $numYnode } { incr i 1 } { set nodeNum1 [expr $i * $numXnode + 1 ] set nodeNum2 [expr ( $i + 1 ) * $numXnode ] equalDOF $nodeNum1 $nodeNum2 1 2 } </ p > < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > system ProfileSPD < p > test NormDispIncr 1 .e-5 10 0 algorithm ModifiedNewton constraints Transformation integrator LoadControl 1 1 1 1 numberer RCM </ p > # create the Analysis analysis Static analyze 2 # switch material stage from elastic (gravity) to plastic < p > switch $matOpt { 1 { updateMaterialStage - material 1 - stage 1 updateMaterials - material 1 bulkModulus [expr $G * 2 / 3 . ] } 2 { updateMaterialStage - material 1 - stage 1 updateMaterialStage - material 2 -stage 1 updateMaterials - material 1 bulkModulus [expr $G * 2 / 3 . ] } 3 { updateMaterialStage - material 1 - stage 1 updateMaterialStage - material 3 -stage 1 } 4 ; # do nothing }</p> < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 wipeAnalysis # # Sinusoidal motion, comment next line if using input motion file < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 $period -factor $accMul\" </ p > # decomment next line if using input motion file < li > pattern UniformExcitation 1 1 - accel \"Series -factor $accMul -filePath $accNam -dt $accDt\" </ li > # recorder for nodal displacement along the vertical center line. < p > set nodeList {} for {set i 0 } { $i & lt ; $numYnode } { incr i 1 } { lappend nodeList [expr $numXnode / 2 + $i * $numXnode ] } eval \"recorder Node -file disp -time -node $nodeList -dof 1 2 -dT $deltaT disp\" eval \"recorder Node -file disp -time -node $nodeList -dof 1 2 -dT $deltaT disp\" der Node - file acc - time - node $nodeList - dof 1 2 - dT $deltaT accel \"</p> # recorder for element output along the vertical center line. <p>set name1 \" stress \"; set name2 \" strain \"; set name3 \" press \" for {set i 1} {$i &lt; $numYnode} {incr i 1} { set ele [expr $numXele-$numXele/2+($i-1)*$numXele] set name11 [join [list $name1 $i] {}] set name22 [join [list $name2 $i] {}] set name33 [join [list $name3 $i] {}] recorder Element -ele $ele -time -file $name11 material 1 stress recorder Element -ele $ele -time -file $name22 material 1 strain if { $matOpt == 2 || $matOpt == 3 } { ;#excess pore pressure ouput recorder Element -ele $ele -time -file $name33 material 1 pressure } }</p> <p>constraints Transformation test NormDispIncr 1.e-5 10 0 numberer RCM algorithm Newton system ProfileSPD rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0.0 integrator Newmark $gamma [expr pow($gamma+0.5, 2)/4] analysis VariableTransient</p> # analyze <p>set startT [clock seconds] analyze $numSteps $deltaT [expr $deltaT/100] $deltaT 5 set endT [clock seconds] puts \" Execution time: [expr $endT-$startT ] seconds. \"</p> <p>wipe #flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acc' ); d1 = load ( 'disp' ); p1 = load ( 'press1' ); s1 = load ( 'stress1' ); e1 = load ( 'strain1' ); p6 = load ( 'press6' ); s5 = load ( 'stress5' ); e5 = load ( 'strain5' ); p10 = load ( 'press10' ); s9 = load ( 'stress9' ); e9 = load ( 'strain9' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 1 ); close 1 ; figure ( 1 ); %integration point 1 stress-strain subplot ( 2 , 1 , 1 ), plot ( e1 (:, 4 ), s1 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 10 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 10 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_10m' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 5 ); close 5 ; figure ( 5 ); %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 6 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 6 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_6m' , 'jpg' ); </ p > < p > %integration point 9 p-q po=(s9(:,2)+s9(:,3)+s9(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s9 ( i , 2 ) - s9 ( i , 3 )) ^ 2 + ( s9 ( i , 3 ) - s9 ( i , 4 )) ^ 2 + ( s9 ( i , 2 ) - s9 ( i , 4 )) ^ 2 + 6.0 * s9 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s9 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 6 ); close 6 ; figure ( 6 ); %integration point 9 stress-strain subplot ( 2 , 1 , 1 ), plot ( e9 (:, 4 ), s9 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at 2 m depth' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at 2 m depth' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_2m' , 'jpg' ); </ p > < p > figure ( 2 ); close 2 ; figure ( 2 ); %node 3 displacement relative to node 1 subplot(2,1,1),a=plot(d1(:,1),d1(:,8),'r') ; hold on subplot ( 2 , 1 , 1 ), b = plot ( d1 (:, 1 ), d1 (:, 14 ), 'g' ); hold on subplot ( 2 , 1 , 1 ), c = plot ( d1 (:, 1 ), d1 (:, 22 ), 'b' ); title ( 'Lateral displacement wrt base' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); legend ([ a , b , c ], '8m depth' , '4m depth' , 'Surface' , 2 ) set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'Disp' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); close 3 ; figure ( 3 ); %node acceleration subplot ( 3 , 1 , 1 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 22 ), 'r' ); legend ( a , 'at surface' , 4 ); title ( 'Lateral acceleration' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); subplot ( 3 , 1 , 2 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 14 ), 'r' ); legend ( a , '4 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); subplot ( 3 , 1 , 3 ), a = plot ( a1 (:, 1 ), s1 + a1 (:, 8 ), 'r' ); legend ( a , '8 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'Acc' , 'jpg' ); </ p > < p > figure ( 4 ); close 4 ; figure ( 4 ); %integration point 1 excess pore water pressure subplot(3,1,1),a=plot(p10(:,1),-p10(:,2),'r') ; legend ( a , '1 m depth' , 4 ); title ( 'Excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); subplot ( 3 , 1 , 2 ), a = plot ( p6 (:, 1 ), - p6 (:, 2 ), 'r' ); legend ( a , '5 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); subplot ( 3 , 1 , 3 ), a = plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); legend ( a , '10 m depth' , 4 ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); Displacement Output File PD_Ex21Disp.jpg Stress-Strain Output File (2 m depth) PD_Ex21SS_PQ2m.jpg Stress-Strain Output File (6 m depth) PD_Ex21SS_PQ6m.jpg Stress-Strain Output File (10 m depth) PD_Ex21SS_PQ10m.jpg Excess Pore Pressure Output File PD_Ex21EPP.jpg Acceleration Output File PD_Ex21Accel.jpg Return to:","title":"PressureDependMultiYield-Example 14\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/525-PressureDependMultiYield-Example%202/","text":"PressureDependMultiYield-Example 2 <center> Elastic Pressure Dependent Dry Level Pushover </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # elastic pressure dependent material # plane strain, single element, # push over analysis (Applied load linearly increases with time), # SI units (m, s, KN, ton) # # 4 3 < li >------- --& gt ; F ( loads applied to node 3 ) </ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ wipe # # some user defined variables # < p > set massDen 2.000 ; # mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.4 ; #friction angle set ptangle 26.5 ; #phase transformation angle set E1 90000.0 ; #Young's modulus set poisson1 0.40 ; set G [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set press 0 ; # isotropic consolidation pressure on quad element ( s ) set loadIncr 1 ; # Static shear load set period 2 ; # Period of applied sinusoidal load set deltaT 0.01 ; # time step for analysis set numSteps 2000 ;# Number of analysis steps set gamma 0.5 ; # Newmark integration parameter set unitWeightX 0.0 ; #unit weight in X direction set unitWeightY [expr -9.81*($massDen)] ; #unit weight in Y direction</p> < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 10 0.015 1.0 nDMaterial FluidSolidPorous 1 2 2 2.2 e6 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static </ p > # analyze analyze 2 # switch the material to elastic pressure dependent updateMaterialStage - material 2 - stage 2 # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE # rezero time setTime 0.0 wipeAnalysis # create a LoadPattern with a Linear time series < p > pattern Plain 1 Linear { load 3 $loadIncr 0.0 ; #load applied in x direction } </ p > # create the Analysis < p > constraints Transformation ; # Penalty 1.0e18 1.0e18 ;# test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # create the recorder < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex9Disp.png Stress-Strain Output File PD_Ex9SS_PQ13.png Return to:","title":"PressureDependMultiYield-Example 2\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/526-PressureDependMultiYield-Example%203/","text":"PressureDependMultiYield-Example 3 Plastic Pressure Dependent Dry Level Dynamic Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # plastic pressure dependent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 7 ; # acceleration multiplier set massDen 2. ;# mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ; #phase transformation angle set E 90000.0 ;#Young's modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element ( s ) set deltaT 0.010 ; # time step for analysis set numSteps 2000 ; # Number of analysis steps set gamma 0.600 ;# Newmark integration parameter set period 1 ; # Period of applied sinusoidal load set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr $massDen * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - $massDen * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 00 0.015 1.0 </ p > # define the nodes < p > node 1 0.0 D0 0.0 D0 node 2 1.0 D0 0.0 D0 node 3 1.0 D0 1.0 D0 node 4 0.0 D0 1.0D0 </ p > # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0D0 wipeAnalysis < p > pattern UniformExcitation 1 1 - accel \"Sine 0 1000 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Transformation ; test NormDispIncr 1 .D-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0. , 0.2 , 4 , 6 ]; accMul = 7 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 40 * pi ); s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex10Disp.png Stress-Strain Output File PD_Ex10SS_PQ13.png Acceleration Output File PD_Ex10Accel.png Return to:","title":"PressureDependMultiYield-Example 3\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/527-PressureDependMultiYield-Example%204/","text":"PressureDependMultiYield-Example 4 Plastic Pressure Dependent Dry Inclined Dynamic Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # plastic pressure dependent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 7 ; # acceleration multiplier set massDen 2. ;# mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ; #phase transformation angle set E 90000.0 ;#shear modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element ( s ) set deltaT 0.010 ; # time step for analysis set numSteps 2000 ; # Number of analysis steps set gamma 0.500 ;# Newmark integration parameter set period 1 ; # Period of applied sinusoidal load set pi 3.1415926535 ; set inclination 4 ; set unitWeightX [expr $massDen * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - $massDen * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 00 0.015 1.0 </ p > # define the nodes < p > node 1 0.0 D0 0.0 D0 node 2 1.0 D0 0.0 D0 node 3 1.0 D0 1.0 D0 node 4 0.0 D0 1.0D0 </ p > # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0D0 wipeAnalysis < p > pattern UniformExcitation 1 1 - accel \"Sine 0 1000 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Transformation ; test NormDispIncr 1 .D-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 7 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 40 * pi ); s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex11Disp.png Stress-Strain Output File PD_Ex11SS_PQ13.png Acceleration Output File PD_Ex11Accel.png Return to:","title":"PressureDependMultiYield-Example 4\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/528-PressureDependMultiYield-Example%205/","text":"PressureDependMultiYield-Example 5 <center> Plastic Pressure Dependent Dry Level Pushover </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # plastic pressure dependent material # plane strain, single element, monotonic pushover. # SI units (m, s, KN, ton) # # 4 3 < li >------- --& gt ; F ( loads applied to node 3 ) </ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ wipe # # some user defined variables # < p > set massDen 2 . ; # mass density set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ; #phase transformation angle set E 90000.0 ; #Young's modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element ( s ) set deltaT 0.010 ; # time step for analysis set numSteps 500 ; # Number of analysis steps set gamma 0.500 ; # Newmark integration parameter set period 1 ;# Period of applied sinusoidal load set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr $massDen * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - $massDen * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction set loadIncr 1 ; # Static shear load bias</p> < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 00 0.015 1.0 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 equalDOF 3 4 1 2 ; #tie nodes 3 and 4 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0 wipeAnalysis # create a LoadPattern with a Linear time series < p > pattern Plain 1 Linear { load 3 $loadIncr 0.0 ; #load applied in x direction } </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # create the Analysis < p > constraints Transformation ; # Penalty 1.0e18 1.0e18 ;# test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex12Disp.png Stress-Strain Output File PD_Ex12SS_PQ13.png Return to:","title":"PressureDependMultiYield-Example 5\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/529-PressureDependMultiYield-Example%206/","text":"PressureDependMultiYield-Example 6 <center> Dry single BbarBrick element with pressure dependent material </center> Input File # dry single BbarBrick element with pressure dependent material. # subjected to 1D sinusoidal base shaking < p > wipe set friction 31.40 ; #friction angle set phaseTransform 26.50 ; #phase transformation angle set E1 93178.4 ; #Young's modulus set poisson1 0.40 ; set G1 [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B1 [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set gamma 0.600 ; # Newmark integration parameter</p> set dt 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 1600 ; # number of time steps set rhoS 2.00 ; # saturated mass density set rhoF 0.00 ; # fluid mass density set densityMult 1 . ; # density multiplier < p > set Bfluid 2.2 e6 ; # fluid shear modulus set fluid1 1 ;# fluid material tag set solid1 10 ; # solid material tag</p> < p > set accMul 4 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 0 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.001 ; </ p > < p > set bUnitWeightX [expr ( $rhoS-0.0 ) * 9.81 * sin ( $inclination / 180.0 * $pi ) * $densityMult ] ; # Total unit weight in X direction set bUnitWeightY 0.0 ; # buoyant unit weight in Y direction set bUnitWeightZ [expr - ( $rhoS-$rhoF ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in Z direction </ p > set ndm 3 ; # space dimension model BasicBuilder - ndm $ndm - ndf $ndm < p > nDMaterial PressureDependMultiYield $solid1 $ndm [expr $rhoS * $densityMult ] $G1 $B1 $friction 0.1 80 0.5 \\ $phaseTransform 0.17 0.4 10 10 0.015 1.0 ; # 27 0.6 0 0 0 101 0.630510273</p> node 1 0.00000 0.0000 0.00000 node 2 0.00000 0.0000 1.00000 node 3 0.00000 1.0000 0.00000 node 4 0.00000 1.0000 1.00000 node 5 1.00000 0.0000 0.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 0.00000 node 8 1.00000 1.0000 1.00000 element bbarBrick 1 1 5 7 3 2 6 8 4 $solid1 $bUnitWeightX $bUnitWeightY $bUnitWeightZ updateMaterialStage - material $solid1 - stage 0 fix 1 1 1 1 0 0 0 fix 2 0 1 0 0 0 0 fix 3 1 1 1 0 0 0 fix 4 0 1 0 0 0 0 fix 5 1 1 1 0 0 0 fix 6 0 1 0 0 0 0 fix 7 1 1 1 0 0 0 fix 8 0 1 0 0 0 0 </ p > # equalDOF # tied nodes around equalDOF 2 4 1 3 equalDOF 2 6 1 3 equalDOF 2 8 1 3 set nodeList {} for {set i 1 } { $i & lt ; = 8 } { incr i 1 } { lappend nodeList $i } set elementList {} for {set i 1 } { $i & lt ; = 1 } { incr i 1 } { lappend elementList $i } # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > system ProfileSPD test NormDispIncr 1 .D-10 25 2 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static analyze 2 # switch the material to plastic < p > updateMaterialStage - material $solid1 - stage 1 updateMaterials -material $solid1 bulkModulus [expr $G1 * 2 / 3 . ]; </ p > analyze 2 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > < li >< ol > < li > create recorders ############################## </ li > </ ol ></ li > < p > eval \"recorder Node -file allNodesDisp.out -time -node $nodeList -dof 1 2 3 -dT 0.01 disp\" eval \"recorder Node -file allNodesAcce.out -time -node $nodeList -dof 1 2 3 -dT 0.01 accel\" eval \"recorder Element -ele $elementList -time -file stress1.out -dT 0.01 material 1 stress\" eval \"recorder Element -ele $elementList -time -file strain1.out -dT 0.01 material 1 strain\" eval \"recorder Element -ele $elementList -time -file stress5.out -dT 0.01 material 5 stress\" eval \"recorder Element -ele $elementList -time -file strain5.out -dT 0.01 material 5 strain\" eval \"recorder Element -ele $elementList -file backbone.out -dT 1000 material 1 backbone 80 100 200 300\" </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-10 25 0 ; # can't combine with constraints Lagrange</p> < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm ModifiedNewton ; # tengent is updated at the begining of each time step not each iteration system ProfileSPD ; # Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient</p> < li >< ol > < li > perform the Analysis and record time used ############# </ li > </ ol ></ li > < p > set startT [ clock seconds ] analyze $numSteps $dt [expr $dt / 64 ] $dt 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'allNodesAcce.out' ); d1 = load ( 'allNodesDisp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress5.out' ); e5 = load ( 'strain5.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 4 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 + 6.0 * s1 ( i , 6 ) ^ 2 + 6.0 * s1 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,7),s1(:,7),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 5 p-q po =( s5 (:, 2 ) + s5 (:, 3 ) + s5 (:, 4 )) / 3 ; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 + 6.0 * s5 ( i , 6 ) ^ 2 + 6.0 * s5 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 4 ); clf ; %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'Integration point 5 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 5 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 5 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); figure ( 3 ); clf ; %node 3 acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex13Disp.png Stress-Strain Output File PD_Ex13SS_PQ13.png Acceleration Output File PD_Ex13Accel.png Return to:","title":"PressureDependMultiYield-Example 6\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/530-PressureDependMultiYield-Example%207/","text":"PressureDependMultiYield-Example 7 <center> Inclined (4 degrees), dry single BbarBrick element with pressure dependent material </center> Input File < li > Inclined ( 4 degrees ) dry single BbarBrick element with pressure dependent material. </ li > # subjected to 1D sinusoidal base shaking < p > wipe set friction 31.40 ; #friction angle set phaseTransform 26.50 ; #phase transformation angle set E1 93178.4 ;#Young's modulus set poisson1 0.40 ; set G1 [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B1 [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set gamma 0.600 ; # Newmark integration parameter </ p > < p > set dt 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 1600 ; # number of time steps set rhoS 2.00 ;# saturated mass density set rhoF 0.00 ; # fluid mass density set densityMult 1 . ; # density multiplier</p> < p > set Bfluid 2.2 e6 ; # fluid shear modulus set fluid1 1 ;# fluid material tag set solid1 10 ; # solid material tag</p> < p > set accMul 7 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 4 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.001 ; </ p > < p > set bUnitWeightX [expr ( $rhoS-$rhoF ) * 9.81 * sin ( $inclination / 180.0 * $pi ) * $densityMult ] ; # buoyant unit weight in X direction set bUnitWeightY 0.0 ; # buoyant unit weight in Y direction set bUnitWeightZ [expr - ( $rhoS-$rhoF ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in Z direction </ p > set ndm 3 ; # space dimension model BasicBuilder - ndm $ndm - ndf $ndm < p > nDMaterial PressureDependMultiYield $solid1 $ndm [expr $rhoS * $densityMult ] $G1 $B1 $friction 0.1 80 0.5 \\ $phaseTransform 0.17 0.4 10 10 0.015 1.0 ; # 27 0.6 0 0 0 101 0.630510273</p> < p > node 1 0.00000 0.0000 0.00000 node 2 0.00000 0.0000 1.00000 node 3 0.00000 1.0000 0.00000 node 4 0.00000 1.0000 1.00000 node 5 1.00000 0.0000 0.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 0.00000 node 8 1.00000 1.0000 1.00000 < p > element bbarBrick 1 1 5 7 3 2 6 8 4 $solid1 $bUnitWeightX $bUnitWeightY $bUnitWeightZ </ p > updateMaterialStage - material $solid1 - stage 0 < p > fix 1 1 1 1 0 0 0 fix 2 0 1 0 0 0 0 fix 3 1 1 1 0 0 0 fix 4 0 1 0 0 0 0 fix 5 1 1 1 0 0 0 fix 6 0 1 0 0 0 0 fix 7 1 1 1 0 0 0 fix 8 0 1 0 0 0 0 </ p > # equalDOF # tied nodes around equalDOF 2 4 1 3 equalDOF 2 6 1 3 equalDOF 2 8 1 3 < p > set nodeList {} for {set i 1 } { $i & lt ; = 8 } { incr i 1 } { lappend nodeList $i } </ p > < p > set elementList {} for {set i 1 } { $i & lt ; = 1 } { incr i 1 } { lappend elementList $i } </ p > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-10 25 2 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static analyze 2 </ p > # switch the material to plastic < p > updateMaterialStage - material $solid1 - stage 1 updateMaterials -material $solid1 bulkModulus [expr $G1 * 2 / 3 . ]; </ p > analyze 2 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > < li >< ol > < li > create recorders ############################## </ li > </ ol ></ li > < p > eval \"recorder Node -file allNodesDisp.out -time -node $nodeList -dof 1 2 3 -dT 0.01 disp\" eval \"recorder Node -file allNodesAcce.out -time -node $nodeList -dof 1 2 3 -dT 0.01 accel\" eval \"recorder Element -ele $elementList -time -file stress1.out -dT 0.01 material 1 stress\" eval \"recorder Element -ele $elementList -time -file strain1.out -dT 0.01 material 1 strain\" eval \"recorder Element -ele $elementList -time -file stress5.out -dT 0.01 material 5 stress\" eval \"recorder Element -ele $elementList -time -file strain5.out -dT 0.01 material 5 strain\" eval \"recorder Element -ele $elementList -file backbone.out -dT 1000 material 1 backbone 80 100 200 300\" </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0. integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-10 25 0 ; # can't combine with constraints Lagrange</p> < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm ModifiedNewton ; # tengent is updated at the begining of each time step not each iteration system ProfileSPD ; # Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient</p> < li >< ol > < li > perform the Analysis and record time used ############# </ li > </ ol ></ li > < p > set startT [ clock seconds ] analyze $numSteps $dt [expr $dt / 64 ] $dt 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'allNodesAcce.out' ); d1 = load ( 'allNodesDisp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress5.out' ); e5 = load ( 'strain5.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 7 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 + 6.0 * s1 ( i , 6 ) ^ 2 + 6.0 * s1 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,7),s1(:,7),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 + 6.0 * s5 ( i , 6 ) ^ 2 + 6.0 * s5 ( i , 7 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 5 stress-strain subplot(2,1,1), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'Integration point 5 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 5 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 5 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > Displacement Output File PD_Ex14Disp.png Stress-Strain Output File PD_Ex14SS_PQ13.png Acceleration Output File PD_Ex14Accel.png Return to:","title":"PressureDependMultiYield-Example 7\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/531-PressureDependMultiYield-Example%208/","text":"PressureDependMultiYield-Example 8 <center> Plastic Pressure Dependent Wet Level Dynamic </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # plastic pressure dependent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 2 ; # acceleration multiplier set massDen 2.0 ;# solid mass density set fluidDen 1.0 ; # fluid mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ;#phase transformation angle set E 90000.0 ; #shear modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element(s) set deltaT 0.010 ; # time step for analysis set numSteps 2000 ;# Number of analysis steps set gamma 0.600 ; # Newmark integration parameter set period 1 ; # Period of applied sinusoidal load set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr ( $massDen-$fluidDen ) * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - ( $massDen-$fluidDen ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 10 0.015 1.0 nDMaterial FluidSolidPorous 1 2 2 2.2 D + 6 </ p > # define the nodes < p > node 1 0.0 D0 0.0 D0 node 2 1.0 D0 0.0 D0 node 3 1.0 D0 1.0 D0 node 4 0.0 D0 1.0D0 </ p > # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 1 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .D-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 1 - stage 1 updateMaterialStage -material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0D0 wipeAnalysis < p > pattern UniformExcitation 1 1 - accel \"Sine 0 1000 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Transformation ; test NormDispIncr 1 .D-6 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain recorder Element - ele 1 - time - file press1.out - dT 0.01 material 1 pressure recorder Element - ele 1 - time -file press3.out - dT 0.01 material 3 pressure </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > < p > wipe # flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); p1 = load ( 'press1.out' ); p3 = load ( 'press3.out' ); </ p > < p > fs =[ 0. , 0.2 , 4 , 6 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ) * 100 , 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (cm)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 40 * pi ); s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); </ p > < p > figure ( 5 ); clf ; %integration point 1 excess pore water pressure subplot ( 2 , 1 , 1 ), plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); title ( 'Integration point 1 excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( p1 (:, 1 ), p1 (:, 3 ), 'r' ); title ( 'Integration point 1 excess pore pressure ratio' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure ratio' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); Displacement Output File PD_Ex15Disp.png Stress-Strain Output File PD_Ex15SS_PQ13.png Excess Pore Pressure Output File PD_Ex15EPP.png Acceleration Output File PD_Ex15Accel.png Return to:","title":"PressureDependMultiYield-Example 8\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield/532-PressureDependMultiYield-Example%209/","text":"PressureDependMultiYield-Example 9 <center> Plastic Pressure Dependent Wet Level Pushover </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # < li > plane strain, single element, # push over analysis ( Applied load linearly increases with time ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >------- --& gt ; F ( loads applied to node 3 ) </ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ wipe # # some user defined variables # < p > set massDen 2.00 ; # solid mass density set fluidDen 1.0 ;# fluid mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set fangle 31.40 ; #friction angle set ptangle 26.50 ; #phase transformation angle set E 90000.0 ;#shear modulus set poisson 0.40 ; set G [expr $E / ( 2 * ( 1 + $poisson ))] ; set B [expr $E / ( 3 * ( 1-2 * $poisson ))] ; set press 0.0 ; # isotropic consolidation pressure on quad element ( s ) set deltaT 0.010 ; # time step for analysis set numSteps 2000 ; # Number of analysis steps set gamma 0.500 ;# Newmark integration parameter set period 1 ; # Period of applied sinusoidal load </ p > < p > set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr ( $massDen-$fluidDen ) * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # unit weight in X direction set unitWeightY [expr - ( $massDen-$fluidDen ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # unit weight in Y direction </ p > set loadIncr 1 ; # Static shear load < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureDependMultiYield 2 2 $massDen $G $B $fangle .1 80 0.5 \\ $ptangle 0.17 0.4 10 00 0.015 1.0 nDMaterial FluidSolidPorous 1 2 2 2.2 e6 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 1 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 equalDOF 3 4 1 2 ; #tie nodes 3 and 4 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 # switch the material to plastic < p > updateMaterialStage - material 1 - stage 1 updateMaterialStage -material 2 - stage 1 updateMaterials - material 2 bulkModulus [expr $G * 2 / 3 . ]; </ p > # analyze analyze 1 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 # loadConst -time 0.0 wipeAnalysis # create a LoadPattern with a Linear time series < p > pattern Plain 1 Linear { load 3 $loadIncr 0.0 ; #load applied in x direction } </ p > < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain recorder Element - ele 1 - time - file press1.out - dT 0.01 material 1 pressure recorder Element - ele 1 - time -file press3.out - dT 0.01 material 3 pressure </ p > # create the Analysis < p > constraints Transformation ; # Penalty 1.0e18 1.0e18 ;# test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); p1 = load ( 'press1.out' ); p3 = load ( 'press3.out' ); </ p > < p > fs =[ 0. , 0.2 , 4 , 6 ]; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ) * 100 , 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (cm)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > figure ( 5 ); clf ; %integration point 1 excess pore water pressure subplot ( 2 , 1 , 1 ), plot ( p1 (:, 1 ), - p1 (:, 2 ), 'r' ); title ( 'Integration point 1 excess pore pressure' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( p1 (:, 1 ), p1 (:, 3 ), 'r' ); title ( 'Integration point 1 excess pore pressure ratio' ); xLabel ( 'Time (s)' ); yLabel ( 'Excess pore pressure ratio' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'EPWP' , 'jpg' ); Displacement Output File PD_Ex16Disp.png Stress-Strain Output File (Integration Point 1) PD_Ex16SS_PQ13.png Excess Pore Pressure Output File PD_Ex16EPP.png Return to:","title":"PressureDependMultiYield-Example 9\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield02/","text":"PressureDependMultiYield02 PressureDependMultiYield02 material is modified from PressureDependMultiYield material, with: additional parameters ($contrac3 and \\(dilat3) to account for K&amp;sigma; effect,</li> <li>a parameter to account for the influence of previous dilation history on subsequent contraction phase (\\) contrac2), and modified logic related to permanent shear strain accumulation ($liquefac1 and $liquefac2). nDMaterial PressureDependMultiYield02 $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $contrac1 $contrac3 $dilat1 \\(dilat3 &lt;\\) noYieldSurf=20 <$r1 $Gs1 \u2026> $contrac2=5. $dilat2=3. $liquefac1=1. $liquefac2=0. $e=0.6 $cs1=0.9 $cs2=0.02 $cs3=0.7 \\(pa=101 &lt;\\) c=0.1>> contrac3 A non-negative constant reflecting K&sigma; effect. dilat3 A non-negative constant reflecting K&sigma; effect. contrac2 A non-negative constant reflecting dilation history on contraction tendency. liquefac1 Damage parameter to define accumulated permanent shear strain as a function of dilation history. (Redefined and different from PressureDependMultiYield material). liquefac2 Damage parameter to define biased accumulation of permanent shear strain as a function of load reversal history. (Redefined and different from PressureDependMultiYield material). c Numerical constant (default value = 0.1 kPa) Others See PressureDependMultiYield material above. NOTE: The following values are suggested for the model parameters. Dr=30% Dr=40% Dr=50% Dr=60% Dr=75% rho 1.7 ton/m<sup>3</sup> or 1.59x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.8 ton/m<sup>3</sup> or 1.685x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.9 ton/m<sup>3</sup> or 1.778x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.0 ton/m<sup>3</sup> or 1.872x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.1 ton/m<sup>3</sup> or 1.965x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> refShearModul (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 6x10<sup>4</sup> kPa or 8.702x10<sup>3</sup> psi 9x10<sup>4</sup> kPa or 1.305x10<sup>4</sup> psi 10x10<sup>4</sup> kPa or 1.45x10<sup>4</sup> psi 11x10<sup>4</sup> kPa or 1.595x10<sup>4</sup> psi 13x10<sup>4</sup> kPa or 1.885x10<sup>4</sup> psi refBulkModu (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 16x10<sup>4</sup> kPa or 2.321x10<sup>4</sup> psi (K<sub>o</sub>=0.5) 22x10<sup>4</sup> kPa or 3.191x10<sup>4</sup> psi (K<sub>o</sub>=0.47) 23.3x10<sup>4</sup> kPa or 3.379x10<sup>4</sup> psi (K<sub>o</sub>=0.45) 24x10<sup>4</sup> kPa or 3.481x10<sup>4</sup> psi (K<sub>o</sub>=0.43) 26x10<sup>4</sup> kPa or 3.771x10<sup>4</sup> psi (K<sub>o</sub>=0.4) frictionAng 31 32 33.5 35 36.5 PTAng 31 26 25.5 26 26 peakShearStra (at p\u2019<sub>r</sub>=101 kPa or 14.65 psi) <center>0.1</center> refPress (p\u2019<sub>r</sub>,) <center>101 kPa or 14.65 psi</center> pressDependCoe <center>0.5</center> Contrac1 0.087 0.067 0.045 0.028 0.013 Contrac3 0.18 0.23 0.15 0.05 0.0 dilat1 0. 0.06 0.06 0.1 0.3 dilat3 0.0 0.27 0.15 0.05 0.0 e 0.85 0.77 0.7 0.65 0.55 Pressure Dependent MultiYield02 Material Examples: <table border=1 width=800> <tr> <td> Example 1 </td> <td>Single 2D 9-4 noded element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> <tr> <td> Example 2 </td> <td>Single 3D brick element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> <tr> <td> Example 3 </td> <td>Single 3D 20-8 noded element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> </table> Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield02\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield02/534-PressureDependMultiYield02-Example%201/","text":"PressureDependMultiYield02-Example 1 <center> Solid-fluid fully coupled (u-p) plane-strain 9-4 noded element: saturated soil element with pressure dependent material, subjected to 1D sinusoidal base shaking </center> Input File # Written by Jinchi Lu and Zhaohui Yang (May 2004) wipe set matOpt 1 ; # 1 = pressure depend; # 2 = pressure independ; set fmass 1 ; # fluid mass density set smass 2.0 ; # saturated soil mass density set G 9.0 e4 set B 2.2 e5 set bulk 2.2 e6 ; #fluid-solid combined bulk modulus set vperm 5 .e-6 ; #vertical permeability (m/s) set hperm [expr $vperm ] ; #horizontal permeability (m/s)</p> < p > set accGravity 9.81 ; #acceleration of gravity set vperm [expr $vperm/$accGravity/$fmass] ;#actual value used in computation set hperm [expr $hperm/$accGravity/$fmass] ;#actual value used in computation set loadBias 0.0 ; # Static shear load, in percentage</p> < dl > < dt > # of gravity load ( = sin ( inclination angle )) </ dt > </ dl > < p > set accMul 2 . ; # acc. multiplier set period 1.0 ;# Period for applied Sine wave set deltaT 0.01 ; # time step for analysis set numSteps 2500 ;# number of time steps set gamma 0.6 ; # Newmark integration parameter</p> < p > set massProportionalDamping 0 . ; set InitStiffnessProportionalDamping 0.002 ; </ p > < li >< ol > # </ ol ></ li > # BUILD MODEL # create the ModelBuilder model basic - ndm 2 - ndf 3 node 1 0 0 node 2 2.5 0 node 3 2.5 2 node 4 0 2 fix 1 1 1 0 fix 2 1 1 0 fix 3 0 0 1 fix 4 0 0 1 equalDOF 3 4 1 2 model basic - ndm 2 - ndf 2 node 5 1.25 0 . node 6 2.5 1 node 7 1.25 2 node 8 0 1 node 9 1.25 1 fix 5 1 1 equalDOF 3 7 1 2 equalDOF 6 8 1 2 equalDOF 6 9 1 2 set gravY [expr - $accGravity ] ; #calc. gravity set gravX [expr - $gravY * $loadBias ] # define material and properties switch $matOpt { 1 { nDMaterial PressureDependMultiYield02 1 2 1.8 $G $B 32 .1 80 0.5 \\ 26. 0.067 0.23 0.06 0.27 } 2 { nDMaterial PressureIndependMultiYield 2 2 1.8 4 .e4 2 .e5 40 .1 } } < li > ele # thick maTag bulk mDensity perm1 perm2 gravity </ li > element 9 _4_QuadUP 1 1 2 3 4 5 6 7 8 9 1.0 1 $bulk $fmass $hperm $vperm $gravX $gravY # set material to elastic for gravity loading updateMaterialStage - material $matOpt - stage 0 # recorder for nodal variables along the vertical center line. set SnodeList {} for {set i 0 } { $i & lt ; 9 } { incr i 1 } { lappend SnodeList [expr $i + 1 ] } set FnodeList {} for {set i 0 } { $i & lt ; 4 } { incr i 1 } { lappend FnodeList [expr $i + 1 ] } # # GRAVITY APPLICATION (elastic behavior) # #create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer numberer RCM system ProfileSPD test NormDispIncr 1.0 e-8 30 0 algorithm KrylovNewton constraints Penalty 1 .e18 1 .e18 set nw 1.5 set nw2 [expr pow ( $nw + 0.5 , 2 ) / 4 ] integrator Newmark $nw $nw2 analysis Transient analyze 10 5 e3 updateMaterialStage - material $matOpt - stage 1 analyze 100 1 .e0 # rezero time wipeAnalysis setTime 0.0 # # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # base input motion pattern UniformExcitation 1 1 - accel \"Sine 0. 10. $period -factor $accMul\" eval \"recorder Node -file disp -time -node $SnodeList -dof 1 2 -dT $deltaT disp\" eval \"recorder Node -file pwp -time -node $FnodeList -dof 3 -dT $deltaT vel\" eval \"recorder Node -file acc -time -node $SnodeList -dof 1 2 -dT $deltaT accel\" recorder Element - ele 1 - time - file stress1 - dT $deltaT material 1 stress recorder Element - ele 1 - time - file strain1 - dT $deltaT material 1 strain recorder Element - ele 1 - time - file stress5 - dT $deltaT material 5 stress recorder Element - ele 1 - time - file strain5 - dT $deltaT material 5 strain recorder Element - ele 1 - time - file stress9 - dT $deltaT material 9 stress recorder Element - ele 1 - time - file strain9 - dT $deltaT material 9 strain constraints Penalty 1 .e18 1 .e18 test NormDispIncr 1 .e-4 25 0 numberer RCM algorithm KrylovNewton system ProfileSPD integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0.0 analysis VariableTransient < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > < p > wipe # flush ouput stream MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acc' ); d1 = load ( 'disp' ); p1 = load ( 'pwp' ); s1 = load ( 'stress1' ); e1 = load ( 'strain1' ); s5 = load ( 'stress5' ); e5 = load ( 'strain5' ); s9 = load ( 'stress9' ); e9 = load ( 'strain9' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; fs2 =[ 0.5 , 0.2 , 4 , 3 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 1 ); close 1 ; figure ( 1 ); %integration point 1 stress-strain subplot ( 2 , 1 , 1 ), plot ( e1 (:, 4 ), s1 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at integration point 1' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 1' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 5 ); close 5 ; figure ( 5 ); %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at integration point 5' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 5' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p5' , 'jpg' ); </ p > < p > %integration point 9 p-q po=(s9(:,2)+s9(:,3)+s9(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s9 ( i , 2 ) - s9 ( i , 3 )) ^ 2 + ( s9 ( i , 3 ) - s9 ( i , 4 )) ^ 2 + ( s9 ( i , 2 ) - s9 ( i , 4 )) ^ 2 + 6.0 * s9 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s9 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 6 ); close 6 ; figure ( 6 ); %integration point 9 stress-strain subplot ( 2 , 1 , 1 ), plot ( e9 (:, 4 ), s9 (:, 5 ), 'r' ); title ( 'shear stress \\tau_x_y VS. shear strain \\epsilon_x_y at integration point 9' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 9' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p9' , 'jpg' ); </ p > < p > figure ( 2 ); close 2 ; figure ( 2 ); %node 3 displacement relative to node 1 plot(d1(:,1),d1(:,6)) ; title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Disp' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 3000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 40 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); close 3 ; figure ( 3 ); %node acceleration a = plot ( a1 (:, 1 ), s1 + a1 (:, 6 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Acc' , 'jpg' ); </ p > < p > figure ( 4 ); close 4 ; figure ( 4 ); a = plot ( p1 (:, 1 ), p1 (:, 2 )); title ( 'Pore pressure at base' ); xLabel ( 'Time (s)' ); yLabel ( 'Pore pressure (kPa)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD02_Ex23Disp.jpg Stress-Strain Output File (integration point 1) PD02_Ex23SS_PQ1.jpg Stress-Strain Output File (integration point 5) PD02_Ex23SS_PQ5.jpg Stress-Strain Output File (integration point 9) PD02_Ex23SS_PQ9.jpg Excess Pore Pressure Output File PD02_Ex23EPP.jpg Acceleration Output File PD02_Ex23Accel.jpg Return to:","title":"PressureDependMultiYield02-Example 1\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield02/535-PressureDependMultiYield02-Example%202/","text":"PressureDependMultiYield02-Example 2 <center> Solid-fluid fully coupled (u-p) 8-node brick element: saturated soil element with pressure dependent material, subjected to 1D sinusoidal base shaking </center> Input File # single BrickUP element with pressure dependent material. # subjected to 1D sinusoidal base shaking # Written by Jinchi Lu and Zhaohui Yang (May 2004) < p > wipe set friction 31 . ; #friction angle set phaseTransform 26. ;#phase transformation angle set G1 9 .e4 ; set B1 22 .e4 ; set gamma 0.600 ; # Newmark integration parameter </ p > < p > set dt 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 2500 ; # number of time steps set rhoS 1.80 ;# saturated mass density set rhoF 1.00 ; # fluid mass density</p> < p > set Bfluid 2.2 e6 ; # fluid shear modulus set perm 1.e-5 ;#permeability ( m / s ) set accGravity 9.81 ; #acceleration of gravity set perm [expr $perm/$accGravity/$rhoF] ;# actual value used in computation set matTag 1 ; # material tag</p> < p > set accMul 1 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 0 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.002 ; </ p > < p > set gravityX [expr $accGravity * sin ( $inclination / 180.0 * $pi )] ; # gravity acceleration in X direction set gravityY 0.0 ; # gravity acceleration in Y direction set gravityZ [expr - $accGravity * cos ( $inclination / 180.0 * $pi )] ; # gravity acceleration in Z direction </ p > set ndm 3 ; # space dimension model BasicBuilder - ndm $ndm - ndf 4 < p > nDMaterial PressureDependMultiYield02 $matTag $ndm $rhoS $G1 $B1 $friction 0.1 80 0.5 \\ $phaseTransform 0.067 0.23 0.06 0.27 </ p > < p > node 1 0.00000 0.0000 0.00000 node 2 0.00000 0.0000 1.00000 node 3 0.00000 1.0000 0.00000 node 4 0.00000 1.0000 1.00000 node 5 1.00000 0.0000 0.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 0.00000 node 8 1.00000 1.0000 1.00000 < p > element brickUP 1 1 5 7 3 2 6 8 4 $matTag $Bfluid $rhoF $perm $perm $perm $gravityX $gravityY $gravityZ </ p > updateMaterialStage - material $matTag - stage 0 < p > fix 1 1 1 1 0 fix 2 0 1 0 1 fix 3 1 1 1 0 fix 4 0 1 0 1 fix 5 1 1 1 0 fix 6 0 1 0 1 fix 7 1 1 1 0 fix 8 0 1 0 1 </ p > # equalDOF # tied nodes around equalDOF 2 4 1 3 equalDOF 2 6 1 3 equalDOF 2 8 1 3 < p > set nodeList {} for {set i 1 } { $i & lt ; = 8 } { incr i 1 } { lappend nodeList $i } </ p > < p > set elementList {} for {set i 1 } { $i & lt ; = 1 } { incr i 1 } { lappend elementList $i } </ p > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > numberer Plain system ProfileSPD test NormDispIncr 1.0 e-8 20 1 algorithm KrylovNewton constraints Penalty 1 .e18 1 .e18 set nw 1.5 integrator Newmark $nw [expr pow ( $nw + 0.5 , 2 ) / 4 ] analysis Transient </ p > analyze 10 5 .e0 # switch the material to plastic updateMaterialStage - material $matTag - stage 1 analyze 10 5 .e1 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > # # create recorders ############################## # < p > eval \"recorder Node -file disp -time -node $nodeList -dof 1 2 3 -dT 0.01 disp\" eval \"recorder Node -file acc -time -node $nodeList -dof 1 2 3 -dT 0.01 accel\" eval \"recorder Node -file pwp -time -node $nodeList -dof 4 -dT 0.01 vel\" eval \"recorder Element -ele $elementList -time -file stress1 -dT 0.01 material 1 stress\" eval \"recorder Element -ele $elementList -time -file strain1 -dT 0.01 material 1 strain\" eval \"recorder Element -ele $elementList -time -file stress3 -dT 0.01 material 3 stress\" eval \"recorder Element -ele $elementList -time -file strain3 -dT 0.01 material 3 strain\" eval \"recorder Element -ele $elementList -time -file stress5 -dT 0.01 material 5 stress\" eval \"recorder Element -ele $elementList -time -file strain5 -dT 0.01 material 5 strain\" </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0.0 constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-3 25 0 ; # can't combine with constraints Lagrange </ p > < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm KrylovNewton ; # system ProfileSPD ;# Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient </ p > # # perform the Analysis and record time used ############# # set startT [ clock seconds ] analyze $numSteps $dt [expr $dt / 64 ] $dt 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acc' ); d1 = load ( 'disp' ); p1 = load ( 'pwp' ); s1 = load ( 'stress1' ); e1 = load ( 'strain1' ); s5 = load ( 'stress3' ); e5 = load ( 'strain3' ); s9 = load ( 'stress5' ); e9 = load ( 'strain5' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; fs2 =[ 0.5 , 0.2 , 4 , 3 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * ( s1 ( i , 5 ) ^ 2 + s1 ( i , 6 ) ^ 2 + s1 ( i , 7 ) ^ 2 ) ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 1 ); close 1 ; figure ( 1 ); %integration point 1 stress-strain subplot ( 2 , 1 , 1 ), plot ( e1 (:, 7 ), s1 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 1' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 1' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * ( s5 ( i , 5 ) ^ 2 + s5 ( i , 6 ) ^ 2 + s5 ( i , 7 ) ^ 2 ); qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 5 ); close 5 ; figure ( 5 ); %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 3' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 3' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p3' , 'jpg' ); </ p > < p > %integration point 9 p-q po=(s9(:,2)+s9(:,3)+s9(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s9 ( i , 2 ) - s9 ( i , 3 )) ^ 2 + ( s9 ( i , 3 ) - s9 ( i , 4 )) ^ 2 + ( s9 ( i , 2 ) - s9 ( i , 4 )) ^ 2 + 6.0 * ( s9 ( i , 5 ) ^ 2 + s9 ( i , 6 ) ^ 2 + s9 ( i , 7 ) ^ 2 ); qo ( i )= sign ( s9 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 6 ); close 6 ; figure ( 6 ); %integration point 9 stress-strain subplot ( 2 , 1 , 1 ), plot ( e9 (:, 7 ), s9 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 5' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 5' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p5' , 'jpg' ); </ p > < p > figure ( 2 ); close 2 ; figure ( 2 ); %node 3 displacement relative to node 1 plot(d1(:,1),d1(:,5)) ; title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Disp' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 3000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 40 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); close 3 ; figure ( 3 ); %node acceleration a = plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Acc' , 'jpg' ); </ p > < p > figure ( 4 ); close 4 ; figure ( 4 ); a = plot ( p1 (:, 1 ), p1 (:, 2 )); title ( 'Pore pressure at base' ); xLabel ( 'Time (s)' ); yLabel ( 'Pore pressure (kPa)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD02_Ex24Disp.jpg Stress-Strain Output File (integration point 1) PD02_Ex24SS_PQ1.jpg Stress-Strain Output File (integration point 3) PD02_Ex24SS_PQ3.jpg Stress-Strain Output File (integration point 5) PD02_Ex24SS_PQ5.jpg Excess Pore Pressure Output File PD02_Ex24EPP.jpg Acceleration Output File PD02_Ex24Accel.jpg Return to:","title":"PressureDependMultiYield02-Example 2\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield02/536-PressureDependMultiYield02-Example%203/","text":"PressureDependMultiYield02-Example 3 <center> Solid-fluid fully coupled (u-p) 20-8 noded brick element: saturated soil element with pressure dependent material, subjected to 1D sinusoidal base shaking </center> Input File # single 20_8_BrickUP element with pressure dependent material. # subjected to 1D sinusoidal base shaking # Written by Jinchi Lu (May 2004) < p > set matOpt 1 ; # 1 = pressure depend;</p> < dl > < dt > # 2 = pressure independ ; </ dt > </ dl > wipe < p > set friction 31 . ; #friction angle set phaseTransform 26. ;#phase transformation angle set G1 9 .e4 ; set B1 22 .e4 ; set gamma 0.600 ; # Newmark integration parameter </ p > < p > set dT 0.01 ; # time step for analysis, does not have to be the same as accDt. set numSteps 2500 ; # number of time steps set rhoS 1.80 ;# saturated mass density set rhoF 1.00 ; # fluid mass density</p> < p > set Bfluid 2.2 e6 ; # fluid shear modulus set fluid1 1 ;# fluid material tag set solid1 10 ; # solid material tag set perm 1.e-5 ; #permeability (m/s) set accGravity 9.81 ;#acceleration of gravity set perm [expr $perm / $accGravity / $rhoF ] ; # actual value used in computation </ p > < p > set accMul 2 ; # acceleration multiplier set pi 3.1415926535 ; set inclination 0 ; </ p > < p > set massProportionalDamping 0.0 ; set InitStiffnessProportionalDamping 0.003 ; </ p > < p > set gravityX [expr $accGravity * sin ( $inclination / 180.0 * $pi )] ; # gravity acceleration in X direction set gravityY 0.0 ; # gravity acceleration in Y direction set gravityZ [expr - $accGravity * cos ( $inclination / 180.0 * $pi )] ; # gravity acceleration in Z direction </ p > set ndm 3 ; # space dimension < p > model BasicBuilder - ndm 3 - ndf 4 node 1 0.00000 0.0000 0.00000 node 2 1.00000 0.0000 0.00000 node 3 1.00000 1.0000 0.00000 node 4 0.00000 1.0000 0.00000 node 5 0.00000 0.0000 1.00000 node 6 1.00000 0.0000 1.00000 node 7 1.00000 1.0000 1.00000 node 8 0.00000 1.0000 1.00000 < p > fix 1 1 1 1 0 fix 2 1 1 1 0 fix 3 1 1 1 0 fix 4 1 1 1 0 fix 5 0 1 0 1 fix 6 0 1 0 1 fix 7 0 1 0 1 fix 8 0 1 0 1 </ p > model BasicBuilder - ndm 3 - ndf 3 node 9 0.50000 0.0000 0.00000 node 10 1.00000 0.5000 0.00000 node 11 0.50000 1.0000 0.00000 node 12 0.00000 0.5000 0.00000 node 13 0.50000 0.0000 1.00000 node 14 1.00000 0.5000 1.00000 node 15 0.50000 1.0000 1.00000 node 16 0.00000 0.5000 1.00000 node 17 0.00000 0.0000 0.50000 node 18 1.00000 0.0000 0.50000 node 19 1.00000 1.0000 0.50000 node 20 0.00000 1.0000 0.50000 fix 9 1 1 1 fix 10 1 1 1 fix 11 1 1 1 fix 12 1 1 1 fix 13 0 1 0 fix 14 0 1 0 fix 15 0 1 0 fix 16 0 1 0 fix 17 0 1 0 fix 18 0 1 0 fix 19 0 1 0 fix 20 0 1 0 # equalDOF # tied nodes around equalDOF 5 6 1 3 equalDOF 5 7 1 3 equalDOF 5 8 1 3 equalDOF 5 13 1 3 equalDOF 5 14 1 3 equalDOF 5 15 1 3 equalDOF 5 16 1 3 equalDOF 17 18 1 3 equalDOF 17 19 1 3 equalDOF 17 20 1 3 # define material and properties < p > switch $matOpt { 1 { nDMaterial PressureDependMultiYield02 1 3 $rhoS $G1 $B1 $friction .1 80 0.5 \\ $phaseTransform 0.067 0.23 0.06 0.27 } 2 { nDMaterial PressureIndependMultiYield 2 3 1.8 4 .e4 2 .e5 40 .1 } } </ p > < p > element 20 _8_BrickUP 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $matOpt $Bfluid $rhoF $perm $perm $perm $gravityX $gravityY $gravityZ </ p > # recorder for nodal variables along the vertical center line. < p > set SnodeList {} for {set i 0 } { $i & lt ; 20 } { incr i 1 } { lappend SnodeList [expr $i + 1 ] } </ p > < p > set FnodeList {} for {set i 0 } { $i & lt ; 8 } { incr i 1 } { lappend FnodeList [expr $i + 1 ] } </ p > # GRAVITY APPLICATION (elastic behavior) < p > numberer Plain system ProfileSPD test NormDispIncr 1.0 e-8 20 1 algorithm KrylovNewton constraints Penalty 1 .e18 1 .e18 ; # set nw 1.5 set nw2 [expr pow ( $nw + 0.5 , 2 ) / 4 ] integrator Newmark $nw $nw2 analysis Transient </ p > analyze 10 5 .e3 # switch the material to plastic updateMaterialStage - material $matOpt - stage 1 analyze 10 1 .e1 < p > setTime 0.0 ; # reset time, otherwise reference time is not zero for time history analysis wipeAnalysis </ p > < p > eval \"recorder Node -file disp -time -node $SnodeList -dof 1 2 3 -dT $dT disp\" eval \"recorder Node -file pwp -time -node $FnodeList -dof 4 -dT $dT vel\" eval \"recorder Node -file acc -time -node $SnodeList -dof 1 2 3 -dT $dT accel\" recorder Element - ele 1 - time - file stress1 - dT $dT material 1 stress recorder Element - ele 1 - time - file strain1 - dT $dT material 1 strain recorder Element - ele 1 - time - file stress5 - dT $dT material 5 stress recorder Element - ele 1 - time - file strain5 - dT $dT material 5 strain recorder Element - ele 1 - time - file stress17 - dT $dT material 17 stress recorder Element - ele 1 - time - file strain17 - dT $dT material 17 strain </ p > < li >< ol > < li > create dynamic time history analysis ################## </ li > </ ol ></ li > < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 1 -factor $accMul\" </ p > < p > rayleigh $massProportionalDamping 0.0 $InitStiffnessProportionalDamping 0.0 integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] constraints Penalty 1 .e18 1 .e18 ; # can't combine with test NormUnbalance test NormDispIncr 1.0 e-3 25 0 ; # can't combine with constraints Lagrange </ p > < li > algorithm Newton ; # tengent is updated at each iteration</li> < p > algorithm KrylovNewton ; # step not each iteration system ProfileSPD ; # Use sparse solver. Next numberer is better to be Plain. numberer Plain ; # method to map between between equation numbers of DOFs analysis VariableTransient ; # splitting time step requires VariableTransient</p> < li >< ol > < li > perform the Analysis and record time used ############# </ li > </ ol ></ li > < p > set startT [ clock seconds ] analyze $numSteps $dT [expr $dT / 64 ] $dT 15 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acc' ); d1 = load ( 'disp' ); p1 = load ( 'pwp' ); s1 = load ( 'stress1' ); e1 = load ( 'strain1' ); s5 = load ( 'stress5' ); e5 = load ( 'strain5' ); s9 = load ( 'stress17' ); e9 = load ( 'strain17' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; fs2 =[ 0.5 , 0.2 , 4 , 3 ]; accMul = 2 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * ( s1 ( i , 5 ) ^ 2 + s1 ( i , 6 ) ^ 2 + s1 ( i , 7 ) ^ 2 ) ; qo ( i )= sign ( s1 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 1 ); close 1 ; figure ( 1 ); %integration point 1 stress-strain subplot ( 2 , 1 , 1 ), plot ( e1 (:, 7 ), s1 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 1' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 1' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p1' , 'jpg' ); </ p > < p > %integration point 5 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * ( s5 ( i , 5 ) ^ 2 + s5 ( i , 6 ) ^ 2 + s5 ( i , 7 ) ^ 2 ); qo ( i )= sign ( s5 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 5 ); close 5 ; figure ( 5 ); %integration point 5 stress-strain subplot ( 2 , 1 , 1 ), plot ( e5 (:, 7 ), s5 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 5' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 5' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p5' , 'jpg' ); </ p > < p > %integration point 9 p-q po=(s9(:,2)+s9(:,3)+s9(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s9 ( i , 2 ) - s9 ( i , 3 )) ^ 2 + ( s9 ( i , 3 ) - s9 ( i , 4 )) ^ 2 + ( s9 ( i , 2 ) - s9 ( i , 4 )) ^ 2 + 6.0 * ( s9 ( i , 5 ) ^ 2 + s9 ( i , 6 ) ^ 2 + s9 ( i , 7 ) ^ 2 ); qo ( i )= sign ( s9 ( i , 7 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 6 ); close 6 ; figure ( 6 ); %integration point 9 stress-strain subplot ( 2 , 1 , 1 ), plot ( e9 (:, 7 ), s9 (:, 7 ), 'r' ); title ( 'shear stress \\tau_x_z VS. shear strain \\epsilon_x_z at integration point 17' ); xLabel ( 'Shear strain \\epsilon_x_z' ); yLabel ( 'Shear stress \\tau_x_z (kPa)' ); subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'confinement p VS. deviatoric stress q at integration point 17' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ_p17' , 'jpg' ); </ p > < p > figure ( 2 ); close 2 ; figure ( 2 ); %node 3 displacement relative to node 1 plot(d1(:,1),d1(:,14)) ; title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Disp' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 3000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 40 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); close 3 ; figure ( 3 ); %node acceleration a = plot ( a1 (:, 1 ), s1 + a1 (:, 14 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'Acc' , 'jpg' ); </ p > < p > figure ( 4 ); close 4 ; figure ( 4 ); a = plot ( p1 (:, 1 ), p1 (:, 2 )); title ( 'Pore pressure at base' ); xLabel ( 'Time (s)' ); yLabel ( 'Pore pressure (kPa)' ); set ( gcf , 'paperposition' , fs2 ); saveas ( gcf , 'EPWP' , 'jpg' ); </ p > < p > Displacement Output File PD02_Ex25Disp.jpg Stress-Strain Output File (integration point 1) PD02_Ex25SS_PQ1.jpg Stress-Strain Output File (integration point 5) PD02_Ex25SS_PQ5.jpg Stress-Strain Output File (integration point 17) PD02_Ex25SS_PQ17.jpg Excess Pore Pressure Output File PD02_Ex25EPP.jpg Acceleration Output File PD02_Ex25Accel.jpg Return to:","title":"PressureDependMultiYield02-Example 3\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureDependMultiYield03/538-PressureDependMultiYield03%20Material/","text":"PressureDependMultiYield03 (The reference for PressureDependMultiYield03 material: Khosravifar, A., Elgamal, A., Lu, J., and Li, J. [2018]. \u201cA 3D model for earthquake-induced liquefaction triggering and post-liquefaction response.\u201d Soil Dynamics and Earthquake Engineering, 110, 43-52) PressureDependMultiYield03 is modified from PressureDependMultiYield02 material to comply with the established guidelines on the dependence of liquefaction triggering to the number of loading cycles, effective overburden stress (K&sigma;), and static shear stress (K&alpha;). Element drivers for single element simulations under undrained cyclic, undrained monotonic, drained cyclic and drained monotonic loading can be downloaded from here . nDMaterial PressureDependMultiYield03 $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $mType $ca $cb $cc $cd $ce $da $db \\(dc &lt;\\) noYieldSurf=20 <$r1 $Gs1 \u2026> $liquefac1=1. $liquefac2=0. \\(pa=101 &lt;\\) s0=1.73>> $ca, $cb, $cc, $cd, \\(ce</strong></p></td> <td><p>Non-negative constants defining the rate of contract or pore pressure buildup. See Tables 1 and 2 below for more information.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) da, $db, $dc A non-negative constant reflecting K&sigma; effect. contrac2 Non-negative constants defining the rate of dilation. See Tables 1 and 2 below for more information. mType 0: Triaxial Compression; 1: Triaxial Extension; 2: Direct Shear s0 Numerical constant (default value = 1.73 kPa). See Tables 1 and 2 below for more information. Others See PressureDependMultiYield02 material above and Tables 1 and 2 below. Table 1 provides the proposed calibrated input parameters for PressureDependMultiYield03 for four different relative densities. Table 2 provides a brief description for each parameter and the adopted calibration procedure. Table 1. Model Input Parameters Pdmy03_table1.png * These are not input parameters to the constitutive model, but rather parameters computed during model calibration. Table 2. Description of Calibration Parameters Pdmy03_table2.png Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield03\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureIndependMultiYield/","text":"PressureIndependMultiYield PressureIndependMultiYield material is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is insensitive to the confinement change. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. During the application of gravity load (and static loads if any), material behavior is linear elastic. In the subsequent dynamic (fast) loading phase(s), the stress-strain response is elastic-plastic (see MATERIAL STAGE UPDATE below). Plasticity is formulated based on the multi-surface (nested surfaces) concept, with an associative flow rule. The yield surfaces are of the Von Mises type. OUTPUT INTERFACE: The following information may be extracted for this material at a given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001) &reg; : \u201c stress \u201d, \u201c strain \u201d, \u201c backbone \u201d, or \u201c tangent \u201d. For 2D problems, the stress output follows this order: \u03c3 xx , \u03c3 yy , \u03c3 zz , \u03c3 xy , &eta; r , where &eta; r is the ratio between the shear (deviatoric) stress and peak shear strength at the current confinement (0<=&eta; r <=1.0). The strain output follows this order: &epsilon; xx , &epsilon; yy , &gamma; xy . For 3D problems, the stress output follows this order: \u03c3 xx , \u03c3 yy , \u03c3 zz , \u03c3 xy , \u03c3 yz , \u03c3 zx , &eta; r , and the strain output follows this order: &epsilon; xx , &epsilon; yy , &epsilon; zz , &gamma; xy , &gamma; yz , &gamma; zx . The \u201c backbone \u201d option records (secant) shear modulus reduction curves at one or more given confinements. The specific recorder command is as follows: recorder Element - ele $eleNum - file $fName - dT $deltaT material $GaussNum backbone $p1 & lt ; $p2 \u2026 > where p1, p2, \u2026 are the confinements at which modulus reduction curves are recorded. In the output file, corresponding to each given confinement there are two columns: shear strain &gamma; and secant modulus G s . The number of rows equals the number of yield surfaces. nDmaterial PressureIndependMultiYield $tag $nd $rho $refShearModul $refBulkModul $cohesi $peakShearStra < $frictionAng = 0. $refPress = 100 . $pressDependCoe = 0 . $noYieldSurf = 20 < $r1 $Gs1 \u2026 > > PreDep_ss.png tag A positive integer uniquely identifying the material among all nDMaterials. nd Number of dimensions, 2 for plane-strain, and 3 for 3D analysis. rho Saturated soil mass density. refShearModul (G r ) Reference low-strain shear modulus, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). refBulkModul (B r ) Reference bulk modulus, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). cohesi (c) Apparent cohesion at zero effective confinement. peakShearStra (&gamma; max ) An octahedral shear strain at which the maximum shear strength is reached, specified at a reference mean effective confining pressure refPress of p\u2019 r (see below). frictionAng (\u03a6) Friction angle at peak shear strength in degrees, optional (default is 0.0). refPress (p\u2019 r ) Reference mean effective confining pressure at which Gr, Br, and &gamma; max are defined, optional (default is 100. kPa). pressDependCoe ( \\(d\\) ) A positive constant defining variations of G and B as a function of instantaneous effective confinement p\u2019(default is 0.0):: PreDep_pressDepCoe.png\u200e If \u03a6=0, d is reset to 0.0. noYieldSurf Number of yield surfaces, optional (must be less than 40, default is 20). The surfaces are generated based on the hyperbolic relation defined in Note 2 below. r , Gs Instead of automatic surfaces generation (Note 2), you can define yield surfaces directly based on desired shear modulus reduction curve. To do so, add a minus sign in front of noYieldSurf, then provide noYieldSurf pairs of shear strain (&gamma;) and modulus ratio (G s ) values. For example, to define 10 surfaces: \u2026 -10&gamma; 1 G s1 \u2026 &gamma; 10 G s10 \u2026 See Note 3 below for some important notes. NOTE: The friction angle \u03a6 and cohesion c define the variation of peak (octahedral) shear strength &tau; f as a function of current effective confinement p\u2019 i : Automatic surface generation: at a constant confinement p\u2019, the shear stress &tau;(octahedral) - shear strain &gamma; (octahedral) nonlinearity is defined by a hyperbolic curve (backbone curve): where &gamma; r satisfies the following equation at p\u2019 r : (User defined surfaces) The user specified friction angle \u03a6 = 0. cohesion c will be ignored. Instead, c is defined by c=sqrt(3)*\u03c3 m /2, where \u03c3 m is the product of the last modulus and strain pair in the modulus reduction curve. Therefore, it is important to adjust the backbone curve so as to render an appropriate c. If the user specifies \u03a6 > 0, this \u03a6 will be ignored. Instead, \u03a6is defined as follows: If the resulting \u03a6 <0, we set \u03a6=0 and c=sqrt(3)*\u03c3 m /2. Also remember that improper modulus reduction curves can result in strain softening response (negative tangent shear modulus), which is not allowed in the current model formulation. Finally, note that the backbone curve varies with confinement, although the variation is small within commonly interested confinement ranges. Backbone curves at different confinements can be obtained using the OpenSees element recorder facility (see OUTPUT INTERFACE above). SUGGESTED PARAMETER VALUES For user convenience, a table is provided below as a quick reference for selecting parameter values. However, use of this table should be of great caution, and other information should be incorporated wherever possible. Parameters Soft Clay Medium Clay Stiff Clay rho 1.3 ton/m 3 or 1.217x10 -4 (lbf)(s 2 )/in 4 1.5 ton/m 3 or 1.404x10 -4 (lbf)(s 2 )/in 4 1.8 ton/m 3 or 1.685x10 -4 (lbf)(s 2 )/in 4 refShearModul 1.3x10 4 kPa or 1.885x10 3 psi 6.0x10 4 kPa or 8.702x10 4 psi 1.5x10 5 kPa or 2.176x10 4 psi refBulkModu 6.5x10 4 kPa or 9.427x10 3 psi 3.0x10 5 kPa or 4.351x10 4 psi 7.5x10 5 kPa or 1.088x10 5 psi cohesi 18 kPa or 2.611 psi 37 kPa or 5.366 psi 75 kPa or 10.878 psi peakShearStra (at p\u2019 r =80 kPa or 11.6 psi) 0.1 0.1 0.1 frictionAng 0 0 0 pressDependCoe 0 0 0 Pressure Independent Material Examples: Material in elastic state Example 1 Single 2D plane-strain quadrilateral element, subjected to sinusoidal base shaking Example 2 Single 2D quadrilateral element, subjected to monotonic pushover ( English units version ) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureIndependMultiYield\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureIndependMultiYield/541-PressureIndependentMultiYield-Example%201/","text":"Example 1 (PressureIndependentMultiYield) Elastic Pressure Independent Wet Level Dynamic Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # elastic pressure independent material < li > plane strain, single element, dynamic analysis ( input motion: sinusoidal acceleration at base ) </ li > # SI units (m, s, KN, ton) # # 4 3 < li >< hr /></ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ < li >& lt ; -- & gt ; input motion: sinusoidal acceleration at base </ li > wipe # # some user defined variables # < p > set accMul 9.81 ; set massDen 2.000 ; # solid mass density set fluidDen 1.0 ; # fluid mass density set massProportionalDamping 0.0 ; set stiffnessProportionalDamping 0.001 ; set cohesion 30 ; set peakShearStrain 0.1 ; set E1 90000.0 ; #Young's modulus set poisson1 0.40 ; set G [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set press 0 ; # isotropic consolidation pressure on quad element ( s ) set period 1 ; # Period of applied sinusoidal load set deltaT 0.01 ; # time step for analysis set numSteps 2000 ;# Number of analysis steps set gamma 0.5 ; # Newmark integration parameter set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr ( $massDen-$fluidDen ) * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in X direction set unitWeightY [expr - ( $massDen-$fluidDen ) * 9.81 * cos ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in Y direction </ p > < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureIndependMultiYield 2 2 $massDen $G $B $cohesion $peakShearStrain nDMaterial FluidSolidPorous 1 2 2 2.2 e6 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM </ p > # create the Analysis analysis Static # analyze analyze 2 < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE (plastic) # rezero time setTime 0.0 wipeAnalysis equalDOF 3 4 1 2 ; #tie nodes 3 and 4 # create a LoadPattern < p > pattern UniformExcitation 1 1 - accel \"Sine 0 10 $period -factor $accMul\" </ p > # create the Analysis < p > constraints Penalty 1.0 e18 1.0 e18 ; # Transformation; # test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh $massProportionalDamping 0.0 $stiffnessProportionalDamping 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # create the recorder < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; accMul = 9.81 ; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > s = accMul * sin ( 0 : pi / 50 : 20 * pi ); s =[ s ' ; zeros ( 1000 , 1 )]; s1 = interp1 ( 0 : 0.01 : 20 , s , a1 (:, 1 )); </ p > < p > figure ( 3 ); clf ; %node 3 relative acceleration subplot ( 2 , 1 , 1 ), plot ( a1 (:, 1 ), s1 + a1 (:, 5 ), 'r' ); title ( 'Lateral acceleration at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Acceleration (m/s^2)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'A' , 'jpg' ); Displacement Output File PInd_Ex1Disp.png Stress-Strain Output File (Integration Point 1) PInd_Ex1SSIP1.png Stress-Strain Output File (Integration Point 3) PInd_Ex1SSIP3.png Acceleration Output File PInd_Ex1Accel.png Return to:","title":"Example 1 (PressureIndependentMultiYield)\n"},{"location":"library/5_Packages/UCSD_CompGeoMech/PressureIndependMultiYield/542-PressureIndependentMultiYield-Example%202/","text":"PressureIndependentMultiYield-Example 2 <center> Elastic Pressure Independent Wet Level Pushover </center> Input File # Created by Zhaohui Yang (zhyang@ucsd.edu) # elastic pressure independent material # plane strain, single element, # push over analysis (Applied load linearly increases with time), # SI units (m, s, KN, ton) # # 4 3 < li >------- --& gt ; F ( loads applied to node 3 ) </ li > < li >| |</ li > < li >| |</ li > < li >| |</ li > # 1-------2 (nodes 1 and 2 fixed) # ^ ^ wipe # # some user defined variables # < p > set massDen 2.000 ; # solid mass density set fluidDen 1.0 ;# fluid mass density set cohesion 30 ; set peakShearStrain 0.1 ; set E1 90000.0 ; #Young's modulus set poisson1 0.40 ; set G [expr $E1 / ( 2 * ( 1 + $poisson1 ))] ; set B [expr $E1 / ( 3 * ( 1-2 * $poisson1 ))] ; set press 0 ; # isotropic consolidation pressure on quad element ( s ) set period 2 ; # Period of applied sinusoidal load set deltaT 0.01 ; # time step for analysis set numSteps 2000 ; # Number of analysis steps set gamma 0.5 ;# Newmark integration parameter set pi 3.1415926535 ; set inclination 0 ; set unitWeightX [expr ( $massDen-$fluidDen ) * 9.81 * sin ( $inclination / 180.0 * $pi )] ; # buoyant unit weight in X direction set unitWeightY [expr -($massDen-$fluidDen)*9.81*cos($inclination/180.0*$pi)] ;# buoyant unit weight in Y direction set loadIncr 1 ; # Static shear load</p> < li >< ol > # </ ol ></ li > # create the ModelBuilder model basic - ndm 2 - ndf 2 # define material and properties < p > nDMaterial PressureIndependMultiYield 2 2 $massDen $G $B $cohesion $peakShearStrain nDMaterial FluidSolidPorous 1 2 2 2.2 e6 </ p > # define the nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 # define the element thick material maTag press density gravity < p > element quad 1 1 2 3 4 1.0 \"PlaneStrain\" 2 $press 0.0 $unitWeightX $unitWeightY </ p > updateMaterialStage - material 2 - stage 0 # fix the base in vertical direction fix 1 1 1 fix 2 1 1 # tie nodes 3 and 4 equalDOF 3 4 1 2 < li >< ol > # </ ol ></ li > # GRAVITY APPLICATION (elastic behavior) < li > create the SOE, ConstraintHandler, Integrator, Algorithm and Numberer </ li > < p > system ProfileSPD test NormDispIncr 1 .e-12 25 0 constraints Transformation integrator LoadControl 1 1 1 1 algorithm Newton numberer RCM analysis Static analyze 2 </ p > < li >< ol > # </ ol ></ li > # NOW APPLY LOADING SEQUENCE AND ANALYZE # rezero time setTime 0.0 wipeAnalysis # create a LoadPattern with a Linear time series < p > pattern Plain 1 Linear { load 3 $loadIncr 0.0 ; #load applied in x direction } </ p > # create the Analysis < p > constraints Transformation ; # Penalty 1.0e18 1.0e18 ;# test NormDispIncr 1 .e-12 25 0 algorithm Newton numberer RCM system ProfileSPD rayleigh 0.0 0.0 0.000 0 . integrator Newmark $gamma [expr pow ( $gamma + 0.5 , 2 ) / 4 ] analysis VariableTransient </ p > # create the recorder < p > recorder Node - file disp.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 disp recorder Node - file acce.out - time - node 1 2 3 4 - dof 1 2 - dT 0.01 accel recorder Element - ele 1 - time - file stress1.out - dT 0.01 material 1 stress recorder Element - ele 1 - time - file strain1.out - dT 0.01 material 1 strain recorder Element - ele 1 - time - file stress3.out - dT 0.01 material 3 stress recorder Element - ele 1 - time - file strain3.out -dT 0.01 material 3 strain </ p > # analyze < p > set startT [ clock seconds ] analyze $numSteps $deltaT [expr $deltaT / 100 ] $deltaT 10 set endT [ clock seconds ] puts \"Execution time: [expr $endT-$startT] seconds.\" </ p > wipe # flush ouput stream < p > MATLAB Plotting File clear all ; </ p > < p > a1 = load ( 'acce.out' ); d1 = load ( 'disp.out' ); s1 = load ( 'stress1.out' ); e1 = load ( 'strain1.out' ); s5 = load ( 'stress3.out' ); e5 = load ( 'strain3.out' ); </ p > < p > fs =[ 0.5 , 0.2 , 4 , 6 ]; </ p > < p > %integration point 1 p-q po=(s1(:,2)+s1(:,3)+s1(:,4))/3; for i = 1 : size ( s1 , 1 ) qo ( i )=( s1 ( i , 2 ) - s1 ( i , 3 )) ^ 2 + ( s1 ( i , 3 ) - s1 ( i , 4 )) ^ 2 + ( s1 ( i , 2 ) - s1 ( i , 4 )) ^ 2 + 6.0 * s1 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s1 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end figure ( 1 ); clf ; %integration point 1 stress-strain subplot(2,1,1), plot(e1(:,4),s1(:,5),'r') ; title ( 'Integration point 1 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 1 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ1' , 'jpg' ); </ p > < p > %integration point 3 p-q po=(s5(:,2)+s5(:,3)+s5(:,4))/3; for i = 1 : size ( s5 , 1 ) qo ( i )=( s5 ( i , 2 ) - s5 ( i , 3 )) ^ 2 + ( s5 ( i , 3 ) - s5 ( i , 4 )) ^ 2 + ( s5 ( i , 2 ) - s5 ( i , 4 )) ^ 2 + 6.0 * s5 ( i , 5 ) ^ 2 ; qo ( i )= sign ( s5 ( i , 5 )) * 1 / 3.0 * qo ( i ) ^ 0.5 ; end </ p > < p > figure ( 4 ); clf ; %integration point 3 stress-strain subplot(2,1,1), plot ( e5 (:, 4 ), s5 (:, 5 ), 'r' ); title ( 'Integration point 3 shear stress \\tau_x_y VS. shear strain \\epsilon_x_y' ); xLabel ( 'Shear strain \\epsilon_x_y' ); yLabel ( 'Shear stress \\tau_x_y (kPa)' ); </ p > < p > subplot ( 2 , 1 , 2 ), plot ( - po , qo , 'r' ); title ( 'Integration point 3 confinement p VS. deviatoric q relation' ); xLabel ( 'confinement p (kPa)' ); yLabel ( 'q (kPa)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'SS_PQ5' , 'jpg' ); </ p > < p > figure ( 2 ); clf ; %node 3 displacement relative to node 1 subplot ( 2 , 1 , 1 ), plot ( d1 (:, 1 ), d1 (:, 6 ), 'r' ); title ( 'Lateral displacement at element top' ); xLabel ( 'Time (s)' ); yLabel ( 'Displacement (m)' ); set ( gcf , 'paperposition' , fs ); saveas ( gcf , 'D' , 'jpg' ); </ p > < p > Displacement Output File PInd_Ex2Disp.png Stress-Strain Output File (Integration Point 1) PInd_Ex2SS_PQ1.png Stress-Strain Output File (Integration Point 3) PInd_Ex2SS_PQ3.png Return to:","title":"PressureIndependentMultiYield-Example 2\n"},{"location":"library/5_Packages/UniaxialLimitState/365-LimitStateMaterialExampleDebugged/","text":"LimitStateMaterialExampleDebugged NOTOC Application of a limit state material is demonstrated on an example of a column modeled with force-based beam-column element. Three types of analysis are performed on a same column: pushover analysis cyclic analysis time history analysis Static analyses: pushover and cyclic Main file to source to perform pushover analysis is: CenterCol_basicModel_Pushover.tcl Main file to source to perform cyclic analysis is: CenterCol_basicModel_Cyclic.tcl Supporting files to be stored in the same folder with the main file: CenterColAxialSpring.tcl CenterColShearSpring.tcl CenterColSecFiber.tcl tags.tcl Time history analysis Main file to source to perform time history analysis is: CenterCol_basicModel_Dynamic.tcl Supporting files to be stored in the same folder with the main file: CenterColAxialSpring.tcl CenterColShearSpring.tcl CenterColSecFiber.tcl tags.tcl Dynamic.EQ.Uniform_LimitState.tcl LibAnalysisDynamicParameters_LimitState.tcl ReadSMDFile.tcl DisplayModel2D.tcl DisplayPlane.tcl TCU047-N.tcl Original code debugged and extended to include time history analysis by: Mohammad Reza Azadi Kakavand, College of Engineering, University of Tehran, Iran","title":"LimitStateMaterialExampleDebugged\n"},{"location":"library/5_Packages/UniaxialLimitState/505-PinchingLimitStateMaterial%20Example/","text":"PinchingLimitStateMaterial Example The following are sample scripts for using the Pinching Limit State Material and associated limit surface ( RotationShearCurve ) to simulate the behavior of a shear-critical reinforced concrete column tested by Sezen and Moehle (2006) (Specimen 1). The scripts below are for a material model and limit surface that are applied to zero-length shear springs in series with fiber-section column elements (see references below for more detail). Mode 1: Direct Parameter Input limitCurve RotationShearCurve 1 3 1 3 3 -1 -1 -10.0 0.0175 uniaxialMaterial PinchingLimitStateMaterial 9 6 2 1 3057.9 2 1 0.3 0.2 0.0 0.3 0.2 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.3 Pinchingmaterial_fitted_sp1.png Mode 2: Calibrated Model Input limitCurve RotationShearCurve 1 3 1 3 3 -1 -1 0 1 16.0 13.625 16.0 115.75 6.0 6.28 169.0 43.0 1.0 0.00393 -3.177 65.5 66.6 0.0 uniaxialMaterial PinchingLimitStateMaterial 9 6 2 1 -3 2 2 1 16.0 13.625 16.0 57.88 6.0 6.28 169.0 43.0 1.0 0.00393 -3.177 65.5 66.6 PinchingLimitState_Sp1-c.png References LeBorgne M. R., 2012, \u201cModeling the Post Shear Failure Behavior of Reinforced Concrete Columns.\u201d Austin, Texas: University of Texas at Austin, PhD, 301. LeBorgne M. R. , Ghannoum W. M., 2013, \u201cAnalytical Element for Simulating Lateral-Strength Degradation in Reinforced Concrete Columns and Other Frame Members,\u201d Journal of Structural Engineering, doi: 10.1061/(ASCE)ST.1943-541X.0000925 Ghannoum W. M., Moehle J. P., 2012, \u201cRotation-Based Shear Failure Model for Lightly Confined Reinforced Concrete Columns,\u201d Journal of Structural Engineering, V. 138, No. 10, 1267-78 Sezen Halil, Moehle Jack P., 2006, \u201cSeismic Tests of Concrete Columns with Light Transverse Reinforcement,\u201d ACI Structural Journal, V. 103, No. 6, 842-9. Code Developed by: Matthew Leborgne and Wassim M. Ghannoum, University of Texas at Austin","title":"PinchingLimitStateMaterial Example\n"},{"location":"library/5_Packages/UniaxialLimitState/506-Pinching%20Limit%20State/","text":"Pinching Limit State Material This command is used to construct a uniaxial material that simulates a pinched load-deformation response and exhibits degradation under cyclic loading. This material works with the RotationShearCurve limit surface that can monitor a key deformation and/or a key force in an associated frame element and trigger a degrading behavior in this material when a limiting value of the deformation and/or force are reached. The material can be used in two modes: 1) direct input mode, where pinching and damage parameters are directly input; and 2) calibrated mode for shear-critical concrete columns, where only key column properties are input for model to fully define pinching and damage parameters. MODE 1: Direct Input uniaxialMaterial PinchingLimitStateMaterial $matTag $nodeT $nodeB $driftAxis $Kelas $crvTyp $crvTag $YpinchUPN $YpinchRPN $XpinchRPN $YpinchUNP $YpinchRNP $XpinchRNP $dmgStrsLimE $dmgDispMax $dmgE1 $dmgE2 $dmgE3 $dmgE4 $dmgELim $dmgR1 $dmgR2 $dmgR3 $dmgR4 $dmgRLim < code class = \"tcl-variable\" > dmgRCyc </ code > $dmgS1 $dmgS2 $dmgS3 $dmgS4 $dmgSLim < code class = \"tcl-variable\" > dmgSCyc </ code ></ p ></ td > matTag unique material object integer tag nodeT integer node tag to define the first node at the extreme end of the associated flexural frame member (L3 or D5 in Figure) nodeB integer node tag to define the last node at the extreme end of the associated flexural frame member (L2 or D2 in Figure) driftAxis integer to indicate the drift axis in which lateral-strength degradation will occur. This axis should be orthogonal to the axis of measured rotation (see $rotAxis in Rotation Shear Curve definition) driftAxis = 1 - Drift along the x-axis driftAxis = 2 - Drift along the y-axis driftAxis = 3 - Drift along the z-axis Kelas floating point value to define the initial material elastic stiffness (Kelastic); Kelas > 0 crvTyp integer flag to indicate the type of limit curve associated with this material. crvTyp = 0 - No limit curve crvTyp = 1 - axial limit curve crvTyp = 2 - RotationShearCurve crvTag integer tag for the unique limit curve object associated with this material YpinchUPN floating point unloading force pinching factor for loading in the negative direction Note: This value must be between zero and unity YpinchRPN floating point reloading force pinching factor for loading in the negative direction Note: This value must be between negative one and unity XpinchRPN floating point reloading displacement pinching factor for loading in the negative direction Note: This value must be between negative one and unity YpinchUNP floating point unloading force pinching factor for loading in the positive direction Note: This value must be between zero and unity YpinchRNP floating point reloading force pinching factor for loading in the positive direction Note: This value must be between negative one and unity XpinchRNP floating point reloading displacement pinching factor for loading in the positive direction Note: This value must be between negative one and unity dmgStrsLimE floating point force limit for elastic stiffness damage (typically defined as the lowest of shear strength or shear at flexrual yielding). This value is used to compute the maximum deformation at flexural yield (\u03b4max Eq. 1) and using the initial elastic stiffness (Kelastic) the monotonic energy (Emono Eq. 1) to yield. Input 1 if this type of damage is not required and set $dmgE1, $dmgE2, $dmgE3, $dmgE4, and $dmgELim to zero dmgDispMax floating point for ultimate drift at failure (\u03b4max Eq. 1) and is used for strength and stiffness damage. This value is used to compute the monotonic energy at axial failure (Emono Eq. 2) by computing the area under the backbone in the positive loading direction up to \u03b4max. Input 1 if this type of damage is not required and set $dmgR1, $dmgR2, $dmgR3, $dmgR4, and $dmgRLim to zero for reloading stiffness damage. Similarly set $dmgS1, $dmgS2, $dmgS3, $dmgS4, and $dmgSLim to zero if reloading strength damage is not required dmgE1 dmgE2 dmgE3 dmgE4 floating point elastic stiffness damage factors \u03b11,\u03b12,\u03b13,\u03b14 shown in Eq. 1 dmgELim floating point elastic stiffness damage limit Dlim shown in Eq. 1; Note: This value must be between zero and unity dmgR1 dmgR2 dmgR3 dmgR4 floating point reloading stiffness damage factors \u03b11,\u03b12,\u03b13,\u03b14 shown in Eq. 1 dmgRLim floating point reloading stiffness damage limit Dlim shown in Eq. 1; Note: This value must be between zero and unity dmgRCyc floating point cyclic reloading stiffness damage index; Note: This value must be between zero and unity dmgS1 dmgS2 dmgS3 dmgS4 floating point backbone strength damage factors \u03b11,\u03b12,\u03b13,\u03b14 shown in Eq. 1 dmgSLim floating point backbone strength damage limit Dlim shown in Eq. 1; Note: This value must be between zero and unity dmgSCyc floating point cyclic backbone strength damage index; Note: This value must be between zero and unity MODE 2: Calibrated Model for Shear-Critical Concrete Columns uniaxialMaterial PinchingLimitStateMaterial $matTag $nodeT $nodeB $driftAxis $Kelas $crvTyp $crvTag $eleTag $b $d $h $a $st $As $Acc $ld $db $rhot $f\u2019c $fy $fyt matTag unique material object integer tag nodeT integer node tag to define the first node at the extreme end of the associated flexural frame member (L3 or D5 in Figure) nodeB integer node tag to define the last node at the extreme end of the associated flexural frame member (L2 or D2 in Figure) driftAxis integer to indicate the drift axis in which lateral-strength degradation will occur. This axis should be orthogonal to the axis of measured rotation (see \\(rotAxis in Rotation Shear Curve definition)</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>driftAxis = 1 - Drift along the x-axis driftAxis = 2 - Drift along the y-axis driftAxis = 3 - Drift along the z-axis</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Kelas</code></td> <td><p>floating point value to define the shear stiffness (Kelastic) of the shear spring prior to shear failure</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>Kelas = -4 - Shear stiffness calculated assuming double curvature and shear springs at both column element ends</p> <p>Kelas = -3 - Shear stiffness calculated assuming double curvature and a shear spring at one column element end</p> <p>Kelas = -2 - Shear stiffness calculated assuming single curvature and shear springs at both column element ends</p> <p>Kelas = -1 - Shear stiffness calculated assuming single curvature and a shear spring at one column element end</p> <p>Kelas &gt; 0 - Shear stiffness is the input value</p> <p>Note: integer inputs allow the model to know whether column height equals the shear span (cantelever) or twice the shear span (double curvature). For columns in frames, input the value for the case that best approximates column end conditions or manually input shear stiffness (typically double curvature better estimates framed column behavior)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">crvTag</code></td> <td><p>integer tag for the unique limit curve object associated with this material</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>integer element tag to define the associated beam-column element used to extract axial load</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">b</code></td> <td><p>floating point column width (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">d</code></td> <td><p>floating point column depth (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">h</code></td> <td><p>floating point column height (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">a</code></td> <td><p>floating point shear span length (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">st</code></td> <td><p>floating point transverse reinforcement spacing (inches) along column height</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">As</code></td> <td><p>floating point total area (inches squared) of longitudinal steel bars in section</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Acc</code></td> <td><p>floating point gross confined concrete area (inches squared) bounded by the transverse reinforcement in column section</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ld</code></td> <td><p>floating point development length (inches) of longitudinal bars using ACI 318-11 Eq. 12-1 and Eq. 12-2</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">db</code></td> <td><p>floating point diameter (inches) of longitudinal bars in column section</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">rhot</code></td> <td><p>floating point transverse reinforcement ratio (Ast/st.db)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) f\u2019c floating point concrete compressive strength (ksi) fy floating point longitudinal steel yield strength (ksi) fyt floating point transverse steel yield strength (ksi) DESCRIPTION: PinchingLimitStateMaterial2.png PinchingLimitStateMaterial1-2.jpg The material model coupled with the RotationShearCurve limit surface: 1) has the ability to continually monitor forces and deformations in the flexural elements for conditions that trigger lateral-strength degradation, 2) has a built-in function that compensates for flexural deformation offsets that arise from the degrading behavior of the material in shear springs, and 3) is able to trigger lateral-strength degradation through either a limiting lateral force or element deformations (whichever is reached first). The material introduces several functionalities that give users a high degree of control over the triggering of strength degradation and the ensuing cyclic degrading behavior. Damage algorithms are implemented to control the degrading behavior through elastic stiffness, reloading stiffness, and backbone strength degradation (Fig. 2). The rate of damage accumulation can be controlled by energy-, displacement-, and cycle-based damage computation algorithms. During the degrading behavior, the model automatically adjusts reloading stiffness to achieve a symmetric global-element lateral load-vs lateral displacement behavior. The model does so by automatically adjusting the reloading stiffness and backbone curve of the material model to compensate for dissymmetry introduced by the unloading of the flexural elements in series with shear springs governed by the model. DAMAGE: Damage accumulations effects based on numbers of cycles can be introduced to reloading stiffness and backbone strength through the simple parameters $dmgRCyc and $dmgSCyc with values ranging from 0 to 1. Elastic stiffness, reloading stiffness, and strength can be adjusted using the following energy and displacement damage model (from Mitra and Lowes (2007)): PinchingLimitStateMaterialEq1.png Examples PinchingLimitStateMaterial Example References LeBorgne M. R., 2012, \u201cModeling the Post Shear Failure Behavior of Reinforced Concrete Columns.\u201d Austin, Texas: University of Texas at Austin, PhD, 301. LeBorgne, M.R., Ghannoum, W.M., 2014, \u201cAnalytical Element for Simulating Lateral-Strength Degradation in Reinforced Concrete Columns and Other Frame Members,\u201d Journal of Structural Engineering, V. 140, No. 7, pp. 04014038 1-12. LeBorgne, M.R., Ghannoum, W.M., 2014, \u201cCalibrated Analytical Element for Lateral-Strength Degradation of Reinforced Concrete Columns,\u201d Engineering Structures, V. 81, pp. 35-48. Ghannoum W. M., Moehle J. P., 2012, \u201cRotation-Based Shear Failure Model for Lightly Confined Reinforced Concrete Columns,\u201d Journal of Structural Engineering, V. 138, No. 10, 1267-78. Mitra Nilanjan, Lowes Laura N., 2007, \u201cEvaluation, Calibration, and Verification of a Reinforced Concrete Beam\u2013Column Joint Model,\u201d Journal of Structural Engineering, V. 133, No. 1, 105-20. Code Developed by: Matthew Leborgne and Wassim M. Ghannoum, University of Texas at Austin","title":"Pinching Limit State Material\n"},{"location":"library/5_Packages/UniaxialLimitState/LimitState/","text":"LimitState This command is used to construct a uniaxial hysteretic material object with pinching of force and deformation, damage due to ductility and energy, and degraded unloading stiffness based on ductility. Failure of the material is defined by the associated Limit Curve . uniaxialMaterial LimitState $matTag $s1p $e1p $s2p $e2p $s3p $e3p $s1n $e1n $s2n $e2n $s3n $e3n $pinchX $pinchY $damage1 $damage2 $beta $curveTag $curveType. matTag integer tag identifying material s1p e1p stress and strain (or force & deformation) at first point of the envelope in the positive direction s2p e2p stress and strain (or force & deformation) at second point of the envelope in the positive direction s3p e3p stress and strain (or force & deformation) at third point of the envelope in the positive direction s1n e1n stress and strain (or force & deformation) at first point of the envelope in the negative direction* s2n e2n stress and strain (or force & deformation) at second point of the envelope in the negative direction* s3n e3n stress and strain (or force & deformation) at third point of the envelope in the negative direction* pinchX pinching factor for strain (or deformation) during reloading pinchY pinching factor for stress (or force) during reloading damage1 damage due to ductility: D1(m-1) damage2 damage due to energy: D2(Ei/Eult) beta power used to determine the degraded unloading stiffness based on ductility, m-b (optional, default=0.0) curveTag an integer tag for the Limit Curve defining the limit surface curveType an integer defining the type of LimitCurve (0 = no curve, 1 = axial curve, all other curves can be any other integer) NOTES: negative backbone points should be entered as negative numeric values Examples Original version of example: LimitStateMaterialExample Debugged version of example: LimitStateMaterialExampleDebugged Manual for the example: Limit State Material - Example Manual Description Modeling Failures in Existing Reinforced Concrete Columns by Ken Elwood: file:ElwoodCJCE2004.pdf References Elwood, K.J and Moehle, J.P., \u201cShake Table Tests and Analystical Studies on the Gravity Load Collapse of Reinforced Concrete Frames\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, CA. PEER 2003/01. Code Developed by: Ken Elwood, University of British Columbia","title":"LimitState\n"},{"location":"library/5_Packages/UniaxialLimitState/Limit_Curves/","text":"Limit Curve This command is used to construct a failure curve for a limit state material. limitCurve $type $arg1 $arg2 ... type type of limit curve $arg1 $arg2 .. args depending on $type The following contain information about the valid types and the args required for each: Shear LimitCurve Axial LimitCurve Code Developed by: Ken Elwood, University of British Columbia","title":"Limit Curve\n"},{"location":"library/5_Packages/UniaxialLimitState/Limit_Curves/28-Axial%20LimitCurve/","text":"Axial LimitCurve This command is used to construct an axial limit curve object that is used to define the point of axial failure for a LimitStateMaterial object. Point of axial failure based on model from Chapter 3 of PEER 2003/01 report. After axial failure the response of LimitStateMaterial is forced to follow axial limit curve. limitCurve Axial $curveTag $eleTag $Fsw $Kdeg $Fres $defType $forType & lt ; $ndI $ndJ $dof $perpDirn $delta & gt ; curveTag unique LimitCurve tag eleTag integer element tag for the associated beam-column element Fsw floating point value describing the amount of transverse reinforcement <math>(F_{sw} = )</math> Kdeg floating point value for the slope of the third branch in the post-failure backbone, assumed to be negative (see Figure 4-6) Fres floating point value for the residual force capacity of the post-failure backbone (see Figure 4-6) defType integer flag for type of deformation defining the abscissa of the limit curve 1 = maximum beam-column chord rotations 2 = drift based on displacment of nodes ndI and ndJ forType nteger flag for type of force defining the ordinate of the limit curve. See NOTES 1. 0 = force in associated limit state material 1 = shear in beam-column element 2 = axial load in beam-column element ndI nteger node tag for the first associated node (normally node I of $eleTag beam-column element) ndJ integer node tag for the second associated node (normally node J of $eleTag beam-column element) dof nodal degree of freedom to monitor for drift. See NOTES 2 perpDirn perpendicular global direction from which length is determined to compute drift. See Notes 2. delta drift (floating point value) used to shift axial limit curve NOTES: Options 1 and 2 assume no member loads 1 = X, 2 = Y, 3 = Z Examples <tcl>CenterColAxialSpring.tcl</tcl> DESCRIPTION: Modeling Failures in Existing Reinforced Concrete Columns by Ken Elwood: file:ElwoodCJCE2004.pdf References Elwood, K.J and Moehle, J.P., \u201cShake Table Tests and Analystical Studies on the Gravity Load Collapse of Reinforced Concrete Frames\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, CA. PEER 2003/01. Code Developed by: Ken Elwood, University of British Columbia","title":"Axial LimitCurve\n"},{"location":"library/5_Packages/UniaxialLimitState/Limit_Curves/608-RotationShearCurve/","text":"RotationShearCurve This command is used to construct a limit surface that defines the ultimate deformation between two nodes and/or the ultimate force that trigger lateral-strength degradation in the Pinching Limit State Material . The curve can be used in two modes: 1) direct input mode, where all parameters are input; and 2) calibrated mode for shear-critical concrete columns, where only key column properties are input for model to fully define pinching and damage parameters. Note: when both strength and rotation limits are used. Lateral-strength degradation is triggered in the material model when the first limit is reached. MODE 1: Direct Input limitCurve RotationShearCurve $crvTag $eleTag $ndI $ndJ $rotAxis $Vn $Vr $Kdeg $rotLim crvTag unique limit curve object integer tag eleTag integer element tag to define the associated beam-column element used to extract axial load ndI integer node tag to define the node at the extreme end of the frame member bounding the plastic hinge (L1 or D1 for bottom spring and L4 or D6 for top spring in Figure) ndJ integer node tag to define the node bounding the plastic hinge (L2 or D3 for bottom spring and L3 or D4 for top spring in Figure) rotAxis integer to indicate axis of measured rotation when triggering lateral-strength degradation rotAxis = 3 - Rotation about z-axis - 2D rotAxis = 4 - Rotation about x-axis - 3D rotAxis = 5 - Rotation about y-axis - 3D rotAxis = 6 - Rotation about z-axis - 3D Vn floating point value to define the ultimate strength in material model Vn = -1 - strength limit is not used. Vn > 0 - strength limit is the input value Vr floating point value to define the backbone residual strength Vr = -1 - Residual strength = 0.2 (max. force in material model at initiation of degradation) -1 < Vr < 0 - Residual shear strength = Vr (max. force in material model at initiation of degradation) Vr > 0 - Residual strength is the input value Kdeg floating point value to define the backbone degrading slope of the material model. Note: the degrading slope must be less than zero. rotLim floating point value to limit the rotational capacity across the plastic hinge (difference between $ndI and $ndJ in absolute value). When this value (radians) is exceeded during the analysis degrading behavior is triggered in the material model. MODE 2: Calibrated Model for Shear-Critical Concrete Columns limitCurve RotationShearCurve $crvTag $eleTag $ndI $ndJ $rotAxis $Vn $Vr $Kdeg $defType $b $d $h $L $st $As $Acc $ld $db $rhot $f\u2019c $fy $fyt $delta crvTag unique limit curve object integer tag eleTag integer element tag to define the associated beam-column element used to extract axial load ndI integer node tag to define the node at one end of the region for which limiting rotations are defined (see $defType) ndJ integer node tag to define the node at the other end of the region for which limiting rotations are defined (see $defType) rotAxis integer to indicate axis of measured rotation when triggering lateral-strength degradation. rotAxis = 3 - Rotation about z-axis - 2D rotAxis = 4 - Rotation about x-axis - 3D rotAxis = 5 - Rotation about y-axis - 3D rotAxis = 6 - Rotation about z-axis - 3D Vn floating point value to define the nominal shear strength Vn = -1 - Shear strength limit is not used Vn = 0 - Shear strength limit is calculated using ASCE 41-06 Eq. 6-4 Vn > 0 - Shear strength limit is the input value Note: Shear capacity calculated according to ASCE 41 only gives the capacity with the k factor equal to 1 (i.e., shear capacity at small deformations) Vr floating point value to define the backbone residual shear strength Vr = -1 - Residual shear strength = 0.2*( max. force in material model at initiation of degradation) -1 < Vr < 0 - Residual shear strength = Vr*( max. force in material model at initiation of degradation) Vr > 0 - Residual shear strength is the input value Kdeg floating point value to define the backbone degrading slope. Kdeg = 0 - Degrading slope calculated by calibrated regression model. Kdeg < 0 - Degrading slope is the input value defType integer flag to define which rotation-based shear failure model is used 1 - Flexure-Shear capacity based on \u03b8_f rotation capacity (Eq. 4.4; Leborgne 2012) For this case select $ndI=D1 or L1 and $ndJ=D3 or L2 for the bottom spring in Fig. 1 2 - Flexure-Shear capacity based on \u03b8_total rotation capacity (Ghannoum and Moehle 2012) For this case select $ndI=D1 or L1 and $ndJ=D3 or L2 for the bottom spring in Fig. 1 3 - Flexure-Shear capacity based on \u03b8flexural rotation capacity (Ghannoum and Moehle 2012) For this case select $ndI=D2 and $ndJ=D3 for the bottom spring in Fig. 1 4 - Flexure-Shear capacity based on \u03b8_total-plastic rotation capacity (Ghannoum and Moehle 2012) For this case select $ndI=L1 and \\(ndJ=L2 for the bottom spring in Fig. 1</p> <p>5 - Flexure-Shear capacity based on \u03b8_flexural-plastic rotation capacity (Ghannoum and Moehle 2012) This is a special case not shown in Fig. 1 where column flexural plastic deformations are simulated separately from bar-slip induced plastic rotations in a lumped-plasticity model</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">b</code></td> <td><p>floating point column width (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">d</code></td> <td><p>floating point column depth (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">h</code></td> <td><p>floating point column height (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">L</code></td> <td><p>floating point column clear span length (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">st</code></td> <td><p>floating point transverse reinforcement spacing (inches) along column height</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">As</code></td> <td><p>floating point total area (inches squared) of longitudinal steel bars in section</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Acc</code></td> <td><p>floating point gross confined concrete area (inches squared) bounded by the transverse reinforcement in column section</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">ld</code></td> <td><p>floating point development length (inches) of longitudinal bars using ACI 318-11 Eq. 12-1 and Eq. 12-2</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">db</code></td> <td><p>floating point diameter (inches) of longitudinal bars in column section</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rhot</code></td> <td><p>floating point transverse reinforcement ratio (Ast/st.db)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) f\u2019c floating point concrete compressive strength (ksi) fy floating point longitudinal steel yield strength (ksi) fyt floating point transverse steel yield strength (ksi) delta floating point offset (radians) added to shear failure models to adjust shear failure location. Note: This value should remain at zero to use the model as per calibration DESCRIPTION: PinchingLimitStateMaterial2.png PinchingLimitStateMaterial1-2.jpg Examples PinchingLimitStateMaterial Example References LeBorgne M. R., 2012, \u201cModeling the Post Shear Failure Behavior of Reinforced Concrete Columns.\u201d Austin, Texas: University of Texas at Austin, PhD, 301. LeBorgne M. R. , Ghannoum W. M., 2013, \u201cAnalytical Element for Simulating Lateral-Strength Degradation in Reinforced Concrete Columns and Other Frame Members,\u201d Journal of Structural Engineering, V. doi: 10.1061/(ASCE)ST.1943-541X.0000925 Ghannoum W. M., Moehle J. P., 2012, \u201cRotation-Based Shear Failure Model for Lightly Confined Reinforced Concrete Columns,\u201d Journal of Structural Engineering, V. 138, No. 10, 1267-78. Code Developed by: Matthew Leborgne and Wassim M. Ghannoum, University of Texas at Austin","title":"RotationShearCurve\n"},{"location":"library/5_Packages/UniaxialLimitState/Limit_Curves/635-Shear%20LimitCurve/","text":"Shear LimitCurve This command is used to construct a shear limit curve object that is used to define the point of shear failure for a LimitStateMaterial object. Point of shear failure is based on empirical drift capacity model from Chapter 2 of PEER 2003/01 report. After shear failure the response of LimitStateMaterial is forced to follow shear limit curve. limitCurve Shear $curveTag $eleTag $rho $fc $b $h $d $Fsw $Kdeg $Fres $defType $forType & lt ; $ndI $ndJ $dof $perpDirn $delta & gt ; curveTag unique LimitCurve tag eleTag integer element tag for the associated beam-column element rho transverse reinforcement ratio <math>()</math> fc concrete compressive strength (psi) b column width (in.) h full column depth (in.) d effective column depth (in.) Fsw floating point value describing the amount of transverse reinforcement <math>(F_{sw} = )</math> Kdeg If positive: unloading stiffness of beam-column element (Kunload from Figure 4-8) if negative: slope of third branch of post-failure backbone (see Figure 4-6) %Fres \u2019 floating point value for the residual force capacity of the post-failure backbone (see Figure 4-6) defType integer flag for type of deformation defining the abscissa of the limit curve 1 = maximum beam-column chord rotations 2 = drift based on displacment of nodes ndI and ndJ forType integer flag for type of force defining the ordinate of the limit curve. See NOTES 1. 0 = force in associated limit state material 1 = shear in beam-column element 2 = axial load in beam-column element ndI nteger node tag for the first associated node (normally node I of $eleTag beam-column element) ndJ integer node tag for the second associated node (normally node J of $eleTag beam-column element) dof nodal degree of freedom to monitor for drift. See NOTES 2 perpDirn perpendicular global direction from which length is determined to compute drift. See Notes 2. delta drift (floating point value) used to shift axial limit curve NOTES: Options 1 and 2 assume no member loads 1 = X, 2 = Y, 3 = Z Examples <tcl>CenterColShearSpring.tcl</tcl> DESCRIPTION: Modeling Failures in Existing Reinforced Concrete Columns by Ken Elwood: file:ElwoodCJCE2004.pdf References Elwood, K.J and Moehle, J.P., \u201cShake Table Tests and Analystical Studies on the Gravity Load Collapse of Reinforced Concrete Frames\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, CA. PEER 2003/01. Code Developed by: Ken Elwood, University of British Columbia","title":"Shear LimitCurve\n"},{"location":"library/5_Packages/optimization/","text":"Sensitivity Command Manual Return to Sensitivity Analysis User Page For OpenSees we have added commands to Tcl for finite element analysis. These commands can be grouped into four sections: General Commands commands added to the interpreter to create the sensitivity analysis. Material Commands commands added to Tcl to create the analysis procedure. Section Commands commands aded to Tcl to monitor what is happening in the model during the analysis. Element Commands commands added to Tcl to help monitor and modify the model and analysis during the run-time. Constraint Commands commands added to Tcl to help monitor and modify the model and analysis during the run-time.","title":"Sensitivity Command Manual\n"},{"location":"library/5_Packages/optimization/275-General%20Commands/","text":"General Commands :; reliability Command This command creates the reliability domain in which the sensitivity, reliability and optimization components are kept. This reliability domain is parallel to the finite element (FE) domain in OpenSees. Currently, the commands for stand-alone sensitivity :analysis (e.g., sensitivityIntegrator, sensitivityAlgorithm) are set in the reliability domain only and, thus, the \u2018reliability\u2019 reliability parameter Command In DDM-based FE response sensitivity analysis, the sensitivity parameters can be material, geometry or discrete loading parameters. Each parameter should be defined as: parameter $tag & lt ; specific object arguments & gt ; addToParameter Command In case that more objects (e.g., element, section) are mapped to an existing parameter, the following command can be used to relate these additional objects to the specific parameter: addToParameter $tag & lt ; specific object arguments & gt ; updateParameter Command Once the parameters in FE model are defined, their value can be updated: updateParameter $tag $newValue sensitivityIntegrator Command For static analysis, the only option currently available is the following, which must be defined before the \u2018analysis\u2019 command. sensitivityIntegrator - static For the dynamic case, currently only the Newmark algorithm is available. Two command need to be used together: integrator NewmarkWithSensitivity $gamma $beta sensitivityIntegrator - definedAbove Currently, \u2018-definedAbove\u2019 is the only option available in OpenSees. This means that the same integration scheme (i.e., \u2018NewmarkWithSensitivity\u2019) is used to perform both response and response sensitivity analysis. sensitivityAlgorithm Command The most general command is the following, which computes the response sensitivity at each time/load step, after the response has converged. sensitivityAlgorithm - computeAtEachStep In those cases in which the sensitivity computation does not need to be performed at each step (e.g., for linear elastic systems : subjected to static pushover analysis), the sensitivity computation may be performed only at the time/load steps required by user: sensitivityAlgorithm - computeByCommand However, before using the \u2018-computeByCommand\u2019 option, it is the user\u2019s responsibility to make sure that the response sensitivities computation is not needed at each time/load step. For example, in case of incremental nonlinear FE analysis or dynamic analysis, using the \u2018-computeByCommand\u2019 option will produce wrong sensitivity results. recorder Commands To record the nodal response and response sensitivity, the most commonly used format is: recorder Node - file disp29.out - time - node 29 - dof 1 & lt ; -precision 16 & gt ; disp recorder Node -file ddm29G1.out -time -node 29 -dof 1 \u201csensitivity 1\u201d recorder Node -file ddm29G1.out -time -node 29 -dof 1 \u201cvelSensitivity 1\u201d recorder Node - file ddm29G1.out - time - node 29 - dof 1 \"accSensitivity 1\" The above \u2018recorder\u2019 commands (extended for recording response sensitivities) save into files (with the file name defined after : the command \u2018-file\u2019) the responses and response sensitivities of the node 29 along the first degree of freedom (dof) direction. : Response quantities can be \u2018disp\u2019 (displacements), \u2018vel\u2019 (velocities) and \u2018acc\u2019 (accelerations). Response sensitivities are denoted by a string in double quotes and containing the response quantity identifier (i.e., \u201csensitivity\u201d for displacements, \u201cvelSensitivity\u201d for velocities and \u201caccSensitivity\u201d for accelerations) and the sensitivity parameter specified by the parameter : tag ( in this example the tag is 1). The command \u2018-precision\u2019 is optional, and allows users to change the number of digits used to record into file the response and/or response sensitivities. This command is particularly useful when the finite difference method is used to verify/validate : DDM-based FE response sensitivities, since high accuracy in the results may be needed. The user may also get responses and response sensitivities directly using the following Tcl commands: nodeDisp 29 1 nodeVel 29 1 nodeAccel 29 1 sensNodeDisp 29 1 2 sensNodeVel 29 1 2 sensNodeAccel 29 1 2 These commands return the responses of the node 29 along the first dof, and their response sensitivities with respect to the parameter with tag 2","title":"General Commands\n"},{"location":"library/5_Packages/optimization/developer/629-Sensitivity%20interface%20at%20Element%20Level/","text":"Sensitivity interface at Element Level The following functions need to be implemented in each element for sensitivity computation: Return to Extension of an existing material,cross section, and element for DDM-based: int setParameter ( const char ** argv , int argc , Parameter & amp ; param ); int updateParameter ( int parameterID , Information & amp ; info ); int activateParameter ( int passedParameterID ); const Vector & amp ; getResistingForceSensitivity ( int gradIndex ); int commitSensitivity ( int gradIndex , int numGrads ); const Matrix & amp ; getInitialStiffSensitivity ( int gradIndex ); const Matrix & amp ; getDampSensitivity ( int gradIndex ); const Matrix & amp ; getMassSensitivity ( int gradIndex );","title":"Sensitivity interface at Element Level\n"},{"location":"library/5_Packages/optimization/developer/631-Sensitivity%20interface%20at%20Section%20Level/","text":"Sensitivity interface at Section Level Return to Extension of an existing material,cross section, and element for DDM-based: The following functions need to be implemented in each section for sensitivity computation: int setParameter ( const char ** argv, int argc, Parameter & param ); int updateParameter ( int parameterID, Information & info ); int activateParameter ( int passedParameterID ); const Vector & getStressResultantSensitivity ( int gradIndex, bool conditional ); const Vector & getSectionDeformationSensitivity ( int gradIndex ); const Matrix & getInitialTangentSensitivity ( int gradIndex ); int commitSensitivity ( const Vector & sectionDeformationGradient,int gradIndex, int numGrads );","title":"Sensitivity interface at Section Level\n"},{"location":"library/5_Packages/optimization/modeling/","text":"Element Commands <noinclude>Currently, several element types have been extended for DDM-based FE response sensitivity computation. element eleType ? arg1 ? ... The type of element created and the additional arguments required depends on the eleType? provided in the command. The following contain information about eleType? and the args required for each of the available element types: </noinclude> dispBeamColumnWithSensitivity Element quadWithSensitivity Element bbarBrickWithSensitivity Element","title":"Element Commands\n"},{"location":"library/5_Packages/optimization/modeling/150-DispBeamColumnWithSensitivity/","text":"DispBeamColumnWithSensitivity This command is used to construct a 2-D or 3-D distributed-plasticity displacement-based beam-column (frame) element. element dispBeamColumnWithSensitivity $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag & lt ; integration method & gt ; tag integer tag identifying an existing parameter. iNode jNode end nodes. numIntgrPts number of integration points along the element. secTag identifier for previously-defined section object. transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object. integration method optional (available options = \u2018Lobatto\u2019 or \u2018Legendre\u2019, default = \u2018Legendre\u2019). Currently, there are no sensitivity parameters in the \u2018dispBeamColumnWithSensitivity\u2019 element command.","title":"DispBeamColumnWithSensitivity\n"},{"location":"library/5_Packages/optimization/modeling/151-DispBeamColumnWithSensitivity%20Command/","text":"DispBeamColumnWithSensitivity Command This command is used to construct a 2-D or 3-D distributed-plasticity displacement-based beam-column (frame) element. element dispBeamColumnWithSensitivity $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag & lt ; integration method & gt ; tag integer tag identifying an existing parameter. iNode jNode end nodes. numIntgrPts number of integration points along the element. secTag identifier for previously-defined section object. transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object. integration method optional (available options = \u2018Lobatto\u2019 or \u2018Legendre\u2019, default = \u2018Legendre\u2019). Currently, there are no sensitivity parameters in the \u2018dispBeamColumnWithSensitivity\u2019 element command.","title":"DispBeamColumnWithSensitivity Command\n"},{"location":"library/5_Packages/optimization/modeling/152-DispBeamColumnWithSensitivity%20Element/","text":"DispBeamColumnWithSensitivity Element This command is used to construct a 2-D or 3-D distributed-plasticity displacement-based beam-column (frame) element. element dispBeamColumnWithSensitivity $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag & lt ; integration method & gt ; tag integer tag identifying an existing parameter. iNode jNode end nodes. numIntgrPts number of integration points along the element. secTag identifier for previously-defined section object. transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object. integration method optional (available options = \u2018Lobatto\u2019 or \u2018Legendre\u2019, default = \u2018Legendre\u2019). Currently, there are no sensitivity parameters in the \u2018dispBeamColumnWithSensitivity\u2019 element command.","title":"DispBeamColumnWithSensitivity Element\n"},{"location":"library/5_Packages/optimization/modeling/18-Aggregator%20Command%20for%20Sensitivity/","text":"Aggregator Command for Sensitivity This command is used to construct a SectionAggregator object which groups previously-defined UniaxialMaterial objects into a single section force-deformation model. section Aggregator $secTag $matTag1 $string1 $matTag2 $string2 \u2026\u2026 & lt ; -section $sectionTag & gt ; secTag unique section object integer tag. $matTag1, \\(matTag2 \u2026</strong></p></td> <td><p>previously-defined UniaxialMaterial Objects.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) string1, $string2 \u2026 force-deformation relations corresponding to each section object. One of the following strings can be used. P axial force-deformation. Mz moment-curvature about section local z axis. Vy shear force-deformation along section local y-axis. My moment-curvature about section local y axis. Vz shear force-deformation along section local z-axis. T torsion force-deformation. Iy second moment of area about the local y-axis (optional, used for 3-D analysis). <-section $sectionTag> specifies a previously defined Section object (identified by the argument $sectionTag) to which these UniaxialMaterial objects are added to define a new Section object. The \u2018section Aggregator\u2019 command does not introduce additional sensitivity parameters. However, sensitivity parameters can be defined for each force-deformation relation used in the section aggragator.","title":"Aggregator Command for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/242-Fiber%20Command%20for%20Sensitivity/","text":"Fiber Command for Sensitivity Both 2-D and 3-D fiber sections are available for response sensitivity computation. section Fiber $secTag { fiber <fiber arguments> patch <patch arguments> layer <layer arguments> } References: http://opensees.berkeley.edu/OpenSees/manuals/usermanual/index.html Spacone E., Filippou F.C., Taucer F.F. (1996). \u201cFibre beam-column element for nonlinear analysis of R/C frames. Part I: Formulation.\u201d Earthquake Engineering and Structural Dynamics, 25:711-725.","title":"Fiber Command for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/244-Fiber%20Section%20for%20Sensitivity/","text":"Fiber Section for Sensitivity This command is used to construct a SectionAggregator object which groups previously-defined UniaxialMaterial objects into a single section force-deformation model. section Aggregator $secTag $matTag1 $string1 $matTag2 $string2 \u2026\u2026 & lt ; -section $sectionTag & gt ; secTag unique section object integer tag. $matTag1, \\(matTag2 \u2026</strong></p></td> <td><p>previously-defined UniaxialMaterial Objects.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) string1, $string2 \u2026 force-deformation relations corresponding to each section object. One of the following strings can be used. P axial force-deformation. Mz moment-curvature about section local z axis. Vy shear force-deformation along section local y-axis. My moment-curvature about section local y axis. Vz shear force-deformation along section local z-axis. T torsion force-deformation. Iy second moment of area about the local y-axis (optional, used for 3-D analysis). <-section $sectionTag> specifies a previously defined Section object (identified by the argument $sectionTag) to which these UniaxialMaterial objects are added to define a new Section object. The \u2018section Aggregator\u2019 command does not introduce additional sensitivity parameters. However, sensitivity parameters can be defined for each force-deformation relation used in the section aggragator.","title":"Fiber Section for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/42-BbarBrickWithSensitivity/","text":"BbarBrickWithSensitivity This command is used to construct an eight-node 3D brick element object based on a trilinear isoparametric formulation. element bbarBrickWithSensitivity $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 $matTag eleTag unique element object tag. $node1 - $node8 eight nodes defining element boundaries (numbered as shown in the figure below). matTag tag associated with previously-defined nDMaterial object. _Numbering_of_nodes_for_the_B-bar_brick_element.jpg Currently, there are no sensitivity parameters in the \u2018bbarBrickWithSensitivity\u2019 element command.","title":"BbarBrickWithSensitivity\n"},{"location":"library/5_Packages/optimization/modeling/43-BbarBrickWithSensitivity%20Command/","text":"BbarBrickWithSensitivity Command This command is used to construct an eight-node 3D brick element object based on a trilinear isoparametric formulation. element bbarBrickWithSensitivity $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 $matTag eleTag unique element object tag. $node1 - $node8 eight nodes defining element boundaries (numbered as shown in the figure below). matTag tag associated with previously-defined nDMaterial object. _Numbering_of_nodes_for_the_B-bar_brick_element.jpg Currently, there are no sensitivity parameters in the \u2018bbarBrickWithSensitivity\u2019 element command.","title":"BbarBrickWithSensitivity Command\n"},{"location":"library/5_Packages/optimization/modeling/44-BbarBrickWithSensitivity%20Element/","text":"BbarBrickWithSensitivity Element This command is used to construct an eight-node 3D brick element object based on a trilinear isoparametric formulation. element bbarBrickWithSensitivity $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 $matTag eleTag unique element object tag. $node1 - $node8 eight nodes defining element boundaries (numbered as shown in the figure below). matTag tag associated with previously-defined nDMaterial object. _Numbering_of_nodes_for_the_B-bar_brick_element.jpg Currently, there are no sensitivity parameters in the \u2018bbarBrickWithSensitivity\u2019 element command.","title":"BbarBrickWithSensitivity Element\n"},{"location":"library/5_Packages/optimization/modeling/559-QuadWithSensitivity/","text":"QuadWithSensitivity This command is used to construct a 2D four-node quadrilateral element object based on a bilinear isoparametric formulation. element quadWithSensitivity $eleTag $iNode $jNode $kNode $lNode $thick $type $matTag & lt ; $pressure $rho $b1 $b2 & gt ; tag integer tag identifying an existing parameter. iNode jnode kNode lNode four nodes defining element boundaries (numbered following a counter-clockwise order around the element). thick element thickness (constant). type string representing material behavior. Valid options depend on the nDMaterial object and the corresponding available material formulations. The \u2018type\u2019 parameter can be either \u201cPlaneStrain\u201d or \u201cPlaneStress\u201d. matTag tag associated with previously-defined NDMaterial object. pressure surface pressure (set temporarily equal to zero for DDM-based sensitivity analysis). rho element mass density (per unit volume) from which a lumped element mass matrix is computed (optional, default=0.0). b1 b2 constant body forces defined in the isoparametric domain (optional, default=0.0). All parameters are the same as those in the \u2018quad\u2019 element command. Currently there are no sensitivity parameters in the \u2018quadWithSensitivity\u2019 element command.","title":"QuadWithSensitivity\n"},{"location":"library/5_Packages/optimization/modeling/560-QuadWithSensitivity%20Command/","text":"QuadWithSensitivity Command This command is used to construct a 2D four-node quadrilateral element object based on a bilinear isoparametric formulation. element quadWithSensitivity $eleTag $iNode $jNode $kNode $lNode $thick $type $matTag & lt ; $pressure $rho $b1 $b2 & gt ; tag integer tag identifying an existing parameter. iNode jnode kNode lNode four nodes defining element boundaries (numbered following a counter-clockwise order around the element). thick element thickness (constant). type string representing material behavior. Valid options depend on the nDMaterial object and the corresponding available material formulations. The \u2018type\u2019 parameter can be either \u201cPlaneStrain\u201d or \u201cPlaneStress\u201d. matTag tag associated with previously-defined NDMaterial object. pressure surface pressure (set temporarily equal to zero for DDM-based sensitivity analysis). rho element mass density (per unit volume) from which a lumped element mass matrix is computed (optional, default=0.0). b1 b2 constant body forces defined in the isoparametric domain (optional, default=0.0). All parameters are the same as those in the \u2018quad\u2019 element command. Currently there are no sensitivity parameters in the \u2018quadWithSensitivity\u2019 element command.","title":"QuadWithSensitivity Command\n"},{"location":"library/5_Packages/optimization/modeling/561-QuadWithSensitivity%20Element/","text":"QuadWithSensitivity Element This command is used to construct a 2D four-node quadrilateral element object based on a bilinear isoparametric formulation. element quadWithSensitivity $eleTag $iNode $jNode $kNode $lNode $thick $type $matTag & lt ; $pressure $rho $b1 $b2 & gt ; tag integer tag identifying an existing parameter. iNode jnode kNode lNode four nodes defining element boundaries (numbered following a counter-clockwise order around the element). thick element thickness (constant). type string representing material behavior. Valid options depend on the nDMaterial object and the corresponding available material formulations. The \u2018type\u2019 parameter can be either \u201cPlaneStrain\u201d or \u201cPlaneStress\u201d. matTag tag associated with previously-defined NDMaterial object. pressure surface pressure (set temporarily equal to zero for DDM-based sensitivity analysis). rho element mass density (per unit volume) from which a lumped element mass matrix is computed (optional, default=0.0). b1 b2 constant body forces defined in the isoparametric domain (optional, default=0.0). All parameters are the same as those in the \u2018quad\u2019 element command. Currently there are no sensitivity parameters in the \u2018quadWithSensitivity\u2019 element command.","title":"QuadWithSensitivity Element\n"},{"location":"library/5_Packages/optimization/modeling/620-Section%20Aggregator%20for%20Sensitivity/","text":"Section Aggregator for Sensitivity This command is used to construct a SectionAggregator object which groups previously-defined UniaxialMaterial objects into a single section force-deformation model. section Aggregator $secTag $matTag1 $string1 $matTag2 $string2 \u2026\u2026 & lt ; -section $sectionTag & gt ; secTag unique section object integer tag. $matTag1, \\(matTag2 \u2026</strong></p></td> <td><p>previously-defined UniaxialMaterial Objects.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) string1, $string2 \u2026 force-deformation relations corresponding to each section object. One of the following strings can be used. P axial force-deformation. Mz moment-curvature about section local z axis. Vy shear force-deformation along section local y-axis. My moment-curvature about section local y axis. Vz shear force-deformation along section local z-axis. T torsion force-deformation. Iy second moment of area about the local y-axis (optional, used for 3-D analysis). <-section $sectionTag> specifies a previously defined Section object (identified by the argument $sectionTag) to which these UniaxialMaterial objects are added to define a new Section object. The \u2018section Aggregator\u2019 command does not introduce additional sensitivity parameters. However, sensitivity parameters can be defined for each force-deformation relation used in the section aggragator.","title":"Section Aggregator for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/708-Transformation%20Constraint/","text":"Transformation Constraint This command is used to construct a multi-point constraint handler based on the transformation equation method. constraints Transformation Reference: Gu Q., Barbato M., Conte J.P. (2009) \u201cHandling of Constraints in Finite Element Response Sensitivity Analysis.\u201d Journal of Engineering Mechanics (ASCE), 135(12):1427-1438.","title":"Transformation Constraint\n"},{"location":"library/5_Packages/optimization/modeling/nDMaterial/","text":"NDmaterial commands nDmaterial commands Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration.","title":"NDmaterial commands\n"},{"location":"library/5_Packages/optimization/modeling/material/17-Aggregator/","text":"Aggregator This command is used to construct a SectionAggregator object which groups previously-defined UniaxialMaterial objects into a single section force-deformation model. section Aggregator $secTag $matTag1 $string1 $matTag2 $string2 \u2026\u2026 & lt ; -section $sectionTag & gt ; secTag unique section object integer tag. $matTag1, \\(matTag2 \u2026</strong></p></td> <td><p>previously-defined UniaxialMaterial Objects.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) string1, $string2 \u2026 force-deformation relations corresponding to each section object. One of the following strings can be used. P axial force-deformation. Mz moment-curvature about section local z axis. Vy shear force-deformation along section local y-axis. My moment-curvature about section local y axis. Vz shear force-deformation along section local z-axis. T torsion force-deformation. Iy second moment of area about the local y-axis (optional, used for 3-D analysis). <-section $sectionTag> specifies a previously defined Section object (identified by the argument $sectionTag) to which these UniaxialMaterial objects are added to define a new Section object. The \u2018section Aggregator\u2019 command does not introduce additional sensitivity parameters. However, sensitivity parameters can be defined for each force-deformation relation used in the section aggragator.","title":"Aggregator\n"},{"location":"library/5_Packages/optimization/modeling/material/189-Elastic/","text":"Elastic This command is used to construct a linear elastic uniaxial material object (with optional material damping) uniaxialMaterial Elastic $matTag $E < $eta > matTag unique material object integer tag E elastic stiffness eta damping stiffness (optional, default=0.0) Note: For this material class, the sensitivity parameters can be: E, eta","title":"Elastic\n"},{"location":"library/5_Packages/optimization/modeling/material/323-Hardening%20Material%20for%20Sensitivity/","text":"Hardening Material for Sensitivity This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. uniaxialMaterial Hardening $matTag $E $sigmaY $Hiso $Hkin matTag unique material object integer tag E initial tangent stiffness sigmaY yield stress (or force) Hiso isotropic hardening Modulus Hkin kinematic hardening Modulus Note: For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso","title":"Hardening Material for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/material/380-Material%20Commands/","text":"Material Commands :; uniaxialMaterial Commands Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType ? arg1 ? ... :; nDmaterial Commands Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. nDMaterial matType ? arg1 ? ...","title":"Material Commands\n"},{"location":"library/5_Packages/optimization/modeling/material/409-NDmaterialCommand/","text":"NDmaterialCommand nDMaterial matType ? arg1 ? ... Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration.","title":"NDmaterialCommand\n"},{"location":"library/5_Packages/optimization/modeling/material/410-NDmaterialCommands/","text":"NDmaterialCommands nDMaterial matType ? arg1 ? ... Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration.","title":"NDmaterialCommands\n"},{"location":"library/5_Packages/optimization/modeling/material/411-NDmaterial%20Commands/","text":"NDmaterial Commands nDMaterial matType ? arg1 ? ... Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration.","title":"NDmaterial Commands\n"},{"location":"library/5_Packages/optimization/modeling/material/630-Sensitivity%20interface%20at%20Material%20Level/","text":"Sensitivity interface at Material Level Return to Extension of an existing material,cross section, and element for DDM-based: The following functions need to be implemented in each material for sensitivity computation: int setParameter (const char **argv, int argc, Parameter &param); int updateParameter (int parameterID, Information &info); int activateParameter (int parameterID); double getStressSensitivity (int gradIndex, bool conditional); double getInitialTangentSensitivity (int gradIndex); int commitSensitivity (double strainGradient, int gradIndex, int numGrads); double getStrainSensitivity(int gradIndex);","title":"Sensitivity interface at Material Level\n"},{"location":"library/5_Packages/optimization/modeling/material/656-SmoothPSConcrete/","text":"SmoothPSConcrete This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. uniaxialMaterial SmoothPSConcrete $matTag $fc $fu $Ec $epso $epsu $eta matTag unique material object integer tag fc concrete compressive strength (positive for compression) fu concrete crushing strength (positive for compression Ec initial tangent stiffness epsco concrete strain at maximum strength (positive for compression) epsu concrete strain at crushing strength (positive for compression) eta smoothing parameter (default value = 0.2). Note: For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta","title":"SmoothPSConcrete\n"},{"location":"library/5_Packages/optimization/modeling/material/665-Steel01%20Material%20for%20Sensitivity/","text":"Steel01 Material for Sensitivity This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). uniaxialMaterial Steel01 $matTag $sigmaY $E $b & lt ; $a1 $a2 $a3 $a4 & gt ; matTag unique material object integer tag E initial tangent stiffness sigmaY yield strength b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent stiffness) a1 a2 a3 a4 isotropic hardening parameters: (optional, default: no isotropic hardening) Note: For this material class, the sensitivity parameters can be: E, sigmaY, b, a1, a2, a3, a4","title":"Steel01 Material for Sensitivity\n"},{"location":"library/5_Packages/optimization/modeling/material/670-SteelMP/","text":"SteelMP This command is used to construct a uniaxial Menegotto-Pinto steel material object. uniaxialMaterial SteelMP $matTag $sigmaY $E $b matTag unique material object integer tag sigmaY yield stress or force E initial tangent stiffness b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent) Note: For this material class, the sensitivity parameters can be: sigmaY, E, b \\[ \\begin{aligned} \\sigma^{*}=b \\cdot \\varepsilon^{*} &+\\frac{(1-b) \\cdot \\varepsilon^{*}}{\\left(1+\\left|\\varepsilon^{*}\\right|^{R}\\right)^{1 / R}} \\\\ \\varepsilon^{*} &=\\frac{\\varepsilon-\\varepsilon_{r}}{\\varepsilon_{y}-\\varepsilon_{r}} \\\\ \\sigma^{*} &=\\frac{\\sigma-\\sigma_{r}}{\\sigma_{y}-\\sigma_{r}} R &= R_{0}-\\frac{a_{1} \\cdot \\xi}{a_{2}+\\xi} \\\\ \\xi &= \\dfrac{\\max _{\\varepsilon}\\left|\\varepsilon_{\\max }-\\varepsilon_{y}\\right| }{\\varepsilon_{y,0}} \\end{aligned} \\] Reference: Barbato M., Conte J.P. (2006). \u201cFinite element structural response sensitivity and reliability analyses using smooth versus non-smooth material constitutive models.\u201d International Journal of Reliability and Safety, 1(1-2):3-39.","title":"SteelMP\n"},{"location":"library/5_Packages/optimization/modeling/material/732-UniaxialJ2Plasticity/","text":"UniaxialJ2Plasticity This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. uniaxialMaterial UniaxialJ2Plasticity $matTag $E $sigmaY $Hkin $Hiso matTag unique material object integer tag E initial tangent stiffness sigmaY yield stress (or force) Hkin kinematic hardening Modulus Hiso isotropic hardening Modulus Note: For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Reference: Conte J.P., Vijalapura P., Meghella M. (2003). \u201cConsistent finite element response sensitivities analysis.\u201d Journal of Engineering Mechanics (ASCE), 129(12):1380-1393.","title":"UniaxialJ2Plasticity\n"},{"location":"library/5_Packages/optimization/modeling/material/733-UniaxialMaterialCommand/","text":"UniaxialMaterialCommand uniaxialMaterial matType ? arg1 ? ... SteelMP This command is used to construct a uniaxial Menegotto-Pinto steel material object. SmoothPSConcrete This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. UniaxialJ2Plasticity This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. Hardening This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. Concrete01 This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). Steel01 This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). Elastic This command is used to construct a linear elastic uniaxial material object (with optional material damping).","title":"UniaxialMaterialCommand\n"},{"location":"library/5_Packages/optimization/modeling/material/734-UniaxialMaterialCommands/","text":"UniaxialMaterialCommands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType ? arg1 ? ... The type of material created and the additional arguments required depends on the matType? provided in the command. The following contain information about matType? and the args required for each of the available material types: </noinclude> SteelMP Material For this material class, the sensitivity parameters can be: sigmaY, E, b SmoothPSConcrete Material For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta UniaxialJ2Plasticity Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Hardening Material for Sensitivity For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Concrete01 Material For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu Steel01 Material for Sensitivity For this material class, the sensitivity parameters can be: E, sigmaY, b, a1, a2, a3, a4 Elastic Material For this material class, the sensitivity parameters can be: E, eta","title":"UniaxialMaterialCommands\n"},{"location":"library/5_Packages/optimization/modeling/material/735-UniaxialMaterial%20Command/","text":"UniaxialMaterial Command <noinclude>This command is used to construct a UniaxialMaterial object which represents uniaxial stress-strain (or force-deformation) relationships. uniaxialMaterial matType ? matTag ? arg1 ? ... The type of material created and the additional arguments required depends on the matType? provided in the command. NOTE: The valid queries to any uniaxial material when creating an ElementRecorder are \u2018strain,\u2019 \u2018stress,\u2019 and \u2018tangent.\u2019 Some materials have additional queries to which they will respond. These are documented in the NOTES section for those materials. The following contain information about matType? and the args required for each of the available material types: </noinclude> Steel &amp; Reinforcing-Steel Materials Steel01 Material Steel02 Material \u2013 Giuffr\u00e9-Menegotto-Pinto Model with Isotropic Strain Hardening Steel4 Material Hysteretic Material Reinforcing Steel Material Dodd Restrepo RambergOsgoodSteel Material SteelMPF - Menegotto and Pinto (1973) Model Extended by Filippou et al. (1983) UVCuniaxial (Updated Voce-Chaboche) Concrete Materials Concrete01 Material \u2013 Zero Tensile Strength Concrete02 Material \u2013 Linear Tension Softening Concrete04 Material \u2013 Popovics Concrete Material Concrete06 Material Concrete07 - Chang &amp; Mander\u2019s 1994 Concrete Model Concrete01 Material With Stuff in the Cracks ConfinedConcrete01 Material ConcreteD FRPConfinedConcrete ConcreteCM - Complete Concrete Model by Chang and Mander (1994) Some Standard Uniaxial Materials Elastic Uniaxial Material Elastic-Perfectly Plastic Material Elastic-Perfectly Plastic Gap Material Elastic-No Tension Material Parallel Material Series Material Other Uniaxial Materials CastFuse Material ViscousDamper Material BilinearOilDamper Material Modified Ibarra-Medina-Krawinkler Deterioration Model with Bilinear Hysteretic Response (Bilin Material) Modified Ibarra-Medina-Krawinkler Deterioration Model with Peak-Oriented Hysteretic Response (ModIMKPeakOriented Material) Modified Ibarra-Medina-Krawinkler Deterioration Model with Pinched Hysteretic Response (ModIMKPinching Material) SAWS Material BARSLIP Material Bond_SP01 - - Strain Penetration Model for Fully Anchored Steel Reinforcing Bars Fatigue Material Hardening Material Impact Material Hyperbolic Gap Material Limit State Material MinMax Material ElasticBilin Material ElasticMultiLinear Material MultiLinear Material Initial Strain Material Initial Stress Material PathIndependent Material Pinching4 Material Engineered Cementitious Composites Material SelfCentering Material Viscous Material BoucWen Material BWBN Material (Pinching Hysteretic Bouc-Wen Material) PyTzQz uniaxial materials for p-y, t-z and q-z elements for modeling soil-structure interaction through the piles in a structural foundation PySimple1 Material TzSimple1 Material QzSimple1 Material PyLiq1 Material TzLiq1 Material PySimple1Gen Command TzSimple1Gen Command KikuchiAikenHDR Material KikuchiAikenLRB Material AxialSp Material AxialSpHD Material Pinching Limit State Material CFSWSWP Wood-Sheathed Cold-Formed Steel Shear Wall Panel CFSSSWP Steel-Sheathed Cold-formed Steel Shear Wall Panel","title":"UniaxialMaterial Command\n"},{"location":"library/5_Packages/optimization/modeling/material/736-UniaxialMaterial%20Commands/","text":"UniaxialMaterial Commands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType ? arg1 ? ... Several uniaxial materials are available for DDM-based FE response sensitivity computation. SteelMP Material This command is used to construct a uniaxial Menegotto-Pinto steel material object. SmoothPSConcrete Material This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. UniaxialJ2Plasticity Material This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. Hardening Material for Sensitivity This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. Concrete01 Material This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). Steel01 Material for Sensitivity This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). Elastic Uniaxial Material This command is used to construct a linear elastic uniaxial material object (with optional material damping).","title":"UniaxialMaterial Commands\n"},{"location":"library/5_Packages/optimization/modeling/material/737-UniaxialMaterial%20commands/","text":"UniaxialMaterial commands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType ? arg1 ? ... The type of material created and the additional arguments required depends on the matType? provided in the command. The following contain information about matType? and the args required for each of the available material types: </noinclude> SteelMP Material For this material class, the sensitivity parameters can be: sigmaY, E, b SmoothPSConcrete Material For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta UniaxialJ2Plasticity Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Hardening Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Concrete01 Material For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu Steel01 Material For this material class, the sensitivity parameters can be: E, sigmaY, b, a1, a2, a3, a4 Elastic Material For this material class, the sensitivity parameters can be: E, eta","title":"UniaxialMaterial commands\n"},{"location":"library/5_Packages/optimization/modeling/material/87-Concrete01/","text":"Concrete01 This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). uniaxialMaterial Concrete01 $matTag $fc $epsco $fcu $epscu matTag unique material object integer tag fc concrete compressive strength (with positive value) epsco concrete strain at maximum strength (with positive value) fcu concrete crushing strength (with positive value) epscu concrete strain at crushing strength (with positive value) Note: For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu","title":"Concrete01\n"},{"location":"library/5_Packages/optimization/parameter/492-Parameter%20Command/","text":"Parameter Command In DDM-based FE response sensitivity analysis, the sensitivity parameters can be material, geometry or discrete loading parameters. Each parameter should be defined as: parameter $tag & lt ; specific object arguments & gt ; tag integer tag identifying the parameter. <specific object arguments> depend on the object in the FE model encapsulating the desired parameters. Note: Each parameter must be unique in the FE domain, and all parameter tags must be numbered sequentially starting from 1. EXAMPLE To identify the elastic modulus, E, of the material 1 at section 3 of element 4, the <specific object arguments> string becomes parameter 1 element 4 section 3 material 1 E To identify the elastic modulus, E, of elastic section 3 of element 4 (for elastic section, no specific material need to be defined), the <specific object arguments> string becomes: parameter 1 element 4 section 3 E To parameterize E for element 4 with material 1 (no section need to be defined), the <specific object arguments> string simplifies as: parameter 1 element 4 material 1 E Notice that the format of the <specific object arguments> is different for each considered element/section/material. The user is referred to the corresponding section of this manual for the specific set of parameters and the relative <specific object arguments> format.","title":"Parameter Command\n"},{"location":"library/5_Packages/optimization/parameter/742-UpdateParameter%20Command/","text":"UpdateParameter Command Once the parameters in FE model are defined, their value can be updated: updateParameter $tag $newValue tag integer tag identifying an existing parameter that is to be updated. <specific object arguments> the updated value to which the parameter needs to be set. Reference: Scott M.H., Haukaas T. (2008). \u201cSoftware framework for parameter updating and finite element response sensitivity analysis.\u201d Journal of Computing in Civil Engineering, 22(5):281-291.","title":"UpdateParameter Command\n"},{"location":"library/5_Packages/optimization/parameter/8-AddToParameter%20Command/","text":"AddToParameter Command In case that more objects (e.g., element, section) are mapped to an existing parameter, the following command can be used to relate these additional objects to the specific parameter: addToParameter $tag & lt ; specific object arguments & gt ; tag integer tag identifying an existing parameter. <specific object arguments> is the same as defined in the \u2019parameter\u2019 command.","title":"AddToParameter Command\n"},{"location":"library/5_Packages/optimization/reliability/130-Discovering%20OpenSees%20--%20Basic%20Reliability%20Analysis%20using%20OpenSees/","text":"Discovering OpenSees \u2013 Basic Reliability Analysis using OpenSees This seminar will occur March 27 at 2 p.m. (Pacific Time) and will be conducted by Prof. Michael Scott, Oregon State University Register for the seminar: March 27, 2:00 pm Pacific Time registration 1 This seminar will discuss how to perform basic reliability analysis using OpenSees. The following topics will be discussed: What is \u201cReliability Analysis\u201d How is it Done Using OpenSees Summary and conclusions Presentation Material of the seminar will be found here: Video","title":"Discovering OpenSees -- Basic Reliability Analysis using OpenSees\n"},{"location":"library/5_Packages/optimization/reliability/591-Reliability%20Analysis/","text":"Reliability Analysis This manual is intended to outline the basic commands currently available within the OpenSees interpreter for performing finite element reliability analysis. Reliability Primer Reliability Commands Reliability Examples References Scott, M.H. and Haukaas, T. \u201cSoftware Framework for Parameter Updating and Finite Element Reliability Analysis.\u201d Journal of Computing in Civil Engineering , 22(5):281-291, September 2008. DOI Haukaas, T. and Der Kiureghian, A. \u201cMethods and Object-Oriented Software for FE Reliability and Sensitivity Analysis with Application to a Bridge Structure.\u201d Journal of Computing in Civil Engineering , 21(3):151-163, May 2007. DOI Additional references will be listed here","title":"Reliability Analysis\n"},{"location":"library/5_Packages/optimization/reliability/594-Reliability%20Sensitivity%20Optimization/","text":"Reliability Sensitivity Optimization","title":"Reliability Sensitivity Optimization\n"},{"location":"library/5_Packages/optimization/reliability/595-Reliability%20Sensitivity%20and%20Optimization%20Modules/","text":"Reliability Sensitivity and Optimization Modules NOTOC Roadmap What is the Vision What are the short term goals Immediate (end of summer 2010!) achievable goals that can be deliverd that are useful to PEER, NEES!, and industry users. What are the long term goals What are the Limits Some elements and materials some of this just will not work for. need to be documented. What is the Product Seperate Module with clear interface to any FE code! Working Interface to OpenSees Documentation Explanation/THEORY (Armen & Terje) have a look: Optimization Portal on IT Earthquake Engineering Probabilistic Assessment of Structures! how to explain what these modules will do to a structural engineer. What does reliability, sensitivity and optimization mean in context of structural engineering What is the process List of References Command Manual for use with OpenSees (Mike, Kevin, Quan, Michele) Examples References: If you use this work, we would appreciate it if you would reference the papers below: Haukaas, T., Der Kiureghian, A. \u201cMethods and object-oriented software for FE reliability and sensitivity analysis with application to a bridge structure.\u201d ASCE Journal of Computing in Civil Engineering, 21(3), pp. 151-163, 2007. Design Based on Terje\u2019s original work, Kevin & Michaels changes. One new change all agree on is use of a new FunctionEvaluator class and introduction of some other class to store results in. <uml> abstract class FunctionEvaluator FunctionEvaluator <|\u2013 TclFunctionEvaluator FunctionEvaluator : double eval(const char * =0) </uml> Class Diagrams for Reliability","title":"Reliability Sensitivity and Optimization Modules\n"},{"location":"library/5_Packages/optimization/reliability/726-UML%20Reliability/","text":"UML Reliability Reliability <uml> package OpenSees #DDDDDD Domain \u2013 Analysis Domain \u2013 Recorder ModelBuilder \u2013 Domain end package package Reliability #CCCCCC ReliabilityDomain \u2013 ReliabilityAnalysis ReliabilityAnalysis <|\u2013 FORMAnalysis ReliabilityAnalysis <|\u2013 SORMAnalysis ReliabilityAnalysis <|\u2013 SORMAnalysis ReliabilityAnalysis <|\u2013 FOSMAnalysis ReliabilityAnalysis <|\u2013 OutCrossingAnalysis ReliabilityAnalysis <|\u2013 SamplingAnalysis ReliabilityAnalysis <|\u2013 SystemAnalysis end package </uml> Reliability Domain <uml> ReliabilityDomain o\u2013 RandomVariale ReliabilityDomain o\u2013 RandomVariablePositioner ReliabilityDomain o\u2013 CorrelationCoefficient ReliabilityDomain o\u2013 PerformanceFunction ReliabilityDomain o\u2013 Filter ReliabilityDomain o\u2013 ModulatingFunction ReliabilityDomain o\u2013 Spectrum </uml> Reliability Analysis <uml> ReliabilityAnalysis o\u2013 FindDesignPoint ReliabilityAnalysis o\u2013 SearchDirection ReliabilityAnalysis o\u2013 StepSizeRule ReliabilityAnalysis o\u2013 FindCurvatures ReliabilityAnalysis o\u2013 FunctionEvaluator ReliabilityAnalysis o\u2013 RandomNuberGenerator ReliabilityAnalysis o\u2013 GradGEvaluator ReliabilityAnalysis o\u2013 ProbabilityTransformation ReliabilityAnalysis o\u2013 MeritFunctionCheck ReliabilityAnalysis o- ConvergenceCheck </uml>","title":"UML Reliability\n"},{"location":"library/5_Packages/optimization/sensitivity/","text":"Sensitivity Analysis Created by: Quan Gu (Xiamen University, China), Joel P. Conte (UCSD), Michele Barbato (LSU), Yong Li (UCSD) This manual is intended to outline the basic commands currently available within the OpenSees interpreter for performing DDM ( Direct Differentiation Method )-based response sensitivity analysis. This interpreter is an extension of the Tcl/Tk language for use with OpenSees. The existing Tcl commands for Finite Element response-only computation are described in the OpenSees user\u2019s guide available online at http://opensees.berkeley.edu and, thus, are not repeated in this document. The notation used herein is the same as that used in the Tcl commands manual for response-only computation. Only new Tcl commands for DDM-based response sensitivity computation are presented and explained in detail. This manual is subdivided as follows: DDM-Based Response Sensitivity Computation Tcl Commands: commands added to the interpreter for response sensitivity computation. Demonstration Examples: five demonstration examples used to illustrate and validate the DDM-based response sensitivity analysis components implemented in OpenSees. Extension of an existing material,cross section, and element for DDM-based: the necessary functions needed for implementation of the DDM-based response sensitivity computation are listed and explained. Tcl input files for the provided application examples: Tcl input files for the above five application examples.","title":"Sensitivity Analysis\n"},{"location":"library/5_Packages/optimization/sensitivity/118-DDM-Based%20Response%20Sensitivity%20Computation%20Tcl%20Commands%3A/","text":"DDM-Based Response Sensitivity Computation Tcl Commands: Created by: Quan Gu (Xiamen University, China), Joel P. Conte (UCSD), Michele Barbato (LSU), Yong Li (UCSD) Return to Sensitivity Analysis User Page <!\u2013 INTRODUCTION \u2013> Introduction The following Analysis commands are added to the interpreter to create the Analysis and perform the analysis: <!\u2013 General commands \u2013> General Commands ::; reliability Command This command creates the reliability domain in which the sensitivity, reliability and optimization components are kept. This reliability domain is parallel to the finite element (FE) domain in OpenSees. Currently, the commands for stand-alone sensitivity analysis (e.g., sensitivityIntegrator, sensitivityAlgorithm) are set in the reliability domain only and, thus, the \u2018reliability\u2019 command must be used before any stand-alone sensitivity analysis. ::; parameter Command In DDM-based FE response sensitivity analysis, the sensitivity parameters can be material, geometry or discrete loading parameters. ::; addToParameter Command In case that more objects (e.g., element, section) are mapped to an existing parameter, the following command can be used to relate these additional objects to the specific parameter. ::; updateParameter Command Once the parameters in FE model are defined, their value can be updated. ::; sensitivityIntegrator Command Define the sensitivity integrator. ::; sensitivityAlgorithm Command Define the sensitivity algorithm. ::; recorder Commands To record the nodal response and response sensitivity. <!\u2013 Material Commands \u2013> Material Commands uniaxialMaterial commands Several uniaxial materials are available for DDM-based FE response sensitivity computation. SteelMP Material This command is used to construct a uniaxial Menegotto-Pinto steel material object. SmoothPSConcrete Material This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. UniaxialJ2Plasticity Material This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. Hardening Material for Sensitivity This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. Concrete01 Material This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). Steel01 Material for Sensitivity This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). Elastic Material This command is used to construct a linear elastic uniaxial material object (with optional material damping). nDmaterial commands Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration. <!\u2013 Section Commands \u2013> Section Commands Currently, only two cross-section models and the section aggregator have been extended for DDM-based FE response sensitivity computation. ::; Section Commands Fiber Both 2-D and 3-D fiber sections are available for response sensitivity computation. Elastic Both 2-D and 3-D elastic sections are available for response sensitivity computation. Aggregator This command is used to construct a SectionAggregator object which groups previously-defined UniaxialMaterial objects into a single section force-deformation model. <!\u2013 Element Commands \u2013> Element Commands Currently, several element types have been extended for DDM-based FE response sensitivity computation. ::; Element Commands dispBeamColumnWithSensitivity This command is used to construct a 2-D or 3-D distributed-plasticity displacement-based beam-column (frame) element. quadWithSensitivity This command is used to construct a 2D four-node quadrilateral element object based on a bilinear isoparametric formulation. bbarBrickWithSensitivity This command is used to construct an eight-node 3D brick element object based on a trilinear isoparametric formulation. <!\u2013 Constraint Commands \u2013> Constraint Commands Currently, several element types have been extended for DDM-based FE response sensitivity computation. ::; Constraint Commands Transformation This command is used to construct a multi-point constraint handler based on the transformation equation method.","title":"DDM-Based Response Sensitivity Computation Tcl Commands:\n"},{"location":"library/5_Packages/optimization/sensitivity/599-Response%20Sensitivity%20Analysis/","text":"Response Sensitivity Analysis This manual is intended to outline the basic commands currently available within the OpenSees interpreter for performing DDM-based response sensitivity analysis. This interpreter is an extension of the Tcl/Tk language for use with OpenSees. The existing Tcl commands for Finite Element response-only computation are described in the OpenSees user\u2019s guide available online at http://opensees.berkeley.edu and, thus, are not repeated in this document. The notation used herein is the same as that used in the Tcl commands manual for response-only computation. Only new Tcl commands for DDM-based response sensitivity computation are presented and explained in detail. This manual is subdivided as follows: DDM-Based Response Sensitivity Computation Tcl Commands: commands added to the interpreter for response sensitivity computation. Demonstration Examples: four demonstration examples used to illustrate and validate the DDM-based response sensitivity analysis components implemented in OpenSees. Extension of an existing material,cross section, and element for DDM-based: the necessary functions needed for implementation of the DDM-based response sensitivity computation are listed and explained. Tcl input files for the provided application examples: Tcl input files for the above four application examples.","title":"Response Sensitivity Analysis\n"},{"location":"library/5_Packages/optimization/sensitivity/625-SensitivityAlgorithm%20Command/","text":"SensitivityAlgorithm Command The most general command is the following, which computes the response sensitivity at each time/load step, after the response has converged. sensitivityAlgorithm - computeAtEachStep In those cases in which the sensitivity computation does not need to be performed at each step (e.g., for linear elastic systems : subjected to static pushover analysis), the sensitivity computation may be performed only at the time/load steps required by user: sensitivityAlgorithm - computeByCommand However, before using the \u2018-computeByCommand\u2019 option, it is the user\u2019s responsibility to make sure that the response sensitivities computation is not needed at each time/load step. For example, in case of incremental nonlinear FE analysis or dynamic analysis, using the \u2018-computeByCommand\u2019 option will produce wrong sensitivity results.","title":"SensitivityAlgorithm Command\n"},{"location":"library/5_Packages/optimization/sensitivity/626-SensitivityIntegrator%20Command/","text":"SensitivityIntegrator Command For static analysis, the only option currently available is the following, which must be defined before the \u2018analysis\u2019 command. sensitivityIntegrator - static For the dynamic case, currently only the Newmark algorithm is available. Two command need to be used together: integrator NewmarkWithSensitivity $gamma $beta gamma Newmark parameter gamma. beta Newmark parameter beta. sensitivityIntegrator - definedAbove Currently, \u2018-definedAbove\u2019 is the only option available in OpenSees. This means that the same integration scheme (i.e., \u2018NewmarkWithSensitivity\u2019) is used to perform both response and response sensitivity analysis. Reference: Haukaas T., Der Kiureghian A. (2004). \u201cFinite element reliability and sensitivity methods for performance-based earthquake engineering.\u201d Report No. 2003/14, Pacific Earthquake Engineering Research Center, April 2004. Haukaas T., Der Kiureghian A. (2005). \u201cParameter sensitivity and importance measures in nonlinear finite element reliability analysis.\u201d Journal of Engineering Mechanics (ASCE), 131(10):1013-1026.","title":"SensitivityIntegrator Command\n"},{"location":"other/","text":"Library Reference The opensees package can be divided by the following objectives: Modeling Analysis Runtime Utilities Post-processing Modeling Libraries opensees.element Materials opensees.uniaxial opensees.material opensees.backbone Sections opensees.section opensees.patch opensees.layer opensees.fiber Utilities opensees.units","title":"Library Reference"},{"location":"other/analysis/ConvergenceTest/CTestEnergyIncr/","text":"CTestEnergyIncr #include <convergenceTest/CTestEnergyIncr.h> class CTestEnergyIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestEnergyIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestEnergyIncr class tests using the energy increment, 0.5 times the absolute value of the dot product of the LinearSOE objects solution and rhs Vectors, and a user specified tolerance value. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol and the max number of iterations to be performed to maxNumIter . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if 0.5 times the absolute value of the dot product of the LinearSOE objects X and B Vectors is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.y","title":"CTestEnergyIncr\n"},{"location":"other/analysis/ConvergenceTest/CTestNormDispIncr/","text":"CTestNormDispIncr #include <convergenceTest/CTestNormDispIncr.h> class CTestNormDispIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestNormDispIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormDispIncr class tests using the norm of the solution Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects X Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormDispIncr\n"},{"location":"other/analysis/ConvergenceTest/CTestNormUnbalance/","text":"CTestNormUnbalance #include <convergenceTest/CTestNormUnbalance.h> class CTestNormUnbalance : public ConvergenceTest MovableObject ConvergenceTest A CTestNormUnbalance object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormUnbalance class tests using the norm of the right hand side Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects B Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 2, puts the tolerance value tol and numIncr in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 2, invokes recvVector() on theChannel , and sets the values of tol and numIncr . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormUnbalance\n"},{"location":"other/analysis/StaticIntegrator/","text":"Incremental-Iterative Analysis (reference)[https://onlinelibrary.wiley.com/doi/epdf/10.1002/nme.1620290702]","title":"Incremental-Iterative Analysis\n"},{"location":"other/analysis/StaticIntegrator/ArcLength/","text":"THE IMPLEMENTATION WILL HAVE TO CHANGE FOR DOMAIN-DECOMPOSITION ANALYSIS .. AS DOES THE CONVERGENCE TEST STUFF .. THIS IS BECAUSE USING DOT PRODUCTS OF VECTORS OBTAINED STRAIGHT FROM SYSTEM OF EQUATION .. MAYBE MODIFY LinearSOE TO DO THE DOT PRODUCT .. WILL WORK IN DD IF ALL USE ONE SOE .. WHAT PetSC DOES, TALK WITH P. DEMMEL ABOUT WHAT HE WILL PROVIDE. ArcLength #include <analysis/integrator/ArcLength.h> class ArcLength : public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator ArcLength is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using an arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation staticFormTaylor to produce a linear system of \\(N+1\\) unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of \\(N\\) unknowns using the method of ??(REF). Rewriting equation staticFormTaylor as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] substituting for \\(\\Delta {{\\bf U}_n^{(i)}}\\) using equation [splitForm$$ this can be expressed as: \\[\\Delta \\lambda_n^{(i)^2} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 \\right) + 2* \\Delta \\lambda_n^{(i)} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2d \\lambda^{(i)} \\right)\\] \\[+ \\left (\\Delta \\overline{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} \\right) =0\\] which is a quadratic in \\(\\Delta \\lambda_n^{(i)}\\) , which can be solved for two roots. The root chosen is the one which will keep a positive angle between the incremental displacement before and after this step. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\ Delta U$ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength\n"},{"location":"other/analysis/StaticIntegrator/ArcLength1/","text":"ArcLength1 #include <analysis/integrator/ArcLength1.h> class ArcLength1 : public StaticIntegrator MovableObject Integrator IncrementalIntegrator ArcLength1 is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a simplified form of the arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor$$ of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation [staticFormTaylor \\[ ](#staticFormTaylor){reference-type=\"ref\" reference=\"staticFormTaylor\"} to produce a linear system of $N+1$ unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of $N$ unknowns using the method of ??(REF). Rewriting equation [\\[staticFormTaylor\\] as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] For our ArcLength1 method we make the ADDITIONAL assumption that \\(2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)}\\) \\(>>\\) \\(\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2\\) the constraint equation at step \\(i\\) reduces to \\[{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] hence if the class was to solve an \\(N+1\\) system of equations at each step, the system would be: \\[\\left[ \\begin{array}{cc} {\\bf K}_n^{(i)} & -{\\bf P} \\\\ {d{\\bf U}^{(i)}}^T & \\alpha^2 d\\lambda^{(i)} \\end{array} \\right] \\left\\{ \\begin{array}{c} \\Delta {\\bf U}_n^{(i)} \\\\ \\Delta \\lambda_n^{(i)} \\end{array} \\right\\} = \\left\\{ \\begin{array}{c} \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) \\\\ 0 \\end{array} \\right\\}\\] instead of solving an \\(N+1\\) system, equation [splitForm$$ is used to give \\[{d{\\bf U}^{(i)}}^T \\left(\\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)}\\right) + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] which knowing \\(\\dot{\\bf U}_n^{(i)}\\) and \\(\\overline{\\bf U}_n^{(i)}\\) can be solved for \\(\\Delta \\lambda_n^{(i)}\\) \\[\\Delta \\lambda_n^{(i)} = -\\frac{{d{\\bf U}^{(i)}}^T \\Delta \\overline{\\bf U}_n^{(i)}}{{d{\\bf U}^{(i)}}^T \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)}}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength 1 (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\ Delta U$ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength1\n"},{"location":"other/analysis/TransientIntegrator/GeneralizedAlpha/","text":"GeneralizedAlpha \\(\\alpha_F\\) and \\(\\alpha_M\\) are defined differently than in the paper, we use \\(\\alpha_F = (1-\\alpha_f)\\) and \\(\\alpha_M=(1-\\gamma_m)\\) where \\(\\alpha_f\\) and \\(\\alpha_m\\) are those used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha_M = 1.0, \\alpha_F = 1.0\\) produces the Newmark Method. \\(\\alpha_M = 1.0\\) corresponds to the HHT method. The method is second-order accurate provided \\(\\gamma = \\tfrac{1}{2} + \\alpha_M - \\alpha_F\\) - The method is unconditionally stable provided \\(\\alpha_M >= \\alpha_F >= \\tfrac{1}{2}, \\beta>=\\tfrac{1}{4} +\\tfrac{1}{2}(\\gamma_M - \\gamma_F)\\) \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is unconditionally stable, second order accurate and high frequency dissipation is maximized. The defaults are: \\[\\gamma = \\tfrac{1}{2} + \\gamma_M - \\gamma_F\\] and \\[\\beta = \\tfrac{1}{4}(1 + \\gamma_M - \\gamma_F)^2\\] Theory The Generalized \\(\\alpha\\) method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. As with the HHT method, the following Newmark approximations are used: \\[ U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t} \\\\ \\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[ R_{t + \\alpha_M \\Delta t} = F_{t+\\Delta t}^\\text{ext} - M \\ddot U_{t + \\alpha_M \\Delta t} - C \\dot U_{t+\\alpha_F \\Delta t} - F^\\text{int}(U_{t + \\alpha_F \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[\\mathbf{d}_{t+ \\alpha_F \\Delta t} = (1 - \\alpha_F) U_t + \\alpha_F U_{t + \\Delta t} \\\\ \\mathbf{v}_{t+\\alpha_F \\Delta t} = (1-\\alpha_F) \\dot U_t + \\alpha_F \\dot U_{t + \\Delta t} \\\\ \\mathbf{a}_{t+\\alpha_M \\Delta t} = (1-\\alpha_M) \\ddot U_t + \\alpha_M \\ddot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, linearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\(K_{t+\\Delta t}^{*i} = \\alpha_F K_t + \\frac{\\alpha_F \\gamma}{\\beta \\Delta t} C_t + \\frac{\\alpha_M}{\\beta \\Delta t^2} M\\) and \\[ R_{t+\\Delta t}^i = F_{t + \\Delta t}^\\text{ext} - F(U_{t + \\alpha F \\Delta t}^{i-1})^\\text{int} - C \\dot U_{t+\\alpha F \\Delta t}^{i-1} - M \\ddot U_{t+ \\alpha M \\Delta t}^{i-1} \\] The linear equations are used to solve for \\(U_{t+\\alpha F \\Delta t}, \\dot U_{t + \\alpha F \\Delta t} \\ddot U_{t+ \\alpha M \\Delta t}\\) . Once convergence has been achieved the displacements, velocities and accelerations at time \\(t + \\Delta t\\) can be computed. REFERENCES J. Chung, G.M.Hubert. \u201cA Time Integration Algorithm for Structural Dynamics with Improved Numerical Dissipation: The Generalized- \\(\\alpha\\) Method\u201d ASME Journal of Applied Mechanics, 60, 371:375, 1993.","title":"GeneralizedAlpha\n"},{"location":"other/analysis/TransientIntegrator/HHT/","text":"HHT #include <analysis/integrator/HHT.h> class HHT : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator HHT is a subclass of TransientIntegrator which implements the Hilber-Hughes-Taylor (HHT) method. In the HHT method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , by solving the following equilibrium equation \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\alpha \\Delta t},{\\bf U}_{t + \\alpha \\Delta t})\\] where \\[{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) {\\bf U}_t + \\alpha {\\bf U}_{t + \\Delta t}\\] \\[\\dot{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] and the velocities and accelerations at time \\(t + \\Delta t\\) are determined using the Newmark relations. The HHT method results in the following for determining the response at \\(t + \\Delta t\\) \\[ \\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\alpha \\gamma}{\\beta \\Delta t} {\\bf C} + \\alpha {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)},{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)}\\right) \\] // Constructors // Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_HHT is passed to the TransientIntegrator constructor. \\(\\alpha\\) , \\(\\beta\\) and \\(\\gamma\\) are set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1\\alpha {\\bf K} + c2\\alpha \\D + c3 {\\bf M}\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group \\ * theDof ); This performs the following: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(8\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) , and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double \u0394t ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 ; c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta * \\Delta t)\\) and c3 to \\(1/ (\\beta * \\Delta t^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) are set using the difference approximations. \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 ${\\bf U}_{t + \\alpha \\Delta t} = {\\bf U}_t$\\ \\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t \\] \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} = (1 - \\alpha) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements and velocities at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & \u0394U ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The displacement Vector at time \\(t + \\alpha \\Delta t\\) is incremented by \\(c1 \\alpha \\Delta U\\) and the velocity Vector by \\(c2 \\alpha \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement and velocity at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. ::: {.tabbing} while \u0304 while w\u0304hile \u0304 \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) \\({\\bf U}_{t + \\alpha \\Delta t} += \\alpha \\Delta \\U\\) \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} += \\frac{\\alpha \\gamma}{\\beta \\Delta t} \\Delta \\U\\] theModel -> setResponse ( U_t_alpha_\u0394t , \\ dot { \\ bf U } _ { t + \\ alpha \\ Delta t }, \\ ddot { \\ bf U } _ { t + \\ Delta t }) theModel -> updateDomain () Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"HHT\n"},{"location":"other/analysis/TransientIntegrator/Newmark/","text":"Newmark #include <analysis/integrator/Newmark.h> class Newmark: public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator Newmark is a subclass of TransientIntegrator which implements the Newmark method. In the Newmark method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , the equilibrium equation (expressed for the TransientIntegrator) is typically solved at time \\(t + \\Delta t\\) for \\({\\bf U}_{t+\\Delta t}\\) , i.e. solve: \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] for \\({\\bf U}_{t+\\Delta t}\\) . The following difference relations are used to relate \\(\\dot{\\bf U}_{t + \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\Delta t}\\) to \\({\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\Delta t} = \\frac{\\gamma}{\\beta \\Delta t} \\left( {\\bf U}_{t + \\Delta t} - {\\bf U}_t \\right) + \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = \\frac{1}{\\beta {\\Delta t}^2} \\left( {\\bf U}_{t+\\Delta t} - {\\bf U}_t \\right) - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] which results in the following \\[\\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\gamma}{\\beta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] An alternative approach, which does not involve \\(\\Delta t\\) in the denumerator (useful for impulse problems), is to solve for the accelerations at time \\(t + \\Delta t\\) \\[{\\bf R} (\\ddot{\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] where we use following functions to relate \\({\\bf U}_{t + \\Delta t}\\) and \\(\\dot{\\bf U}_{t + \\Delta t}\\) to \\(\\ddot{\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\left[ \\left(\\frac{1}{2} - \\beta\\right)\\ddot{\\bf U}_t + \\beta \\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t^2\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\left[ \\left(1 - \\gamma\\right)\\ddot{\\bf U}_t + \\gamma\\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t\\] which results in the following \\[\\left[ {\\bf M} + \\gamma \\Delta t {\\bf C} + \\beta \\Delta t^2 {\\bf K} \\right] \\Delta \\ddot{\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] Constructors ### Destructor // Public Methods // Public Methods for Output Sets \\(\\gamma\\) to \\(1/2\\) and \\(\\beta\\) to \\(1/4\\) . Sets a flag indicating whether the incremental solution is done in terms of displacement, \\(\\Delta \\U\\) , if dispFlag is true , or acceleration, \\(\\Delta \\ddot \\U\\) , if dispFlag is false . In addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\gamma\\) to gamma and \\(\\beta\\) to beta . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\gamma\\) to gamma , \\(\\beta\\) to beta , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 {\\bf K} + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. The method returns \\(0\\) after performing the following operations: if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group * theDof ); The method returns \\(0\\) after performing the following operations: theDof -> zeroUnbalance () if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\ Delta t$ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 depending on the flag indicating whether incremental displacements or accelerations are being solved for at each iteration. If dispFlag was true , c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta \\Delta t)\\) and c3 to \\(1/ (\\beta \\Delta t^2)\\) . If the flag is false c1 is set to \\(\\beta \\Delta t^2\\) , c2 to \\(\\gamma \\Delta t\\) and c3 to \\(1.0\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) are set using the difference approximations if dispFlag was true . (displacement and velocity if false ). if (displIncr == true) { \\(\\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\) } else { \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\frac{\\Delta t^2}{2}\\ddot{\\bf U}_t\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\Delta t \\ddot{\\bf U}_t\\) } The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with new quantities for time \\(t + \\Delta t\\) . theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response at the DOF_Group objects are then updated by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. if (displIncr == true) { \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) } else { \\(\\ddot{\\bf U}_{t + \\Delta t} += \\Delta \\Udd\\) \\({\\bf U}_{t + \\Delta t} += \\beta \\Delta t^2 \\Delta \\Udd\\) \\(\\dot{\\bf U}_{t + \\Delta t} += \\gamma \\Delta t \\Delta \\Udd\\) } theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) theModel- \\(>\\) setUpdateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\delta U\\) are of different sizes. int sendSelf(int commitTag, Channel &theChannel); Places in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, \\(\\gamma\\) is set to 0.5, \\(\\beta\\) to 0.25 and the Rayleigh damping flag set to false , and a \\(-1\\) is returned, if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"Newmark\n"},{"location":"other/analysis/TransientIntegrator/WilsonTheta/","text":"WilsonTheta #include <analysis/integrator/WilsonTheta.h> class WilsonTheta : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator WilsonTheta is a subclass of TransientIntegrator which implements the Wilson- \\(\\Theta\\) method. In the Wilson- \\(\\Theta\\) method, to determine the velocities, accelerations and displacements at time \\(t + \\theta \\Delta t\\) , \\(\\theta \\ge 1.37\\) , for \\({\\bf U}_{t+ \\theta \\Delta t}\\) \\[{\\bf R} ({\\bf U}_{t + \\theta \\Delta t}) = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+ \\theta \\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\theta \\Delta t},{\\bf U}_{t + \\theta \\Delta t})\\] where we use following functions to relate \\(\\dot{\\bf U}_{t + \\theta \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\theta \\Delta t}\\) to \\({\\bf U}_{t + \\theta \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\theta \\Delta t} = \\frac{3}{\\theta \\Delta t} \\left( {\\bf U}_{t + \\theta \\Delta t} - {\\bf U}_t \\right) - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\theta \\Delta t} = \\frac{6}{\\theta^2 \\Delta t^2} \\left( {\\bf U}_{t+\\theta \\Delta t} - {\\bf U}_t \\right) - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\] which results in the following for determining the responses at \\(t + \\theta \\Delta t\\) \\[\\left[ \\frac{6}{\\theta^2 \\Delta t^2} {\\bf M} + \\frac{3}{\\theta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\theta \\Delta t}^{(i)} = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\theta \\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\theta \\Delta t}^{(i-1)},{\\bf U}_{t + \\theta \\Delta t}^{(i-1)}\\right)\\] The response quantities at time \\(t + \\Delta t\\) are then determined using the following \\[\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\] \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_WilsonTheta is passed to the TransientIntegrator constructor. \\(\\Theta\\) is set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 \\K + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group * theDof ); This performs the following: theDof -> zeroUnbalance () if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) (between newStep() and commit() the \\(t + \\Delta t\\) quantities store \\(t + \\Theta \\Delta t\\) quantities). The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\ Delta t$ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 : c1 is set to \\(1.0\\) , c2 to \\(3 / (\\Theta \\Delta t)\\) and c3 to \\(6 / (\\Theta \\Delta t)^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Theta \\Delta t\\) are set using the difference approximations, \\({\\bf U}_{t + \\theta \\Delta t} = {\\bf U}_t\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} = - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} = - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\) The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Theta \\Delta t\\) . \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\theta \\Delta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\] current time is obtained from the AnalysisModel, incremented by \\(\\Theta \\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\ Delta U$ ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Theta \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements, velocities and accelerations at time \\(t + \\Theta \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. \\({\\bf U}_{t + \\theta \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} += \\frac{3}{\\theta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} += \\frac{6}{\\theta^2 \\Delta t^2} \\Delta \\U\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\alpha \\theta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\) theModel- \\(>\\) updateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the quantities at time \\(t + \\Delta t\\) are determined using the quantities at time \\(t\\) and \\(t + \\Theta \\Delta t\\) . Then the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . The time is obtained from the AnalysisModel and \\((\\Theta - 1) \\Delta t\\) is subtracted from the value. The time is set in the Domain by invoking setCurrentDomainTime(time) on the AnalysisModel. Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. \\(\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\) \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+ \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) time = theModel- \\(>\\) getDomainTime() time -= \\((\\theta -1) * \\Delta t\\) theModel- \\(>\\) setTime(time) theModel- \\(>\\) commitDomain() Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places \\(\\Theta\\) , rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) in a vector if size 4 and invokes sendVector on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 4 the value of \\(\\Theta\\) , the rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) .. Returns \\(0\\) if successful, a warning message is printed, \\(\\Theta\\) is set to \\(0\\) , the rayleigh damping flag to false , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) .","title":"WilsonTheta\n"},{"location":"other/analysis/constraint_enforcement/Lagrange/","text":"Lagrange This command is used to construct a LagrangeMultiplier constraint handler, which enforces the constraints by introducing Lagrange multiplies to the system of equation. The following is the command to construct a plain constraint handler: constraints Lagrange < $alphaS $alphaM > $alphaS \\(\\alpha_S\\) factor on singe points. optional, default = 1.0 $alphaM \\(\\alpha_M\\) factor on multi-points, optional default = 1.0; NOTES: The Lagrange multiplier method introduces new unknowns to the system of equations. The diagonal part of the system corresponding to these new unknowns is 0.0. This ensure that the system IS NOT symmetric positive definite. THEORY: Code Developed by: fmk C++ Interface #include <analysis/handler/LagrangeConstraintHandler.h> class LagrangeConstraintHandler : public ConstraintHandler ; The LagrangeConstraintHandler class is a class which deals with both single and multi point constraints using the Lagrange method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating a LagrangeDOF_Group object and either a LagrangeSP_FE or a LagrangeMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by modifying the tangent matrix and residual vector. The integer HANDLER_TAG_LagrangeConstraintHandler (defined in <classTags.h> ) is passed to the LagrangeConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the LagrangeSP_FE and LagrangeMP_FE objects in handle() . Destructor Currently invokes clearAll() , this will change when clearAll() is rewritten. Methods Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mappinging between Elements and FE_Elements, SP_Constraints and LagrangeSP_FEs, MP_Constraints and LagrangeMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a LagrangeSP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a LagrangeMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf ( int commitTag , Channel & theChannel ); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Lagrange\n"},{"location":"other/analysis/constraint_enforcement/Penalty/","text":"Penalty #include <analysis/handler/PenaltyConstraintHandler.h> class PenaltyConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The PenaltyConstraintHandler class is a class which deals with both single and multi point constraints using the penalty method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a PenaltySP_FE or a PenaltyMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PenaltyConstraintHandler (defined in <classTags.h> ) is passed to the PenaltyConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the PenaltySP_FE and PenaltyMP_FE objects in handle() . Currently invokes clearAll() , this will change when clearAll() is rewritten. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements, SP_Constraints and PenaltySP_FEs, MP_Constraints and PenaltyMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a PenaltySP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a PenaltyMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Penalty\n"},{"location":"other/analysis/constraint_enforcement/Plain/","text":"Plain #include <analysis/handler/PlainHandler.h> class PlainHandler: public ConstraintHandler MovableObject ConstraintHandler The PlainHandler class is a class which only deals with homogeneous single point constraints. To do this it creates regular FE_Element and DOF_Group objects and enforces the constraints by specifying that degrees-of-freedom which are constrained are not assigned an equation number. Pointers to the DOF_Group and FE_Element objects are kept in two arrays. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PlainHandler (defined in <classTags.h> ) is passed to the PlainHandler constructor. Invokes the destructor on all the FE_Element and DOF_Group objects created in handle . Then invokes the destructor on the two pointer arrays. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements and Nodes and DOF_Groups) Creates two arrays of pointers to store the FE_elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) if no SP_Constraint exists for the dof, or \\(-1\\) if a SP_Constraint exists or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. If any MP_Constraint objects exist in the Domain a warning message is printed and \\(-6\\) is returned. If all is successful, the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Returns \\(0\\) . int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) .","title":"Plain\n"},{"location":"other/analysis/constraint_enforcement/Transformation/","text":"Transformation UNDER CONSTRUCTION. #include <analysis/handler/TransformationConstraintHandler.h> class TransformationConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The TransformationConstraintHandler class is a class which deals with both single and multi point constraints using the Transformation method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a TransformationSP_FE or a TransformationMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_TransformationConstraintHandler (defined in <classTags.h> ) is passed to the TransformationConstraintHandler constructor. Currently invokes clearAll() , this will change when clearAll() is rewritten.","title":"Transformation\n"},{"location":"other/analysis/nonlinear_solve/Linear/","text":"Linear #include <analysis/algorithm/equiSolnAlgo/Linear.h> class Linear : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The Linear class is an algorithmic class which uses the linear solution algorithm to solve the equations. This is based on a Taylor expansion of the linear system \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}_{a}\\) . \\[\\R(\\U) = \\R({\\bf U}_{a}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}_{a}}\\right] \\left( {\\bf U} - {\\bf U}_{a} \\right)\\] which can be expressed as: \\[{\\bf K}_{a} \\Delta {\\bf U} = {\\bf R}({\\bf U}_{a})\\] which is solved for \\(\\Delta \\U\\) to give the approximation \\({\\bf U} = {\\bf U}_{a} + \\Delta \\U\\) . To start the iteration \\({\\bf U}_a = {\\bf U}_\\text{trial}\\) , i.e. the current trial response quantities are chosen as approximate solution quantities. Constructor Destructor Public Methods // Public Methods for Output The integer EquiALGORITHM_TAGS_Linear (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. This method performs the linear solution algorithm: // form {\\bf K}_{a} theIntegrator -> formTangent () // form \\R({\\bf U}_{a}) theIntegrator -> formUnbalance () // solve for \\Delta \\U theSOE -> solveX () // set U = Ua + DU theIntegrator -> update ( theSOE -> getX ()) The method returns a 0 if successful, otherwise warning message is printed and a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. int sendSelf ( int commitTag , Channel & theChannel ); Does nothing. Returns 0. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Does nothing. Returns 0. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string 'Linear Algorithm' to the stream.","title":"Linear\n"},{"location":"other/analysis/nonlinear_solve/ModifiedNewton/","text":"ModifiedNewton #include <analysis/algorithm/equiSolnAlgo/ModifiedNewton.h> class ModifiedNewton : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The ModifiedNewton class is an algorithmic class which obtains a solution to a non-linear system using the modified Newton-Raphson iteration scheme. The Newton-Rapson iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\(\\U{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[\\ {\\bf K}^{(i)} \\Delta \\U{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. in the modified version the tangent is formed only once, i.e \\[\\ {\\bf K}^{(1)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors and Destructors The constructor takes as an argument the ConvregenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_ModifiedNewton (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_ModofiedNewton. recvSelf() must be invoked on this object. ~ ModifiedNewton (); Does nothing. Public Methods int solveCurrentStep ( void ); When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the modified Newton-Raphson iteration algorithm: theTest -> start (); theIntegrator -> formTangent (); do { theIntegrator -> formUnbalance (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. void setTest ( ConvergenceTest & theTest ); A method to set the tolerance criteria of the algorithm to be equal to the value theTol . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018ModifiedNewton\u2019 to the stream if flag equals \\(0\\) .","title":"ModifiedNewton\n"},{"location":"other/analysis/nonlinear_solve/NewtonRaphson/","text":"NewtonRaphson C++ Interface #include <analysis/algorithm/equiSolnAlgo/NewtonRaphson.h> class NewtonRaphson : public EquiSolnAlg ; MovableObject / SolutionAlgorithm / EquiSolnAlgo The NewtonRaphson class is an algorithmic class which obtains a solution to a non-linear system using the Newton-Raphson iteration scheme. The iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}^{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[ {\\bf K}^{(i)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors Destructor // Public Member Functions // Public Methods for Output The constructor takes as an argument the ConvergenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_NewtonRaphson (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_NewtonRaphson is passed. recvSelf() must be invoked on this object. Does nothing. When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the Newton-Raphson iteration algorithm: theTest -> start () theIntegrator -> formUnbalance (); do { theIntegrator -> formTangent (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); theIntegrator -> formUnbalance (); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. NOTE it is up to ConvergenceTest to ensure an infinite loop situation is not encountered. void setTest ( ConvergenceTest & theTest ); A method to set the ConvergenceTest object associated with the Algorithm to be theTest . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. * int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018NewtonRaphson\u2019 to the stream if flag equals \\(0\\) .","title":"NewtonRaphson\n"},{"location":"other/modeling/","text":"Modeling Capabilities Elements ( opensees.element ) Beam-column \u2013 3D elements with the following integration rules Linear elastic material (closed form), Concentrated plasticity integrated over specified hinge lengths, or Distributed plasticity integrated along the element length. Zero length \u2013 3D element which uses multiple uniaxial materials to model the element force-deformation relation. Truss \u2013 3D element with material non-linearity modeled by Uniaxial material stress-strain integrated over cross-sectional area, or Section force-deformation relationship. Quad \u2013 2D bilinear isoparametric element which uses ND materials at each of its integration points. Geometric Transforms Linear \u2013 first order geometry, P-Delta \u2013 second order \u201cleaning truss\u201d transformation, or Corotational \u2013 large displacement transformation. Cross Sections ( openseees.section ) Fiber \u2013 discretized by fibers which collectively define section response. The fiber models available are opensees.patch opensees.fiber opensees.layer Elastic \u2013 uncoupled axial and bending response. Uniaxial2d/3d \u2013 associates with a uniaxial material and enforces the Bernoulli beam assumption for axial and uni/bi-directional bending Generic1d/Nd \u2013 map stresses from uniaxial and ND materials to section stress resultants. For example, a uniaxial material can be used to model section moment-curvature behavior, or an ND plasticity model can be used to model section moment-axial-shear interaction. Aggregator \u2013 combination of a section and multiple uncoupled uniaxial materials used to define additional section force-deformation relations. For example, a fiber section can be combined with an uncoupled shear force-deformation relation. Backbone Materials Popovic\u2019s (Mander) Hognestad (Kent-Park) Uniaxial Materials ( opensees.uniaxial ) Core Elastic \u2013 linear elastic material tangent with optional linear damping tangent ElasticPP \u2013 elastic-perfectly plastic ElasticPPGap \u2013 one-sided EPP with an initial gap Hardening \u2013 bilinear model with combined linear isotropic and kinematic hardening Parallel \u2013 multiple uniaxial materials in parallel Series \u2013 multiple uniaxial materials in series FEDEAS Steel01 \u2013 bilinear steel model with linear kinematic and exponential isotropic hardening Concrete01 \u2013 concrete model with Kent-Park envelope, degraded linear unloading/reloading, and no tensile strength Hysteretic \u2013 trilinear backbone with pinching, damage, and degraded unloading stiffness SNAP BiLinear \u2013 bilinear hysteretic model with degradation Clough \u2013 Clough type hysteretic model with degradation Pinch \u2013 pinching hysteretic model with degradation ND Materials ElasticIsotropic \u2013 plane stress and plane strain formulations for use with the quad element.","title":"Modeling Capabilities\n"},{"location":"other/modeling/constraint/rigidBeam/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } RigidBeam RigidBeamLink (name, nodes, **kwds) name Tag nodes [nodes1,nodes2] nodes1 Ref(uniaxial) nodes2 Ref(uniaxial)","title":"RigidBeam\n"},{"location":"other/modeling/damping/rayleigh/","text":"Rayleigh","title":"Rayleigh\n"},{"location":"other/modeling/nD/BidirectionalMaterial/","text":"BidirectionalMaterial #include <material/nD/BidirectionalMaterial.h> class BidirectionalMaterial : public NDMaterial TaggedObject MovableObject Material NDMaterial BidirectionalMaterial is an implementation of NDMaterial. BidirectionalMaterial is a two-dimensional elasto-plastic material model with combined linear isotropic and kinematic hardening. The yield surface is circular with a specified radius. A radial return map algorithm is used in the state determination. Constructors Destructor // Public Methods // Public Methods for Output Constructs a BidirectionalMaterial whose unique integer among NDMaterials in the domain is given by tag . Sets the elastic modulus to E , initial yield stress to fy , and isotropic and kinematic hardening moduli to Hiso and Hkin , respectively. Sets all committed history variables to \\(0.0\\) . The integers tag and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Constructs a BidirectionalMaterial with tag 0. All material parameters and committed history variables are set to \\(0.0\\) . The integers 0 and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Does nothing. Sets the trial strain of this material to be strain . Returns 0. Returns the current trial strain of this material. Returns the current stress computed by the radial return mapping algorithm. This is the 2d generalization of the 1d algorithm described in Simo & Hughes (1998), Box \\(1.5\\) . Returns the tangent consistent with the stress computed by the radial return mapping algorithm in getStress() . Sets the committed history variables to be their corresponding trial values. Returns 0. Does nothing. Returns 0. Sets all committed history variables to \\(0.0\\) . Returns 0. Returns a pointer to a new instance of BidirectionalMaterial with the same tag, elastic modulus, initial yield stress, and hardening moduli. Copies the committed history variables to the new object. It is up to the caller to invoke the destructor. Returns 0 if successful and a negative number if any of the send operation fails. Returns 0 if successful and a negative number if any of the receive operation fails. Prints the tag of this object and its elastic modulus, initial yield stress, and hardening moduli to the stream s .","title":"BidirectionalMaterial\n"},{"location":"other/modeling/nD/ElasticIsotropicPlaneStrain2D/","text":"ElasticIsotropicPlaneStrain2D #include <material/nD/ElasticIsotropicPlaneStrain2D.h> class ElasticIsotropicPlaneStrain2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStrain2D provides the implementation of an elastic isotropic material which exhibits plane strain behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStrain2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ \\begin{array}{ccc} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & 1-2\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStrain2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStrain2D\n"},{"location":"other/modeling/nD/ElasticIsotropicPlaneStress2D/","text":"ElasticIsotropicPlaneStress2D #include <material/nD/ElasticIsotropicPlaneStress2D.h> class ElasticIsotropicPlaneStress2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStress2D provides the implementation of an elastic isotropic material which exhibits plane stress behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStress2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{1-\\nu^2} \\left[ \\begin{array}{ccc} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & 1-\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStress2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStress2D\n"},{"location":"other/modeling/section/GenericSection1D/","text":"GenericSection1D #include <material/section/GenericSection1D.h> class GenericSection1D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSection1D provides a wrapper around a UniaxialMaterial so that any UniaxialMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSection1D whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the UniaxialMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the UniaxialMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the UniaxialMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the UniaxialMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Sets the section flexibility matrix, \\(\\fsec\\) , to be the inverse of the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\fsec\\) . This function overrides the base class implementation. Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. This function overrides the base class implementation. Invokes commitState() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToStart() on the UniaxialMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSection1D, using the same tag, UniaxialMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantity returned by this instance of GenericSection1D. Returns 1. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the UniaxialMaterial using the same values of s and flag .","title":"GenericSection1D\n"},{"location":"other/modeling/section/GenericSectionND/","text":"GenericSectionND #include <material/section/GenericSectionND.h> class GenericSectionND : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSectionND provides a wrapper around a NDMaterial so that any NDMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSectionND whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the NDMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the NDMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the NDMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the NDMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the NDMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Invokes commitState() on the NDMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the NDMaterial and returns the result of that invocation. Invokes revertToStart() on the NDMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSectionND, using the same tag, NDMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantities returned by this instance of GenericSectionND. Returns the result of invoking getOrder() on the NDMaterial. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the NDMaterial using the same values of s and flag .","title":"GenericSectionND\n"}]}