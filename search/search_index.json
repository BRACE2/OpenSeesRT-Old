{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".home-feature { justify-content: space-between !important; align-items: center !important; display: flex !important; margin-top: 3rem !important; margin-bottom: 3rem !important; } anabel anabel Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Get Started Guides View guides that explain the concepts and components of anabel . API Documentation Peruse a comprehensive list of functions provided by anabel , with detailed explanations of their interfaces. Gallery Walk through some examples of the various analysis procedures that anabel provides. Inelasticity Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Partial Differential Equations Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Reliability Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.","title":""},{"location":"contrib/analysis/integrator/154-Displacement%20Control/","text":"Displacement Control This command is used to construct a DisplacementControl integrator object. In an analysis step with Displacement Control we seek to determine the time step that will result in a displacement increment for a particular degree-of-freedom at a node to be a prescribed value. integrator DisplacementControl $node $dof \\(incr &lt;\\) numIter $<math>U </math> \\(&lt;math&gt;\\Delta U \\text{max}&lt;/math&gt;&gt;</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">node</code></p></td> <td><p>node whose response controls solution</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">dof</code></p></td> <td><p>degree of freedom at the node, valid options: 1 through ndf at node.</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">incr</code></p></td> <td><p>first displacement increment &lt;math&gt;\\Delta U_{\\text{dof}}&lt;/math&gt;</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">numIter</code></p></td> <td><p>the number of iterations the user would like to occur in the solution algorithm. Optional, default = 1.0.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) <math>U </math> the min stepsize the user will allow. optional, defualt = <math>U_{min} = U_0</math> $<math>U </math> the max stepsize the user will allow. optional, default = <math>U_{max} = U_0</math> Examples integrator DisplacementControl 1 2 0.1; # displacement control algorithm seking constant increment of 0.1 at node 1 at 2\u2019nd dof. Theory If we write the governing finite element equation at <math>t + t!</math>as: <math> R(U_{t+t}, {t+t}) = {t+ t} F^{ext} - F(U_{t+t}) !</math> where <math>F(U_{t+t})!</math> are the internal forces which are a function of the displacements <math>U_{t+ t}!</math>, <math>F^{ext}!</math> is the set of reference loads and <math>!</math> is the load multiplier. Linearizing the equation results in: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = \\left ( \\lambda^i_{t+\\Delta t} + \\Delta \\lambda^i \\right ) F^{ext} - F(U_{t+\\Delta t})\\] This equation represents n equations in \\(n+1\\) unknowns, and so an additional equation is needed to solve the equation. For displacement control, we introduce a new constraint equation in which in each analysis step we set to ensure that the displacement increment for the degree-of-freedom \\(\\text{dof}\\) at the specified node is: <math> U_ = !</math> MORE TO COME: In Displacement Control the \\(\\Delta_U\\text{dof}\\) set to <math>t + _{t+1}</math> where, \\[\\Delta U_\\text{dof}^{t+1} = \\max \\left ( \\Delta U_{min}, \\min \\left ( \\Delta U_\\text{max}, \\frac{\\text{numIter}}{\\text{lastNumIter}} \\Delta U_\\text{dof}^{t} \\right ) \\right ) \\] Code Developed by: fmk","title":"Displacement Control\n"},{"location":"contrib/analysis/integrator/231-Explicit%20Difference/","text":"Explicit Difference This command is used to construct a Explicit Difference integrator object. integrator Explicitdifference Examples integrator Explicitdifference NOTES: When using Rayleigh damping, the damping ratio of high vibration modes is overrated, and the critical time step size will be much smaller. Hence Modal damping is more suitable for this method. There should be no zero element on the diagonal of the mass matrix when using this method. Diagonal solver should be used when lumped mass matrix is used because the equations are uncoupled. For stability, Theory The Explicit Difference Integrator is based on the Leap-frog method. The basic formula of Leap-frog method is shown as below: As mass matrix M is a diagonal matrix, the equations can be uncoupled, then the solution procedure will be very efficient. Code Developed by: Shuhao Zhang, Tsinghua University, and Prof. Xinzheng Lu, Tsinghua University","title":"Explicit Difference\n"},{"location":"contrib/analysis/integrator/24-Arc-Length%20Control/","text":"Arc-Length Control This command is used to construct an ArcLength integrator object. In an analysis step with ArcLength we seek to determine the time step that will result in our constraint equation being satisfied. integrator ArcLength $s $alpha s \\(s\\) the arcLength. alpha \\(\\alpha\\) a scaling factor on the reference loads. Examples integrator ArcLength 1.0 0.1; Theory If we write the governing finite element equation at <math>t + t!</math>as: <math> R(U_{t+t}, {t+t}) = {t+ t} F^{ext} - F(U_{t+t}) !</math> where <math>F(U_{t+t})!</math> are the internal forces which are a function of the displacements <math>U_{t+ t}!</math>, <math>F^{ext}!</math> is the set of reference loads and <math>!</math> is the load multiplier. Linearizing the equation results in: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = \\left ( \\lambda^i_{t+\\Delta t} + \\Delta \\lambda^i \\right ) F^{ext} - F(U_{t+\\Delta t})\\] This equation represents n equations in \\(n+1\\) unknowns, and so an additional equation is needed to solve the equation. For displacement control, we introduce a new constraint equation in which in each analysis step we set to ensure that the displacement increment for the degree-of-freedom \\(\\text{dof}\\) at the specified node is: <math> !</math> MORE TO COME: Code Developed by: fmk","title":"Arc-Length Control\n"},{"location":"contrib/analysis/integrator/277-Generalized%20Alpha%20Method/","text":"Generalized Alpha Method This command is used to construct a Generalized \\(\\alpha\\) integration object. This is an implicit method that like the HHT method allows for high frequency energy dissipation and second order accuracy, i.e. \\(\\Delta t^2\\) . Depending on choices of input parameters, the method can be unconditionally stable. integrator GeneralizedAlpha $alphaM $alphaF &lt; $gamma $beta &gt; alphaM \\(\\alpha_M\\) factor alphaF \\(\\alpha_F\\) factor gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator GeneralizedAlpha 1.0 0.8 NOTES: \\(\\alpha_F\\) and \\(\\alpha_M\\) are defined differently that in the paper, we use \\(\\alpha_F = (1-\\alpha_f)\\) and \\(\\alpha_M=(1-\\gamma_m)\\) where \\(\\alpha_f\\) and \\(\\alpha_m\\) are those used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha_M = 1.0, \\alpha_F = 1.0\\) produces the Newmark Method. \\(\\alpha_M = 1.0\\) corresponds to the HHT method. The method is second-order accurate provided \\(\\gamma = \\tfrac{1}{2} + \\alpha_M - \\alpha_F\\) The method is unconditionally stable provided \\(\\alpha_M >= \\alpha_F &gt;= \\tfrac{1}{2}, \\beta>=\\tfrac{1}{4} +\\tfrac{1}{2}(\\gamma_M - \\gamma_F)\\) \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is unconditionally stable, second order accurate and high frequency dissipation is maximized. The defaults are: \\[\\gamma = \\tfrac{1}{2} + \\gamma_M - \\gamma_F\\] and \\[\\beta = \\tfrac{1}{4}(1 + \\gamma_M - \\gamma_F)^2\\] REFERENCES J. Chung, G.M.Hubert. \u201cA Time Integration Algorithm for Structural Dynamics with Improved Numerical Dissipation: The Generalized- \\(\\alpha\\) Method\u201d ASME Journal of Applied Mechanics, 60, 371:375, 1993. Theory The Generalized \\(\\alpha\\) method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. In the HHT method, the same Newmark approximations are used: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[R_{t + \\alpha_M \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\alpha_M \\Delta t} - C \\dot U_{t+\\alpha_F \\Delta t} - F^{int}(U_{t + \\alpha_F \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[U_{t+ \\alpha_F \\Delta t} = (1 - \\alpha_F) U_t + \\alpha_F U_{t + \\Delta t}\\] \\[\\dot U_{t+\\alpha_F \\Delta t} = (1-\\alpha_F) \\dot U_t + \\alpha_F \\dot U_{t + \\Delta t}\\] \\[\\ddot U_{t+\\alpha_M \\Delta t} = (1-\\alpha_M) \\ddot U_t + \\alpha_M \\ddot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, linearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = \\alpha_F K_t + \\frac{\\alpha_F \\gamma}{\\beta \\Delta t} C_t + \\frac{\\alpha_M}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\alpha F \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\alpha F \\Delta t}^{i-1} - M \\ddot U_{t+ \\alpha M \\Delta t}^{i-1}\\] The linear equations are used to solve for \\[U_{t+\\alpha F \\Delta t}, \\dot U_{t + \\alpha F \\Delta t} \\ddot U_{t+ \\alpha M \\Delta t}\\] Once convergence has been achieved the displacements, velocities and accelerations at time \\(t + \\Delta t\\) can be computed. Code Developed by: fmk","title":"Generalized Alpha Method\n"},{"location":"contrib/analysis/integrator/326-Hilber-Hughes-Taylor%20Method/","text":"Hilber-Hughes-Taylor Method This command is used to construct a Hilber-Hughes-Taylor (HHT) integration object. This is an implicit method that allows for energy dissipation and second order accuracy (which is not possible with the regular Newmark method). Depending on choices of input parameters, the method can be unconditionally stable. integrator HHT $alpha &lt; $gamma $beta &gt; alpha \\(\\alpha\\) factor gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator HHT 0.9 NOTES: \\(\\alpha\\) is defined differently that in the paper, we use \\(\\alpha = (\\alpha_{HHT} - 1})\\) where \\(\\alpha_{HHT}\\) is that used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha = 1.0\\) corresponds to the Newmark method. \\(\\alpha\\) should be between 0.67 and 1.0. The smaller the \\(\\alpha\\) the greater the numerical damping. \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is second order accurate and unconditionally stable when \\(\\alpha\\) is \\(\\tfrac{2}{3} &lt;= \\alpha &lt;= 1.0\\) . The defaults are: \\[\\beta = \\frac{(2 - \\alpha)^2}{4}\\] and \\[\\gamma = \\frac{3}{2} - \\alpha\\] REFERENCES Hilber, H.M, Hughes,T.J.R and Talor, R.L. \u201cImproved Numerical Dissipation for Time Integration Algorithms in Structural Dynamics\u201d Earthquake Engineering and Structural Dynamics, 5:282-292, 1977. Theory The HHT method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. In the HHT method, the same Newmark approximations are used: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[ R_{t + \\alpha \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\Delta t} - C \\dot U_{t+\\alpha \\Delta t} - F^{int}(U_{t + \\alpha \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[U_{t+ \\alpha \\Delta t} = (1 - \\alpha) U_t + \\alpha U_{t + \\Delta t}\\] \\[\\dot U_{t+\\alpha \\Delta t} = (1-\\alpha) \\dot U_t + \\alpha \\dot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, loinearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = \\alpha K_t + \\frac{\\alpha \\gamma}{\\beta \\Delta t} C_t + \\frac{1}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\alpha \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\alpha \\Delta t}^{i-1} - M \\ddot U_{t+ \\Delta t}^{i-1}\\] The linear equations are used to solve for \\(U_{t+\\alpha \\Delta t}, \\dot U_{t + \\alpha \\Delta t} \\ddot U_{t+\\Delta t}\\) . Once convergence has been achieved the displacements and velocities at time \\(t + \\Delta t\\) can be computed. Code Developed by: fmk","title":"Hilber-Hughes-Taylor Method\n"},{"location":"contrib/analysis/integrator/372-Load%20Control/","text":"Load Control This command is used to construct a LoadControl integrator object. integrator LoadControl $lambda &lt; $numIter $minLambda $maxLambda &gt; lambda the load factor increment <math></math> numIter the number of iterations the user would like to occur in the solution algorithm. Optional, default = 1.0. minLambda the min stepsize the user will allow. optional, defualt = \\(\\lambda_{min} = \\lambda\\) maxLambda the max stepsize the user will allow. optional, default = \\(\\lambda_{max} = \\lambda\\) NOTES: The change in applied loads that this causes depends on the active load patterns (those load patterns not set constant) and the loads in the load patterns. If the only active loads acting on the domain are in load patterns with a Linear time series with a factor of 1.0, this integrator is the same as the classical load control method. The optional arguments are supplied to speed up the step size in cases where convergence is too fast and slow down the step size in cases where convergence is too slow. Examples integrator LoadControl 0.1; Theory In Load Control the time in the domain is set to \\(t + \\lambda_{t+1}\\) where, \\[\\lambda_{t+1} = \\max \\left ( \\lambda_{min}, \\min \\left ( \\lambda_{max}, \\frac{\\text{numIter}}{\\text{lastNumIter}} \\lambda_{t} \\right ) \\right ) \\] Code Developed by: fmk","title":"Load Control\n"},{"location":"contrib/analysis/integrator/387-Minimum%20Unbalanced%20Displacement%20Norm/","text":"Minimum Unbalanced Displacement Norm This command is used to construct a StaticIntegrator object of type MinUnbalDispNorm. integrator MinUnbalDispNorm $dlambda1 &lt; $Jd $minLambda $maxLambda &gt; dlambda1 first load increment (pseudo-time step) at the first iteration in the next invocation of the analysis command. Jd factor relating first load increment at subsequent time steps (optional, default: 1.0) $minLambda, $maxLambda arguments used to bound the load increment (optional, default: $dLambda1 for both) Examples integrator MinUnbalDispNorm 0.1; Theory The load increment at iteration i, <math>d_{1,i}</math>, is related to the load increment at (i-1), \\(d\\lambda_{1,i-1}\\) , and the number of iterations at (i-1), \\(J_{i-1}\\) , by the following: \\[d\\lambda_{1,i} = d\\lambda_{1,i-1}\\frac{J_d}{J_{i-1}}\\] Code Developed by: fmk","title":"Minimum Unbalanced Displacement Norm\n"},{"location":"contrib/analysis/integrator/416-Newmark%20Method/","text":"Newmark Method This command is used to construct a Newmark integrator object. integrator Newmark $gamma $beta gamma \\(\\gamma\\) factor beta \\(\\beta\\) factor Examples integrator Newmark 0.5 0.25 NOTES: If the accelerations are chosen as the unknowns and \\(\\beta\\) is chosen as 0, the formulation results in the fast but conditionally stable explicit Central Difference method. Otherwise the method is implicit and requires an iterative solution process. Two common sets of choices are Average Acceleration Method (<math>=, = </math>) Linear Acceleration Method (<math>=, = </math>) \\(\\gamma &gt; \\tfrac{1}{2}\\) results in numerical damping proportional to <math> - </math> The method is second order accurate if and only if <math>=</math> The method is conditionally stable for <math> >= >= </math> REFERENCES Newmark, N.M. \u201cA Method of Computation for Structural Dynamics\u201d ASCE Journal of Engineering Mechanics Division, Vol 85. No EM3, 1959. Theory The Newmark method is a one step implicit method for solving the transient problem, represented by the residual for the momentum equation: \\[R_{t + \\Delta t} = F_{t+\\Delta t}^{ext} - M \\ddot U_{t + \\Delta t} - C \\dot U_{t + \\Delta t} + F(U_{t + \\Delta t})^{int}\\] Using the Taylor series approximation of <math>U_{t+ t}</math> and \\(\\dot U_{t+\\Delta t}\\) : \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + \\tfrac{\\Delta t^2}{2} \\ddot U_t + \\tfrac{\\Delta t^3}{6} \\dot \\ddot U_t + \\cdots \\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + \\Delta t \\ddot U_t + \\tfrac{\\Delta t^2}{2} \\dot \\ddot U_t + \\cdots \\] Newton truncated these using the following: \\[U_{t+\\Delta t} = u_t + \\Delta t \\dot U_t + \\tfrac{\\Delta t^2}{2} \\ddot U + \\beta {\\Delta t^3} \\dot \\ddot U \\] \\[\\dot U_{t + \\Delta t} = \\dot U_t + \\Delta t \\ddot U_t + \\gamma \\Delta t^2 \\dot \\ddot U \\] in which he assumed linear acceleration within a time step, i.e. \\[\\dot \\ddot U = \\frac{{\\ddot U_{t+\\Delta t}} - \\ddot U_t}{\\Delta t} \\] which results in the following expressions: \\[U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t}\\] \\[\\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] The variables \\(\\beta\\) and \\(\\gamma\\) are numerical parameters that control both the stability of the method and the amount of numerical damping introduced into the system by the method. For \\(\\gamma=\\tfrac{1}{2}\\) there is no numerical damping; for \\(\\gamma&gt;=\\tfrac{1}{2}\\) numerical damping is introduced. Two well known and commonly used cases are: Average Acceleration Method (<math>=, = </math>) Constant Acceleration Method (<math>=, = </math>) The linearization of the Newmark equations gives: \\[dU_{t+\\Delta t}^{i+1} = \\beta \\Delta t^2 d \\ddot U_{t+\\Delta t}^{i+1}\\] \\[d \\dot U_{t+\\Delta t}^{i+1} = \\gamma \\Delta t \\ddot U_{t+\\Delta t}^{i+1}\\] which gives the update formula when displacement increment is used as unknown in the linearized system as: \\[U_{t+\\Delta t}^{i+1} = U_{t+\\Delta t}^i + dU_{t+\\Delta t}^{i+1}\\] \\[\\dot U_{t+\\Delta t}^{i+1} = \\dot U_{t+\\Delta t}^i + \\frac{\\gamma}{\\beta \\Delta t}dU_{t+\\Delta t}^{i+1}\\] \\[\\ddot U_{t+\\Delta t}^{i+1} = \\ddot U_{t+\\Delta t}^i + \\frac{1}{\\beta \\Delta t^2}dU_{t+\\Delta t}^{i+1}\\] The linearization of the momentum equation using the displacements as the unknowns leads to the following linear equation: \\[K_{t+\\Delta t}^{*i} \\Delta U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\[K_{t+\\Delta t}^{*i} = K_t + \\frac{\\gamma}{\\beta \\Delta t} C_t + \\frac{1}{\\beta \\Delta t^2} M\\] and \\[R_{t+\\Delta t}^i = F_{t + \\Delta t}^{ext} - F(U_{t + \\Delta t}^{i-1})^{int} - C \\dot U_{t+\\Delta t}^{i-1} - M \\ddot U_{t+ \\Delta t}^{i-1}\\] Code Developed by: fmk","title":"Newmark Method\n"},{"location":"contrib/analysis/integrator/675-TRBDF2/","text":"TRBDF2 This command is used to construct a TRBDF2 integrator object. The TRBDF2 integrator is a composite scheme that alternates between the Trapezoidal scheme and a 3 point backward Euler scheme. It does this in an attempt to conserve energy and momentum, something newmark does not always do. integrator TRBDF2 NOTES: As opposed to dividing the time-step in 2 as outlined in the papers, we just switch alternate between the 2 integration strategies,i.e. the time step in our implementation is double that described in the papers. Examples integrator TRBDF2 REFERENCES Bank, R.E., Coughran W.M., Fichter W., Grosse E.H., Rose, D.J., and Smith R.K. \u201cTransient Simulations of Silicon Devices and Circuits\u201d, IEE Trans CAD, Vol(4), 436-451, 1985. Bathe, K.J. \u201cConserving Energy and Momentum in Nonlinear Dynamics: A Simple Impicit Time Integration Scheme\u201d, Computers and Structures, Vol(85), 437-445, 2007. doi:10.1016/j.compstruc.2006.09.004 Theory COMING SOON. LOOK AT BATHE\u2019S PAPER FOR NOW. Code Developed by: fmk","title":"TRBDF2\n"},{"location":"contrib/analysis/integrator/81-Central%20Difference/","text":"Central Difference This command is used to construct a Central Difference integrator object. integrator CentralDifference Examples integrator CentralDifference NOTES: The calculation of \\(U_{t+\\Delta t}\\) , as shown below, is based on using the equilibrium equation at time t. For this reason the method is called an explicit integration method . If there is no rayleigh damping and the C matrix is 0, for a diagonal mass matrix a diagonal solver may and should be used. For stability, <math> < </math> REFERENCES Theory The Central difference approximations for velocity and acceleration: \\[v_n = \\frac{d_{n+1} - d_{n-1}}{2 \\Delta t}\\] \\[a_n = \\frac{d_{n+1} - 2 d_n + d_{n-1}}{\\Delta t^2}\\] In the Central Difference method we determine the displacement solution at time \\(t+\\delta t\\) by considering the the eqilibrium equation for the finite element system in motion at time t: \\[M \\ddot U_t + C \\dot U_t + K U_t = R_t\\] which when using the above two expressions of becomes: \\[\\left ( \\frac{1}{\\Delta t^2} M + \\frac{1}{2 \\Delta t} C \\right ) U_{t+\\Delta t} = R_t - \\left (K - \\frac{2}{\\Delta t^2}M \\right )U_t - \\left (\\frac{1}{\\Delta t^2}M - \\frac{1}{2 \\Delta t} C \\right) U_{t-\\Delta t} \\] Code Developed by: fmk","title":"Central Difference\n"},{"location":"contrib/analysis/numberer/3-AMD%20Numberer/","text":"AMD Numberer This command is used to construct an AMD degree-of-freedom numbering object to provide the mapping between the degrees-of-freedom at the nodes and the equation numbers. An AMD numberer uses the approximate minimum degree scheme to order the matrix equations. The command to construct an AMD numberer is a follows: numberer AMD REFERENCES: Algorithm 837: AMD, An approximate minimum degree ordering algorithm, P. Amestoy, T. A. Davis, and I. S. Duff, ACM Transactions on Mathematical Software, vol 30, no. 3, Sept. 2004, pp. 381-388. An approximate minimum degree ordering algorithm, P. Amestoy, T. A. Davis, and I. S. Duff, SIAM Journal on Matrix Analysis and Applications, vol 17, no. 4, pp. 886-905, Dec. 1996. Direct Methods for Sparse Linear Systems, T. A. Davis, SIAM, Philadelphia, Sept. 2006. Part of the SIAM Book Series on the Fundamentals of Algorithms. Code Developed by: fmk","title":"AMD Numberer\n"},{"location":"contrib/analysis/numberer/437-Numberer%20Command/","text":"Numberer Command This command is used to construct the DOF_Numberer object. The DOF_Numberer object determines the mapping between equation numbers and degrees-of-freedom \u2013 how degrees-of-freedom are numbered. numberer numbererType? arg1? ... The type of DOF_Numberer created and the additional arguments required depends on the numbererType? provided in the command. The following contain information about numbererType? and the args required for each of the available dof numberer types: Plain Numberer Reverse Cuthill-McKee Numberer Alternative_Minimum_Degree Numberer","title":"Numberer Command\n"},{"location":"contrib/analysis/numberer/509-Plain%20Numberer/","text":"Plain Numberer This command is used to construct a Plain degree-of-freedom numbering object to provide the mapping between the degrees-of-freedom at the nodes and the equation numbers. A Plain numberer just takes whatever order the domain gives it nodes and numbers them, this ordering is both dependent on node numbering and size of the model. The command to construct a Plain numberer is a follows: numberer Plain NOTES: For very small problems and for the sparse matrix solvers which provide their own numbering scheme, order is not really important so plain numberer is just fine. For large models and analysis using solver types other than the sparse solvers, the order will have a major impact on performance of the solver and the plain handler is a poor choice. Code Developed by: fmk","title":"Plain Numberer\n"},{"location":"contrib/analysis/numberer/566-RCM%20Numberer/","text":"RCM Numberer This command is used to construct an RCM degree-of-freedom numbering object to provide the mapping between the degrees-of-freedom at the nodes and the equation numbers. An RCM numberer uses the reverse Cuthill-McKee scheme to order the matrix equations. The command to construct an RCM numberer is a follows: numberer RCM REFERENCES: E. Cuthill and J. McKee. [ http://portal.acm.org/citation.cfm?id=805928 Reducing the bandwidth of sparse symmetric matrices ] In Proc. 24th Nat. Conf. ACM , pages 157-172, 1969. Code Developed by: fmk","title":"RCM Numberer\n"},{"location":"contrib/analysis/test/209-Energy%20Increment%20Test/","text":"Energy Increment Test This command is used to construct a convergence test which uses the dot product of the solution vector and norm of the right hand side of the matrix equation to determine if convergence has been reached. The physical meaning of this quantity depends on the integrator and constraint handler chosen. Usually, though not always, it is equal to the energy unbalance in the system. The command to create a EnergyIncr test is the following: test EnergyIncr $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successful test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCCESSFUL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Penalty method additional large forces to enforce the penalty functions exist on the right hand side, making convergence using this test usually impossible (even though solution might have converged). When Lagrange multipliers are used, the solution vector contains the Lagrange multipliers. Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math> U^i R(U^i) < !</math> Code Developed by: fmk","title":"Energy Increment Test\n"},{"location":"contrib/analysis/test/433-Norm%20Displacement%20Increment%20Test/","text":"Norm Displacement Increment Test This command is used to construct a convergence test which uses the norm of the left hand side solution vector of the matrix equation to determine if convergence has been reached. What the solution vector of the matrix equation is depends on integrator and constraint handler chosen. Usually, though not always, it is equal to the displacement increments that are to be applied to the model. The command to create a NormDispIncr test is the following: test NormDispIncr $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successful test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCCESSFUL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Lagrange method to enforce the constraints, the Lagrange multipliers appear in the solution vector. Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math>U^i < !</math> Code Developed by: fmk","title":"Norm Displacement Increment Test\n"},{"location":"contrib/analysis/test/434-Norm%20Unbalance%20Test/","text":"Norm Unbalance Test This command is used to construct a convergence test which uses the norm of the right hand side of the matrix equation to determine if convergence has been reached. What the right-hand-side of the matrix equation is depends on integrator and constraint handler chosen. Usually, though not always, it is equal to the unbalanced forces in the system. The command to create a NormUnbalance test is the following: test NormUnbalance $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successful test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCEESSFULL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Penalty method additional large forces to enforce the penalty functions exist on the right hand side, making convergence using this test usually impossible (even though solution might have converged). Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math>R(U^i) < !</math> Code Developed by: fmk","title":"Norm Unbalance Test\n"},{"location":"contrib/analysis/test/588-Relative%20Energy%20Increment%20Test/","text":"Relative Energy Increment Test This command is used to construct a convergence test which uses the dot product of the solution vector and norm of the right hand side of the matrix equation to determine if convergence has been reached. The physical meaning of this quantity depends on the integrator and constraint handler chosen. Usually, though not always, it is equal to the energy unbalance in the system. The test is relatively to the first dot product computed for each step. The command to create a EnergyIncr test is the following: test RelativeEnergyIncr $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successfull test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCEESSFULL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Penalty method additional large forces to enforce the penalty functions exist on the right had side, making convergence using this test usually impossible (even though solution might have converged). When Lagrange multipliers are used, the solution vector contains the Lagrange multiplies. Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math> < !</math> Code Developed by: fmk","title":"Relative Energy Increment Test\n"},{"location":"contrib/analysis/test/589-Relative%20Norm%20Displacement%20Increment%20Test/","text":"Relative Norm Displacement Increment Test This command is used to construct a convergence test which uses the relative of the solution vector of the matrix equation to determine if convergence has been reached. What the solution vector of the matrix equation is depends on integrator and constraint handler chosen. Usually, though not always, it is equal to the displacement increments that are to be applied to the model. The command to create a RelativeNormDispIncr test is the following: test RelativeNormDispIncr $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successful test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCCESSFUL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Lagrange Multipliers method additional unknown, the Lagrange multipliers, exist in the solution vector, making convergence using this test usually impossible (even though solution might have converged). <math> ^0 !</math> is the initial solution when solveCurrentStep() is invoked on the algorithm. Sometimes there may be problems converging if <math> ^0 !</math> is very small to being with. Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math> < !</math> Code Developed by: fmk","title":"Relative Norm Displacement Increment Test\n"},{"location":"contrib/analysis/test/590-Relative%20Norm%20Unbalance%20Test/","text":"Relative Norm Unbalance Test This command is used to construct a convergence test which uses the relative norm of the right hand side of the matrix equation to determine if convergence has been reached. What the right-hand-side of the matrix equation is depends on integrator and constraint handler chosen. Usually, though not always, it is equal to the unbalanced forces in the system. The command to create a RelativeNormUnbalance test is the following: test RelativeNormUnbalance $tol $iter &lt; $pFlag &gt; &lt; $nType &gt; tol the tolerance criteria used to check for convergence iter the max number of iterations to check before returning failure condition pFlag optional print flag, default is 0. valid options: 0 print nothing 1 print information on norms each time test() is invoked 2 print information on norms and number of iterations at end of successful test 4 at each step it will print the norms and also the \\(\\Delta U\\) and \\(R(U)\\) vectors. 5 if it fails to converge at end of $numIter it will print an error message BUT RETURN A SUCCESSFUL test nType optional type of norm, default is 2. (0 = max-norm, 1 = 1-norm, 2 = 2-norm, \u2026) NOTES: When using the Penalty method additional large forces to enforce the penalty functions exist on the right hand side, making convergence using this test usually impossible (even though solution might have converged). <math> R(U^0) !</math> is the initial unbalance seen by the system when solveCurrentStep() is invoked on the algorithm. Sometimes there may be problems converging if <math> R(U^0) !</math> is very small to being with. Theory If the system of equations formed by the integrator is: <math>K U^i = R(U^i),!</math> This integrator is testing: <math> < !</math> Code Developed by: fmk","title":"Relative Norm Unbalance Test\n"},{"location":"contrib/commands/206-Element%20Command/","text":"Element Command <noinclude> This command is used to construct an element and add it to the Domain. element eleType? arg1? ... The type of element created and the additional arguments required depends on the eleType? provided in the command. NOTE: The valid queries to any element when creating an ElementRecorder are documented in the NOTES section for each element. The following contain information about eleType? and the args required for each of the available element types: </noinclude> Zero-Length Elements zeroLength Element zeroLengthND Element zeroLengthSection Element CoupledZeroLength Element zeroLengthContact Element zeroLengthContactNTS2D zeroLengthInterface2D zeroLengthImpact3D Truss Elements Truss Element Corotational Truss Element Beam-Column Elements Elastic Beam Column Element Elastic Beam Column Element with Stiffness Modifiers Elastic Timoshenko Beam Column Element Beam With Hinges Element Displacement-Based Beam-Column Element Force-Based Beam-Column Element Flexure-Shear Interaction Displacement-Based Beam-Column Element MVLEM - Multiple-Vertical-Line-Element-Model for RC Walls SFI_MVLEM - Cyclic Shear-Flexure Interaction Model for RC Walls Joint Elements BeamColumnJoint Element ElasticTubularJoint Element Joint2D Element Link Elements Two Node Link Element Bearing Elements Elastomeric Bearing (Plasticity) Element Elastomeric Bearing (Bouc-Wen) Element Flat Slider Bearing Element Single Friction Pendulum Bearing Element TFP Bearing Triple Friction Pendulum Element MultipleShearSpring Element KikuchiBearing Element YamamotoBiaxialHDR Element ElastomericX LeadRubberX HDR RJ-Watson EQS Bearing Element FPBearingPTV Quadrilateral Elements Quad Element Shell Element ShellDKGQ ShellNLDKGQ ShellNL Bbar Plane Strain Quadrilateral Element Enhanced Strain Quadrilateral Element SSPquad Element Triangular Elements Tri31 Element ShellDKGT ShellNLDKGT Brick Elements Standard Brick Element Bbar Brick Element Twenty Node Brick Element Twenty Seven Node Brick Element SSPbrick Element Tetrahedron Elements FourNodeTetrahedron u-p Elements UC San Diego u-p element (saturated soil) Four Node Quad u-p Element Brick u-p Element bbarQuad u-p Element bbarBrick u-p Element Nine Four Node Quad u-p Element Twenty Eight Node Brick u-p Element Twenty Node Brick u-p Element Brick Large Displacement u-p Element SSPquadUP Element SSPbrickUP Element Misc. ShallowFoundationGen SurfaceLoad Element VS3D4 AC3D8 ASI3D8 AV3D4 Contact Elements SimpleContact2D Element SimpleContact3D Element BeamContact2D Element BeamContact3D Element BeamEndContact3D Element zeroLengthImpact3D Cable Elements CatenaryCable Element","title":"Element Command\n"},{"location":"contrib/commands/207-Element%20Commands/","text":"Element Commands <noinclude>Currently, several element types have been extended for DDM-based FE response sensitivity computation. element eleType? arg1? ... The type of element created and the additional arguments required depends on the eleType? provided in the command. The following contain information about eleType? and the args required for each of the available element types: </noinclude> dispBeamColumnWithSensitivity Element quadWithSensitivity Element bbarBrickWithSensitivity Element","title":"Element Commands\n"},{"location":"contrib/commands/380-Material%20Commands/","text":"Material Commands :;<h2> uniaxialMaterial Commands </h2> Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType? arg1? ... :;<h2> nDmaterial Commands </h2> Currently, only one multi-axial material model has been extended for DDM-based FE response sensitivity computation. nDMaterial matType? arg1? ...","title":"Material Commands\n"},{"location":"contrib/commands/408-NDMaterial%20Command/","text":"NDMaterial Command <noinclude> This command is used to construct an NDMaterial object which represents the stress-strain relationship at the gauss-point of a continuum element. nDMaterial matType? arg1? ... The type of material created and the additional arguments required depends on the matType? provided in the command. NOTE: The valid queries to any uniaxial material when creating an ElementRecorder are \u2018strain\u2019, and \u2018stress\u2019. Some materials have additional queries to which they will respond. These are documented in the NOTES section for those materials. The following contain information about matType? and the args required for each of the available material types: </noinclude> Elastic Isotropic Material Elastic Orthotropic Material J2 Plasticity Material Drucker Prager Material Concrete Damage Model Plane Stress Material Plane Strain Material Multi Axial Cyclic Plasticity Bounding Surface Cam Clay Material Plate Fiber Material Plane Stress Concrete Materials FSAM - 2D RC Panel Constitutive Behavior Tsinghua Sand Models CycLiqCP Material (Cyclic ElasticPlasticity) CycLiqCPSP Material Manzari Dafalias Material J2CyclicBoundingSurface Material PM4Sand Material PM4Silt Material (Beta) Stress Density Material Materials for Modeling Concrete Walls PlaneStressUserMaterial PlateFromPlaneStress PlateRebar LayeredShell Contact Materials for 2D and 3D ContactMaterial2D ContactMaterial3D Wrapper material for Initial State Analysis InitialStateAnalysisWrapper UC San Diego soil models (Linear/Nonlinear, dry/drained/undrained soil response under general 2D/3D static/cyclic loading conditions (please visit UCSD for examples) PressureIndependMultiYield Material PressureDependMultiYield Material PressureDependMultiYield02 Material PressureDependMultiYield03 Material UC San Diego Saturated Undrained soil FluidSolidPorousMaterial Misc. AcousticMedium Steel &amp; Reinforcing-Steel Materials UVCmultiaxial (Updated Voce-Chaboche) UVCplanestress (Updated Voce-Chaboche)","title":"NDMaterial Command\n"},{"location":"contrib/commands/733-UniaxialMaterialCommand/","text":"UniaxialMaterialCommand uniaxialMaterial matType? arg1? ... SteelMP This command is used to construct a uniaxial Menegotto-Pinto steel material object. SmoothPSConcrete This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. UniaxialJ2Plasticity This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. Hardening This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. Concrete01 This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). Steel01 This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). Elastic This command is used to construct a linear elastic uniaxial material object (with optional material damping).","title":"UniaxialMaterialCommand\n"},{"location":"contrib/commands/734-UniaxialMaterialCommands/","text":"UniaxialMaterialCommands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType? arg1? ... The type of material created and the additional arguments required depends on the matType? provided in the command. The following contain information about matType? and the args required for each of the available material types: </noinclude> SteelMP Material For this material class, the sensitivity parameters can be: sigmaY, E, b SmoothPSConcrete Material For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta UniaxialJ2Plasticity Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Hardening Material for Sensitivity For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Concrete01 Material For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu Steel01 Material for Sensitivity For this material class, the sensitivity parameters can be: E, sigmaY, b, a1, a2, a3, a4 Elastic Material For this material class, the sensitivity parameters can be: E, eta","title":"UniaxialMaterialCommands\n"},{"location":"contrib/commands/735-UniaxialMaterial%20Command/","text":"UniaxialMaterial Command <noinclude>This command is used to construct a UniaxialMaterial object which represents uniaxial stress-strain (or force-deformation) relationships. uniaxialMaterial matType? matTag? arg1? ... The type of material created and the additional arguments required depends on the matType? provided in the command. NOTE: The valid queries to any uniaxial material when creating an ElementRecorder are \u2018strain,\u2019 \u2018stress,\u2019 and \u2018tangent.\u2019 Some materials have additional queries to which they will respond. These are documented in the NOTES section for those materials. The following contain information about matType? and the args required for each of the available material types: </noinclude> Steel &amp; Reinforcing-Steel Materials Steel01 Material Steel02 Material \u2013 Giuffr\u00e9-Menegotto-Pinto Model with Isotropic Strain Hardening Steel4 Material Hysteretic Material Reinforcing Steel Material Dodd Restrepo RambergOsgoodSteel Material SteelMPF - Menegotto and Pinto (1973) Model Extended by Filippou et al. (1983) UVCuniaxial (Updated Voce-Chaboche) Concrete Materials Concrete01 Material \u2013 Zero Tensile Strength Concrete02 Material \u2013 Linear Tension Softening Concrete04 Material \u2013 Popovics Concrete Material Concrete06 Material Concrete07 - Chang &amp; Mander\u2019s 1994 Concrete Model Concrete01 Material With Stuff in the Cracks ConfinedConcrete01 Material ConcreteD FRPConfinedConcrete ConcreteCM - Complete Concrete Model by Chang and Mander (1994) Some Standard Uniaxial Materials Elastic Uniaxial Material Elastic-Perfectly Plastic Material Elastic-Perfectly Plastic Gap Material Elastic-No Tension Material Parallel Material Series Material Other Uniaxial Materials CastFuse Material ViscousDamper Material BilinearOilDamper Material Modified Ibarra-Medina-Krawinkler Deterioration Model with Bilinear Hysteretic Response (Bilin Material) Modified Ibarra-Medina-Krawinkler Deterioration Model with Peak-Oriented Hysteretic Response (ModIMKPeakOriented Material) Modified Ibarra-Medina-Krawinkler Deterioration Model with Pinched Hysteretic Response (ModIMKPinching Material) SAWS Material BARSLIP Material Bond_SP01 - - Strain Penetration Model for Fully Anchored Steel Reinforcing Bars Fatigue Material Hardening Material Impact Material Hyperbolic Gap Material Limit State Material MinMax Material ElasticBilin Material ElasticMultiLinear Material MultiLinear Material Initial Strain Material Initial Stress Material PathIndependent Material Pinching4 Material Engineered Cementitious Composites Material SelfCentering Material Viscous Material BoucWen Material BWBN Material (Pinching Hysteretic Bouc-Wen Material) PyTzQz uniaxial materials for p-y, t-z and q-z elements for modeling soil-structure interaction through the piles in a structural foundation PySimple1 Material TzSimple1 Material QzSimple1 Material PyLiq1 Material TzLiq1 Material PySimple1Gen Command TzSimple1Gen Command KikuchiAikenHDR Material KikuchiAikenLRB Material AxialSp Material AxialSpHD Material Pinching Limit State Material CFSWSWP Wood-Sheathed Cold-Formed Steel Shear Wall Panel CFSSSWP Steel-Sheathed Cold-formed Steel Shear Wall Panel","title":"UniaxialMaterial Command\n"},{"location":"contrib/commands/736-UniaxialMaterial%20Commands/","text":"UniaxialMaterial Commands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType? arg1? ... Several uniaxial materials are available for DDM-based FE response sensitivity computation. SteelMP Material This command is used to construct a uniaxial Menegotto-Pinto steel material object. SmoothPSConcrete Material This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. UniaxialJ2Plasticity Material This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. Hardening Material for Sensitivity This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. Concrete01 Material This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). Steel01 Material for Sensitivity This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (refer to http://peer.berkeley.edu ). Elastic Uniaxial Material This command is used to construct a linear elastic uniaxial material object (with optional material damping).","title":"UniaxialMaterial Commands\n"},{"location":"contrib/commands/737-UniaxialMaterial%20commands/","text":"UniaxialMaterial commands <noinclude>Several uniaxial materials are available for DDM-based FE response sensitivity computation. uniaxialMaterial matType? arg1? ... The type of material created and the additional arguments required depends on the matType? provided in the command. The following contain information about matType? and the args required for each of the available material types: </noinclude> SteelMP Material For this material class, the sensitivity parameters can be: sigmaY, E, b SmoothPSConcrete Material For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta UniaxialJ2Plasticity Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Hardening Material For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Concrete01 Material For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu Steel01 Material For this material class, the sensitivity parameters can be: E, sigmaY, b, a1, a2, a3, a4 Elastic Material For this material class, the sensitivity parameters can be: E, eta","title":"UniaxialMaterial commands\n"},{"location":"contrib/guides/134-Discovering%20OpenSees%20--%20Force-based%20Element%20vs.%20Displacement-based%20Element/","text":"Discovering OpenSees \u2013 Force-based Element vs. Displacement-based Element The two most commonly used OpenSees elements for modeling beam-column elements are force-based element (FBE) and displacement-based element (DBE). Although OpenSees command for defining these two elements has the same arguments, a beam-column element needs to be modeled differently using these two elements to achieve a comparable level of accuracy. The intent of this seminar is to show users how to properly model beam-column elements with both FBE and DBE. The theory behind these two elements along with two examples will be presented to users to enhance their understanding of the elements and assure their correct application. This seminar covers: Introduction Theory of force-based element Theory of displacement-based element Example 1 - steel beam (made up configuration that highlights modeling differences between FBE and DBE elements) Example 2 - practical example (bridge RC column) Summary and conclusions PPT presentation of the seminar can be found here: FBE vs. DBE Video of the seminar can be found here: FBE vs. DBE OpenSees files used to demonstrate the effect of rigid constraints can be found here: The main file that is to be sourced from the OpenSees interpreter: ConventionalColumn_Cyclic.tcl Supporting files to be stored in the same folder with the main file: LibUnits.tcl (define system of units) singlecycle.tcl (procedure for writing one cycle of displacement history) leh415.xls (experimental force-displacement response)","title":"Discovering OpenSees -- Force-based Element vs.\u00a0Displacement-based\nElement\n"},{"location":"contrib/guides/258-Force-based%20Element%20vs.%20Displacement-based%20Element%2C%20Dec%202011/","text":"Force-based Element vs. Displacement-based Element, Dec 2011 This seminar will occur on December 14 & 15 Register for the seminar: December 14 at 9:00 pm Pacific Time registration link December 15 at 4:30 pm Pacific Time registration link The two most commonly used OpenSees elements for modeling beam-column elements: force-based element (FBE) and displacement-based element (DBE). Although OpenSees command for defining these two elements has the same arguments, a beam-column element needs to be modeled differently using these two elements to achieve a comparable level of accuracy. The intent of this seminar is to show users how to properly model beam-column elements with both FBE and DBE. The theory behind these two elements along with two examples will be presented to users to enhance their understanding of the elements and assure their correct application. This seminar covers: Introduction Theory of force-based element Theory of displacement-based element Example 1 - steel beam (made up configuration that highlights modeling differences between FBE and DBE elements) Example 2 - practical example (bridge RC column) Summary and conclusions PPT presentation of the seminar can be found here: FBE vs. DBE Video of the seminar can be found here: FBE vs. DBE OpenSees files used to demonstrate the effect of rigid constraints can be found here: The main file that is to be sourced from the OpenSees interpreter: ConventionalColumn_Cyclic.tcl Supporting files to be stored in the same folder with the main file: LibUnits.tcl (define system of units) singlecycle.tcl (procedure for writing one cycle of displacement history) leh415.xls (experimental force-displacement response)","title":"Force-based Element vs.\u00a0Displacement-based Element, Dec 2011\n"},{"location":"contrib/guides/303-Getting%20Started%20with%20OpenSees%20--%20Elements/","text":"Getting Started with OpenSees \u2013 Elements The elastic columns and beams are defined using the OpenSees Elastic Beam Column Element . The characteristics of a 2-D elastic element depend on the material modulus and the section area and moment of inertia. Because the elements in this frame represent reinforced-concrete elements, the value of 4227 ksi for the elastic modulus of concrete will be used. The following values represent the area and moment of inertia of the columns and beams: Columns Area=(5 12) (5*12)=3600 Iz = 1/12 (5 12) (5 12)^3=1080000 Beams Area=(5 12) (8*12)=5760 Iz = 1/12 (5 12) (8 12)^3=4423680 The OpenSees Geometric Transformation Command defines how the element coordinates correlate to the global model coordinates. <br> In a 2D problem, element orientation does not need to be considered, and can be the same for all elements. The linear transformation will be used in this demonstration: geomTransf Linear $transfTag <-jntOffset $dXi $dYi $dXj $dYj> geomTransf Linear 1 The following commands define the two columns (element 1 and 2) and the beam (element 3): element elasticBeamColumn $eleTag $iNode $jNode $A $E $Iz $transfTag element elasticBeamColumn 1 1 3 3600 4227 1080000 1 element elasticBeamColumn 2 2 4 3600 4227 1080000 1 element elasticBeamColumn 3 3 4 5760 4227 4423680 1 The element connectivity is shown in the following figure: GettingStartedNodes.JPG Return to Getting Started with OpenSees","title":"Getting Started with OpenSees -- Elements\n"},{"location":"contrib/guides/discovering/139-Discovering%20OpenSees%20--%20Modeling%20Diaphragms%20in%202D%20Models%20with%20Linear%20and%20Nonlinear%20Elements/","text":"Discovering OpenSees \u2013 Modeling Diaphragms in 2D Models with Linear and Nonlinear Elements Floor diaphragm need to be axially rigid to assure proper distribution of seismic forces to all lateral force resisting elements (columns and walls). Common modeling approach for frame structures is to represent the structural components (beams and columns) by line elements located at the original member centerlines and having cross-sectional properties equal to those of components. The effect of a rigid diaphragm at a floor level is usually modeled by imposing rigid constraints on all nodes of that floor level and thus enforcing the same lateral displacements of all nodes at the floor level. These constrains enforce condition of zero axial strain on elements that are part of that floor level. For sections where the neutral axis does not shift as a consequence of bending in the beam, axial strains at element\u2019s centerlines are zero, and thus rigid constraints can be applied to model the rigid diaphragm (e.g. steel sections, elastic materials). However, for nonlinear beam-column elements (force-based or displacement-based) with reinforced concrete fiber section where the neutral axis shifts due to bending in the beam axial strains at element\u2019s centerlines are no longer zero. Thus, rigid constraints that enforce condition of zero axial strain on elements will change the response of the frame. In this web-learning session, the effect of a rigid constraints is demonstrated on a 2D frame with force-based beam column elements considering three types of sections: elastic, nonlinear steel, and nonlinear reinforced concrete. This web-learning series covers: Introduction to problem Consequences of applying a rigid constraint on a force-based beam-column element with different types of sections (demonstrated on examples) Conclusions and summary PPT presentation of the seminar can be found here: Modeling Diaphragms in 2D Models Video of the seminar can be found here: Modeling Diaphragms in 2D Models OpenSees files used to demonstrate the effect of rigid constraints can be found here: The main file that is to be sourced from the OpenSees interpreter: ModelingDiaphragms2D.tcl Supporting files to be stored in the same folder with the main file: RectangularRCsection2D.tcl (procedure for discretizing RC rectangular section into fibers) WSection.tcl (procedure for discretizing W steel section into fibers) A10000.tcl (ground motion)","title":"Discovering OpenSees -- Modeling Diaphragms in 2D Models with Linear and\nNonlinear Elements\n"},{"location":"contrib/guides/extending/10-Add%20A%20New%20Material/","text":"Add A New Material The OpenSees applications allows developers to use their own material modules to the application. Unlike most other programs, the materials are added at run-time and not at compile time. The advantage of this is the the developers: Do not need the OpenSees source files or libraries to compile and link the application. Can share their modules with others without having to provide the source code. <uml> Material <|\u2013 UniaxialMaterial Material <|\u2013 SectionForceDeformation Material <|\u2013 NDMaterial </uml> The material modules can be written using either C++, C, or Fortran. Whatever the language the developer wishes to use, the material modules make use of the OpenSees API . Add a New UniaxialMaterial C++ Add a New UniaxialMaterial C Add a New UniaxialMaterial Fortran Add a New nDMaterial C++ Add a New nDMaterial C Add a New ndMaterial Fortran","title":"Add A New Material\n"},{"location":"contrib/guides/extending/11-Add%20A%20New%20Recorder/","text":"Add A New Recorder A Recorder in the interpreted OpenSees applications is used to obtain information from the model during the analysis. To add a new Recorder option into the interpreted applications, the developer must provide a new C++ subclass of the Recorder class and an interface function that will be used to parse the input and create the new recorder. Recorder Class The Recorder class itself is an abstract base class. It inherits from both the TaggedObject class and the MovableObject class. The class has a minimal interface, which is as shown below: The Recorder Class: class Recorder : public MovableObject , public TaggedObject { public : Recorder ( int classTag ); virtual ~ Recorder ();</ p > < p > virtual int record ( int commitTag , double timeStamp ) = 0 ;</ p > < p > virtual int restart ( void ); virtual int domainChanged ( void ); virtual int setDomain ( Domain & amp ; theDomain ); virtual int sendSelf ( int commitTag , Channel & amp ; theChannel ); virtual int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker );</ p > < p > virtual void Print ( OPS_Stream & amp ; s , int flag );</ p > < p > protected : protected :</ p > < p > private : static int lastRecorderTag ; }; The most important methods in the interface are: setDomain() - this is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. record() - this is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. Other Important methods are: domainChanged() - this is a method called when something major has happened in the Domain, ie. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it\u2019s pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it wuill have been deleted and it\u2019s old pointer information will no longer be valid.) send/recvSelf() - are two methods called in parallel applications. When invoked the recorders send/recv information about what they are recording. restart() - this method is called if restart() is invoked on the Domain. What the recorder does is up to you the developer. Example - SumElementForcesRecorder In the following section we will provide all necessary code to add a new recorder. The purpose of this recorder will be to sum the forces obtained from the list of inputted elements. The recorder will use the getResistingForce() method in the elements to obtain these forces. A similar class exists in the framework, which uses the setResponse()/getResponse() methods in the element interface. To demonstrate some of the output file options, the result will go to either the screen, a text file, or a binary file. More output options are of course available and the developer should look at existing recorder options. Header The header for thew new class, which we will call SumElementForcesRecorder is as follows: </ p > < ol > < li > ifndef SumElementForcesRecorder_h </ li > < li > define SumElementForcesRecorder_h </ li > </ ol > < ol > < li > include & lt ; Recorder . h & gt ;</ li > < li > include & lt ; Information . h & gt ;</ li > < li > include & lt ; ID . h & gt ;</ li > </ ol > < p > class Domain ; class Vector ; class Matrix ; class Element ; class Response ; class FE_Datastore ;</ p > < p > class SumElementForcesRecorder : public Recorder { public : // constructors SumElementForcesRecorder (); SumElementForcesRecorder ( const ID eleID , bool echoTime , OPS_Stream * theOutputHandler ); // destructors ~ SumElementForcesRecorder ();</ p > < p > // public methods int record(int commitTag, double timeStamp); int restart ( void ); int domainChanged ( void ); int setDomain ( Domain & amp ; theDomain ); const char * getClassType ( void ) const ; int sendSelf ( int commitTag , Channel & amp ; theChannel ); int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker );</ p > < p > protected :</ p > < p > private : int numEle ; // the number of elements Element ** theElements ; // pointer to array of element pointers ID eleID; // ID ( integer list ) of element tags to record </ p > < p > Domain * theDomain ; // pointer to domain holding elements OPS_Stream * theOutput ; // pointer to output location bool echoTimeFlag; // flag indicating if pseudo time to be printed Vector * data ; // Vector (double array ) to store sum of element forces };</ p > < ol > < li > endif </ li > </ ol > < p > The header file defines the interface and variables for the class SumElementForceRecorder. It defines the new class to be a sublass of the Recorder class. In the public interface are 2 constructors and 1 destructor in addition to all the methods defined for the Recorder class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we store data that will be used by the SumElementForceRecorder objects. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Domain, Vector, Element, OPS_Stream) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, SumElementForcesRecorder.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_SumElementForcesRecorder() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. </ p > < ol > < li > include \"SumElementForcesRecorder.h\" </ li > < li > include & lt ; elementAPI . h & gt ;</ li > </ ol > < ol > < li > include & lt ; Domain . h & gt ;</ li > < li > include & lt ; Element . h & gt ;</ li > < li > include & lt ; ElementIter . h & gt ;</ li > < li > include & lt ; Matrix . h & gt ;</ li > < li > include & lt ; Vector . h & gt ;</ li > < li > include & lt ; ID . h & gt ;</ li > < li > include & lt ; string . h & gt ;</ li > < li > include & lt ; Response . h & gt ;</ li > < li > include & lt ; Message . h & gt ;</ li > < li > include & lt ; Channel . h & gt ;</ li > < li > include & lt ; FEM_ObjectBroker . h & gt ;</ li > </ ol > < ol > < li > include & lt ; StandardStream . h & gt ;</ li > < li > include & lt ; BinaryFileStream . h & gt ;</ li > < li > include & lt ; DataFileStream . h & gt ;</ li > </ ol > < ol > < li > include & lt ; elementAPI . h & gt ;</ li > </ ol > < p > Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. SumElementForcesRecorder :: SumElementForcesRecorder ()</ p > < dl > < dt ></ dt > < dd > Recorder (- 1 ), </ dd > </ dl > < p > numEle ( 0 ), theElements ( 0 ), eleID ( 0 ), theDomain ( 0 ), theOutput ( 0 ), echoTimeFlag ( true ), data ( 0 ) {</ p > < p >}</ p > < p > SumElementForcesRecorder :: SumElementForcesRecorder ( const ID ele , bool echoTime , OPS_Stream * theoutput )</ p > < dl > < dt ></ dt > < dd > Recorder (- 1 ), </ dd > </ dl > < p > numEle ( 0 ), theElements ( 0 ), eleID ( ele ), theDomain ( 0 ), theOutput ( theoutput ), echoTimeFlag ( echoTime ), data ( 0 ) { // set numEle numEle = eleID . Size (); if ( numEle == 0 ) { opserr & lt ;& lt ; \"WARNING SumElementForcesRecorder :: SumElementForcesRecorder () - no elements tags passed in input ! \\n \"; } } Destructor The we provide the destructor. In the destructor all memory that the Recorder created or was passed to it in the constructor must be destroyed. Failing to delete this memory, will result in memory leaks. SumElementForcesRecorder ::~ SumElementForcesRecorder () { if ( theElements != 0 ) delete [] theElements ;</ p > < p > if ( data != 0 ) delete data ;</ p > < p > if ( theOutput != 0 ) delete theOutput ; } record() Method After the destructor, we provide the code for the record() method. It does the following operations: Zeros the vector which will contain the final sum If the time stamp is needed, it places it at the first location in the vector. Loops over all valid elements adding their resting force to the vector. Send the vector to the output handler to be written. Returns success. int SumElementForcesRecorder :: record ( int commitTag , double timeStamp ) { // check for initialization if (data == 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::record() - setDomain() has not been called\\n \"; return -1; }</p> < p > // zero the data vector data-&gt;Zero();</p> < p > int forceSize = data -& gt ; Size (); int startLoc = 0 ;</ p > < p > // write the time if echTimeFlag set if (echoTimeFlag == true) { (* data )( 0 ) = timeStamp ; forceSize -= 1 ; startLoc = 1 ; }</ p > < p > // // for each element that has been added to theElements add force contribution //</p> < p > for ( int i = 0 ; i & lt ; numEle ; i ++) { if ( theElements [ i ] != 0 ) { int loc = startLoc ; const Vector & amp ; force = theElements [ i ]-& gt ; getResistingForce (); int forceSize = force . Size (); for ( int j = 0 ; j & lt ; forceSize ; j ++, loc ++) (* data )( loc ) += force ( j ); } }</ p > < p > // // send the response vector to the output handler for o/p //</p> < p > if ( theOutput != 0 ) theOutput -& gt ; write (* data );</ p > < p > // succesfull completion - return 0 return 0; } restart() and domainChanged() methods Afte the record() method, we have the two simple short methods restart() and domainChanged(). restart does nothing and domainChanged simply calls the objects own setDomain() method. int SumElementForcesRecorder :: restart ( void ) { return 0 ; }</ p > < p > int SumElementForcesRecorder :: domainChanged ( void ) { if ( theDomain != 0 ) this -& gt ; setDomain (* theDomain ); } setDomain() Method The setDomain() method follows. In this method we perform the following: set the pointer for the enclosing domain object. allocate space from memoory for our array of ponters and our data vector. initialize the array components to be 0 or point to an element given by the eleID. determine the size of the vector that will be used to store the sum of the forces. allocate space for the vector. int SumElementForcesRecorder :: setDomain ( Domain & amp ; theDom ) { theDomain = & amp ; theDom ;</ p > < p > // set numEle if (numEle == 0) { opserr &lt;&lt; \"WARNING SumElementForcesRecorder :: initialize () - no elements tags passed in input ! \\n \"; return 0; }</p> < p > // create theElements, an array of pointers to elements theElements = new Element *[ numEle ]; if ( theElements == 0 ) { opserr & lt ;& lt ; \"WARNING SumElementForcesRecorder :: initialize () - out of memory\\n \"; numEle = 0; // set numEle = 0, in case record() still called return -1; }</p> < p > // // loop over the list of elements, // if element exists add it's pointer o the array // get its resisting force, check size to determine compatable with others //</p> < p > int sizeArray = - 1 ;</ p > < p > for ( int i = 0 ; i & lt ; numEle ; i ++) { int eleTag = eleID ( i ); Element * theEle = theDomain -& gt ; getElement ( eleTag );</ p > < p > if ( theEle != 0 ) {</ p > < p > const Vector & amp ; force = theEle -& gt ; getResistingForce (); int forceSize = force . Size (); if ( sizeArray == - 1 ) { sizeArray = forceSize ; theElements [ i ] = theEle ; } else if ( sizeArray != forceSize ) { opserr & lt ;& lt ; \"WARNING: forces mismatch - element: \" & lt ;& lt ; eleTag & lt ;& lt ; \" will not be included \\n \" ; theElements [ i ] = 0 ; } else { theElements [ i ] = theEle ; } } else { theElements [ i ] = 0 ; } }</ p > < p > // if echTimeFlag is set, add room for the time to be output if ( echoTimeFlag == true ) sizeArray ++;</ p > < p > // create the vector to hold the data data = new Vector ( sizeArray );</ p > < p > if ( data == 0 || data -& gt ; Size () != sizeArray ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::initialize() - out of memory \\n \" ; delete [] theElements ; theElements = 0 ; numEle = 0 ; }</ p > < p > return 0 ; } sendSelf() and recvSelf() methods These methods only need be provided if the object will be used in a parallel program. We provide their implementation for completeness, though typicall developers are interested in running the code in a sequential application and should just return -1. static char myClassType [] = { \"SumElementForcesRecorder\" };</ p > < p > const char * SumElementForcesRecorder :: getClassType ( void ) const { return myClassType ; }</ p > < p > int SumElementForcesRecorder :: sendSelf ( int commitTag , Channel & amp ; theChannel ) { // send in an ID (integar array) to the receiving object the following : // recorder tag // size of eleID // class tag of handler // echoTimeFlag</p> < p > static ID idData ( 5 ); idData ( 0 ) = this -& gt ; getTag ();; idData ( 1 ) = eleID . Size (); idData ( 2 ) = theOutput -& gt ; getClassTag (); if ( echoTimeFlag == true ) idData ( 3 ) = 1 ; else idData ( 3 ) = 0 ;</ p > < p > if ( theChannel . sendID ( 0 , commitTag , idData ) & lt ; 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return - 1 ; }</ p > < p > // send eleID to receiving object if (theChannel.sendID(0, commitTag, eleID ) & lt ; 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::sendSelf() - failed to send idData\\n \"; return -1; }</p> < p > // send theOutput to receiving object if ( theOutput -& gt ; sendSelf ( commitTag , theChannel ) & lt ; 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::sendSelf() - failed to send theOutput \\n \" ; return - 1 ; }</ p > < p > return 0 ; } int SumElementForcesRecorder :: recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker ) { // receive from the sending object the ID static ID idData(5); if ( theChannel . recvID ( 0 , commitTag , idData ) & lt ; 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return - 1 ; }</ p > < p > // with the data received // setTag // resize the eleID array // set echoTimeFlag // get an outputHandler</p> < p > this -& gt ; setTag ( idData ( 0 )); eleID . resize ( idData ( 1 )); idData ( 2 ) = theOutput -& gt ; getClassTag (); if ( idData ( 3 ) == 0 ) echoTimeFlag = true ; else echoTimeFlag = false ;</ p > < p > if ( theOutput != 0 & amp ;& amp ; theOutput -& gt ; getClassTag () != idData ( 4 )) delete theOutput ;</ p > < p > theOutput = theBroker . getPtrNewStream ( idData ( 4 )); if ( theOutput == 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::recvSelf() - failed to get Output of correct type\\n \"; return -1; }</p> < p > // receive eleID if (theChannel.recvID(0, commitTag, eleID) &lt; 0) { opserr & lt ;& lt ; \"SumElementForcesRecorder::recvSelf() - failed to recv eleID\\n \"; return -1; }</p> < p > // get theOutput to receive data if ( theOutput -& gt ; recvSelf ( commitTag , theChannel , theBroker ) & lt ; 0 ) { opserr & lt ;& lt ; \"SumElementForcesRecorder::sendSelf() - failed to send theOutput\\n \"; return -1; }</p> < p > return 0 ; } Interface Function At the end of the implementation file is the interface function. This function is required by all new classes. It is a function which will use the api to parse the input based on the input create objects create a recorder object of the correct type, and return it to the calling function. The interface function is the function that is called when the interpreter comes across the command telling it to create a SumElementForcesRecorder. </ p > < ol > < li > ifdef _USRDLL </ li > < li > include & lt ; windows . h & gt ;</ li > < li > define OPS_Export extern \"C\" _declspec ( dllexport )</ li > < li > elif _MACOSX </ li > < li > define OPS_Export extern \"C\" __attribute__((visibility( \"default\" ))) </ li > < li > else </ li > < li > define OPS_Export extern \"C\" </ li > < li > endif </ li > </ ol > < p > static int numSumElementForcesREcorder = 0 ;</ p > < p > OPS_Export void * OPS_SumElementForcesRecorder () { Recorder * theRecorder = 0 ;</ p > < p > int numRemainingArgs = OPS_GetNumRemainingInputArgs ();</ p > < p > // check for quick return, possibly parallel case if ( numRemainingArgs == 0 ) { Recorder * theRecorder = new SumElementForcesRecorder (); }</ p > < p > // // parse args //</p> < p > int numEle = 0 , eleTag ; ID eleID ( 0 );</ p > < p > OPS_Stream * theOutputStream = 0 ; int outMode = 0 ; // standard stream bool echoTime = false ;</ p > < p > bool doneParsingArgs = false ; char data [ 100 ]; char outputName [ 200 ]; char ** eleArgs = 0 ; int numEleArgs = 0 ; while ( numRemainingArgs & gt ; 0 ) { if ( OPS_GetString ( data , 100 ) & lt ; 0 ) return 0 ;</ p > < p > // output to standard file if (strcmp(data,\"-file\") == 0) { outMode = 1 ; if ( OPS_GetString ( outputName , 200 ) & lt ; 0 ) return 0 ; numRemainingArgs -= 2 ; }</ p > < p > // output to binary file else if (strcmp(data,\"-binary\") == 0) { outMode = 2 ; if ( OPS_GetString ( outputName , 200 ) & lt ; 0 ) return 0 ; numRemainingArgs -= 2 ; }</ p > < p > // echo domain time stamp in output else if (strcmp(data,\"-time\") == 0 ) { echoTime = true ; numRemainingArgs -= 1 ; }</ p > < p > // read the list of elements &amp; place in an ID else if (( strcmp ( data , \"-ele\" ) == 0 ) || ( strcmp ( data , \"-eles\" ) == 0 ) || ( strcmp ( data , \"-element\" ) == 0 )) {</ p > < p > numRemainingArgs --; int one = 1 ; while ( numRemainingArgs & gt ; 0 & amp ;& amp ; OPS_GetIntInput (& amp ; one , & amp ; eleTag ) == 0 ) { eleID [ numEle ] = eleTag ; numEle ++; numRemainingArgs --; } doneParsingArgs = true ; }</ p > < p > // // create the output handler //</p> < p > if ( outMode == 0 ) theOutputStream = new StandardStream (); if ( outMode == 1 ) theOutputStream = new DataFileStream ( outputName ); else if ( outMode == 2 ) theOutputStream = new BinaryFileStream ( outputName );</ p > < p > // // create the recorder //</p> < p > theRecorder = new SumElementForcesRecorder ( eleID , echoTime , theOutputStream );</ p > < p > // return it return theRecorder; } Example Script (OpenSeesDeveloper/recorder/example1.tcl) An example OpenSees tcl input file for this new recorder is: </p> <ol> <li> create the model</li> </ol> <p>model basic -ndm 2 -ndf 2 node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 uniaxialMaterial Elastic 1 3000 element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 fix 1 1 1 fix 2 1 1 fix 3 1 1 </p> <p>pattern Plain 1 Linear { </p> <ol> <li>apply the load - command : load nodeID xForce yForce</li> </ol> <p> load 4 100 -50 } </p> <ol> <li>Create the analysis</li> </ol> <p> system ProfileSPD constraints Plain integrator LoadControl 1.0 algorithm Linear numberer RCM analysis Static recorder Element -file a.out -time -ele 1 2 3 forces recorder SumElementForcesRecorder -file b.out -time -ele 1 2 3 </p> <ol> <li>perform the analysis</li> </ol> <p>analyze 10 Example Output The output shows that the model is in equilibrium, and that at node 4 the node the element resisting forces are equal to the applied forces. 1 -100 50 100 -50 2 -200 100 200 -100 3 - 300 150 300 -150 4 -400 200 400 -200 5 -500 250 500 -250 6 -600 300 600 - 300 7 -700 350 700 -350 8 -800 400 800 -400 9 -900 450 900 -450 10 - 1000 500 1000 -500","title":"Add A New Recorder\n"},{"location":"contrib/guides/extending/12-Add%20a%20New%20Element%20C%2B%2B/","text":"Add a New Element C++ To add a new Element module using the C++ language, the developer must: provide a new C++ subclass of the Element class provide an interface function that will be used to parse the input and create the new element. Unlike the C and Fortran modules, no information about the state of the model is passed as arguments to the element methods. It is the responsibility of the element to obtain this information using it\u2019s assocaiations. NOTE: This document assumes the reader is familiar with the C++ programming language. Element Class The Element class itself is an abstract base class. It inherits from both the DomainComponent class, which is itself a subclass of TaggedObject class and the MovableObject class. The class has a large number of methods defined in the interface, not all these methods need to be included in a new Element class. The following is the minimal interface that should be considered: The Element Class: class Element : public DomainComponent { public : Element ( int tag , int classTag ); virtual ~ Element ();</ p > < p > // initialization virtual int setDomain(Domain *theDomain);</p> < p > // methods dealing with nodes and number of external dof virtual int getNumExternalNodes ( void ) const = 0 ; virtual const ID & amp ; getExternalNodes ( void ) = 0 ; virtual Node ** getNodePtrs ( void ) = 0 ; virtual int getNumDOF ( void ) = 0 ;</ p > < p > // methods dealing with committed state and update virtual int commitState ( void ); // called when a converged solution has been obtained for a time step virtual int revertToLastCommit ( void ) = 0 ; // called when the soln algorithm has failed to converge to a solution at a time step virtual int revertToStart ( void ); // called when model is rest to initial conditions virtual int update ( void ); // called when a new trial step has been set at the nodes </ p > < p > // methods dealing with element stiffness virtual const Matrix & amp ; getTangentStiff ( void ) = 0 ; virtual const Matrix & amp ; getInitialStiff ( void ) = 0 ;</ p > < p > // methods dealing with element forces virtual void zeroLoad(void); virtual int addLoad ( ElementalLoad * theLoad , double loadFactor ); virtual const Vector & amp ; getResistingForce ( void ) = 0 ;</ p > < p > // public methods for output void Print(OPS_Stream &amp;s, int flag = 0 ); virtual Response * setResponse ( const char ** argv , int argc , OPS_Stream & amp ; theHandler ); virtual int getResponse ( int responseID , Information & amp ; eleInformation );</ p > < p > // method for database/parallel processing int sendSelf(int commitTag , Channel & amp ; theChannel ); int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker );</ p > < p >}</ p > < p > Example - Truss2D In the following section we will provide all necessary code to add a new 2d planar truss element into an OpenSees interpreter. To demonstrate the power of object-oriented programming, the stress-strain relationship will be provided by a UniaxialMaterial object. Header The header for thew new class, which we will call Truss2D is as follows: // include directives</p> < ol > < li > include & lt ; Element . h & gt ;</ li > < li > include & lt ; Matrix . h & gt ;</ li > < li > include & lt ; Vector . h & gt ;</ li > </ ol > < p > // forward declarations class UniaxialMaterial;</p> < p > class Truss2D : public Element { public : // constructors Truss2D(int tag , int Nd1 , int Nd2 , UniaxialMaterial & amp ; theMaterial , double A );</ p > < p > Truss2D ();</ p > < p > // destructor ~Truss2D();</p> < p > // initialization int setDomain(Domain *theDomain);</p> < p > // public methods to obtain inforrmation about dof &amp; connectivity int getNumExternalNodes ( void ) const ; const ID & amp ; getExternalNodes ( void ); Node ** getNodePtrs ( void ); int getNumDOF ( void );</ p > < p > // public methods to set the state of the element int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); int update ( void );</ p > < p > // public methods to obtain stiffness const Matrix & amp ; getTangentStiff ( void ); const Matrix & amp ; getInitialStiff ( void );</ p > < p > // public method to obtain resisting force const Vector & amp ; getResistingForce ( void );</ p > < p > // method for obtaining information specific to an element void Print ( OPS_Stream & amp ; s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & amp ; s ); int getResponse ( int responseID , Information & amp ; eleInformation );</ p > < p > // public methods for database/parallel processing int sendSelf(int commitTag , Channel & amp ; theChannel ); int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker ); void Print ( OPS_Stream & amp ; s , int flag = 0 );</ p > < p > protected :</ p > < p > private : // private member functions - only available to objects of the class double computeCurrentStrain ( void ) const ;</ p > < p > // private attributes - a copy for each object of the class UniaxialMaterial * theMaterial ; // pointer to a material ID externalNodes ; // contains the id's of end nodes Matrix trans; // hold the transformation matrix double L ; // length of truss (undeformed configuration ) double A ; // area of truss Node *theNodes[2]; // node pointers </ p > < p > // static data - single copy for all objects of the class static Matrix trussK ; // class wide matrix for returning stiffness static Vector trussR ; // class wide vector for returning residual };</p> < ol > < li > endif </ li > </ ol > < p > The header file defines the interface and variables for the class Truss2D. It defines the new class to be a sublass of the Element class. In the public interface, are two constructors and a destructor in addition to minimal set of methods we showed for the Element class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section, we define one private method, computeCurrentStrain(), and we define a number of private variables and a number of static variables. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Node, UniaxialMaterial) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, Truss2D.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_Truss2D() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. </ p > < ol > < li > include \"Truss2D.h\" </ li > </ ol > < ol > < li > include & lt ; elementAPI . h & gt ;</ li > < li > include & lt ; G3Globals . h & gt ;</ li > < li > include & lt ; Information . h & gt ;</ li > < li > include & lt ; Domain . h & gt ;</ li > < li > include & lt ; Node . h & gt ;</ li > < li > include & lt ; Channel . h & gt ;</ li > < li > include & lt ; Message . h & gt ;</ li > < li > include & lt ; FEM_ObjectBroker . h & gt ;</ li > < li > include & lt ; UniaxialMaterial . h & gt ;</ li > < li > include & lt ; Renderer . h & gt ;</ li > < li > include & lt ; ElementResponse . h & gt ;</ li > </ ol > < ol > < li > include & lt ; math . h & gt ;</ li > < li > include & lt ; stdlib . h & gt ;</ li > < li > include & lt ; string . h & gt ;</ li > </ ol > < p > Static Variables Next, we initialize the static variables. For this example we are using 2 static-variables (objects shared by each Truss2D object that is created), one to return the tangent matrix and the other to return the resisting force. // initialise the class wide variables Matrix Truss2D :: trussK ( 4 , 4 ); Vector Truss2D :: trussR ( 4 ); Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. The first constructor is the one most typically used. The arguments provide the elements tag, the tags of the two end nodes, the element\u2019s area and a copy of the element\u2019s material. The code in the constructor does the following: The elements tag and a 0 are passed to the Element constructor. The matreial pointer, theMaterial, is set to a copy of the material obtained from the material that is passed in the arguments. The externalNodes array is set to be an array of size 2 and it\u2019s values are set to the nodal tags of the 2 nodes. The theNodes array components are set to be 0. It should be noted that the static variables dealing with length, transformations, and nodes are set to 0 in the constructors. They will be filled in when the setDomain() method is invoked on the object. Truss2D :: Truss2D ( int tag , int Nd1 , int Nd2 , UniaxialMaterial & amp ; theMat , double a )</ p > < dl > < dt ></ dt > < dd > Element ( tag , 0 ), </ dd > </ dl > < p > externalNodes ( 2 ), trans ( 1 , 4 ), L ( 0.0 ), A ( a ) { // get a copy of the material object for our own use theMaterial = theMat . getCopy (); if ( theMaterial == 0 ) { opserr & lt ;& lt ; \"FATAL TrussCPP::TrussCPP() - out of memory , could not get a copy of the Material\\n \"; exit(-1); }</p> < p > // fill in the ID containing external node info with node id's if ( externalNodes . Size () != 2 ) { opserr & lt ;& lt ; \"FATAL TrussCPP :: TrussCPP () - out of memory , could not create an ID of size 2 \\n \"; exit(-1); }</p> < p > externalNodes ( 0 ) = Nd1 ; externalNodes ( 1 ) = Nd2 ;</ p > < p > theNodes [ 0 ] = 0 ; theNodes [ 1 ] = 0 ; } The second constructor is called when paralell processing or the database feature of the OpenSees application is used. It\u2019s pupose is to create a blank Truss2D object, that will be filled in when the recvSelf() method is invoked on the object. Truss2D :: Truss2D ()</ p > < dl > < dt ></ dt > < dd > Element ( 0 , 0 ), </ dd > </ dl > < p > theMaterial ( 0 ), externalNodes ( 2 ), trans ( 1 , 4 ), L ( 0.0 ), A ( 0.0 ) { theNodes [ 0 ] = 0 ; theNodes [ 1 ] = 0 ; } Destructor The we provide the destructor. In the destructor all memory that the Truss2D created or was passed to it in the constructor must be destroyed. For our example, we need to invoke the destructor on the copy of the material object. Truss2D ::~ Truss2D () { if ( theMaterial != 0 ) delete theMaterial ; } ===== setDomain() Initialization Method The setDomain() method is invoked when the truss element is being added to the Domain. It is in this method that most of the private variables of the object are determined. The method returns 0 if successfull, a negative number if not. In the method we obtain pointers to the end nodes, nodal coordinates are obtained and the elements length and transformation matrix is set once the coordinates have been obtained. void Truss2D :: setDomain ( Domain * theDomain ) { // check Domain is not null - invoked when object removed from a domain if ( theDomain == 0 ) { return ; }</ p > < p > // first ensure nodes exist in Domain and set the node pointers Node * end1Ptr , * end2Ptr ; int Nd1 = externalNodes ( 0 ); int Nd2 = externalNodes ( 1 ); end1Ptr = theDomain -& gt ; getNode ( Nd1 ); end2Ptr = theDomain -& gt ; getNode ( Nd2 ); if ( end1Ptr == 0 ) { opserr & lt ;& lt ; \"WARNING Truss2D :: setDomain () - at truss \" &lt;&lt; this-&gt;getTag() &lt;&lt; \" node \" &lt;&lt; Nd1 &lt;&lt; \" does not exist in domain\\n \"; return; // don 't go any further - otherwise segemntation fault } if (end2Ptr == 0) { opserr & lt ;& lt ; \"WARNING Truss2D::setDomain() - at truss \" & lt ;& lt ; this -& gt ; getTag () & lt ;& lt ; \" node \" & lt ;& lt ; Nd2 & lt ;& lt ; \" does not exist in domain\\n \"; return; // don't go any further - otherwise segemntation fault } theNodes [ 0 ] = end1Ptr ; theNodes [ 1 ] = end2Ptr ; // call the DomainComponent class method THIS IS VERY IMPORTANT this -& gt ; DomainComponent :: setDomain ( theDomain );</ p > < p > // ensure connected nodes have correct number of dof's int dofNd1 = end1Ptr -& gt ; getNumberDOF (); int dofNd2 = end2Ptr -& gt ; getNumberDOF (); if (( dofNd1 != 2 ) || ( dofNd2 != 2 )) { opserr & lt ;& lt ; \"Truss2D::setDomain(): 2 dof required at nodes \\n \" ; return ; }</ p > < p > // now determine the length &amp; transformation matrix const Vector & amp ; end1Crd = end1Ptr -& gt ; getCrds (); const Vector & amp ; end2Crd = end2Ptr -& gt ; getCrds ();</ p > < p > double dx = end2Crd ( 0 )- end1Crd ( 0 ); double dy = end2Crd ( 1 )- end1Crd ( 1 );</ p > < p > L = sqrt ( dx * dx + dy * dy );</ p > < p > if ( L == 0.0 ) { opserr & lt ;& lt ; \"WARNING Truss2D::setDomain() - Truss2D \" &lt;&lt; this-&gt;getTag() &lt;&lt; \" has zero length\\n \"; return ; // don't go any further - otherwise divide by 0 error }</p> < p > double cs = dx / L ; double sn = dy / L ;</ p > < p > trans ( 0 , 0 ) = - cs ; trans ( 0 , 1 ) = - sn ; trans ( 0 , 2 ) = cs ; trans ( 0 , 3 ) = sn ; } Methods Dealing With Nodes Next comes 4 rather simple methods that return basic information about the elements nodes. These are one line methods that should not need any explanation! int Truss2D :: getNumExternalNodes ( void ) const { return 2 ; }</ p > < p > const ID & amp ; Truss2D :: getExternalNodes ( void ) { return externalNodes ; }</ p > < p > Node ** Truss2D :: getNodePtrs ( void ) { return theNodes ; }</ p > < p > int Truss2D :: getNumDOF ( void ) { return 4 ; } Methods Dealing With Current State int Truss2D :: commitState () { return theMaterial -& gt ; commitState (); }</ p > < p > int Truss2D :: revertToLastCommit () { return theMaterial -& gt ; revertToLastCommit (); }</ p > < p > int Truss2D :: revertToStart () { return theMaterial -& gt ; revertToStart (); }</ p > < p > int Truss2D :: update () { // determine the current strain given trial displacements at nodes double strain = this -& gt ; computeCurrentStrain ();</ p > < p > // set the strain in the materials theMaterial -& gt ; setTrialStrain ( strain );</ p > < p > return 0 ; } Methods To Return Tangent Matrix In both methods, we obtain the appropriate tangent from the material and use this to return the transformed matrix. const Matrix & amp ; Truss2D :: getTangentStiff ( void ) { if ( L == 0.0 ) { // length = zero - problem in setDomain () warning message already printed trussK . Zero (); return trussK ; }</ p > < p > // get the current E from the material for the last updated strain double E = theMaterial -& gt ; getTangent ();</ p > < p > // form the tangent stiffness matrix trussK = trans^trans; trussK *= A * E / L ;</ p > < p > // return the matrix return trussK; }</p> < p > const Matrix & amp ; Truss2D :: getInitialStiff ( void ) { if ( L == 0.0 ) { // length = zero - problem in setDomain() warning message already printed trussK . Zero (); return trussK ; }</ p > < p > // get the current E from the material for the last updated strain double E = theMaterial -& gt ; getInitialTangent ();</ p > < p > // form the tangent stiffness matrix trussK = trans^trans; trussK *= A * E / L ;</ p > < p > // return the matrix return trussK; } Methods To Return Resisting Force In this method we obtain the stress from the material and use this to return the transformed force vector. const Vector & amp ; Truss2D :: getResistingForce () { if ( L == 0.0 ) { // if length == 0, problem in setDomain () trussR . Zero (); return trussR ; }</ p > < p > // want: R = Ku - Pext</p> < p > // force = F * transformation double force = A * theMaterial -& gt ; getStress (); for ( int i = 0 ; i & lt ; 4 ; i ++) trussR ( i ) = trans ( 0 , i )* force ;</ p > < p > return trussR ; } Methods Dealing With Output Information is obtained by the user when the print command is invoked by the user and also when the user issues the recorder command. When the print command is invoked the Print method is invoked. This method simply prints information about the element, and then asks the material to do likewise. void Truss2D :: Print ( OPS_Stream & amp ; s , int flag ) { s & lt ;& lt ; \"Element: \" & lt ;& lt ; this -& gt ; getTag (); s & lt ;& lt ; \" type : Truss2D iNode : \" &lt;&lt; externalNodes(0); s &lt;&lt; \" jNode : \" & lt ;& lt ; externalNodes ( 1 ); s & lt ;& lt ; \" Area: \" & lt ;& lt ; A ; s & lt ;& lt ; \" \\t Material : \" &lt;&lt; *theMaterial; } There are two methods used by the element recorders. The first method, setResponse(), is called when the recorder is created. The element informs the recorder that it can respond to a request of that type, if it cannot respond to the request it returns a 0, otherwise it returns an Response object. The response object includes a pointer to the element, an integer flag used to id the response when the getResponse() method is called, and a Vector detailing the size of the response. The second method, getReponse(), is called by the recorder when it is actually recording the information. Response * Truss2D :: setResponse ( const char ** argv , int argc , OPS_Stream & amp ; output ) { Response * theResponse = 0 ;</ p > < p > output . tag ( \"ElementOutput\" ); output . attr ( \"eleType\" , this -& gt ; getClassType ()); output . attr ( \"eleTag\" , this -& gt ; getTag ()); int numNodes = this -& gt ; getNumExternalNodes (); const ID & amp ; nodes = this -& gt ; getExternalNodes (); static char nodeData [ 32 ];</ p > < p > for ( int i = 0 ; i & lt ; numNodes ; i ++) { sprintf ( nodeData , \"node %d \" , i + 1 ); output . attr ( nodeData , nodes ( i )); }</ p > < p > if ( strcmp ( argv [ 0 ], \"force\" ) == 0 || strcmp ( argv [ 0 ], \"forces\" ) == 0 || strcmp ( argv [ 0 ], \"globalForce\" ) == 0 || strcmp ( argv [ 0 ], \"globalForces\" ) == 0 ) { const Vector & amp ; force = this -& gt ; getResistingForce (); int size = force . Size (); for ( int i = 0 ; i & lt ; size ; i ++) { sprintf ( nodeData , \"P %d \" , i + 1 ); output . tag ( \"ResponseType\" , nodeData ); } theResponse = new ElementResponse ( this , 1 , this -& gt ; getResistingForce ()); }</ p > < p > else if ( strcmp ( argv [ 0 ], \"dampingForce\" ) == 0 || strcmp ( argv [ 0 ], \"dampingForces\" ) == 0 ) { const Vector & amp ; force = this -& gt ; getResistingForce (); int size = force . Size (); for ( int i = 0 ; i & lt ; size ; i ++) { sprintf ( nodeData , \"P %d \" , i + 1 ); output . tag ( \"ResponseType\" , nodeData ); } theResponse = new ElementResponse ( this , 2 , this -& gt ; getResistingForce ()); } else if ( strcmp ( argv [ 0 ], \"axialForce\" ) == 0 ) return new ElementResponse ( this , 3 , 0.0 );</ p > < p > output . endTag (); return theResponse ; }</ p > < p > int Truss2D :: getResponse ( int responseID , Information & amp ; eleInfo ) { double strain ;</ p > < p > switch ( responseID ) { case - 1 : return - 1 ; case 1 : // global forces return eleInfo . setVector ( this -& gt ; getResistingForce ()); case 2 : return eleInfo . setVector ( this -& gt ; getRayleighDampingForces ()); case 3 : theMaterial -& gt ; setTrialStrain ( strain ); return eleInfo . setDouble ( A * theMaterial -& gt ; getStress ()); default : return 0 ; } } Methods Dealing With Databases/Parallel Processing There are two methods provided which are required is the user uses to use the database or parallel procesing features of the OpenSees applications. If neither are to be used, the developer need simply return a negative value in both methods. The idea is that the element must pack up it\u2019s information using Vector and ID objects and send it off to a Channel object. On the flip side, the receiving blank element must receive the same Vector and ID data, unpack it and set the variables. ```cpp int Truss2D::sendSelf(int commitTag, Channel &theChannel) { int res; // note: we don\u2019t check for dataTag == 0 for Element // objects as that is taken care of in a commit by the Domain // object - don\u2019t want to have to do the check if sending data int dataTag = this->getDbTag(); // Truss2D packs it\u2019s data into a Vector and sends this to theChannel // along with it\u2019s dbTag and the commitTag passed in the arguments Vector data(5); data(0) = this->getTag(); data(1) = A; data(2) = theMaterial->getClassTag(); int matDbTag = theMaterial->getDbTag(); // NOTE: we do have to ensure that the material has a database // tag if we are sending to a database channel. if (matDbTag == 0) { matDbTag = theChannel.getDbTag(); if (matDbTag != 0) theMaterial->setDbTag(matDbTag); } data(3) = matDbTag; res = theChannel.sendVector(dataTag, commitTag, data); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send Vector\u201d; return -1; } // Truss2D then sends the tags of it\u2019s two end nodes res = theChannel.sendID(dataTag, commitTag, externalNodes); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send ID\u201d; return -2; } // finally Truss2D asks it\u2019s material object to send itself res = theMaterial->sendSelf(commitTag, theChannel); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send the Material\u201d; return -3; } return 0; } int Truss2D::recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { int res; int dataTag = this->getDbTag(); // Truss2D creates a Vector, receives the Vector and then sets the // internal data with the data in the Vector Vector data(5); res = theChannel.recvVector(dataTag, commitTag, data); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive Vector\u201d; return -1; } this->setTag((int)data(0)); A = data(1); // Truss2D now receives the tags of it\u2019s two external nodes res = theChannel.recvID(dataTag, commitTag, externalNodes); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive ID\u201d; return -2; } // we create a material object of the correct type, // sets its database tag and asks this new object to recveive itself. int matClass = data(2); int matDb = data(3); theMaterial = theBroker.getNewUniaxialMaterial(matClass); if (theMaterial == 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to create a Material\u201d; return -3; } // we set the dbTag before we receive the material - this is important theMaterial->setDbTag(matDb); res = theMaterial->recvSelf(commitTag, theChannel, theBroker); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive the Material\u201d; return -3; } return 0; }","title":"Add a New Element C++\n"},{"location":"contrib/guides/extending/13-Add%20a%20New%20Element%20Fortran/","text":"Add a New Element Fortran to be completed To add a new Element module using the Fortran language, the developer must provide a new Fortran routine for the Element. Some information about the state of the model is passed as arguments to the element methods. The input arguments are: the element object, eleObj the model state, modl the isw switch, isw , which indicates what action is needed for each invocation of the procedure. The output arguments are: the tangent stiffness matrix, tang the residual vector, resid the error code, error The name of the routine is important for the OpenSees interpreter: when it encounters a new element type it will look for a library with the same name of the element. NOTE: This document assumes the reader is familiar with the Fortran programming language. Element Routine It should be noted the command contains all underscores. This is a consequence of the Fortran compiler, which for the compiler used output the procedure is in all lower case. Please note that before calling memory allocated for the pointers the Fortran code must make a call to the Fortran routine c f pointer(). Example - Truss2D In the following section we will provide all necessary code to add a new 2d planar truss element into an OpenSees interpreter. The stress-strain relationship will be provided by a UniaxialMaterial object. Please refer to the comments inserted in the code for further explanations. Please note that the following example has been corrected and expanded by the author of this page. The following code may not match the actual version in the OpenSees repository. SUBROUTINE trussf(eleObj,modl,tang,resid,isw,error) < / p > < p > !DEC$ IF DEFINED (_DLL) !DEC$ ATTRIBUTES DLLEXPORT :: TRUSSF !DEC$ END IF < / p > < p > use elementTypes use elementAPI implicit none < / p > < p > type(eleObject):: eleObj type(modelState):: modl double precision tang( 4 , * ) double precision resid( 4 ) integer:: isw; integer:: error; < / p > < p > integer :: tag, nd1, nd2, matTag, numCrd, i, j, numDOF real * 8 , pointer:: theParam(:) integer , pointer:: theNodes(:) < / p > < p > double precision A, dx, dy, L, cs, sn double precision dLength, force, k < / p > < p > integer :: iData( 3 ); integer :: matTags( 2 ); < / p > < p > type(c_ptr) :: theCMatPtr type(c_ptr) , pointer :: theCMatPtrPtr(:) type(matObject) , pointer :: theMat < / p > < p > double precision dData( 1 ), nd1Crd( 2 ), nd2Crd( 2 ) double precision d1( 2 ), d2( 2 ), tran( 4 ) double precision strs( 1 ), strn( 1 ), tng( 1 ) < / p > < p > integer numData, err, matType < / p > < p > The main IF/THEN structure of the routine begins here; it is needed to select the proper code depending on what the flag isw is requesting. < / p > < p > IF (isw .eq. ISW_INIT) THEN < / p > < p > c get the input data - tag ? nd1 ? nd2 ? A ? matTag ? < / p > < p > numData = 3 err = OPS_GetIntInput(numData, iData) tag = iData( 1 ); nd1 = iData( 2 ); nd2 = iData( 3 ); < / p > < p > numData = 1 err = OPS_GetDoubleInput(numData, dData) A = dData( 1 ); < / p > < p > numData = 1 err = OPS_GetIntInput(numData, iData) matTag = iData( 1 ); < / p > < p > c Allocate the element state < / p > < p > eleObj%tag = tag eleObj%nnode = 2 eleObj%ndof = 4 eleObj%nparam = 4 eleObj%nstate = 0 eleObj%nmat = 1 < / p > < p > matTags( 1 ) = matTag; matType = OPS_UNIAXIAL_MATERIAL_TYPE; err = OPS_AllocateElement(eleObj, matTags, matType) < / p > < p > c Initialize the element properties < / p > < p > call c_f_pointer(eleObj%param, theParam, [ 4 ] ); call c_f_pointer(eleObj%node, theNodes, [2]);</p> < p > numCrd = 2 ; err = OPS_GetNodeCrd(nd1, numCrd, nd1Crd); err = OPS_GetNodeCrd(nd2, numCrd, nd2Crd); < / p > < p > dx = nd2Crd( 1 ) - nd1Crd( 1 ); dy = nd2Crd( 2 ) - nd1Crd( 2 ); < / p > < p > L = sqrt (dx * dx + dy * dy); < / p > < p > if (L == 0.0 ) then c OPS_Error( \" Warning - truss element has zero length\\n \" , 1 ); return ; end if < / p > < p > cs = dx / L; sn = dy / L; < / p > < p > theParam( 1 ) = A; theParam( 2 ) = L; theParam( 3 ) = cs; theParam( 4 ) = sn; < / p > < p > theNodes( 1 ) = nd1; theNodes( 2 ) = nd2; < / p > < p > ELSE < / p > < p > IF (isw == ISW_COMMIT) THEN < / p > < p > In ISW_COMMIT, the state of the model is saved. If your element uses state variables, save them here. <source lang=\u201cfortran\u201d> call c_f_pointer(eleObj%mats, theCMatPtrPtr, [1]); theCMatPtr = theCMatPtrPtr(1); j=OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) ELSE IF (isw == ISW_REVERT_TO_START) THEN call c_f_pointer(eleObj%mats, theCMatPtrPtr, [1]); theCMatPtr = theCMatPtrPtr(1); j=OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) ELSE IF (isw == ISW_FORM_MASS) THEN In ISW_FORM_MASS, the mass matrix (if given by the element) must be returned in TANG. IMPORTANT: if your element returns no mass, remember to initialize TANG to zero! If not initialized, Fortran will return a mass matrix with random values. Also, do not overwrite RESID! ```fortran </p> <p>ELSE IF (isw == ISW_FORM_TANG_AND_RESID) THEN</p> <p> In ISW_FORM_TANG_AND_RESID, all the trials during a non-linear analysis are performed. DO NOT save state variables here. < / p > < p > call c_f_pointer(eleObj%param, theParam, [ 4 ] ); call c_f_pointer(eleObj%node, theNodes, [2]); call c_f_pointer(eleObj%mats, theCMatPtrPtr, [ 1 ] ); theCMatPtr = theCMatPtrPtr( 1 ); < / p > < p > A = theParam( 1 ); L = theParam( 2 ); cs = theParam( 3 ); sn = theParam( 4 ); nd1 = theNodes( 1 ); nd2 = theNodes( 2 ); < / p > < p > numDOF = 2 ; err = OPS_GetNodeDisp(nd1, numDOF, d1); err = OPS_GetNodeDisp(nd2, numDOF, d2); < / p > < p > tran( 1 ) = - cs; tran( 2 ) = - sn; tran( 3 ) = cs; tran( 4 ) = sn; < / p > < p > dLength = 0.0 ; do i = 1 , 2 dLength = dLength - (d2(i) - d1(i)) * tran(i); continue < / p > < p > strn( 1 ) = dLength / L; < / p > < p > c i = 0 c i = OPS_InvokeMaterial(eleObj, i, modl, strn, strs, tng, isw) j = OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) < / p > < p > force = A * strs( 1 ); k = A * tng( 1 ) / L; < / p > < p > do i = 1 , 4 resid(i) = force * tran(i); do j = 1 , 4 tang(i,j) = k * tran(i) * tran(j); continue continue < / p > < p > END IF < / p > < p > END IF < / p > < p > c return error code error = 0 < / p > < p > END SUBROUTINE trussf Compilation Instructions for Visual Studio on Windows The compilation can be carried out with Visual Studio, if Windows machines are used. Intel Visual Fortran can be used, it integrates itself with Visual Studio IDE during installation.","title":"Add a New Element Fortran\n"},{"location":"contrib/guides/extending/14-Add%20a%20New%20UniaxialMaterial%20C%2B%2B/","text":"Add a New UniaxialMaterial C++ To add a new Uniaxial Material module using the C++ language, the developer must: provide a new C++ subclass of the UniaxialMaterial class provide an interface function that will be used to parse the input and create the new material. Unlike the C and Fortran modules, no information about the state of the model is passed as arguments to the material methods. It is the responsibility of the material to okeep whatever information it needs. This information will include both parameters (information needed to define the material) and state variables or history variables (information needed by the material to remember it\u2019s current state for the computation of the stress and tangent) NOTE: This document assumes the reader is familiar with the C++ programming language. UniaxialMaterial Class The Uniaxial class itself is an abstract base class. It inherits from both the Material class, which is itself a subclass of TaggedObject class and the MovableObject class. The class has a large number of methods defined in the interface, not all these methods need to be included in a new UniaxialMaterial class. The following is the minimal interface that should be considered: The UniaxialMaterial Class: </ p > < ol > < li > ifndef ElasticPPcpp_h </ li > < li > define ElasticPPcpp_h </ li > </ ol > < p > // Written: fmk // // Description: This file contains the class definition for // ElasticPPcpp. ElasticPPcpp provides the abstraction // of an elastic perfectly plastic uniaxial material , // // What: \"@(#) ElasticPPcpp . h , revA \"</p> < ol > < li > include & lt ; UniaxialMaterial . h & gt ;</ li > </ ol > < p > class UniaxialMaterial : public Material { public : UniaxialMaterial ( int tag , int classTag ); virtual ~ UniaxialMaterial ();</ p > < p > virtual int setTrialStrain ( double strain , double strainRate = 0 ) = 0 ;</ p > < p > virtual double getStrain ( void ) = 0 ; virtual double getStrainRate ( void ); virtual double getStress ( void ) = 0 ; virtual double getTangent ( void ) = 0 ; virtual double getInitialTangent ( void ) = 0 ;</ p > < p > virtual int commitState ( void ) = 0 ; virtual int revertToLastCommit ( void ) = 0 ; virtual int revertToStart ( void ) = 0 ;</ p > < p > virtual UniaxialMaterial * getCopy ( void ) = 0 ;</ p > < p > virtual Response * setResponse ( const char ** argv , int argc , OPS_Stream & amp ; theOutputStream ); virtual int getResponse ( int responseID , Information & amp ; matInformation );</ p > < p > virtual int sendSelf ( int commitTag , Channel & amp ; theChannel ); virtual int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker );</ p > < p > virtual void Print ( OPS_Stream & amp ; s , int flag = 0 );</ p > < p > protected :</ p > < p > private : } The methods with =0; are methods that you must implement for the class to link successfully with OpenSees. The other classes are optional. The setTriaStrain() is the method called by an element when a new strain in the material is to be set. Subsequent calls to getTangent() and getStress() are to return thecorresponding tangent and stress values for that stress. setTrialStrain() is invoked as the solution algorithm tries a number of trial solution steps as it goes from one commited solution to the next on the solution path. The commitState() method is invoked when a trial solution has been determined to be on the solution path. It is the responsibility of the material to be able to back track to that solution if a revertToLastCOmmit() is invoked. This will happen if the algorithm fails to find a solution on the solution path. The getCopy() method is invoked by an element in the elements constructor. The material is to return a unique copy of itself to the element. This way different elements can use the same material type with the same properties, with each element having it\u2019s own unique copy. The setResponse()/getResponse() typically do not have to be provided. These are the methods called by a recorder after a commit(). If you are appy with the existing responses fro a UniaxialMaterial which responds to \u201cstress\u201d, \u201cstrain\u201d, \u201ctangent\u201d, \u201cstressANDstrain\u201d you do not have to implement these methods. The example below shows them just for those ew who want additional info out of their materials. The sendSelf()/recvSelf() methods are used in parallel processing with OpenSeesSP and when using the database command. If you don\u2019t envision using the material in these situations you can again ignore these methods. Again I am only showing them in the code for those even fewer who would do this. The commit() method is what is called Example - ElasticPPecpp In the following section we will provide all necessary code to add a new elastic perfectly plastic material into an OpenSees interpreter. Header The header for thew new class, which we will call Truss2D is as follows: </ p > < ol > < li > ifndef ElasticPPcpp_h </ li > < li > define ElasticPPcpp_h </ li > </ ol > < ol > < li > include & lt ; UniaxialMaterial . h & gt ;</ li > </ ol > < p > class ElasticPPcpp : public UniaxialMaterial { public : ElasticPPcpp ( int tag , double E , double eyp ); ElasticPPcpp ();</ p > < p >~ ElasticPPcpp ();</ p > < p > int setTrialStrain ( double strain , double strainRate = 0.0 ); double getStrain ( void ); double getStress ( void ); double getTangent ( void );</ p > < p > double getInitialTangent ( void ) { return E ;};</ p > < p > int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void );</ p > < p > UniaxialMaterial * getCopy ( void );</ p > < p > int sendSelf ( int commitTag , Channel & amp ; theChannel ); int recvSelf ( int commitTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker );</ p > < p > void Print ( OPS_Stream & amp ; s , int flag = 0 );</ p > < p > protected :</ p > < p > private : double fyp , fyn ; // positive and negative yield stress double ezero ; // initial strain double E; // elastic modulus double ep; // plastic strain at last commit</p> < p > double trialStrain ; // trial strain double trialStress; // current trial stress double trialTangent ; // current trial tangent double commitStrain ; // last commited strain double commitStress; // last commited stress double commitTangent ; // last committed tangent The header file defines the interface and variables for the class ElasticPPcpp. It defines the new class to be a sublass of the UniaxialMaterial class. In the public interface, are two constructors and a destructor in addition to minimal set of methods we showed for the UniaxialMaterial class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we define a number of private variables and a number of variables. Some of these are parameter variable which do not change with each commit, e.g. E, and some state variable which do change, e.g. ep, fyp, and fyn. Implementation It another file, ElasticPPcpp.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_ElasticPPcpp() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. </ p > < ol > < li > include \"ElasticPPcpp.h\" </ li > </ ol > < ol > < li > include & lt ; elementAPI . h & gt ;</ li > < li > include & lt ; Vector . h & gt ;</ li > < li > include & lt ; Channel . h & gt ;</ li > < li > include & lt ; math . h & gt ;</ li > < li > include & lt ; float . h & gt ;</ li > </ ol > < p > Static Variables Next, we initialize the static variables. For this example we are using 1 static-variables to keep track of the number of times the external procedure to parse and create such an object is called. static int numElasticPPcpp = 0 ; Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0 if you use pointers in your class. We will use none here. The first constructor is the one most typically used. The arguments provide the materials tag, youngs modulus and initial yield point strain values. material. The code in the constructor simply computes the positive and negative yield stress based on the input provided. ElasticPPcpp :: ElasticPPcpp ( int tag , double e , double eyp )</ p > < dl > < dt ></ dt > < dd > UniaxialMaterial ( tag , 0 ), </ dd > </ dl > < p > ezero ( 0.0 ), E ( e ), ep ( 0.0 ), trialStrain ( 0.0 ), trialStress ( 0.0 ), trialTangent ( E ), commitStrain ( 0.0 ), commitStress ( 0.0 ), commitTangent ( E ) { fyp = E * eyp ; fyn = - fyp ; } The second constructor is called when paralell processing or the database feature of the OpenSees application is used. It\u2019s purpose is to create a blank TElasticPPcpp object, that will be filled in when the recvSelf() method is invoked on the object. ElasticPPcpp :: ElasticPPcpp ()</ p > < dl > < dt ></ dt > < dd > UniaxialMaterial ( 0 , 0 ), </ dd > </ dl > < p > fyp ( 0.0 ), fyn ( 0.0 ), ezero ( 0.0 ), E ( 0.0 ), ep ( 0.0 ), trialStrain ( 0.0 ), trialStress ( 0.0 ), trialTangent ( E ), commitStrain ( 0.0 ), commitStress ( 0.0 ), commitTangent ( E ) {</ p > < p >}</ p > < p > Destructor The we provide the destructor. In the destructor all memory that the the object created or was passed to it in the constructor must be destroyed. For this example we have no such memory. We could have left the destructor out entirely. Hoowever, it is good practice to leave it in your source code. ElasticPPcpp ::~ ElasticPPcpp () { // does nothing } getCopy() Method This is the method called by each element or section to get unique copies of a material. UniaxialMaterial * ElasticPPcpp :: getCopy ( void ) { ElasticPPcpp * theCopy = new ElasticPPcpp ( this -& gt ; getTag (), E , fyp / E ); theCopy -& gt ; ep = this -& gt ; ep ;</ p > < p > return theCopy ; } setTrialStrain() Method This, as mentioned, is the method called when the element has computed a nw strain for the element. The element will make subsequent calls to getStress() and getTangent() to obtain new values of these for the new strain. This is typically the most complicated method to write and to determine the theory for before you even write the code. ALl subsequent methods are trivial. int ElasticPPcpp :: setTrialStrain ( double strain , double strainRate ) { if ( fabs ( trialStrain - strain ) & lt ; DBL_EPSILON ) return 0 ;</ p > < p > trialStrain = strain ;</ p > < p > double sigtrial ; // trial stress double f; // yield function</p> < p > // compute trial stress sigtrial = E * ( trialStrain - ezero - ep );</ p > < p > //sigtrial = E * trialStrain; //sigtrial -= E * ezero; //sigtrial -= E * ep ;</ p > < p > // evaluate yield function if ( sigtrial &gt;= 0.0 ) f = sigtrial - fyp ; else f = - sigtrial + fyn ;</ p > < p > double fYieldSurface = - E * DBL_EPSILON ; if ( f & lt ;= fYieldSurface ) {</ p > < p > // elastic trialStress = sigtrial; trialTangent = E;</p> < p >} else {</ p > < p > // plastic if ( sigtrial &gt; 0.0 ) { trialStress = fyp; } else { trialStress = fyn ; }</ p > < p > trialTangent = 0.0 ; }</ p > < p > return 0 ; }</ p > < p > Trivial Methods Next comes 3 rather simple methods that return basic information computed in the setTrialStrain(). You do of course have the option to ignore the setTrialStrain() method and compute the stress and tangent quantities again in the interests of saving memory. <source lang=\u201ccpp\u201d> double ElasticPPcpp::getStrain(void) { return trialStrain; } double ElasticPPcpp::getStress(void) { return trialStress; } double ElasticPPcpp::getTangent(void) { return trialTangent; } </p> <h5 id=\"methods_dealing_with_current_state\">Methods Dealing With Current State</h5> <p>As mentioned, when the algorithm finds a solution state as it goes from one converged solution to the next. As it attempts to find these solutions it goes through a number of trial steps (each setTrialStrain() is invoked in each of these steps). Once it finds a trial step that is on the solution path it will stop and invoke commitState() on the material. Any state variables that the material uses needs to be updated at this time. Should the algorithm fail to find a solution it may return to the last converged step or indeed the start. You the developer must provide code so that your mateial can indeed go back to these states and report correct getTangent() and getStress() values for subsequent analysis atte,pts.</p> <p> ```cpp int ElasticPPcpp::commitState(void) { double sigtrial; // trial stress double f; // yield function</p> <p>// compute trial stress sigtrial = E * ( trialStrain - ezero - ep );</p> <p>// evaluate yield function if ( sigtrial &gt;= 0.0 ) f = sigtrial - fyp; else f = -sigtrial + fyn;</p> <p>double fYieldSurface = - E * DBL_EPSILON; if ( f &gt; fYieldSurface ) { // plastic if ( sigtrial &gt; 0.0 ) { ep += f / E; } else { ep -= f / E; } }</p> <p>commitStrain = trialStrain; commitTangent=trialTangent; commitStress = trialStress;</p> <p>return 0; }</p> <p>int ElasticPPcpp::revertToLastCommit(void) { trialStrain = commitStrain; trialTangent = commitTangent; trialStress = commitStress;</p> <p>return 0; }</p> <p>int ElasticPPcpp::revertToStart(void) { trialStrain = commitStrain = 0.0; trialTangent = commitTangent = E; trialStress = commitStress = 0.0;</p> <p>ep = 0.0;</p> <p>return 0; }</p> <p> Methods Dealing With Output Information is obtained by the user when the print command is invoked by the user and also when the user issues the recorder command. When the print command is invoked the Print method is invoked. This method simply prints information about the element, and then asks the material to do likewise. void ElasticPPcpp :: Print ( OPS_Stream & amp ; s , int flag ) { s & lt ;& lt ; \"ElasticPPcpp tag: \" & lt ;& lt ; this -& gt ; getTag () & lt ;& lt ; endln ; s & lt ;& lt ; \" E: \" & lt ;& lt ; E & lt ;& lt ; endln ; s & lt ;& lt ; \" ep: \" & lt ;& lt ; ep & lt ;& lt ; endln ; s & lt ;& lt ; \" stress: \" & lt ;& lt ; trialStress & lt ;& lt ; \" tangent: \" & lt ;& lt ; trialTangent & lt ;& lt ; endln ; } There are two methods used by the element recorders. The first method, setResponse(), is called when the recorder is created. The element informs the recorder that it can respond to a request of that type, if it cannot respond to the request it returns a 0, otherwise it returns an Response object. The response object includes a pointer to the element, an integer flag used to id the response when the getResponse() method is called, and a Vector detailing the size of the response. The second method, getReponse(), is called by the recorder when it is actually recording the information. </ p > < p > Methods Dealing With Databases/Parallel Processing There are two methods provided which are required is the user uses to use the database or parallel procesing features of the OpenSees applications. If neither are to be used, the developer need simply return a negative value in both methods. The idea is that the material must pack up it\u2019s information using Vector and ID objects and send it off to a Channel object. On the flip side, the receiving blank element must receive the same Vector and ID data, unpack it and set the variables. int ElasticPPcpp :: sendSelf ( int cTag , Channel & amp ; theChannel ) { int res = 0 ; static Vector data ( 9 ); data ( 0 ) = this -& gt ; getTag (); data ( 1 ) = ep ; data ( 2 ) = E ; data ( 3 ) = ezero ; data ( 4 ) = fyp ; data ( 5 ) = fyn ; data ( 6 ) = commitStrain ; data ( 7 ) = commitStress ; data ( 8 ) = commitTangent ;</ p > < p > res = theChannel . sendVector ( this -& gt ; getDbTag (), cTag , data ); if ( res & lt ; 0 ) opserr & lt ;& lt ; \"ElasticPPcpp::sendSelf() - failed to send data\\n \";</p> < p > return res ; }</ p > < p > int ElasticPPcpp :: recvSelf ( int cTag , Channel & amp ; theChannel , FEM_ObjectBroker & amp ; theBroker ) { int res = 0 ; static Vector data ( 9 ); res = theChannel . recvVector ( this -& gt ; getDbTag (), cTag , data ); if ( res & lt ; 0 ) opserr & lt ;& lt ; \"ElasticPPcpp::recvSelf() - failed to recv data\\n \"; else { this-&gt;setTag(data(0)); ep = data(1); E = data(2); ezero = data ( 3 ); fyp = data ( 4 ); fyn = data ( 5 ); commitStrain = data ( 6 ); commitStress = data ( 7 ); commitTangent = data ( 8 ); trialStrain = commitStrain ; trialTangent = commitTangent ; trialStress = commitStress ; }</ p > < p > return res ; } External Procedure This is the all importat extenal procedure that the interpreter will parse when it comes accross your element on the command line. You need to parse the command line, create a material using the command line arguments you parsed and then return this material. The name of the procedure must be OPS_YourClassName (no exceptions). If this procedure is missing or the name is incorrect, your material will fail to load. NOTE: parsing the command line is easy with some other procedures that are defined in the elementAPI.h file. In the example we show how to get integer and double values from the command line. Other options such as character strings and obtaining the number of input arguments are also available. The #ifdef stuff at the start is required for different operating systems. </ p > < ol > < li > ifdef _USRDLL </ li > < li > define OPS_Export extern \"C\" _declspec ( dllexport )</ li > < li > elif _MACOSX </ li > < li > define OPS_Export extern \"C\" __attribute__((visibility( \"default\" ))) </ li > < li > else </ li > < li > define OPS_Export extern \"C\" </ li > < li > endif </ li > </ ol > < p > OPS_Export void * OPS_ElasticPPcpp () { // print out some KUDO's if ( numElasticPPcpp == 0 ) { opserr & lt ;& lt ; \"ElasticPPcpp unaxial material - Written by fmk UC Berkeley Copyright 2008 - Use at your Own Peril\\n \"; numElasticPPcpp = 1 ; }</ p > < p > // Pointer to a uniaxial material that will be returned UniaxialMaterial * theMaterial = 0 ;</ p > < p > // // parse the input line for the material parameters //</p> < p > int iData [ 1 ]; double dData [ 2 ]; int numData ; numData = 1 ; if ( OPS_GetIntInput (& amp ; numData , iData ) != 0 ) { opserr & lt ;& lt ; \"WARNING invalid uniaxialMaterial ElasticPP tag \" &lt;&lt; endln; return 0; }</p> < p > numData = 2 ; if ( OPS_GetDoubleInput (& amp ; numData , dData ) != 0 ) { opserr & lt ;& lt ; \"WARNING invalid E &amp; ep \\n \" ; return 0 ; }</ p > < p > // // create a new material //</p> < p > theMaterial = new ElasticPPcpp ( iData [ 0 ], dData [ 0 ], dData [ 1 ]);</ p > < p > if ( theMaterial == 0 ) { opserr & lt ;& lt ; \"WARNING could not create uniaxialMaterial of type ElasticPPCpp\\n \"; return 0; }</p> < p > // return the material return theMaterial; }","title":"Add a New UniaxialMaterial C++\n"},{"location":"contrib/modeling/element/105-CorotTruss2%20Element/","text":"CorotTruss2 Element","title":"CorotTruss2 Element\n"},{"location":"contrib/modeling/element/107-Corotational%20Truss%20Element/","text":"Corotational Truss Element This command is used to construct a corotational truss element object. There are two ways to construct a corotational truss element object: One way is to specify an area and a UniaxialMaterial identifier: element corotTruss $eleTag $iNode $jNode $A $matTag &lt;-rho $rho &gt; &lt;-cMass $cFlag &gt; &lt;-doRayleigh $rFlag &gt; the other is to specify a Section identifier: element corotTrussSection $eleTag $iNode $jNode $secTag &lt;-rho $rho &gt; &lt;-cMass $cFlag &gt; &lt;-doRayleigh $rFlag &gt; eleTag unique element object tag $iNode $jNode end nodes A cross-sectional area of element matTag tag associated with previously-defined UniaxialMaterial secTag tag associated with previously-defined Section rho mass per unit length, optional, default = 0.0 cFlag consistent mass flag, optional, default = 0 cFlag = 0 lumped mass matrix (default) cFlag = 1 consistent mass matrix rFlag Rayleigh damping flag, optional, default = 0 rFlag = 0 NO RAYLEIGH DAMPING (default) rFlag = 1 include Rayleigh damping NOTE: When constructed with a UniaxialMaterial object, the corotational truss element considers strain-rate effects, and is thus suitable for use as a damping element. The valid queries to a truss element when creating an ElementRecorder object are \u2018axialForce,\u2019 \u2018stiff,\u2019 deformations,\u2019 \u2018material matArg1 matArg2\u2026,\u2019 \u2018section sectArg1 sectArg2\u2026\u2019 There will be more queries after the interface for the methods involved have been developed further. For backward compatability the command \u2019element corotTruss $eleTag $iNode $jNode $secTag will still work and produce a CorotTrussSection element. CorotTruss DOES NOT include Rayleigh damping by default. Examples element truss 1 2 4 5.5 9; # truss element with tag 1 added between nodes 2 and 4 with area 5.5 that uses material 9 Code Developed by: Michael H. Scott, Oregon State University","title":"Corotational Truss Element\n"},{"location":"contrib/modeling/element/109-CoupledZeroLength%20Element/","text":"CoupledZeroLength Element This command is used to construct a CoupledZeroLength element object, which is defined by two nodes at the same location. The nodes are connected a single UniaxialMaterial element to represent the force-deformation relationship for the element in a 2d plane. Unlike a ZeroLength element which can only provide a rectangular force interaction surface in a 2d plane, this element provides a circular force interaction surface. element CoupledZeroLength $eleTag $iNode $jNode $dirn1 $dirn2 $matTag &lt; $rFlag &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tags associated with previously-defined UniaxialMaterial</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dir1 $dir2 the two directions, 1 through ndof. rFlag optional, default = 0 rFlag = 0 NO RAYLEIGH DAMPING (default) rFlag = 1 include rayleigh damping NOTE: The valid queries to a zero-length element when creating an ElementRecorder object are \u2018force,\u2019 and \u2018material matArg1 matArg2 \u2026\u2019 Examples element CoupledZeroLength 1 2 4 5 6 7; # truss tag 1 between nodes 2 and 4 acting in directions 5 and 6 with material 7. Theory if change in element end displacements for 2 dof of interest are d1 and d2: the deformation (strain in uniaxial material) of the material is set to be: <math>= sqrt( ^2 + ^2)</math> and if resulting force (stress from uniaxial material) is Sigma then the force computed for the two directions 1 and 2 are: <math> F_1 = () / </math> <math> F_2 = () / </math> NOTE: in case where \\(\\epsilon = 0.0\\) , the forces are computed using \\(\\Sigma\\) and the last committed set of displacements that were not zero. Code Developed by: fmk","title":"CoupledZeroLength Element\n"},{"location":"contrib/modeling/element/153-Displacement-Based%20Beam-Column%20Element/","text":"Displacement-Based Beam-Column Element This command is used to construct a displacement beam element object, which is based on the displacement formulation, and considers the spread of plasticity along the element. element dispBeamColumn $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; &lt;-integration $intType &gt; To change the sections along the element length, the following form of command may be used: element dispBeamColumn $eleTag $iNode $jNode $numIntgrPts -sections $secTag1 $secTag2 ... $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; &lt;-integration $intType &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">numIntgrPts</code></td> <td><p>number of integration points along the element.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">secTag</code></td> <td><p>identifier for previously-defined section object</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) secTag1 \\(secTag2 ...</strong></p></td> <td><p>\\) numIntgrPts identifiers of previously-defined section object transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object massDens element mass density (per unit length), from which a lumped-mass matrix is formed (optional, default = 0.0) -cMass to form consistent mass matrix (optional, default = lumped mass matrix) intType numerical integration type, options are Lobotto, Legendre, Radau, NewtonCotes, Trapezoidal (optional, default = Legendre) NOTE: The default integration along the element is based on Gauss-Legendre quadrature rule. The default element is prismatic, i.e. the beam is represented by the section model identified by $secTag at each integration point. The valid queries to a displacement-based beam-column element when creating an ElementRecorder object are \u2018force,\u2019 and \u2018section $secNum secArg1 secArg2\u2026\u2019 Where $secNum refers to the integration point whose data is to be output valid entries being 1 through $numIntgrPts. Examples element dispBeamColumn 1 2 4 5 8 9; # displacement-based beam column element added with tag 1 between nodes 2 and 4 that has 5 integration points, each using section 8, and the element uses geometric transformation 9 REFERENCES: Code Developed by: Michael H. Scott, Oregon State University","title":"Displacement-Based Beam-Column Element\n"},{"location":"contrib/modeling/element/183-ElasticTubularJoint%20Element/","text":"ElasticTubularJoint Element This command is used to construct an ElasticTubularJoint element object, which models joint flexibility of tubular joints in two dimensional analysis of any structure having tubular joints. element ElasticTubularJoint $Tag $iNode $jNode $Brace_Diameter $Brace_Angle $E $Chord_Diameter $Chord_Thickness $Chord_Angle Tag unique element object tag iNode first end node- it is always located on the chord axis jNode second end node - it is always located on the chord wall Brace_Diameter outer diameter of brace Brace_Angle angle between brace and chord axis 0 < Brace_Angle < 90 E Young\u2019s Modulus $ Chord_Diameter outer diameter of chord Chord_Thickness thickness of chord Chord_Angle angle between chord axis and global x-axis 0 < Chord_Angle < 180 Examples element ElasticTubularJoint 1 1 2 0.25 45 210E+09 0.5 0.016 45 # Tubular joint having tag 1 which interconnects nodes 1 and 2; brace diameter is 25cm; intersection angle is 45 degrees; Young\u2019s modulus of the material used is 210e9; outer diameter and thickness of the chord are 50 cm and 1.6 cm respectively; angle between chord axis and global horizontal axis is 45 degrees. Code Developed by: M. Kia and P. Alanjari, Sharif University of Technology and K. N. Toosi University of Technology, Tehran, Iran.","title":"ElasticTubularJoint Element\n"},{"location":"contrib/modeling/element/184-Elastic%20Beam%20Column%20Element/","text":"Elastic Beam Column Element This command is used to construct an elasticBeamColumn element object. The arguments for the construction of an elastic beam-column element depend on the dimension of the problem, ndm: For a two-dimensional problem: element elasticBeamColumn $eleTag $iNode $jNode $A $E $Iz $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; For a three-dimensional problem: element elasticBeamColumn $eleTag $iNode $jNode $A $E $G $J $Iy $Iz $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; eleTag unique element object tag $iNode $jNode end nodes A cross-sectional area of element E Young\u2019s Modulus G Shear Modulus J torsional moment of inertia of cross section Iz second moment of area about the local z-axis Iy second moment of area about the local y-axis transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object massDens element mass per unit length (optional, default = 0.0) -cMass to form consistent mass matrix (optional, default = lumped mass matrix) NOTE: The valid queries to an elastic beam-column element when creating an ElementRecorder object are \u2018force\u2019. Examples element elasticBeamColumn 1 2 4 5.5 100.0 1e6 9; # elastic element tag 1 between nodes 2 and 4 with area 5.5, E 100 and Iz 1e6 which uses transformation 9 Code Developed by: fmk","title":"Elastic Beam Column Element\n"},{"location":"contrib/modeling/element/185-Elastic%20Beam%20Column%20Element%20with%20Stiffness%20Modifiers/","text":"Elastic Beam Column Element with Stiffness Modifiers This command is used to construct a ModElasticBeam2d element object. The arguments for the construction of an elastic beam-column element with stiffness modifiers is applicable for 2-D problems. This element should be used for modelling of a structural element with an equivalent combination of one elastic element with stiffness-proportional damping, and two springs at its two ends with no stiffness proportional damping to represent a prismatic section. The modelling technique is based on a number of analytical studies discussed in Zareian and Medina (2010) and Zareian and Krawinkler (2009) and is utilized in order to solve problems related to numerical damping in dynamic analysis of frame structures with concentrated plasticity springs. element ModElasticBeam2d $eleTag $iNode $jNode $A $E $Iz $K11 $K33 $K44 $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; eleTag unique element object tag $iNode $jNode end nodes A cross-sectional area of element E Young\u2019s Modulus Iz second moment of area about the local z-axis K11 stiffness modifier for translation K33 stiffness modifier for translation K44 stiffness modifier for rotation transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object massDens element mass per unit length (optional, default = 0.0) -cMass to form consistent mass matrix (optional, default = lumped mass matrix) Element Formation : For structural elements with time invariant moment gradient, a two-dimensional, prismatic beam element with six degrees of freedom is to be replaced with a two-dimensional, prismatic beam element composed of semi-rigid rotational springs at the ends and an elastic beam element in the middle. The rotational stiffness at the end of the original beam element is Ke = 6EIz/L (where E is the modulus of elasticity, Iz the moment of inertia, and L the length of the beam), and the ratio of the rotational spring stiffness, Ks, to the elastic beam stiffness, Ke, of the modified beam element is defined as n = Ks/Ke. Elastic Element with 2-end Springs: The elastic element in between the two springs should have an elastic moment of inertia equal to Iz,mod = (n+1)/n * Iz The \u201cn\u201d times stiff rotational springs should have an elastic stiffness of Ks=n 6 EIz,mod/L the elastic element should have an elastic stiffness coefficient K44 = 6 (1+n)/(2+3 n) The elastic element should have an elastic stiffness coefficient K11 = K33 = (1+2 n) K44/(1+n) The modified stiffness coefficient bmod for stiffness proportional damping of the elastic element is: \u201cbmod\u201d = 1+(1/2n)*b Elastic Element with 1-end Spring: The elastic element in between the two springs should have an elastic moment of inertia equal to Iz,mod = (n+1)/n * Iz The \u201cn\u201d times stiff rotational springs should have an elastic stiffness of Ks=n 6 EIz,mod/L The elastic element should have an elastic stiffness coefficient K44 = 6 n/( 1+3 n ) the elastic element should have an elastic stiffness coefficient K11 = (1+2 n) K44/(1+n) the elastic element should have an elastic stiffness coefficient K33 = 2*K44 The modified stiffness coefficient bmod for stiffness proportional damping of the elastic element is: \u201cbmod\u201d = 1+(1/2n)*b EXAMPLE : element ModelasticBeam2d 1 2 4 5.5 100.0 1e6 4.0 4.0 2.0 1; # elastic element tag 1 between nodes 2 and 4 with area 5.5, E 100 and IZ 1e6 with K11=K33=4.0, K44=2.0 which uses transformation 1 Note: For n = 1 rigid spring, the stiffness coefficients of the elastic springs are as follows: K11=K33 = 4.0 and K44 = 2.0 References : [1] Zareian, F. and Medina, R. A. (2010). \u201cA practical method for proper modeling of structural damping in inelastic plane structural systems,\u201d Computers & Structures, Vol. 88, 1-2, pp. 45-53. [2] Zareian, F. and Krawinkler, H. (2009). \u201cSimplified performance-based earthquake engineering\u201d Technical Report 169, The John A. Blume Earthquake Engineering Research Center, Department of Civil Engineering, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] Code Developed by: by Dr. Dimitrios G. Lignos (McGill University)","title":"Elastic Beam Column Element with Stiffness Modifiers\n"},{"location":"contrib/modeling/element/194-Elastic%20Timoshenko%20Beam%20Column%20Element/","text":"Elastic Timoshenko Beam Column Element This command is used to construct an ElasticTimoshenkoBeam element object. A Timoshenko beam is a frame member that accounts for shear deformations. The arguments for the construction of an elastic Timoshenko beam element depend on the dimension of the problem, ndm: For a two-dimensional problem: element ElasticTimoshenkoBeam $eleTag $iNode $jNode $E $G $A $Iz $Avy $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; For a three-dimensional problem: element ElasticTimoshenkoBeam $eleTag $iNode $jNode $E $G $A $Jx $Iy $Iz $Avy $Avz $transfTag &lt;-mass $massDens &gt; &lt;-cMass&gt; eleTag unique element object tag $iNode $jNode end nodes E Young\u2019s Modulus G Shear Modulus A cross-sectional area of element Jx torsional moment of inertia of cross section Iy second moment of area about the local y-axis Iz second moment of area about the local z-axis Avy Shear area for the local y-axis Avz Shear area for the local z-axis transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object massDens element mass per unit length (optional, default = 0.0) -cMass to form consistent mass matrix (optional, default = lumped mass matrix) NOTES: The valid queries to an elastic Timoshenko beam element when creating an ElementRecorder object are \u2018force\u2019. For solid rectangular sections, the shear area is 5/6 of the gross area. For solid circular sections, the shear area is 9/10 of the gross area. For I-shapes, the shear area can be approximated as Aweb. Examples element ElasticTimoshenkoBeam 1 2 4 100.0 45.0 6.0 4.5 5.0 9; # elastic Timoshenko element with tag 1 between nodes 2 and 4 with E=100, G=45, A=6.0, I=4.5 and Av=5.0 which uses transformation 9 Code Developed by: Andreas Schellenberg","title":"Elastic Timoshenko Beam Column Element\n"},{"location":"contrib/modeling/element/196-ElastomericX/","text":"ElastomericX This command is used to construct an ElastomericX bearing element object in three-dimension. The 3D continuum geometry of an elastomeric bearing is modeled as a 2-node, 12 DOF discrete element. This elements extends the formulation of Elastomeric_Bearing_(Bouc-Wen)_Element element. However, instead of the user providing material models as input arguments, it only requires geometric and material properties of an elastomeric bearing as arguments. The material models in six direction are formulated within the element from input arguments. The time-dependent values of mechanical properties (e.g., shear stiffness, buckling load capacity) can also be recorded using the \u201cparameters\u201d recorder . For a 3D problem: element ElastomericX $eleTag $Nd1 $Nd2 $Fy $alpha $Gr $Kbulk $D1 $D2 $ts $tr $n &lt;&lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt; $kc &gt; &lt; $PhiM &gt; &lt; $ac &gt; &lt; $sDratio &gt; &lt; $m &gt; &lt; $cd &gt; &lt; $tc &gt; &lt; $tag1 &gt; &lt; $tag2 &gt; &lt; $tag3 &gt; &lt; $tag4 &gt; eleTag unique element object tag $Nd1 \\(Nd2</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Fy</code></td> <td><p>yield strength</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>post-yield stiffness ratio</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Gr</code></td> <td><p>shear modulus of elastomeric bearing</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Kbulk</code></td> <td><p>bulk modulus of rubber</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">D1</code></p></td> <td><p>internal diameter</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">D2</code></p></td> <td><p>outer diameter (excluding cover thickness)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ts</code></td> <td><p>single steel shim layer thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">tr</code></td> <td><p>single rubber layer thickness</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">n</code></td> <td><p>number of rubber layers</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) kc cavitation parameter (optional, default = 10.0) PhiM damage parameter (optional, default = 0.5) ac strength reduction parameter (optional, default = 1.0) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.5) m element mass (optional, default = 0.0) cd viscous damping parameter (optional, default = 0.0) tc cover thickness (optional, default = 0.0) tag1 Tag to include cavitation and post-cavitation (optional, default = 0) tag2 Tag to include buckling load variation (optional, default = 0) tag3 Tag to include horizontal stiffness variation (optional, default = 0) tag4 Tag to include vertical stiffness variation (optional, default = 0) Important note: Because default values of heating parameters are in SI units, user must override the default heating parameters values if using Imperial units <br /> User should distinguish between yield strength of elastomeric bearing (Fy) and characteristic strength (Qd): Qd=Fy*(1-alpha) Physical Model and Mechanical Properties The physical model of an elastomeric bearing is considered as a two-node, twelve degrees-of-freedom discrete element. The two nodes are connected by six springs that represent the mechanical behavior in the six basic directions of a bearing. The degrees of freedom and discrete spring representation of an elastomeric bearing is shown in the below figures. The general form of element force vector, $$, and element stiffness matrix,<math></math> , for element representation considered above is given by equation below: <math>=; =</math> The coupling of the two shear springs is considered directly by using a coupled bidirectional model. All other springs are uncoupled. The coupling of vertical and horizontal directions are considered indirectly by using expressions for mechanical properties in one direction that are dependent on the response parameters in the other direction. Linear uncoupled springs are considered in the torsion and the two rotational springs as they are not expected to significantly affect the response of an elastomeric bearing. The off-diagonal terms due to coupling between axial and shear, and axial and rotation, are not considered in the two-spring model (Koh and Kelly, 1987) used here. An exact model would have non-zero values of these off-diagonal terms. A discussion on the formulation of the two-spring model and the exact model is presented in Ryan et al.(1991). The subscript b refers to the element\u2019s basic coordinate system. The response quantities are transformed between the basic, local and global coordinates to perform computations. The discrete spring model presented here has the advantages of easy implementation and being computationally efficient. The mechanical properties of the six springs (also referred to as material models in OpenSees) are defined using analytical solutions available from the analysis of elastomeric bearings. The expression for mechanical properties, including stiffness and buckling load capacity, are derived using explicit consideration for geometric nonlinearity due to large displacement effects. The material models in six directions are: Axial direction: a new mathematical model that captures the behavior under cyclic tension Link Two shear directions: a special case of the Bouc-Wen model extended by Nagarajaiah et al.(1991) for seismic isolation bearings Torsion: a linear elastic model Two rotational directions: linear elastic models In addition to the behavior captured by existing bearing elements, this element can capture following characteristics: Cavitation and post-cavitation behavior in tension (tag1) Variation in critical buckling load capacity due to lateral displacement (tag2) Variation in horizontal shear stiffness with axial load on the bearing (tag3) Variation in vertical axial stiffness with horizontal displacement (tag4) User may choose to include an individual or a combination of these behaviors through user tags (include:1, exclude:0) in their analysis. For the full capabilities of this element, users are referred to: EESD Article Consideration of characteristics to include under extreme loading A recent paper by Kumar et. al (2015) explains which of the four tags should be included in the analysis. Although the analysis presented in the paper is for the base-isolated NPP, the conclusions are valid for design earthquake and maximum considered earthquake for regular building structures as well. Following are few thumb rules that can be followed: tag 1: Unless you are investigating the tensile behavior, the effect of the tensile model on shear response is insignificant. tag 2: It is recommended to use tag to include variable buckling load capacity. It affects the compression capacity and shear stiffness. The apparent softening in shear force-deformation behavior at high axial load is due to this. A constant buckling load will show less softening. tag 3: Recommended if axial load expected during the loading is more than 10% of the buckling load capacity. tag2+tag3 provide greater softening. tag 4: Unless you are investigating the axial behavior, the effect of the tensile model on shear response is insignificant. Verification and validation This is element has been verified per ASME guidelines. Users are referred to the SMiRT23 Paper and chapter 4 of the Manish Kumar\u2019s Dissertation for complete details. Recorders In addition to regular recorders provided by the bearing elements ( Element Recorder ), this element can also record instantaneous values of cavitation force (Fcn), buckling load capacity (Fcrn), vertical stiffness (Kv) and horizontal stiffness (ke) using the \u201cParameters\u201d recorder in that order. Example: recorder Element <-file \\(fileName&gt; -time &lt;-ele (\\) ele1 $ele2 \u2026)> Parameters recorder Element -file param.out -time -ele 1 Parameters To check if bearing has buckled or cavitated, an user can obtain the histories of Fcn and Fcrn as described above and divide the axial force (obtained from basicForce recorder, qb(2)) by Fcn and Fcrn at each time step, which provides demand vs capacity (D/C) ratios at each time step. If Fcn/qb(0) > 1.0 : Cavitation, or Fcrn/qb(0)>1.0 : Buckling. Examples An example is presented here in which a low damping rubber bearing (LDR 5 in Warn(2006)) is subjected to a tensile harmonic loading in laboratory (SEESL at UB). The response obtained from ElastomericX element in OpenSees is compared with the experimental results. The behavior of elastomeric bearing in shear and compression is well established, and is not explored here. element ElastomericX 1 1 2 $Fy_h $alpha $G $K $D1 $D2 $ts $tr $n 0 1 0 1 0 0 $kc $PhiM $ac 0.5 0.0 $cd $tc 1 0 0 0 Excitation files: \u200e Tcl files: inline|Numerical and experimental response comparison More examples of this element would be uploaded soon! References Kumar, M., Whittaker, A., and Constantinou, M. (2014). \u201cAn advanced numerical model of elastomeric seismic isolation bearings.\u201d Earthquake Engineering & Structural Dynamics, 43(13), 1955-1974. Link Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cExperimental investigation of cavitation in elastomeric seismic isolation bearings.\u201d Engineering Structures, 101, 290-305. Link Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cResponse of base-isolated nuclear structures to extreme earthquake shaking.\u201d Nuclear Engineering and Design (In press). Link Warn, G. P. (2006). \u201cThe coupled horizontal-vertical response of elastomeric and lead-rubber seismic isolation bearings.\u201d PhD Dissertation, Civil, Structural and Environmental Engineering, University at Buffalo. Koh, C. G., and Kelly, J. M. (1987). \u201cEffects of axial load on elastomeric isolation bearings.\u201d EERC/UBC 86/12, Earthquake Engineering Research Center, University of California, Berkeley, United States, 108p. Nagarajaiah, S., Reinhorn, A. M., and Constantinou, M. C. (1991). \u201cNonlinear dynamic analysis of 3-d-base-isolated structures.\u201d Journal of structural engineering New York, N.Y., 117(7), 2035-2054. Ryan, K. L., Kelly, J. M., and Chopra, A. K. (2005). \u201cNonlinear model for lead-rubber bearings including axial-load effects.\u201d Journal of Engineering Mechanics, 131(12), 1270-1278. Code Developed by: Manish Kumar, University at Buffalo, SUNY. Any bugs in this element can be reported to mkumar2 AT buffalo dot edu","title":"ElastomericX\n"},{"location":"contrib/modeling/element/197-Elastomeric%20Bearing%20%28Bouc-Wen%29%20Element/","text":"Elastomeric Bearing (Bouc-Wen) Element This command is used to construct an elastomericBearing element object, which is defined by two nodes. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) plasticity properties for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. By default (sDratio = 0.5) P-Delta moments are equally distributed to the two end-nodes. To avoid the introduction of artificial viscous damping in the isolation system (sometimes referred to as \u201cdamping leakage in the isolation system\u201d), the bearing element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element elastomericBearingBoucWen $eleTag $iNode $jNode $kInit $qd $alpha1 $alpha2 $mu $eta $beta $gamma -P $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; For a three-dimensional problem: element elastomericBearingBoucWen $eleTag $iNode $jNode $kInit $qd $alpha1 $alpha2 $mu $eta $beat $gamma -P $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; eleTag unique element object tag $iNode $jNode end nodes kInit initial elastic stiffness in local shear direction qd characteristic strength alpha1 post yield stiffness ratio of linear hardening component alpha2 post yield stiffness ratio of non-linear hardening component mu exponent of non-linear hardening component eta yielding exponent (sharpness of hysteresis loop corners) (default = 1.0) beta first hysteretic shape parameter (default = 0.5) gamma second hysteretic shape parameter (default = 0.5) -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.5) -doRayleigh to include Rayleigh damping from the bearing (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. Elastomeric bearings are very stiff in compression, but not rigid. It is not a good idea to specify an extremely large axial stiffness (such as 1E10), because it can lead to problems with numerical sensitivity. Always specify a realistic value for the stiffness of the material that is assigned along the axial direction. To assign different compression and tension stiffness the Elastic or ElasticMultiLinear material can be used. The valid queries to an elastomeric bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples element elastomericBearingBoucWen 1 1 2 20.0 2.50 0.02 0.0 3.0 1.0 0.5 0.5 -P 1 -Mz 2; # for a 2D elastomeric bearing element elastomericBearingBoucWen 1 1 2 20 2.50 0.02 0.0 3.0 1.0 0.5 0.5 -P 1 -T 2 -My 3 -Mz 4; # for a 3D elastomeric bearing Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Elastomeric Bearing (Bouc-Wen) Element\n"},{"location":"contrib/modeling/element/198-Elastomeric%20Bearing%20%28Plasticity%29%20Element/","text":"Elastomeric Bearing (Plasticity) Element This command is used to construct an elastomericBearing element object, which is defined by two nodes. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) plasticity properties for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. By default (sDratio = 0.5) P-Delta moments are equally distributed to the two end-nodes. To avoid the introduction of artificial viscous damping in the isolation system (sometimes referred to as \u201cdamping leakage in the isolation system\u201d), the bearing element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element elastomericBearingPlasticity $eleTag $iNode $jNode $kInit $qd $alpha1 $alpha2 $mu -P $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; For a three-dimensional problem: element elastomericBearingPlasticity $eleTag $iNode $jNode $kInit $qd $alpha1 $alpha2 $mu -P $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; eleTag unique element object tag $iNode $jNode end nodes kInit initial elastic stiffness in local shear direction qd characteristic strength alpha1 post yield stiffness ratio of linear hardening component alpha2 post yield stiffness ratio of non-linear hardening component mu exponent of non-linear hardening component -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.5) -doRayleigh to include Rayleigh damping from the bearing (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) ElastomericBearingPlasticityFig01.png NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. Elastomeric bearings are very stiff in compression, but not rigid. It is not a good idea to specify an extremely large axial stiffness (such as 1E10), because it can lead to problems with numerical sensitivity. Always specify a realistic value for the stiffness of the material that is assigned along the axial direction. To assign different compression and tension stiffness the Elastic or ElasticMultiLinear material can be used. The valid queries to an elastomeric bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples element elastomericBearingPlasticity 1 1 2 20.0 2.50 0.02 0.0 3.0 -P 1 -Mz 2; # for a 2D elastomeric bearing element elastomericBearingPlasticity 1 1 2 20 2.50 0.02 0.0 3.0 -P 1 -T 2 -My 3 -Mz 4; # for a 3D elastomeric bearing Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Elastomeric Bearing (Plasticity) Element\n"},{"location":"contrib/modeling/element/199-Elastomeric%20Bearing%20Element/","text":"Elastomeric Bearing Element","title":"Elastomeric Bearing Element\n"},{"location":"contrib/modeling/element/2-AC3D8/","text":"AC3D8 This command is used to construct an eight-node 3D brick acoustic element object based on a trilinear isoparametric formulation. element AC3D8 $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 $matTag eleTag unique element object tag \\(node1 ..\\) node8 8 end nodes matTag Material Tag of previously defined nD material For further documentation and figures see attached: pdf Reference: ABAQUS theory manual. (2.9.1 Coupled acoustic-structural medium analysis) Code Developed by: Quan Gu, Yichao Gao and Zhijian Qiu","title":"AC3D8\n"},{"location":"contrib/modeling/element/211-Enhanced%20Strain%20Quadrilateral%20Element/","text":"Enhanced Strain Quadrilateral Element This command is used to construct a four-node quadrilateral element, which uses a bilinear isoparametric formulation with enhanced strain modes. element enhancedQuad $eleTag $iNode $jNode $kNode $lNode $thick $type $matTag eleTag unique element object tag $iNode $jNode $kNode $lNode four nodes defining element boundaries, input in counter-clockwise order around the element. thick element thickness type string representing material behavior. Valid options depend on the NDMaterial object and its available material formulations. The type parameter can be either \u201cPlaneStrain\u201d or \u201cPlaneStress.\u201d matTag tag of nDMaterial NOTE: The valid queries to a Quad element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. Examples REFERENCES: Code Developed by: Edward Love, Sandia National Laboratories","title":"Enhanced Strain Quadrilateral Element\n"},{"location":"contrib/modeling/element/233-FPBearingPTV/","text":"FPBearingPTV The FPBearingPTV command creates a single Friction Pendulum bearing element, which is capable of accounting for the changes in the coefficient of friction at the sliding surface with instantaneous values of the sliding velocity, axial pressure and temperature at the sliding surface. The constitutive modelling is similar to the existing singleFPBearing element, otherwise. The FPBearingPTV element has been verified and validated in accordance with the ASME guidelines, details of which are presented in Chapter 4 of Kumar et al. (2015a). \u2019\u2019\u2019 element FPBearingPTV $eleTag $iNode $jNode $MuRef $IsPressureDependent $pRef $isTemperatureDependent $Diffusivity $Conductivity $IsVelocityDependent $rateParameter $ReffectiveFP $Radius_Contact $kInitial $theMaterialA $theMaterialB $theMaterialC $theMaterialD $x1 $x2 $x3 $y1 $y2 $y3 $shearDist $doRayleigh $mass $iter $tol \\(unit</p> <p>'''</p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode \\(jNode</strong></p></td> <td><p>End nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">MuRef</code></td> <td><p>Reference coefficient of friction</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">IsPressureDependent</code></td> <td><p>1.0 if the coefficient of friction is a function of instantaneous axial pressure</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">pRef</code></td> <td><p>Reference axial pressure (the bearing pressure under static loads)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">IsTemperatureDependent</code></td> <td><p>1.0 if the coefficient of friction is a function of instantaneous temperature at the sliding surface</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Diffusivity</code></td> <td><p>Thermal diffusivity of steel</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Conductivity</code></td> <td><p>Thermal conductivity of steel</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">IsVelocityDependent</code></td> <td><p>1.0 if the coefficient of friction is a function of instantaneous velocity at the sliding surface</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rateParameter</code></td> <td><p>The exponent that determines the shape of the coefficient of friction vs. sliding velocity curve</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ReffectiveFP</code></td> <td><p>Effective radius of curvature of the sliding surface of the FPbearing</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Radius_Contact</code></td> <td><p>Radius of contact area at the sliding surface</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">kInitial</code></td> <td><p>Lateral stiffness of the sliding bearing before sliding begins</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">theMaterialA</code></td> <td><p>Tag for the uniaxial material in the axial direction</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">theMaterialB</code></td> <td><p>Tag for the uniaxial material in the torsional direction</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">theMaterialC</code></td> <td><p>Tag for the uniaxial material for rocking about local Y axis</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">theMaterialD</code></td> <td><p>Tag for the uniaxial material for rocking about local Z axis</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>Vector components to define local X axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) y1 $y2 $y3 Vector components to define local Y axis shearDist Shear distance from iNode as a fraction of the length of the element doRayleigh To include Rayleigh damping from the bearing mass Element mass iter Maximum number of iterations to satisfy the equilibrium of element tol Convergence tolerance to satisfy the equilibrium of the element unit Tag to identify the unit from the list below. 1: N, m, s, C 2: kN, m, s, C 3: N, mm, s, C 4: kN, mm, s, C 5: lb, in, s, C 6: kip, in, s, C 7: lb, ft, s, C 8: kip, ft, s, C NOTE: Updating the coefficient of friction during analysis The coefficient of friction at the sliding surface of a sliding bearing changes continuously with instantaneous values of sliding velocity, temperature at the sliding surface and axial pressure. The following definition of the coefficient of friction is implemented in the element. Kv=1-0.5e^(-av) (1) kp = 0.70^((p-p0)/50) (2) kt = 0.79(0.70^(T/50)+0.40) (3) where kv,kp and kt and are the factors to account for the effects of sliding velocity, axial pressure and temperature at the sliding surface, respectively, v,p and T are velocity of sliding, axial pressure and temperature at the sliding surface, respectively, controls the shape of the kv vs. v curve, and p0 is the reference axial pressure. The reference coefficient of friction, Uref , is defined as the coefficient of friction at a reference axial pressure on the bearing p0, measured at 20\u02daC at a high velocity of sliding (e.g., 1000 mm/s). The coefficient of friction, adjusted for the effects of sliding velocity, axial pressure and temperature, U(p,T,v), is obtained as follows. U(p,T,v) = Uref(kpktkv)(4) where all parameters were defined previously. More details on this definition of the coefficient of friction are presented in Kumar et al. (2015a, 2015b). OUTPUT The global and local forces, displacements, velocities and accelerations can be output through node and element recorders. In addition, temperature, three friction factors ( in sequence), and adjusted coefficient of friction can be output using the element recorder with tags Temperature, FrictionFactors, MuAdjusted, respectively. Examples are given below. recorder Element -file Results/Temperature.out -time -ele 1 Temperature; recorder Element -file Results/Mu.out -time -ele 1 MuAdjusted; recorder Element -file Results/MuFactors.out -time -ele 1 MuFactors; EXAMPLE (All numbers are in SI units (kg, m, C, S)): set iNode 1; set jNode 2; set R 2.2352 ; set Mu_Ref 0.06 ; set p_Ref 50000000 ; set kp_Factor 1 ; set kT_Factor 1 ; set kv_Factor 1 ; set DF 4.44e-6; set TK 18.0; set a 100.0; set Radius 0.2; set pi [expr 22.0/7.0]; set Mass_Slider [expr \\(p_Ref*1.0*\\) pi* \\(Radius*\\) Radius/9.81]; set kInit [expr \\(Mass_Slider*\\) accelGravity* \\(Mu_Ref/\\) uy]; element FPBearingPTV 1 $iNode $jNode $Mu_Ref $kp_Factor $p_Ref $kT_Factor \\(DF</p> <p>\\) TK $kv_Factor $a $R $Radius $kInit 1 2 3 4 0.0 0.0 1.0 1.0 0.0 0.0 0.0 0 0.0 100 1.0E-8 1 ; FPWithUpdate.tcl files models a single concave sliding bearing with the mass concentrated on the slider. Download the example file and the ground motions. REFERENCES Kumar, M., Whittaker, A. S., and Constantinou (2015a). \u201cSeismic isolation of nuclear power plants using sliding bearings,\u201d Report MCEER-15- 0006, University at Buffalo, State University of New York, Buffalo, NY. Kumar, M., Whittaker, A. S., and Constantinou, M. C. (2015b). &quot;Characterizing friction in sliding isolation bearings,&quot; Earthquake Engineering &amp; Structural Dynamics, Vol. 44, No. 9, pp. 1409-1425.","title":"FPBearingPTV\n"},{"location":"contrib/modeling/element/251-Flat%20Slider%20Bearing%20Element/","text":"Flat Slider Bearing Element This command is used to construct a flatSliderBearing element object, which is defined by two nodes. The iNode represents the flat sliding surface and the jNode represents the slider. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) friction properties for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. To capture the uplift behavior of the bearing, the user-specified UniaxialMaterial in the axial direction is modified for no-tension behavior. By default (sDratio = 0.0) P-Delta moments are entirely transferred to the flat sliding surface (iNode). It is important to note that rotations of the flat sliding surface (rotations at the iNode) affect the shear behavior of the bearing. To avoid the introduction of artificial viscous damping in the isolation system (sometimes referred to as \u201cdamping leakage in the isolation system\u201d), the bearing element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element flatSliderBearing $eleTag $iNode $jNode $frnMdlTag $kInit -P $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; For a three-dimensional problem: element flatSliderBearing $eleTag $iNode $jNode $frnMdlTag $kInit -P $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; eleTag unique element object tag $iNode $jNode end nodes frnMdlTag tag associated with previously-defined FrictionModel kInit initial elastic stiffness in local shear direction -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.0) -doRayleigh to include Rayleigh damping from the bearing (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) maxIter maximum number of iterations to undertake to satisfy element equilibrium (optional, default = 20) tol convergence tolerance to satisfy element equilibrium (optional, default = 1E-8) FlatSliderBearingFig01.png NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. Because the friction force is affected by both the axial force and the slip rate, the element can be sensitive numerically. It is recommended that for dynamic analysis a smaller time step is being used than what would be used for a comparable structure with no isolators. If there is uplift (and therefore impact) in the bearing element, it can be helpful to use an integration method that provides numerical damping. Providing some viscous damping for the material that is assigned to the axial direction can also be helpful in dissipating impact energy. The valid queries to a flat slider bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples For a 2D flat slider bearing: element flatSliderBearing 1 1 2 1 250.0 -P 1 -Mz 2 -orient 0 1 0 -1 0 0; TestSlider2d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestSlider2d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestSlider2d_2.tcl models an isolated one story stick and the bearing element has finite length. TestSlider2d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestSlider2d_4.tcl models an isolated five story one bay building and the bearing element has finite length. For a 3D flat slider bearing: element flatSliderBearing 1 1 2 1 250.0 -P 1 -T 2 -My 3 -Mz 4 -orient 0 0 1 -1 0 0; TestSlider3d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestSlider3d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestSlider3d_2.tcl models an isolated one story stick and the bearing element has finite length. TestSlider3d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestSlider3d_4.tcl models an isolated five story one bay building and the bearing element has finite length. Download the GroundMotions.zip as a compressed file or download AllSliderExamples.zip as a compressed file. Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Flat Slider Bearing Element\n"},{"location":"contrib/modeling/element/252-Flexure-Shear%20Interaction%20Displacement-Based%20Beam-Column%20Element/","text":"Flexure-Shear Interaction Displacement-Based Beam-Column Element This command is used to construct a dispBeamColumnInt element object, which is a distributed-plasticity, displacement-based beam-column element which includes interaction between flexural and shear components. element dispBeamColumnInt $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag $cRot &lt;-mass $massDens &gt; eleTag unique element object tag $iNode $jNode end nodes numIntgrPts number of integration points along the element. secTag identifier for previously-defined section object transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object cRot identifier for element center of rotation (or center of curvature distribution). Fraction of the height distance from bottom to the center of rotation (0 to 1) massDens element mass density (per unit length), from which a lumped-mass matrix is formed (optional, default=0.0) NOTE: The valid queries to a nonlinear beam-column element when creating an ElementRecorder object are \u2018force,\u2019 and \u2018section $secNum secArg1 secArg2\u2026\u2019 Where $secNum refers to the integration point whose data is to be output. The element requires a special section and special care when numbering the materials. see Discussion below for section command and material numbering. Examples geomTransf LinearInt 1 element dispBeamColumnInt 1 1 3 2 2 1 0.4 DISCUSSION: In the original fiber element (Displacement-Based Beam-Column Element) implemented in OpenSees, based on linear interpolation of the curvature and constant axial strain, a third strain component was included to account for shear flexibility. The fiber discretization leads no longer to just uniaxial behavior, but rather a biaxial response by incorporating a membrane material model based on simple uniaxial stress-strain curves for concrete and steel. Although the material models can be cyclic, the element model formulation has been implemented and verified initially for monotonic static analysis. Details of the formulation can be found elsewhere (Massone et al., 2006; Massone 2006). The compatibility equations to relate nodal displacements (6 DOF) and internal strains (axial strain, curvature and shear strain) are defined only in a 2D plane, so that no 3D analysis is possible with this element. It also requires a specific geometric transformation called \u201cLinearInt\u201d, which is based on the traditional geometric linear transformation, and therefore no other geometric transformation can be used. The input parameters are the same as the original fiber element, however a new term, the location of the center of rotation (c), is required to distribute transversal displacement between flexural (curvature) and shear (shear strain) components. This parameter is defined as the fraction of the element height (measured from top) that corresponds to the center of curvature. The section formulation required for each element is based also on a similar formulation implemented in OpenSees. However, not all capabilities are included as in the original formulation. The section is defined as a fiber section, but based only in fiber components and not in patch or layer components for simplicity. It has been formulated in this way to make sure that the strip modeling is understood since differently to the standard fiber section analysis the strips in the model with interaction between shear and flexure requires that all the strips are formed with smeared (average) concrete and reinforcement areas. SECTIONAL ANALYSIS The definition of the fiber section is initiated by establishing in the heading of the command the thickness of the section (three in this case to represent boundary elements). The thickness of the element is required to verify equilibrium in the horizontal direction (assuming that same area ratio holds between concrete materials inside a strip in horizontal and vertical directions). For generality, the section is allowed to have three different thicknesses to be able to model barbell or T-shaped walls (Fig. 1). Each thickness may be associated to several strips. Strips are created from concrete and steel materials. Since the strip unit corresponds to the membrane (panel) element, the location of each of them is defined by the fiber coordinate ($yLoc), and therefore, tributary concrete and steel areas inside each strip are located at one same point (Fig. 1). This may difficult the analysis, but the model is based on uniform (smeared) steel and concrete distribution. Even though a center of area (concrete and steel) defined by using a transformed area for steel may be acceptable, in tensile governed elements a better approximation may be using the steel location. For simplicity, the center of area of concrete may be selected for calculations, regarding a reasonable small strip size selection. In the fiber section definition, each strip is defined by fibers with same coordinate, and strips are organized from negative to positive location. Therefore all steel and concrete components of one strip have to be together (one after the other). The change in fiber location tells the program that a different strip is initiated. To complete the strip definition, the horizontal steel reinforcement has to be included. The steel is assumed uniformly distributed in the section, so that it may be located as only one fiber (recommended). In the case of horizontal steel, the component is called as \u201cHfiber\u201d and the area defined in such fiber corresponds to the total horizontal steel area in one single element (for the entire element). This steel is assumed to be the same for all strips inside the section. For consistency when defining the fiber section, the command requires to define the number of strips within each sub-section with the same thickness, which has to add up the same number of different fiber locations defined in the section (total number of strips). BeamShearFlexure.png The original uniaxial definition of the fiber components inside the fiber section recorded only uniaxial stresses and strains for the fiber, and resultant axial force, moment, axial strain and curvature for the section. In the membrane (panel) formulation for the strips, other quantities may be useful to record. At the strip level new recorders have been included: eX (horizontal strain), eY (axial strain), e1 (principal strain in direction 1), e2 (principal strain in direction 2), alpha (angle for principal axis, measured counterclockwise from eY to e1), sX (average horizontal steel stress), sY (average vertical steel stress), s1 (average principal concrete stress in direction 1) and s2 (average principal concrete stress in direction 2). The mentioned recorders are called by sections, so that the output gives the results organized in columns for each strip inside the section, using the same order defined in the fiber section. At the section level, axial strain, curvature, shear strain, resultant axial force, moment and shear force are obtained with the standard recorder forceAndDeformation. Examples recorder Element -file Sect_eX.out -ele 1 section 1 eX recorder Element -file Sect_s2.out -ele 1 section 1 s2 This commnand allows the user to construct a FiberSection object. Each FiberSection object is composed of Fibers, with each fiber containing a UniaxialMaterial, an area and a location (y,z). The command to generate FiberSection object contains in { } the commands to generate all the fibers in the object. To construct a FiberSection and populate it, the following command is used: section FiberInt $secTag -NStrip $nStrip1 $thick1 $nStrip2 $thick2 $nStrip3 \\(thick3 {</strong></p></td> </tr> <tr class=\"even\"> <td><p><strong><a href=\"fiber_Command\" title=\"wikilink\"> fiber</a>...</strong></p></td> </tr> <tr class=\"odd\"> <td><p><strong>Hfiber ...</strong></p></td> </tr> <tr class=\"even\"> <td><p><strong>...</strong></p></td> </tr> <tr class=\"odd\"> <td><p><strong>}</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">sectTag</code></td> <td><p>unique tag among FiberSections</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">thick1</code></p></td> <td><p>section thickness 1.</p></td> </tr> <tr class=\"odd\"> <td><p><em>\\) nStrip1 \u2019 number of strips with thickness $thick1. Considers first $nStrip1 strips in the fiber section with thickness \\(thick1.</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">thick2</code></p></td> <td><p>section thickness 2.</p></td> </tr> <tr class=\"odd\"> <td><p><em>\\) nStrip2 \u2019 number of strips with thickness $thick2. Considers next $nStrip2 strips in the fiber section with thickness \\(thick2.</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">thick3</code></p></td> <td><p>section thickness 3.</p></td> </tr> <tr class=\"odd\"> <td><p><em>\\) nStrip3 \u2019 umber of strips with thickness $thick3. Considers last $nStrip3 strips in the fiber section with thickness $thick3. Total number of strips has to match the fiber section defined. fiber \u2026 command to generate concrete and vertical steel fibers. Hfiber\u2026 command to generate horizontal steel fibers (stirrups) \u2018\u2026\u2019\u2019\u2019 Examples Examples section FiberInt 2 -NStrip 1 6.5 1 2.0 1 6.5 { fiber -25.55 0 15.6 2 fiber -25.55 0 1.24 1003 fiber 0 0 35.6 2 fiber 0 0 0.84 1003 fiber +25.55 0 15.6 2 fiber +25.55 0 1.24 1003 Hfiber 0 0 0.0718 1005 } FIBER MODELLING: As described previously, the section is created based on strips, and each strip consists of vertical fibers (fiber) that represent steel and concrete materials and horizontal fibers (Hfiber) that represent the horizontal steel. Since uniform distribution of reinforcement steel is assumed at strip level, all horizontal steel reinforcement can be included as only one horizontal fiber. The location of such fiber is included in the command just for completeness, but it is not necessary for any calculation. The area required in the Hfiber corresponds to the total steel tributary area present in the element that holds the defined section. The internal numerical scheme defined to achieve equilibrium handles two different types of materials: steel and concrete. Since different steel and concrete stress-strain laws can be implemented and used with this model, the program needs to distinguish between concrete and steel. For simplicity, it has been selected the material tag ($matTag) to define whether a material is concrete or steel. Concrete materials are defined as materials with tag number under (or equal to) 1000 and steel materials use tag numbers over 1000 (see example). HFiber Command Hfiber $yLoc $zLoc $A $matTag yLoc y coordinate of the fiber in the section (just for completeness, not required in calculations) zLoc z coordinate of the fiber in the section (just for completeness, not required in calculations) A total steel area located inside the section matTag identifier for previously-defined material object Examples uniaxialMaterial Concrete01 2 -3 -0.002 0 -0.01 uniaxialMaterial Steel02 1003 60 29000 0.02 20 0.9 0.2 0 0.1 0 0.1 uniaxialMaterial Steel02 1005 60 29000 0.02 20 0.9 0.2 0 0.1 0 0.1 . . . fiber -25.55 0 15.6 2 # vert. concrete fiber -25.55 0 1.24 1003 # vert. steel Hfiber 0 0 0.0718 1005 # horz. steel NOTE Note: concrete materials are defined as materials with tag number under (or equal) 1000 and steel materials use tag numbers over 1000 (see example). Wall01.tcl <tcl>Wall01.tcl</tcl> REFERENCES: Massone, L. M., 2006; \u201cRC Wall Shear - Flexure Interaction: Analytical and Experimental Responses\u201d, Ph.D. Dissertation, University of California, Los Angeles, June 2006, 398 pp. Massone, L. M.; Orakcal, K.; and Wallace, J. W. , 2006; \u201cShear - Flexure Interaction for Structural Walls\u201d; SP-236, ACI Special Publication - Deformation Capacity and Shear Strength of Reinforced Concrete Members Under Cyclic Loading, editors: Adolfo Matamoros & Kenneth Elwood, p. 127-150. Code Developed by: Leo Massone, University of Chile and Kutay Orakcal and John Wallace, UCLA","title":"Flexure-Shear Interaction Displacement-Based Beam-Column Element\n"},{"location":"contrib/modeling/element/257-Force-Based%20Beam-Column%20Element/","text":"Force-Based Beam-Column Element This command is used to construct a forceBeamColumn element object, which is based on the iterative force-based formulation. A variety of numerical integration options can be used in the element state determination and encompass both distributed plasticity and plastic hinge integration. See image:IntegrationTypes.pdf for more details on the available numerical integration options. element forceBeamColumn $eleTag $iNode $jNode $transfTag \u201cIntegrationType arg1 arg2 \u2026\u201d <-mass $massDens> <-iter $maxIters \\(tol&gt;</strong></p></td> </tr> </tbody> </table> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode $jNode end nodes transfTag identifier for previously-defined coordinate-transformation (CrdTransf) object IntegrationType arg1 arg2 \u2026 specifies locations and weights of integration points and their associated section force-deformation models (see image:IntegrationTypes.pdf ) massDens element mass density (per unit length), from which a lumped-mass matrix is formed (optional, default=0.0) maxIters maximum number of iterations to undertake to satisfy element compatibility (optional, default=10) tol tolerance for satisfaction of element compatibility (optional, default=10-12) Original command that assumes Gauss-Lobatto integration with a copy of the same section force-deformation model at each integration point: element forceBeamColumn $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag &lt;-mass $massDens &gt; &lt;-iter $maxIters $tol &gt; &lt;-integration $intType &gt; eleTag unique element object tag numIntgrPts number of Gauss-Lobatto integration points along the element. secTag identifier for previously-defined section object Alternative command (kept for backward compatability): element nonlinearBeamColumn $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag &lt;-mass $massDens &gt; &lt;-iter $maxIters $tol &gt; &lt;-integration $intType &gt; eleTag unique element object tag intType numerical integration type, options are Lobatto, Legendre, Radau, NewtonCotes, Trapezoidal (optional, default= Lobatto) NOTE: The following three commands give the same element definition (with Gauss-Lobatto integration) despite some apparent permutations of the input arguments: element forceBeamColumn $eleTag $iNode $jNode $transfTag Lobatto $secTag $numIntgrPts element forceBeamColumn $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag element nonlinearBeamColumn $eleTag $iNode $jNode $numIntgrPts $secTag $transfTag NOTE: The -iter switch enables the iterative form of the flexibility formulation. Note that the iterative form can improve the rate of global convergence at the expense of more local element computation. The valid response elements that an element of this type will respond to are: force or globalForce localForce basicForce section $sectionNumber $arg1 $arg2 \u2026 (note: $sectionNumer is integer 1 through $numIntegrPts) basicDeformation plasticDeformation inflectionPoint tangentDrift integrationPoints integrationWeights Here is a link to the source code to obtain information about the location and weight of the Gauss-Lobatto integration points 1 Examples element forceBeamColumn 1 2 4 9 Lobatto 8 5; # force beam column element added with tag 1 between nodes 2 and 4 that has Gauss-Lobatto 5 integration points, each using section 8, and the element uses geometric transformation 9 FURTHER DOCUMENTATION ON INTEGRATION OPTIONS: image:IntegrationTypes.pdf REFERENCES: Neuenhofer, Ansgar, FC Filippou. Geometrically Nonlinear Flexibility-Based Frame Finite Element. ASCE Journal of Structural Engineering, Vol. 124, No. 6, June, 1998. ISSN 0733-9445/98/0006-0704-0711. Paper 16537. pp. 704-711. Neuenhofer, Ansgar, FC Filippou. Evaluation of Nonlinear Frame Finite-Element Models. ASCE Journal of Structural Engineering, Vol. 123, No. 7, July, 1997. ISSN 0733-9445/97/0007-0958-0966. Paper No. 14157. pp. 958-966. Neuenhofer, Ansgar, FC Filippou. ERRATA \u2013 Geometrically Nonlinear Flexibility-Based Frame Finite Element. ASCE Journal of Structural Engineering, Vol. 124, No. 6, June, 1998. ISSN 0733-9445/98/0006-0704-0711. Paper 16537. pp. 704-711. Taucer, Fabio F, E Spacone, FC Filippou. A Fiber Beam-Column Element for Seismic Response Analysis of Reinforced Concrete Structures. Report No. UCB/EERC-91/17. Earthquake Engineering Research Center, College of Engineering, University of California, Berkeley. December 1991. Spacone, Enrico, V Ciampi, FC Filippou. A Beam Element for Seismic Damage Analysis. Report No. UCB/EERC-92/07. Earthquake Engineering Research Center, College of Engineering, University of California, Berkeley. August 1992. Code maintained by: Michael H. Scott, Oregon State University","title":"Force-Based Beam-Column Element\n"},{"location":"contrib/modeling/element/264-FourNodeQuad%20u-p%20Element/","text":"FourNodeQuad u-p Element This command is used to construct an eFourNodeQuadUP element object. A FourNodeQuadUP element is a four-node plane-strain element using bilinear isoparametric formulation. This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Each element node has 3 degrees-of-freedom (DOF): DOF 1 and 2 for solid displacement (u) and DOF 3 for fluid pressure (p). The arguments for the construction of this element are: element quadUP $eleTag $Node1 $Node2 $Node3 $Node4 $thick $matTag $bulk $fmass $PermX \\(PermY &lt;\\) b1=0 $b2=0 \\(t=0&gt;</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Node1 .. \\(Node4</strong></p></td> <td><p>Four element node (previously defined) numbers in counter-clockwise order around the element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>Element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus Bc relating changes in pore pressure and volumetric strain, may be approximated by: where Bf is the bulk modulus of fluid phase (2.2x106 kPa for water), and n the initial porosity.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">PermX</code></td> <td><p>Permeability coefficient in X direction</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">PermY</code></td> <td><p>Permeability coefficient in Y direction</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) bX, $bY Optional gravity acceleration components in X and Y directions respectively (defaults are 0.0) t Optional uniform element normal traction, positive in tension (default is 0.0) NOTE: This element requires 3 degrees-of-freedom (ndf=3), the 3rd degree-of-freedom being pore pressure. The Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel The valid queries to a quadUP element when creating an ElementRecorder are \u2018force\u2019, and \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. TYPICAL RANGE OF PERMEABILITY COEFFICIENT (cm/s) Gravel Sand Silty Sand Silt Clay >1.0x10-1 1.0x10-3 ~ 1.0x10-1 1.0x10-5 ~ 1.0x10-3 1.0x10-7 ~ 1.0x10-5 <1.0x10-7 Examples Please visit http://cyclic.ucsd.edu/opensees for examples. REFERENCES: Code Developed by: Zhaohui Yang, UC San Diego","title":"FourNodeQuad u-p Element\n"},{"location":"contrib/modeling/element/265-FourNodeTetrahedron/","text":"FourNodeTetrahedron Tet.png This command is used to construct a standard four-node tetrahedron element objec with one-point Gauss integration. element FourNodeTetrahedron $eleTag $node1 $node2 $node3 $node4 $matTag &lt; $b1 $b2 $b3 &gt; eleTag unique element object tag $node1 \\(node2</strong></p> <p><strong>\\) node3 \\(node4</strong></p></td> <td><p>four nodes defining element boundaries, input order is shown in the figure.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag of nDMaterial</p></td> </tr> <tr class=\"even\"> <td><p><strong>'\\) b1 $b2 $b3 body forces in global x,y,z directions Because sometimes bricks will give you headaches! Use this if you don\u2019t care much about the stress/strain fields (tets are notoriously bad). Otherwise, you can use the 10-node quadratic tetrahedron (in development). NOTE: The valid queries to a FourNodeTetrahedron element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 (\u2018strains\u2019 version > 2.2.0) and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. This element can only be defined in -ndm 3 -ndf 3 Examples REFERENCES: Carlos Felipa\u2019s AFEM Course: Chapter 9 The Linear Tetrahedron. Code Developed by Jos\u00e9 A. Abell at Universidad de los Andes, Chile","title":"FourNodeTetrahedron\n"},{"location":"contrib/modeling/element/266-Four%20Node%20Quad%20u-p%20Element/","text":"Four Node Quad u-p Element FourNodeQuadUP is a four-node plane-strain element using bilinear isoparametric formulation. This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Each element node has 3 degrees-of-freedom (DOF): DOF 1 and 2 for solid displacement (u) and DOF 3 for fluid pressure (p). Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a quadUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element quadUP $eleTag $iNode $jNode $kNode $lNode $thick $matTag $bulk $fmass $hPerm \\(vPerm &lt;\\) b1=0 $b2=0 \\(t=0&gt;</strong></p></td> </tr> </tbody> </table> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode, $jNode, $kNode, \\(lNode</strong></p></td> <td><p>Four element node (previously defined) numbers in counter-clockwise order around the element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>Element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) hPerm, \\(vPerm</strong></p></td> <td><p>Permeability coefficient in horizontal and vertical directions respectively.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1, $b2 Optional gravity acceleration components in horizontal and vertical directions respectively (defaults are 0.0) t Optional uniform element normal traction, positive in tension (default is 0.0) TYPICAL RANGE OF PERMEABILITY COEFFICIENT Gravel Sand Silty Sand Silt Clay >1.0x10<sup>-1</sup> cm/s (or 3.94x10<sup>-2</sup> in/s) 1.0x10<sup>-3</sup> cm/s (or 3.94 x10<sup>-4</sup> in/s) ~ 1.0x10<sup>-1</sup> cm/s (or 3.94 x10<sup>-2</sup> in/s) 1.0x10<sup>-5</sup> cm/s (or 3.94 x10<sup>-6</sup> in/s) ~ 1.0x10<sup>-3</sup> cm/s (or 3.94 x10<sup>-4</sup> in/s) 1.0x10<sup>-7</sup> cm/s (or 3.94 x10<sup>-8</sup> in/s) ~ 1.0x10<sup>-5</sup> cm/s (or 3.94 x10<sup>-6</sup> in/s) <1.0x10<sup>-7</sup> cm/s (or 3.94x10 <sup>-8</sup> in/s) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"Four Node Quad u-p Element\n"},{"location":"contrib/modeling/element/287-GettingStartedInputFile.tcl%20--%20Element%20Section/","text":"GettingStartedInputFile.tcl \u2013 Element Section NOTOC </p> <ol> <li>ELEMENT SECTION ---------------------------------------</li> </ol> <p>addSectionData SectionLabel 30x30RCRectangularFiber addSectionData SectionDescription \"Square Rectangular RC Section\" addSectionData SectionModelLabel RCRectangularFiber; addSectionData H 30 * \\$ in; addSectionData B 30 * \\$ in; addSectionData NBarBot 6 ; # number of bottom longitudinal reinforcing bars in section addSectionData NBarTop 6 ; # number of top longitudinal reinforcing bars in section addSectionData NBarInt 6 ; # total number of intermediate bars in section (2 bars per layer) addSectionData BarSizeBot # 9 ; addSectionData BarSizeTop # 9 ; addSectionData BarSizeInt # 9 ; addSectionData CoverBot 2.6 * \\$ in; addSectionData CoverTop 2.6 * \\$ in; addSectionData CoverInt 2.6 * \\$ in; addSectionData CoreMaterialLabel 4ksiConfinedConcrete; addSectionData CoverMaterialLabel 4ksiUnconfinedConcrete; addSectionData ReinfMaterialLabel 60ksiReinforcingSteel; addSection</p> <p>addSectionData SectionLabel 30x60RCRectangularFiber addSectionData SectionDescription \"Rectangular RC Section\" addSectionData SectionModelLabel RCRectangularFiber; addSectionData H 60 * \\$ in; addSectionData B 30 * \\$ in; addSectionData NBarBot 6 ; # number of bottom longitudinal reinforcing bars in section addSectionData NBarTop 4 ; # number of top longitudinal reinforcing bars in section addSectionData NBarInt 6 ; # total number of intermediate bars in section (2 bars per layer) addSectionData BarSizeBot # 9 ; addSectionData BarSizeTop # 11 ; addSectionData BarSizeInt # 6 ; addSectionData CoverBot 2.6 * \\$ in; addSectionData CoverTop 2.6 * \\$ in; addSectionData CoverInt 2.6 * \\$ in; addSectionData CoreMaterialLabel 4ksiConfinedConcrete; addSectionData CoverMaterialLabel 4ksiUnconfinedConcrete; addSectionData ReinfMaterialLabel 60ksiReinforcingSteel; addSection</p> <p> puts --DoneSections--</p> <p> Return to Getting Started with BuildingTcl","title":"GettingStartedInputFile.tcl -- Element Section\n"},{"location":"contrib/modeling/element/320-HDR/","text":"HDR This command is used to construct an HDR bearing element object in three-dimension. The 3D continuum geometry of an high damping rubber bearing is modeled as a 2-node, 12 DOF discrete element. This is the third element in the series of elements developed for analysis of base-isolated structures under extreme loading (others being ElastomericX and LeadRubberX ). The major difference between HDR element with ElastomericX is the hysteresis model in shear. The HDR element uses a model proposed by Grant et al. (2004) to capture the shear behavior of a high damping rubber bearing. The time-dependent values of mechanical properties (e.g., vertical stiffness, buckling load capacity) can also be recorded using the \u201cparameters\u201d recorder . For a 3D problem: element HDR $eleTag $Nd1 $Nd2 $Gr $Kbulk $D1 $D2 $ts $tr $n $a1 $a2 $a3 $b1 $b2 $b3 $c1 $c2 $c3 $c4 &lt;&lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt; $kc &gt; &lt; $PhiM &gt; &lt; $ac &gt; &lt; $sDratio &gt; &lt; $m &gt; &lt; $tc &gt; eleTag unique element object tag $Nd1 \\(Nd2</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Gr</code></td> <td><p>shear modulus of elastomeric bearing</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Kbulk</code></td> <td><p>bulk modulus of rubber</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">D1</code></p></td> <td><p>internal diameter</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">D2</code></p></td> <td><p>outer diameter (excluding cover thickness)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ts</code></td> <td><p>single steel shim layer thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">tr</code></td> <td><p>single rubber layer thickness</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">n</code></td> <td><p>number of rubber layers</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) a1 $a2 $a3 $b1 $b2 $b3 $c1 $c2 $c3 \\(c4</strong></p></td> <td><p>parameters of the Grant model</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) kc cavitation parameter (optional, default = 10.0) PhiM damage parameter (optional, default = 0.5) ac strength reduction parameter (optional, default = 1.0) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.5) m element mass (optional, default = 0.0) tc cover thickness (optional, default = 0.0) Physical Model and Mechanical Properties The physical model is considered as a two-node, twelve degrees-of-freedom discrete element. The two nodes are connected by six springs that represent the mechanical behavior in the six basic directions of a bearing. The degrees of freedom and discrete spring representation of an elastomeric bearing is shown in the below figures. The general form of element force vector, $$, and element stiffness matrix,<math></math> , for element representation considered above is given by equation below: <math>=; =</math> The coupling of the two shear springs is considered directly by using a coupled bidirectional model. All other springs are uncoupled. The coupling of vertical and horizontal directions are considered indirectly by using expressions for mechanical properties in one direction that are dependent on the response parameters in the other direction. Linear uncoupled springs are considered in the torsion and the two rotational springs as they are not expected to significantly affect the response of an elastomeric bearing. The off-diagonal terms due to coupling between axial and shear, and axial and rotation, are not considered in the two-spring model (Koh and Kelly, 1987) used here. An exact model would have non-zero values of these off-diagonal terms. A discussion on the formulation of the two-spring model and the exact model is presented in Ryan et al.(1991). The subscript b refers to the element\u2019s basic coordinate system. Response quantities are transformed between the basic, local and global coordinates to perform computations. The discrete spring model presented here has the advantages of easy implementation and being computationally efficient. The mechanical properties of the six springs (also referred to as material models in OpenSees) are defined using analytical solutions available from the analysis of elastomeric bearings. The expression for mechanical properties, including stiffness and buckling load capacity, are derived using explicit consideration for geometric nonlinearity due to large displacement effects. The P-Delta effect, which is an approximate method to account for geometric nonlinearity in structural analysis problems, is therefore not considered. The material models in six directions are: Axial direction: a new mathematical model that captures the behavior under cyclic tension Link Two shear directions: a bidirectional model proposed by Grant et al. (2004) Torsion: a linear elastic model Two rotational directions: linear elastic models In addition to the behavior captured by existing bearing elements, this element can capture the following: Degradation of bearing stiffness and damping due to scragging effects in shear Cavitation and post-cavitation behavior in tension Variation in critical buckling load capacity due to lateral displacement Variation in vertical axial stiffness with horizontal displacement Recorders In addition to regular recorders provided by the bearing elements ( Element Recorder ), this element can also record instantaneous values of cavitation force (Fcn), buckling load capacity (Fcrn), and vertical stiffness (Kv) using the \u201cParameters\u201d recorder in that order. Example: recorder Element <-file \\(fileName&gt; -time &lt;-ele (\\) ele1 $ele2 \u2026)> Parameters recorder Element -file param.out -time -ele 1 Parameters To check if bearing has buckled or cavitated, an user can obtain the histories of Fcn and Fcrn as described above and divide the axial force (obtained from basicForce recorder, qb(2)) by Fcn and Fcrn at each time step, which provides demand vs capacity (D/C) ratios at each time step. If Fcn/qb(0) > 1.0 : Cavitation, or Fcrn/qb(0)>1.0 : Buckling. Examples An example is presented here, in which a high damping rubber bearing (bearing KL301 in Grant et al. (2004)) is subjected to different amplitudes and sequences of loading. The bearing (KL301) and parameters of Grant\u2019s model presented in Grant et al. (2004) have been used. The tcl files can be found here: References Kumar, M., Whittaker, A., and Constantinou, M. (2014). \u201cAn advanced numerical model of elastomeric seismic isolation bearings.\u201d Earthquake Engineering & Structural Dynamics, Published online, DOI: 10.1002/eqe.2431. Link Grant, D. N., Fenves, G. L., and Whittaker, A. S. (2004). \u201cBidirectional modeling of high-damping rubber bearings.\u201d Journal of Earthquake Engineering, 8(sup001), 161-185. Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cExperimental investigation of cavitation in elastomeric seismic isolation bearings.\u201d Engineering Structures, 101, 290-305. Link Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cResponse of base-isolated nuclear structures to extreme earthquake shaking.\u201d Nuclear Engineering and Design (In press). Link Code Developed by: Manish Kumar, University at Buffalo, SUNY. Any bugs in this element can be reported to mkumar2 AT buffalo dot edu","title":"HDR\n"},{"location":"contrib/modeling/element/350-Joint2D%20Element/","text":"Joint2D Element This command is used to construct a two-dimensional beam-column-joint element object. The two dimensional beam-column joint is idealized as a parallelogram shaped shear panel with adjacent elements connected to its mid-points. The midpoints of the parallelogram are referred to as external nodes. These nodes are the only analysis components that connect the joint element to the surrounding structure. element Joint2D $eleTag $Nd1 $Nd2 $Nd3 $Nd4 $NdC &lt; $Mat1 $Mat2 $Mat3 $Mat4 &gt; $MatC $LrgDspTag eleTag unique element object tag $Nd1 $Nd2 $Nd3 $Nd4 integer tags indicating four external nodes where the joint element is connected to the adjoining beam-column element NdC integer tags indicating the central node of beam-column joint (the tag is used to generate the internal node, thus, the node should not exist in the domain or be used by any other node) Mat1 uniaxial material tag for interface rotational spring at node 1. Use a zero tag to indicate the case that a beam-column element is rigidly framed to the joint. (optional) Mat2 uniaxial material tag for interface rotational spring at node 2. Use a zero tag to indicate the case that a beam-column element is rigidly framed to the joint. (optional) Mat3 uniaxial material tag for interface rotational spring at node 3. Use a zero tag to indicate the case that a beam-column element is rigidly framed to the joint. (optional) Mat4 uniaxial material tag for interface rotational spring at node 4. Use a zero tag to indicate the case that a beam-column element is rigidly framed to the joint. (optional) MatC uniaxial material tag for rotational spring of the central node that describes shear panel behavior LrgDspTag an integer indicating the flag for considering large deformations: 0 - for small deformations and constant geometry 1 - for large deformations and time varying geometry 2 - for large deformations ,time varying geometry and length correction NOTES: The nodes must be located such that the main chords bisect. The node tags shall be entered in a clockwise or counter-clockwise order. In the case that the beam-column element is rigidly framed to the joint, the tag for materials $Mat1 to $Mat4 shall be zero. The shear panel uniaxial material (with the tag $MatC) shall be calibrated for shear-equivalent moment versus shear distortion. In the calibration formulations the shear-equivalent moment is calculated by multiplying the joint average shear stress to the joint panel volume. The element connects the external nodes to the central node via multi-point constraints, and Joint2D must be used along with either the Penalty or the Transformation constraint handler. If the LrgDspTag flag is set to zero the element uses a constant constraint matrix for small-deformation formulation. In the large-deformation formulation the constraint matrix is time varying and it is updated at every converged time step. Valid inquires to the joint element include: centralNode - The displacement components of the central node deformation - Interface rotations and the shear panel deformation force - Nodal moments and the joint panel shear-equivalent moment size - Length of the main chord (element size) stiffness - Joint element stiffness matrix defoANDforce - Joint deformation components followed by the nodal moments Examples element Joint2D 12 1 2 3 4 112 10 0; # constructs a Joint2D element with tag 12 that is connected to nodes 1, 2, 3, and 4. The element will generate a center node with tag 112, and it uses the uniaxial material object with tag 10 as the shear panel rotational spring. This joint element does not have rotational springs at external nodes and does not include large deformations. element Joint2D 13 5 6 7 8 113 11 0 11 0 10 2; # constructs a Joint2D element with tag 13 that is connected to nodes 5, 6, 7, and 8. The element will generate a center node with tag 113, and it uses the uniaxial material object with tag 11 for nodes 5 and 7, and rigid connections for nodes 6 and 8 to prevent member end rotations. The shear panel behavior is modeled with uniaxial material with tag 10. The generated multipoint constraint matrices will be time varying to cover large deformations and the nodal positions will be corrected to maintain the initial joint size. REFERENCES: Arash Altoontash, 2004, \u201cSimulation and damage models for performance assessment of reinforced concrete beam-column joints\u201d, PhD Dissertation, Stanford University, California, USA. 1 Code Developed by: Arash Altoontash","title":"Joint2D Element\n"},{"location":"contrib/modeling/element/354-KikuchiBearing%20Element/","text":"KikuchiBearing Element This command is used to construct a KikuchiBearing element object, which is defined by two nodes. This element consists of multiple shear spring model (MSS) and multiple normal spring model (MNS). element KikuchiBearing $eleTag $iNode $jNode -shape $shape -size $size $totalRubber <-totalHeight $totalHeight> -nMSS $nMSS -matMSS $matMSSTag <-limDisp $limDisp> -nMNS $nMNS -matMNS $matMNSTag <-lambda \\(lambda&gt; &lt;-orient &lt;\\) x1 $x2 $x3> $yp1 $yp2 $yp3> <-mass $m> <-noPDInput> <-noTilt> <-adjustPDOutput $ci $cj> <-doBalance $limFo $limFi \\(nIter&gt;</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) inode \\(jnode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">shape</code></td> <td><p>following shapes are available: <strong>round</strong>, <strong>square</strong></p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">size</code></td> <td><p>diameter (round shape), length of edge (square shape)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">totalRubber</code></td> <td><p>total rubber thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">totalHeight</code></td> <td><p>total height of the bearing (defaulut: distance between iNode and jNode)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">nMSS</code></td> <td><p>number of springs in MSS = nMSS</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matMSSTag</code></td> <td><p>matTag for MSS</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">limDisp</code></td> <td><p>minimum deformation to calculate equivalent coefficient of MSS (see note 1)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">nMNS</code></td> <td><p>number of springs in MNS = nMNS*nMNS (for round and square shape)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matMNSTag</code></td> <td><p>matTag for MNS</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">lambda</code></td> <td><p>parameter to calculate compression modulus distribution on MNS (see note 2)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) yp1 $yp2 \\(yp3</strong></p></td> <td><p>vector components in global coordinates defining vector yp which lies in the local x-y plane for the element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">m</code></td> <td><p>element mass</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-flag\">-noPDInput</code></p></td> <td><p>not consider P-Delta moment</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-noTilt</code></p></td> <td><p>not consider tilt of rigid link</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) ci \\(cj</strong></p></td> <td><p>P-Delta moment adjustment for reaction force (default: <code class=\"tcl-variable\">ci</code>=0.5, <code class=\"tcl-variable\">cj</code>=0.5)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) limFo $limFi $nIter tolerance of external unbalanced force ( limFo ), tolorance of internal unbalanced force ( limFi ), number of iterations to get rid of internal unbalanced force ( nIter ) NOTES: If limdisp is positive and the shear deformation of MSS exceeds limdisp , this element calculates equivalent coefficient to adjust force and stiffness of MSS. The adjusted MSS force and stiffness reproduce the behavior of the previously defined uniaxial material under monotonic loading in every direction. Recommended value is (D/t) sqrt(3 G/K), where D, t, G and K are size (for round and square shape), thickness, shear modulus and bulk modulus of a rubber layer, respectively. The valid queries to a KikuchiBearing element when creating an ElementRecorder object are \u2018globalForce\u2019, \u2018localForce\u2019, \u2018basicForce\u2019, \u2018localDisplacement\u2019 and \u2018basicDeformation\u2019. KikuchiBearing_Model.png Examples element KikuchiBearing 1 1 2 -shape round -size 1.016 0.320 -nMSS 8 -matMSS 1 -nMNS 30 -matMNS 2 KikuchiBearing_Sample.tcl , KikuchiBearing_input_Z.tcl , KikuchiBearing_input_X.tcl case 1: P-Delta effect not considered (use -noPDInput -noTilt option) case 2: P-Delta effect considered, uniform distribution of compression modulus case 3: P-Delta effect considered (use -lambda option) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFERENCES: M. Kikuchi , I. D. Aiken and A. Kasalanati , \u201cSimulation analysis for the ultimate behavior of full-scale lead-rubber seismic isolation bearings\u201d, 15th World Conference on Earthquake Engineering , No. 1688, 2012. Code Developed by: mkiku","title":"KikuchiBearing Element\n"},{"location":"contrib/modeling/element/361-LeadRubberX/","text":"LeadRubberX This command is used to construct a LeadRubberX bearing element object in three-dimension. The 3D continuum geometry of a lead rubber bearing is modeled as a 2-node, 12 DOF discrete element. It extends the formulation of ElastomericX by including strength degradation in lead rubber bearing due to heating of the lead-core. The LeadRubberX element requires only the geometric and material properties of an elastomeric bearing as arguments. The material models in six direction are formulated within the element from input arguments. The time-dependent values of mechanical properties (e.g., shear stiffness, buckling load capacity, temperature in the lead-core, yield strength) can also be recorded using the \u201cparameters\u201d recorder . For a 3D problem: element LeadRubberX $eleTag $Nd1 $Nd2 $Fy $alpha $Gr $Kbulk $D1 $D2 $ts $tr $n &lt;&lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt; $kc &gt; &lt; $PhiM &gt; &lt; $ac &gt; &lt; $sDratio &gt; &lt; $m &gt; &lt; $cd &gt; &lt; $tc &gt; &lt; $qL &gt; &lt; $cL &gt; &lt; $kS &gt; &lt; $aS &gt; &lt; $tag1 &gt; &lt; $tag2 &gt; &lt; $tag3 &gt; &lt; $tag4 &gt; &lt; $tag5 &gt; eleTag unique element object tag $Nd1 \\(Nd2</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Fy</code></td> <td><p>yield strength</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>post-yield stiffness ratio</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Gr</code></td> <td><p>shear modulus of elastomeric bearing</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Kbulk</code></td> <td><p>bulk modulus of rubber</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">D1</code></p></td> <td><p>internal diameter</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">D2</code></p></td> <td><p>outer diameter (excluding cover thickness)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ts</code></td> <td><p>single steel shim layer thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">tr</code></td> <td><p>single rubber layer thickness</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">n</code></td> <td><p>number of rubber layers</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) kc cavitation parameter (optional, default = 10.0) PhiM damage parameter (optional, default = 0.5) ac strength reduction parameter (optional, default = 1.0) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.5) m element mass (optional, default = 0.0) cd viscous damping parameter (optional, default = 0.0) tc cover thickness (optional, default = 0.0) qL density of lead (optional, default = 11200 kg/m3) cL specific heat of lead (optional, default = 130 N-m/kg oC) kS thermal conductivity of steel (optional, default = 50 W/m oC) aS thermal diffusivity of steel (optional, default = 1.41e-05 m2/s) tag1 Tag to include cavitation and post-cavitation (optional, default = 0) tag2 Tag to include buckling load variation (optional, default = 0) tag3 Tag to include horizontal stiffness variation (optional, default = 0) tag4 Tag to include vertical stiffness variation (optional, default = 0) tag5 Tag to include strength degradation in shear due to heating of lead core (optional, default = 0) Important note: Because default values of heating parameters are in SI units, user must override the default heating parameters values if using Imperial units <br /> User should distinguish between yield strength of elastomeric bearing (Fy) and characteristic strength (Qd): Qd=Fy*(1-alpha) Physical Model and Mechanical Properties The physical model of an elastomeric bearing is considered as a two-node, twelve degrees-of-freedom discrete element. The two nodes are connected by six springs that represent the mechanical behavior in the six basic directions of a bearing. The degrees of freedom and discrete spring representation of an elastomeric bearing are shown in the below figures. The general form of element force vector, $$, and element stiffness matrix,<math></math> , for element representation considered above is given by equation below: <math>=; =</math> The coupling of the two shear springs is considered directly by using a coupled bidirectional model. All other springs are uncoupled. The coupling of vertical and horizontal directions are considered indirectly by using expressions for mechanical properties in one direction that are dependent on the response parameters in the other direction. Linear uncoupled springs are considered in the torsion and the two rotational springs as they are not expected to significantly affect the response of an elastomeric bearing. The off-diagonal terms due to coupling between axial and shear, and axial and rotation, are not considered in the two-spring model (Koh and Kelly, 1987) used here. An exact model would have non-zero values of these off-diagonal terms. A discussion on the formulation of the two-spring model and the exact model is presented in Ryan et al.(1991). The subscript b refers to the element\u2019s basic coordinate system. When the model is implemented in software programs, response quantities are transformed between the basic, local and global coordinates to perform computations. The discrete spring model presented here has the advantages of easy implementation and being computationally efficient. The mechanical properties of the six springs (also referred to as material models in OpenSees) are defined using analytical solutions available from the analysis of elastomeric bearings. The expression for mechanical properties, including stiffness and buckling load capacity, are derived using explicit consideration for geometric nonlinearity due to large displacement effects. The material models in six directions are: Axial direction: a new mathematical model that captures the behavior under cyclic tension Link Two shear directions: a special case of the Bouc-Wen model extended by Nagarajaiah et al.(1991) for seismic isolation bearings combined with a strength degradation model of Kalpakidis et al.(2010) Torsion: a linear elastic model Two rotational directions: linear elastic models In addition to the behavior captured by existing bearing elements, this element can capture following characteristics: Cavitation and post-cavitation behavior in tension (tag1) Variation in critical buckling load capacity due to lateral displacement (tag2) Variation in horizontal shear stiffness with axial load on the bearing (tag3) Variation in vertical axial stiffness with horizontal displacement (tag4) Strength degradation in cyclic shear loading due to heating of lead core (tag5) User may choose to include an individual or a combination of these behaviors through user tags (include:1, exclude:0) in their analysis. For the full capabilities of this element, users are referred to: EESD Article Consideration of characteristics to include under extreme loading A recent paper by Kumar et. al (2015) explains which of the five tags should be included in the analysis. Although the analysis presented in the paper is for the base-isolated NPP, the conclusions are valid for design earthquake and maximum considered earthquake for regular building structures as well. Following are few thumb rules that can be followed: tag 1: Unless you are investigating the tensile behavior, the effect of the tensile model on shear response is insignificant. tag 2: It is recommended to use tag to include variable buckling load capacity. It affects the compression capacity and shear stiffness. The apparent softening in shear force-deformation behavior at high axial load is due to this. A constant buckling load will show less softening. tag 3: Recommended if axial load expected during the loading is more than 10% of the buckling load capacity. tag2+tag3 provides greater softening. tag 4: Unless you are investigating the axial behavior, the effect of the tensile model on shear response is insignificant. tag 5: Recommended for long duration and low frequency ground motions. Effect is more prominent at beyond design basis earthquakes. Verification and validation This is element has been verified per ASME guidelines. A great deal of effort has gone into benchmarking performance of this user element using experimental data and verification using same element implement in LS-DYNA and ABAQUS. Users are referred to the Engineering Structures Paper for complete details. Additional information is also presented in SMiRT23 Paper and chapter 4 of the MCEER Report MCEER 15-0008 . Update: The LR isolator element is now implemented in the Mastadon software LR Isolator Element at Idaho National Laboratory by the research group working at University at Buffalo and Idaho National Laboratory. Recorders In addition to regular recorders provided by the bearing elements ( Element Recorder ), this element can also record instantaneous values of cavitation force (Fcn), buckling load capacity (Fcrn), vertical stiffness (Kv), horizontal stiffness (ke), temperature increase (dT), and yield strength (qYield) using the \u201cParameters\u201d recorder in that order. Example: recorder Element <-file \\(fileName&gt; -time &lt;-ele (\\) ele1 $ele2 \u2026)> Parameters recorder Element -file param.out -time -ele 1 Parameters To check if bearing has buckled or cavitated, an user can obtain the histories of Fcn and Fcrn as described above and divide the axial force (obtained from basicForce recorder, qb(2)) by Fcn and Fcrn at each time step, which provides demand vs capacity (D/C) ratios at each time step. If Fcn/qb(0) > 1.0 : Cavitation, or Fcrn/qb(0)>1.0 : Buckling. Examples An example is presented here in which a lead rubber bearing (large size bearing in Kalpakidis et al. (2010)) is subjected to a shear harmonic loading in laboratory (SEESL at UB). The response obtained from LeadRubberX element in OpenSees is compared with the experimental results. Excitation files: \u200e Tcl files: inline|Numerical and experimental response comparison References Kumar, M., Whittaker, A., and Constantinou, M. (2014). \u201cAn advanced numerical model of elastomeric seismic isolation bearings.\u201d Earthquake Engineering & Structural Dynamics, 43(13), 1955-1974. Link Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cExperimental investigation of cavitation in elastomeric seismic isolation bearings.\u201d Engineering Structures, 101, 290-305. Link Kumar, M., Whittaker, A., and Constantinou, M. (2015). \u201cResponse of base-isolated nuclear structures to extreme earthquake shaking.\u201d Nuclear Engineering and Design, 295, 860-874. Link Kumar, M., and Whittaker, A. (2018). \u201cCross-platform implementation, verification and validation of advanced mathematical models of elastomeric seismic isolation bearings.\u201d Engineering Structures, 175, 926-943. Link Kalpakidis, I. V., Constantinou, M. C., and Whittaker, A. S. (2010). \u201cModeling strength degradation in lead-rubber bearings under earthquake shaking.\u201d Earthquake Engineering and Structural Dynamics, 39(13), 1533-1549. Code Developed by: Manish Kumar, University at Buffalo, SUNY Any bugs in this element can be reported to mkumar2 AT buffalo dot edu","title":"LeadRubberX\n"},{"location":"contrib/modeling/element/376-MVLEM%20-%20Multiple-Vertical-Line-Element-Model%20for%20RC%20Walls/","text":"MVLEM element MVLEM $eleTag $Dens $iNode $jNode $m $c -thick { Thicknesses } \\ - width { Widths } -rho { Reinforcing_ratios } \\ -matConcrete { Concrete_tags } -matSteel { Steel_tags } \\ -matShear { Shear_tag } eleTag Unique element object tag Dens Wall density $iNode $jNode End node tags m Number of element macro-fibers c Location of center of rotation from the iNode, c = 0.4 (recommended) {Thicknesses} Array of m macro-fiber thicknesses {Widths} Array of m macro-fiber widths {Reinforcing_ratios} Array of m reinforcing ratios corresponding to macro-fibers; for each fiber: rho<sub class=\u201csubscript\u201d>i</sub> = A<sub class=\u201csubscript\u201d>s,i</sub>/A<sub class=\u201csubscript\u201d>gross,i</sub> (1 < i < m) {Concrete _tags} Array of m uniaxialMaterial tags for concrete {Steel_tags} Array of m uniaxialMaterial tags for steel {Shear_tag} Tag of uniaxialMaterial for shear material Element Recorders: The following recorders are available with the MVLEM element: globalForce Element global forces Curvature Element curvature Shear_Force_Deformation Element shear force-deformation relationship Fiber_Strain Vertical strains in m fibers along the cross-section Fiber_Stress_Concrete Vertical concrete stresses in m fibers along the cross-section Fiber_Stress_Steel Vertical steel stresses in m fibers along the cross-section Developed and Implemented by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles The MVLEM element command is used to generate a two-dimensional Multiple-Vertical-Line-Element-Model (MVLEM; Vulcano et al., 1988; Orakcal et al., 2004, Kolozvari et al., 2015) for simulation of flexure-dominated RC wall behavior. A single model element incorporates six global degrees of freedom, three of each located at the center of rigid top and bottom beams, as illustrated in Figure 1a. The axial/flexural response of the MVLEM is simulated by a series of uniaxial elements (or macro-fibers) connected to the rigid beams at the top and bottom (e.g., floor) levels, whereas the shear response is described by a shear spring located at height ch from the bottom of the wall element (Figure 1a). Shear and flexural responses of the model element are uncoupled. The relative rotation between top and bottom faces of the wall element occurs about the point located on the central axis of the element at height ch (Figure 1b). Rotations and resulting transverse displacements are calculated based on the wall curvature, derived from section and material properties, corresponding to the bending moment at height ch of each element (Figure 1b). A value of c =0.4 was recommended by Vulcano et al. (1988) based on comparison of the model response with experimental results. Source: /usr/local/cvs/OpenSees/SRC/element/MVLEM/ Figure 1. a) MVLEM Element, b) MVLEM Rotations and Displacements Input Format: Examples Element MVLEM 1 0.0 1 2 8 0.4 -thick 4 4 4 4 4 4 4 4 \\ - width 7.5 1.5 7.5 7.5 7.5 7.5 1.5 7.5 \\ -rho 0.0293 0.0 0.0033 0.0033 0.0033 0.0033 0.0 0.0293 \\ -matConcrete 3 4 4 4 4 4 4 3 -matSteel 1 2 2 2 2 2 2 1 \\ -matShear 5 Recorder Element -file MVLEM_Fgl.out -time -ele 1 globalForce Recorder Element -file MVLEM_FiberStrain.out -time -ele 1 Fiber_Strain References Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Orakcal K. (2004). \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. Orakcal K., Conte J.P., and Wallace J.W. (2004). \u201cFlexural Modeling of Reinforced Concrete Structural Walls - Model Attributes\u201d, ACI Structural Journal, V. 101, No. 5, pp 688-698. Orakcal K. and Wallace J.W. (2006). \u201cFlexural Modeling of Reinforced Concrete Structural Walls - Experimental Verification\u201d, ACI Structural Journal, V. 103, No. 2, pp. 196-206. Vulcano A., Bertero V.V., and Colotti V. (1988). \u201cAnalytical Modeling of RC Structural Walls\u201d, Proceedings, 9th World Conference on Earthquake Engineering, V. 6, Tokyo-Kyoto, Japan, pp. 41-46. Example 1. Simulation of Flexural Behavior of a Slender RC Wall Specimen under Cyclic Loading using MVLEM Model Application of the MVLEM element for simulation of flexural response of RC walls is illustrated using the RC wall specimen RW2 tested by Thomsen and Wallace (1995). The specimen was tested under constant axial load and cyclic lateral displacement history applied at the top of the wall. Input parameters and selected output results are presented in the following sections. E1.1. Model Calibration Specimen RW2 was 144 in tall, 48 in wide and 4 in thick, resulting in aspect ratio of 3.0 (slender wall). Figure E1.1 displays model discretization of the RW2 cross-section, with eight uniaxial elements defined along the length of the wall. The analytical model was discretized along wall height with 16 MVLEM elements with element heights in agreement with instrumentation provided on the specimen to allow consistent strain comparisons between model and experimental results. The material models were calibrated to match as tested material properties. Details about model calibration and experimental validation are provided by Orakcal (2004), and Orakcal and Wallace (2004). Figure E1.1. Geometry and Discretization of Wall Specimen RW2 E1.2. Input Files Input files (. tcl ) used to build the wall model and perform displacement-controlled analysis can be found in Example 1. MVLEM.zip : MVLEM_RW2.tcl - model generation and definition of analysis parameters gravity.tcl - application of gravity load dispControl.tcl - application of lateral displacement history (run this file) LibAnalysisStaticParameters.tcl - definition of static analysis parameters LibGeneratePeaks.tcl - generation of displacement history E1.3. Analysis Results Flexural load-deformation responses predicted by the MVLEM model and measured during the experiment are shown on Figure E1.2. Figure E1.2. Experimental and Analytical Load versus Flexural Deformation Relationships Figure E1.3 illustrates the sensitivity of analytical predictions obtained using the MVLEM to the optional gap closure parameter of the ConcreteCM model ( -GapClose $gap ), which allows consideration of different intensities of gradual gap closure in concrete (Figure E1.3a), as well as selection of the steel material model SteelMPF versus Steel02 (Figure E1.3b). It can be observed from Figure E1.3a that pinching characteristics of the response are slightly more pronounced when less gradual gap closure versus more gradual gap closure (i.e., gap =0 versus gap =1) is adopted. Figure E1.3b illustrates that the wall yield capacity as well as pinching characteristics of the behavior predicted by the MVLEM vary slightly when SteelMPF versus Steel02 is used. Figure E1.3. Sensitivity of Analytical Results to Material Modeling Parameters of: a) Concrete, and b) Steel For illustration purposes, additional response predictions obtained using the MVLEM model are presented in Figure E1.4 and Figure E1.5, where analytically-predicted strain histories at the outermost and central wall fibers, and concrete and steel strain-stress relationships at the outermost fiber are presented, respectively. Responses are obtained using MVLEM recorders Fiber_Strain , Fiber_Stress_Concrete , and Fiber_Stress_Steel . Figure E1.4. Analytical Strain Histories at Outermost and Central Wall Fibers Figure E1.5. Analytically Predicted Stress-Strain Relationships at Wall Outermost Fiber: a) Concrete, b) Steel","title":"MVLEM\n"},{"location":"contrib/modeling/element/394-Modeling%20Diaphragms%20in%202D%20Models%20with%20Linear%20and%20Nonlinear%20Elements%2C%20Oct%202011/","text":"Modeling Diaphragms in 2D Models with Linear and Nonlinear Elements, Oct 2011 Floor diaphragm need to be axially rigid to assure proper distribution of seismic forces to all lateral force resisting elements (columns and walls). Common modeling approach for frame structures is to represent the structural components (beams and columns) by line elements located at the original member centerlines and having cross-sectional properties equal to those of components. The effect of a rigid diaphragm at a floor level is usually modeled by imposing rigid constraints on all nodes of that floor level and thus enforcing the same lateral displacements of all nodes at the floor level. These constrains enforce condition of zero axial strain on elements that are part of that floor level. For sections where the neutral axis does not shift as a consequence of bending in the beam, axial strains at element\u2019s centerlines are zero, and thus rigid constraints can be applied to model the rigid diaphragm (e.g. steel sections, elastic materials). However, for nonlinear beam-column elements (force-based or displacement-based) with reinforced concrete fiber section where the neutral axis shifts due to bending in the beam axial strains at element\u2019s centerlines are no longer zero. Thus, rigid constraints that enforce condition of zero axial strain on elements will change the response of the frame. In this web-learning session, the effect of a rigid constraints is demonstrated on a 2D frame with force-based beam column elements considering three types of sections: elastic, nonlinear steel, and nonlinear reinforced concrete. This web-learning series covers: Introduction to problem Consequences of applying a rigid constraint on a force-based beam-column element with different types of sections (demonstrated on examples) Conclusions and summary PPT presentation of the seminar can be found here: Modeling Diaphragms in 2D Models Video of the seminar can be found here: Modeling Diaphragms in 2D Models OpenSees files used to demonstrate the effect of rigid constraints can be found here: The main file that is to be sourced from the OpenSees interpreter: ModelingDiaphragms2D.tcl Supporting files to be stored in the same folder with the main file: RectangularRCsection2D.tcl (procedure for discretizing RC rectangular section into fibers) WSection.tcl (procedure for discretizing W steel section into fibers) A10000.tcl (ground motion)","title":"Modeling Diaphragms in 2D Models with Linear and Nonlinear Elements, Oct\n2011\n"},{"location":"contrib/modeling/element/4-ASI3D8/","text":"ASI3D8 This command is used to construct an eight-node zero-thickness 3D brick acoustic-structure interface element object based on a bilinear isoparametric formulation. The nodes in the acoustic domain share the same coordinates with the nodes in the solid domain. element ASI3D8 $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 eleTag unique element object tag \\(node1 ..\\) node4 four nodes defining structure domain of element boundaries (numbered as shown in pdf) $node5 .. $node8 four nodes defining acoustic domain of element boundaries (numbered as shown in pdf) For further documentation and figures see attached: pdf Reference: ABAQUS theory manual. (2.9.1 Coupled acoustic-structural medium analysis) Code Developed by: Quan Gu, Yichao Gao and Zhijian Qiu","title":"ASI3D8\n"},{"location":"contrib/modeling/element/406-MultipleShearSpring%20Element/","text":"MultipleShearSpring Element This command is used to construct a multipleShearSpring (MSS) element object, which is defined by two nodes. This element consists of a series of identical shear springs arranged radially to represent the isotropic behavior in the local y-z plane. element multipleShearSpring $eleTag $iNode $jNode $nSpring -mat $matTag &lt;-lim $dsp &gt; &lt;-orient &lt; $x1 $x2 $x3 &gt; $yp1 $yp2 $yp3 &gt; &lt;-mass $m &gt; eleTag unique element object tag $inode \\(jnode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">nSpring</code></td> <td><p>number of springs</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag associated with previously-defined UniaxialMaterial object</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">dsp</code></td> <td><p>minimum deformation to calculate equivalent coefficient (see note 1)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) yp1 $yp2 $yp3 vector components in global coordinates defining vector yp which lies in the local x-y plane for the element m element mass NOTES: If dsp is positive and the shear deformation of MSS exceeds dsp , this element calculates equivalent coefficient to adjust force and stiffness of MSS. The adjusted MSS force and stiffness reproduce the behavior of the previously defined uniaxial material under monotonic loading in every direction. If dsp is zero, the element does not calculate the equivalent coefficient. The valid queries to a multipleShearSpring element when creating an ElementRecorder object are \u2018globalForce\u2019, \u2018localForce\u2019, \u2018basicForce\u2019, \u2018localDisplacement\u2019 and \u2018basicDeformation\u2019. MultipleShearSpring_Model.png Examples element multipleShearSpring 1 1 2 16 -mat 1 MultipleShearSpring_Sample.tcl , MultipleShearSpring_input_X.tcl , MultipleShearSpring_input_Y.tcl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFERENCES: Wada. A. and Hirose K. , \u201cBuilding Frames Subjected to 2D Earthquake Motion\u201d, Seismic Engineering: Research and Practice, American Society of Civil Engineers , 388-397, 1989. Code Developed by: mkiku","title":"MultipleShearSpring Element\n"},{"location":"contrib/modeling/element/419-Nine%20Four%20Node%20Quad%20u-p%20Element/","text":"Nine Four Node Quad u-p Element Nine_Four_Node_QuadUP is a 9-node quadrilateral plane-strain element. The four corner nodes have 3 degrees-of-freedom (DOF) each: DOF 1 and 2 for solid displacement (u) and DOF 3 for fluid pressure (p). The other five nodes have 2 DOFs each for solid displacement. This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a Nine_Four_Node_QuadUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element 9_4_QuadUP $eleTag $Node1 $Node2 $Node3 $Node4 $Node5 $Node6 $Node7 $Node8 $Node9 $thick $matTag $bulk $fmass $hPerm \\(vPerm &lt;\\) b1=0 \\(b2=0&gt;</strong></p></td> </tr> </tbody> </table> <figure> <img src=\"/OpenSeesRT/contrib/static/Elem9_4QuadUp.png\" title=\"Elem9_4QuadUp.png\" alt=\"Elem9_4QuadUp.png\" /> <figcaption aria-hidden=\"true\">Elem9_4QuadUp.png</figcaption> </figure> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Node1,\u2026 \\(Node9</strong></p></td> <td><p>Nine element node (previously defined) numbers (see figure above for order of numbering).</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>Element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) hPerm, \\(vPerm</strong></p></td> <td><p>Permeability coefficient in horizontal and vertical directions respectively.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1, $b2 Optional gravity acceleration components in horizontal and vertical directions respectively (defaults are 0.0) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"Nine Four Node Quad u-p Element\n"},{"location":"contrib/modeling/element/45-BbarBrick%20u-p%20Element/","text":"BbarBrick u-p Element bbarBrickUP is a 8-node mixed volume/pressure element, which uses a tri-linear isoparametric formulation. Each node has 4 degrees-of-freedom (DOF): DOFs 1 to 3 for solid displacement (u) and DOF 4 for fluid pressure (p). This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a bbarBrickUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element bbarBrickUP $eleTag $Node1 $Node2 $Node3 $Node4 $Node5 $Node6 $Node7 $Node8 $matTag $bulk $fmass $PermX $PermY \\(PermZ &lt;\\) bX=0 $bY=0 \\(bZ=0&gt;</strong></p></td> </tr> </tbody> </table> <figure> <img src=\"/OpenSeesRT/contrib/static/BrickUp.png\" title=\"BrickUp.png\" alt=\"BrickUp.png\" /> <figcaption aria-hidden=\"true\">BrickUp.png</figcaption> </figure> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Node1,\u2026 \\(Node8</strong></p></td> <td><p>Eight element node (previously defined) numbers (see figure above for order of numbering).</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) permX, $permY, \\(permZ</strong></p></td> <td><p>Permeability coefficients in x, y, and z directions respectively.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) bX, $bY, $bZ Optional gravity acceleration components in x, y, and z directions directions respectively (defaults are 0.0) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"BbarBrick u-p Element\n"},{"location":"contrib/modeling/element/46-BbarQuad%20u-p%20Element/","text":"BbarQuad u-p Element bbarQuadUP is a four-node plane-strain mixed volume/pressure element, which uses a tri-linear isoparametric formulation. This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Each element node has 3 degrees-of-freedom (DOF): DOF 1 and 2 for solid displacement (u) and DOF 3 for fluid pressure (p). Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a bbarQuadUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element bbarQuadUP $eleTag $iNode $jNode $kNode $lNode $thick $matTag $bulk $fmass $hPerm \\(vPerm &lt;\\) b1=0 $b2=0 \\(t=0&gt;</strong></p></td> </tr> </tbody> </table> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode, $jNode, $kNode, \\(lNode</strong></p></td> <td><p>Four element node (previously defined) numbers in counter-clockwise order around the element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>Element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) hPerm, \\(vPerm</strong></p></td> <td><p>Permeability coefficient in horizontal and vertical directions respectively.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1, $b2 Optional gravity acceleration components in horizontal and vertical directions respectively (defaults are 0.0) t Optional uniform element normal traction, positive in tension (default is 0.0) TYPICAL RANGE OF PERMEABILITY COEFFICIENT Gravel Sand Silty Sand Silt Clay >1.0x10<sup>-1</sup> cm/s (or 3.94x10<sup>-2</sup> in/s) 1.0x10<sup>-3</sup> cm/s (or 3.94 x10<sup>-4</sup> in/s) ~ 1.0x10<sup>-1</sup> cm/s (or 3.94 x10<sup>-2</sup> in/s) 1.0x10<sup>-5</sup> cm/s (or 3.94 x10<sup>-6</sup> in/s) ~ 1.0x10<sup>-3</sup> cm/s (or 3.94 x10<sup>-4</sup> in/s) 1.0x10<sup>-7</sup> cm/s (or 3.94 x10<sup>-8</sup> in/s) ~ 1.0x10<sup>-5</sup> cm/s (or 3.94 x10<sup>-6</sup> in/s) <1.0x10<sup>-7</sup> cm/s (or 3.94x10 <sup>-8</sup> in/s) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"BbarQuad u-p Element\n"},{"location":"contrib/modeling/element/47-Bbar%20Brick%20Element/","text":"Bbar Brick Element","title":"Bbar Brick Element\n"},{"location":"contrib/modeling/element/48-Bbar%20Plane%20Strain%20Quadrilateral%20Element/","text":"Bbar Plane Strain Quadrilateral Element This command is used to construct a four-node quadrilateral element object, which uses a bilinear isoparametric formulation along with a mixed volume/pressure B-bar assumption. This element is for plane strain problems only. element bbarQuad $eleTag $iNode $jNode $kNode $lNode $thick $matTag eleTag unique element object tag $iNode $jNode $kNode $lNode four nodes defining element boundaries, input in counter-clockwise order around the element. thick element thickness matTag tag of nDMaterial NOTE: PlainStrain only. The valid queries to a Quad element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. Examples Code Developed by: Edward Love, Sandia National Laboratories","title":"Bbar Plane Strain Quadrilateral Element\n"},{"location":"contrib/modeling/element/5-AV3D4/","text":"AV3D4 This command is used to construct a four-node 3D acoustic viscous boundary quad element object based on a bilinear isoparametric formulation. element AV3D4 $eleTag $node1 $node2 $node3 $node4 $matTag eleTag unique element object tag \\(node1 ..\\) node4 4 end nodes matTag Material Tag of previously defined nD material For further documentation and figures see attached: pdf Code Developed by: Quan Gu, Yichao Gao and Zhijian Qiu","title":"AV3D4\n"},{"location":"contrib/modeling/element/52-BeamColumnJoint%20Element/","text":"BeamColumnJoint Element This command is used to construct a two-dimensional beam-column-joint element object. The element may be used with both two-dimensional and three-dimensional structures; however, load is transferred only in the plane of the element. element beamColumnJoint $eleTag $Nd1 $Nd2 $Nd3 $Nd4 $Mat1 $Mat2 $Mat3 $Mat4 $Mat5 $Mat6 $Mat7 $Mat8 $Mat9 $Mat10 $Mat11 $Mat12 $Mat13 &lt; $eleHeightFac $eleWidthFac &gt; Tag unique element object tag $Nd1 $Nd2 $Nd3 $Nd4 four nodes Mat1 uniaxial material tag for left bar-slip spring at node 1 Mat2 uniaxial material tag for right bar-slip spring at node 1 Mat3 uniaxial material tag for interface-shear spring at node 1 Mat4 uniaxial material tag for lower bar-slip spring at node 2 Mat5 uniaxial material tag for upper bar-slip spring at node 2 Mat6 uniaxial material tag for interface-shear spring at node 2 Mat7 uniaxial material tag for left bar-slip spring at node 3 Mat8 uniaxial material tag for right bar-slip spring at node 3 Mat9 uniaxial material tag for interface-shear spring at node 3 Mat10 uniaxial material tag for lower bar-slip spring at node 4 Mat11 uniaxial material tag for upper bar-slip spring at node 4 Mat12 uniaxial material tag for interface-shear spring at node 4 Mat13 uniaxial material tag for shear-panel eleHeightFac floating point value (as a ratio to the total height of the element) to be considered for determination of the distance in between the tension-compression couples (optional, default: 1.0) eleWidthFac floating point value (as a ratio to the total width of the element) to be considered for determination of the distance in between the tension-compression couples (optional, default: 1.0) BeamColumnJoint.png Examples BeamColumnJointExample - the original file (has some errors) BeamColumnJointExample_Corrected (corrected by Vesna Terzic) REFERENCES: Lowes, Laura N.; Mitra, Nilanjan; Altoontash, Arash A beam-column joint model for simulating the earthquake response of reinforced concrete frames PEER-2003/10 Pacific Earthquake Engineering Research Center, University of California, Berkeley 2003 59 pages (400/P33/2003-10) Code Developed by: Nilanjan Mitra, Cal Poly","title":"BeamColumnJoint Element\n"},{"location":"contrib/modeling/element/53-BeamContact2D/","text":"BeamContact2D This command is used to construct a BeamContact2D element object. element BeamContact2D $eleTag $iNode $jNode $cNode $lNode $matTag $width $gTol $fTol &lt; $cFlag $&gt; eleTag unique integer tag identifying element object $iNode \\(jNode</strong></p></td> <td><p>retained nodes (-ndm 2 -ndf 3)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">cNode</code></td> <td><p>constrained node (-ndm 2 -ndf 2)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">lNode</code></td> <td><p>Lagrange multiplier node (-ndm 2 -ndf 2)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">width</code></td> <td><p>the width of the wall represented by the beam element in plane strain</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">gTol</code></td> <td><p>gap tolerance</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fTol</code></td> <td><p>force tolerance</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">cFlag</code></td> <td><p>optional initial contact flag</p></td> </tr> <tr class=\"even\"> <td></td> <td><p>\\) cFlag = 0 >> contact between bodies is initially assumed (DEFAULT) $cFlag = 1 >> no contact between bodies is initially assumed The BeamContact2D element is a two-dimensional beam-to-node contact element which defines a frictional contact interface between a beam element and a separate body. The retained nodes (3 DOF) are the endpoints of the beam element, and the constrained node (2 DOF) is a node from a second body. The Lagrange multiplier node (2 DOF) is required to enforce the contact condition. Each contact element should have a unique Lagrange multiplier node. The Lagrange multiplier node should not be fixed, otherwise the contact condition will not work. Under plane strain conditions in 2D, a beam element represents a unit thickness of a wall. The width is the dimension of this wall in the 2D plane. This width should be built-in to the model to ensure proper enforcement of the contact condition. The Excavation Supported by Cantilevered Sheet Pile Wall practical example provides some further examples and discussion on the usage of this element. NOTE: The BeamContact2D element has been written to work exclusively with the ContactMaterial2D nDMaterial object. The valid recorder queries for this element are: force - returns the contact force acting on the constrained node in vector form. frictionforce - returns the frictional force acting on the constrained node in vector form. forcescalar - returns the scalar magnitudes of the normal and tangential contact forces. masterforce - returns the reactions (forces and moments) acting on the retained nodes. The BeamContact2D elements are set to consider frictional behavior as a default, but the frictional state of the BeamContact2D element can be changed from the input file using the setParameter command. When updating, value of 0 corresponds to the frictionless condition, and a value of 1 signifies the inclusion of friction. An example command for this update procedure is provided below The BeamContact2D element works well in static and pseudo-static analysis situations. In transient analysis, the presence of the contact constraints can effect the stability of commonly-used time integration methods in the HHT or Newmark family (e.g., Laursen, 2002). For this reason, use of alternative time-integration methods which numerically damp spurious high frequency behavior may be required. The TRBDF2 integrator is an effective method for this purpose. The Newmark integrator can also be effective with proper selection of the gamma and beta coefficients. The trapezoidal rule, i.e., Newmark with gamma = 0.5 and beta = 0.25, is particularly prone to instability related to the contact constraints and is not recommended. EXAMPLES: BeamContact2D element with tag 1, connectivity with nodes 1, 2, 3, and 4, material with tag 1, width 0.5, gap and force tolerances of 1.0e-10, and a contact flag set to assume initial contact. element BeamContact2D 1 1 2 3 4 1 0.5 1.0e-10 1.0e-10 0 Update all of the BeamContact2D elements with tags between 10 and 20 to consider a frictionless interface setParameter -value 0 -eleRange 10 20 friction REFERENCES: Laursen, T. A. (2002). Computational Contact and Impact Mechanics. Springer-Verlag, Berlin. Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"BeamContact2D\n"},{"location":"contrib/modeling/element/54-BeamContact3D/","text":"BeamContact3D This command is used to construct a BeamContact3D element object. element BeamContact3D $eleTag $iNode $jNode $cNode $lNode $radius $crdTransf $matTag $gTol $fTol &lt; $cFlag $&gt; eleTag unique integer tag identifying element object $iNode \\(jNode</strong></p></td> <td><p>retained nodes (-ndm 3 -ndf 6)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">cNode</code></td> <td><p>constrained node (-ndm 3 -ndf 3)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">lNode</code></td> <td><p>Lagrange multiplier node (-ndm 3 -ndf 3)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">radius</code></td> <td><p>constant radius of circular beam associated with beam element</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">crdTransf</code></td> <td><p>unique integer tag associated with previously-defined <a href=\"Geometric_Transformation_Command\" title=\"wikilink\"> geometricTransf</a> object</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">gTol</code></td> <td><p>gap tolerance</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fTol</code></td> <td><p>force tolerance</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">cFlag</code></td> <td><p>optional initial contact flag</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>\\) cFlag = 0 >> contact between bodies is initially assumed (DEFAULT) $cFlag = 1 >> no contact between bodies is initially assumed The BeamContact3D element is a three-dimensional beam-to-node contact element which defines a frictional contact interface between a beam element and a separate body. The retained nodes (6 DOF) are the endpoints of the beam element, and the constrained node (3 DOF) is a node from a second body. The Lagrange multiplier node (3 DOF) is required to enforce the contact condition. Each contact element should have a unique Lagrange multiplier node. The Lagrange multiplier node should not be fixed, otherwise the contact condition will not work. NOTE: The BeamContact3D element has been written to work exclusively with the ContactMaterial3D nDMaterial object. The valid recorder queries for this element are: force - returns the contact force acting on the constrained node in vector form. frictionforce - returns the frictional force acting on the constrained node in vector form. forcescalar - returns the scalar magnitudes of the single normal and two tangential contact forces. masterforce - returns the reactions (forces only) acting on the retained nodes. mastermoment - returns the reactions (moments only) acting on the retained nodes. masterreaction - returns the full reactions (forces and moments) acting on the retained nodes. The BeamContact3D elements are set to consider frictional behavior as a default, but the frictional state of the BeamContact3D element can be changed from the input file using the setParameter command. When updating, value of 0 corresponds to the frictionless condition, and a value of 1 signifies the inclusion of friction. An example command for this update procedure is provided below The BeamContact3D element works well in static and pseudo-static analysis situations. In transient analysis, the presence of the contact constraints can effect the stability of commonly-used time integration methods in the HHT or Newmark family (e.g., Laursen, 2002). For this reason, use of alternative time-integration methods which numerically damp spurious high frequency behavior may be required. The TRBDF2 integrator is an effective method for this purpose. The Newmark integrator can also be effective with proper selection of the gamma and beta coefficients. The trapezoidal rule, i.e., Newmark with gamma = 0.5 and beta = 0.25, is particularly prone to instability related to the contact constraints and is not recommended. EXAMPLES: BeamContact3D element with tag 1, connectivity with nodes 1, 2, 3, and 4, beam radius of 0.25, geomTransf object with tag 1, material with tag 1, gap and force tolerances of 1.0e-10, and a contact flag set to assume initial contact. element BeamContact3D 1 1 2 3 4 0.25 1 1 1.0e-10 1.0e-10 0 Update all of the BeamContact3D elements with tags between 10 and 20 to consider a frictionless interface setParameter -value 0 -eleRange 10 20 friction REFERENCES: Laursen, T. A. (2002). Computational Contact and Impact Mechanics. Springer-Verlag, Berlin. Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"BeamContact3D\n"},{"location":"contrib/modeling/element/55-BeamEndContact3D/","text":"BeamEndContact3D This command is used to construct a BeamEndContact3D element object. element BeamEndContact3D $eleTag $iNode $jNode $cNode $lNode $radius $gTol $fTol &lt; $cFlag $&gt; eleTag unique integer tag identifying element object iNode retained node from the beam (-ndm 3 -ndf 6) jNode the remaining node on the beam element with \\(iNode (-ndm 3 -ndf 6)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">cNode</code></td> <td><p>constrained node (-ndm 3 -ndf 3)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">lNode</code></td> <td><p>Lagrange multiplier node (-ndm 3 -ndf 3)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">radius</code></td> <td><p>radius of circular beam associated with beam element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">gTol</code></td> <td><p>gap tolerance</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fTol</code></td> <td><p>force tolerance</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">cFlag</code></td> <td><p>optional initial contact flag</p></td> </tr> <tr class=\"even\"> <td></td> <td><p>\\) cFlag = 0 >> contact between bodies is initially assumed (DEFAULT) \\(cFlag = 1 &gt;&gt; no contact between bodies is initially assumed</p></td> </tr> </tbody> </table> <hr /> <p>The BeamEndContact3D element is a node-to-surface contact element which defines a normal contact interface between the end of a beam element and a separate body. The first retained node (\\) iNode) is the beam node which is at the end of the beam (i.e. only connected to a single beam element), the second node ( \\(jNode) is the remaining node on the beam element in question. The constrained node (\\) cNode) is a node from a second body. The Lagrange multiplier node ( \\(lNode) is required to enforce the contact condition. This node should not be shared with any other element in the domain, and should be created with the same number of DOF as the constrained node.</p> <p>The BeamEndContact3D element enforces a contact condition between a fictitious circular plane associated with a beam element and a node from a second body. The normal direction of the contact plane coincides with the endpoint tangent of the beam element at the retained beam node (\\) iNode). The extents of this circular plane are defined by the radius input parameter. The retained beam node can only come into contact with a constrained node which is within the extents of the contact plane. There is a lag step associated with changing between the \u2018in contact\u2019 and \u2018not in contact\u2019 conditions. This element was developed for use in establishing a contact condition for the tip of a pile modeled as using beam elements and the underlying soil elements in three-dimensional analysis. NOTE: The BeamEndContact3D element does not use a material object. The valid recorder queries for this element are: force - returns the contact force acting on the constrained node in vector form. masterforce - returns the reactions (forces and moments) acting on the retained node. The BeamEndContact3D element works well in static and pseudo-static analysis situations. In transient analysis, the presence of the contact constraints can effect the stability of commonly-used time integration methods in the HHT or Newmark family (e.g., Laursen, 2002). For this reason, use of alternative time-integration methods which numerically damp spurious high frequency behavior may be required. The TRBDF2 integrator is an effective method for this purpose. The Newmark integrator can also be effective with proper selection of the gamma and beta coefficients. The trapezoidal rule, i.e., Newmark with gamma = 0.5 and beta = 0.25, is particularly prone to instability related to the contact constraints and is not recommended. EXAMPLE: BeamEndContact3D element with tag 1, and connectivity with nodes 1, 2, 3, and 4, beam radius of 0.25, gap and force tolerances of 1.0e-10, and a contact flag set to initially assume contact. element BeamEndContact3D 1 1 2 3 4 0.25 1.0e-10 1.0e-10 0 REFERENCES: Laursen, T. A. (2002). Computational Contact and Impact Mechanics. Springer-Verlag, Berlin. Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"BeamEndContact3D\n"},{"location":"contrib/modeling/element/56-Beam%20With%20Hinges%20Element/","text":"Beam With Hinges Element This command is used to construct a forceBeamColumn element object, which is based on the non-iterative (or iterative) flexibility formulation. The locations and weights of the element integration points are based on so-called plastic hinge integration, which allows the user to specify plastic hinge lenghts at the element ends. Two-point Gauss integration is used on the element interior while two-point Gauss-Radau integration is applied over lengths of 4LpI and 4LpJ at the element ends, viz. \u201cmodified Gauss-Radau plastic hinge integration\u201d. A total of six integration points are used in the element state determination (two for each hinge and two for the interior). Users may be familiar with the beamWithHinges command format (see below); however, the format shown here allows for the simple but important case of using a material nonlinear section model on the element interior. The previous beamWithHinges command constrained the user to an elastic interior, which often led to unconservative estimates of the element resisting force when plasticity spread beyond the plastic hinge regions in to the element interior. The advantages of this new format over the previous beamWithHinges command are Plasticity can spread beyond the plastic hinge regions Hinges can form on the element interior, e.g., due to distributed member loads element forceBeamColumn $eleTag $iNode $jNode $transfTag \u201cHingeRadau $secTagI $LpI $secTagJ $LpJ $secTagInterior\u201d <-mass $massDens> <-iter $maxIters \\(tol&gt;</strong></p></td> </tr> </tbody> </table> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode $jNode nodes at element ends I and J, respectively secTagI identifier for previously-defined section object at end I LpI plastic hinge length at end I secTagJ identifier for previously-defined section object at end J LpJ plastic hinge length at end J secTagInterior identifier for previously-defined section object on the element interior (DOES NOT HAVE TO BE ELASTIC, but can be any type of section, including fiber) transfTag identifier for previously-defined coordinate-transformation maxIters maximum number of iterations to undertake to satisfy element compatibility (optional, default=1) tol tolerance for satisfaction of element compatibility (optional, default=10-16) NOTE: The keyword HingeRadau can be changed to one of the following in order to use a different hinge integration approach: HingeRadau \u2013 two-point Gauss-Radau applied to the hinge regions over 4LpI and 4LpJ (six element integration points) HingeRadauTwo \u2013 two-point Gauss-Radau in the hinge regions applied over LpI and LpJ (six element integration points) HingeMidpoint \u2013 midpoint integration over the hinge regions (four element integration points) HingeEndpoint \u2013 endpoint integration over the hinge regions (four element integration points) For more information on the behavior, advantages, and disadvantages of these approaches to plastic hinge integration, see Scott, M.H. and G.L. Fenves. \u201c Plastic Hinge Integration Methods for Force-Based Beam-Column Elements \u201d, Journal of Structural Engineering, 132(2):244-252, February 2006. Scott, M.H. and K.L. Ryan. \u201c Moment-Rotation Behavior of Force-Based Plastic Hinge Elements \u201d, Earthquake Spectra, 29(2):597-607, May 2013. The primary advantages of HingeRadau are The user can specify a physically meaningful plastic hinge length The largest bending moment is captured at the element ends The exact numerical solution is recovered for a linear-elastic prismatic beam The characteristic length is equal to the user-specified plastic hinge length when deformations localize at the element ends while the primary disadvantages are The element post-yield response is too flexible for strain-hardening section response (consider using HingeRadauTwo ) The user needs to know the plastic hinge length a priori (empirical equations are available) NOTE: See the forceBeamColumn page for valid recorder queries. Original command (maintained for backward compatibility) NOTE: this form of the command forces the element interior to be linear-elastic, which is not always the best approach. For 2D: element beamWithHinges $eleTag $iNode $jNode $secTagI $Lpi $secTagJ $Lpj $E $A $Iz $transfTag &lt;-mass $massDens &gt; &lt;-iter $maxIters $tol &gt; For 3D: element beamWithHinges $eleTag $iNode $jNode $secTagI $Lpi $secTagJ $Lpj $E $A $Iz $Iy $G $J $transfTag &lt;-mass $massDens &gt; &lt;-iter $maxIters $tol &gt; All inputs are the same as above, with the following additional inputs, which are used solely to create a \u201cdummy\u201d elastic section at the two Gauss integration points of the element interior E Youngs modulus elastic portion A Area for elastic portion Iz second moment of area for elastic portion about local z Iy second moment of area for elastic portion about local y G torsional moment of inertia of cross section for elastic portion J Shear Modulus of elastic portion. Code maintained by: Michael H. Scott, Oregon State University","title":"Beam With Hinges Element\n"},{"location":"contrib/modeling/element/562-Quad%20Element/","text":"Quad Element This command is used to construct a FourNodeQuad element object which uses a bilinear isoparametric formulation. element quad $eleTag $iNode $jNode $kNode $lNode $thick $type $matTag &lt; $pressure $rho $b1 $b2 &gt; eleTag unique element object tag $iNode $jNode $kNode \\(lNode</strong></p></td> <td><p>four nodes defining element boundaries, input in counter-clockwise order around the element.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">type</code></td> <td><p>string representing material behavior. The type parameter can be either \"PlaneStrain\" or \"PlaneStress.\"</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag of nDMaterial</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">pressure</code></td> <td><p>surface pressure (optional, default = 0.0)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">rho</code></td> <td><p>element mass density (per unit volume) from which a lumped element mass matrix is computed (optional, default=0.0)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1 $b2 constant body forces defined in the isoparametric domain (optional, default=0.0) NOTE: Consistent nodal loads are computed from the pressure and body forces. The valid queries to a Quad element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. Examples Code Developed by: Micheal Scott, Oregon State","title":"Quad Element\n"},{"location":"contrib/modeling/element/563-Quad%20u-p%20Element/","text":"Quad u-p Element","title":"Quad u-p Element\n"},{"location":"contrib/modeling/element/568-RJ-Watson%20EQS%20Bearing%20Element/","text":"RJ-Watson EQS Bearing Element This command is used to construct a RJWatsonEqsBearing element object, which is defined by two nodes. The iNode represents the masonry plate and the jNode represents the sliding surface plate. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) friction properties (with post-yield stiffening due to the mass-energy-regulator (MER) springs) for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. To capture the uplift behavior of the bearing, the user-specified UniaxialMaterial in the axial direction is modified for no-tension behavior. By default (sDratio = 1.0) P-Delta moments are entirely transferred to the sliding surface (jNode). It is important to note that rotations of the sliding surface (rotations at the jNode) affect the shear behavior of the bearing. To avoid the introduction of artificial viscous damping in the isolation system (sometimes referred to as \u201cdamping leakage in the isolation system\u201d), the bearing element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element RJWatsonEqsBearing $eleTag $iNode $jNode $frnMdlTag $kInit -P $matTag -Vy $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; For a three-dimensional problem: element RJWatsonEqsBearing $eleTag $iNode $jNode $frnMdlTag $kInit -P $matTag -Vy $matTag -Vz $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; eleTag unique element object tag $iNode $jNode end nodes frnMdlTag tag associated with previously-defined FrictionModel kInit initial stiffness of sliding friction component in local shear direction -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -Vy $matTag tag associated with previously-defined UniaxialMaterial in shear direction along local y-axis (MER spring behavior not including friction) -Vz $matTag tag associated with previously-defined UniaxialMaterial in shear direction along local z-axis (MER spring behavior not including friction) -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.0) -doRayleigh to include Rayleigh damping from the bearing (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) maxIter maximum number of iterations to undertake to satisfy element equilibrium (optional, default = 20) tol convergence tolerance to satisfy element equilibrium (optional, default = 1E-8) RJWatsonEQSBearingFig01.png NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. Because the friction force is affected by both the axial force and the slip rate, the element can be sensitive numerically. It is recommended that for dynamic analysis a smaller time step is being used than what would be used for a comparable structure with no isolators. If there is uplift (and therefore impact) in the bearing element, it can be helpful to use an integration method that provides numerical damping. Providing some viscous damping for the material that is assigned to the axial direction can also be helpful in dissipating impact energy. The valid queries to a RJ-Watson EQS bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples For a 2D RJ-Watson EQS bearing: element RJWatsonEqsBearing 1 1 2 1 250.0 -P 1 -Vy 2 -Mz 3 -orient 0 1 0 -1 0 0; TestFPS2d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestFPS2d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestFPS2d_2.tcl models an isolated one story stick and the bearing element has finite length. TestFPS2d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestFPS2d_4.tcl models an isolated five story one bay building and the bearing element has finite length. For a 3D RJ-Watson EQS bearing: element RJWatsonEqsBearing 1 1 2 1 250.0 -P 1 -Vy 2 -Vz 2 -T 3 -My 4 -Mz 4 -orient 0 0 1 -1 0 0; TestFPS3d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestFPS3d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestFPS3d_2.tcl models an isolated one story stick and the bearing element has finite length. TestFPS3d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestFPS3d_4.tcl models an isolated five story one bay building and the bearing element has finite length. Download the GroundMotions.zip as a compressed file or download AllFPSExamples.zip as a compressed file. Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"RJ-Watson EQS Bearing Element\n"},{"location":"contrib/modeling/element/611-SFI%20MVLEM%20-%20Cyclic%20Shear-Flexure%20Interaction%20Model%20for%20RC%20Walls/","text":"SFI MVLEM - Cyclic Shear-Flexure Interaction Model for RC Walls Developed and Implemented by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles The SFI_MVLEM command is used to construct a Shear-Flexure Interaction Multiple-Vertical-Line-Element Model (SFI-MVLEM, Kolozvari et al., 2015a, b, c), which captures interaction between axial/flexural and shear behavior of RC structural walls and columns under cyclic loading. The SFI_MVLEM element (Figure 1) incorporates 2-D RC panel behavior described by the Fixed-Strut-Angle-Model (nDMaterial FSAM ; Ulugtekin, 2010; Orakcal et al., 2012), into a 2-D macroscopic fiber-based model (MVLEM). The interaction between axial and shear behavior is captured at each RC panel (macro-fiber) level, which further incorporates interaction between shear and flexural behavior at the SFI_MVLEM element level. Source: /usr/local/cvs/OpenSees/SRC/element/SFI_MVLEM/ Figure 1. a) SFI_MVLEM Element, b) RC Panel Element (nDMaterial FSAM) Input Format: Element SFI_MVLEM $eleTag $iNode $jNode $m $c -thick { Thicknesses } -width { Widths } -mat { Material_tags } eleTag Unique element object tag $iNode $jNode End node tags m Number of element macro-fibers c Location of center of rotation with from the iNode, c = 0.4 (recommended) {Thicknesses} Array of m macro-fiber thicknesses {Widths} Array of m macro-fiber widths {Material_tags} Array of m macro-fiber nDMaterial <sup class=\u201csuperscript\u201d>1</sup> tags <sup class=\u201csuperscript\u201d>1</sup> SFI_MVLEM element shall be used with nDMaterial FSAM , which is a 2-D plane-stress constitutive relationship representing reinforced concrete panel behavior. Element Recorders: The following recorders are available with the SFI_MVLEM element: globalForce Element global forces Curvature Element curvature ShearDef Element shear deformation RCPanel $fibTag \\(Response</strong></p></td> <td><p>Returns RC panel (macro-fiber) <em>\\) Response for a \\(fibTag</em>-th panel (1 \u2264 <em>fibTag</em> \u2264 m). For available <em>\\) Response -s refer to nDMaterial FSAM . Examples: Element SFI_MVLEM 1 1 2 5 0.4 -thick 6 6 6 6 6 -width 9 10 10 10 9 -mat 7 6 6 6 7 Recorder Element -file SFI_MVLEM_Fgl.out -time -ele 1 2 3 globalForce Recorder Element -file SFI_MVLEM_panel_strain.out -time -ele 1 RCPanel 1 panel_strain References: Kolozvari K., Orakcal K., and Wallace J. W. (2015a). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Kolozvari K., Orakcal K., and Wallace J. W. (2015b). \u201dModeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls. I: Theory\u201d, ASCE Journal of Structural Engineering, 141(5), 04014135 doi Kolozvari K., Tran T., Orakcal K., and Wallace, J.W. (2015c). \u201dModeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls. II: Experimental Validation\u201d, ASCE Journal of Structural Engineering, 141(5), 04014136 doi Kolozvari K. (2013). \u201cAnalytical Modeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls\u201d, PhD Dissertation, University of California, Los Angeles. Example 1. Simulation of Shear-Flexural Behavior of a Medium-Rise RC Wall Specimen under Cyclic Loading using the SFI-MVLEM Model The behavior of RC wall specimen RW-A15-P10-S78 (Tran and Wallace, tested under constant axial load and cyclic lateral displacement history applied at the top of the wall is predicted using the SFI_MVLEM model. The input parameters and output results are presented in the following sections. E1.1. Model Calibration Basic properties of the specimen with model discretization are shown on Figure E1.1. Detailed information about the test specimen can be found in paper by Tran and Wallace (2012), whereas details of model calibration are provided by Kolozvari (2013) and Kolozvari et al. (2015b). Figure E1.1. Model discretization: a) Plan view, b) Cross-section E1.2. Input Files Input files (. tcl ) used to build the wall model and perform displacement-controlled analysis can be found in Example 1. SFI_MVLEM.zip : SFI_MVLEM_SP4.tcl - model generation and definition of analysis parameters gravity.tcl - application of gravity load dispControl.tcl - application of lateral displacement history (run this file) LibAnalysisStaticParameters.tcl - definition of static analysis parameters LibGeneratePeaks.tcl - generation of displacement history E1.3. Analysis Results The following sub-section presents analytical results obtained for the test specimen described above, using the input files provided. The results include global wall responses (compared against experimental results), model element responses, and individual RC panel (macro-fiber) responses. E1.3.1. Global Wall Responses Analytical and experimental lateral load versus top total displacement responses and wall cracking patterns are presented on Figure E1.2, whereas lateral load versus flexural and shear deformations are shown on Figure E1.3. Total top displacement is obtained from the top node, shear force is recorded using globalForce element recorder, total shear displacement is obtained using shearDef element recorder and crack orientations are obtained using RCPanel and cracking_angles element recorders. Figure E1.2. Wall responses: a) Load versus Top Displacement Behavior, b) Cracking Patterns Figure E1.3. Load versus Deformation Behavior for: a) Flexure, b) Shear E1.3.2. Model Element Responses Figure E1.4 plots lateral load versus total, flexural and shear displacement responses, as well as moment versus curvature relationship, obtained from the analysis for the bottom wall model element. Responses are recorded using globalForce , ShearDef , and Curvature element recorders. Figure E1.4. Model Element Responses: a) Shear Force vs. Total Deformation, b) Shear force vs. Flexural Deformation, c) Shear Force vs. Shear Deformation, d) Moment vs. Curvature E1.3.3. Reinforced Concrete Panel Responses Various stress-strain responses for an individual boundary panel element (outermost macro-fiber) within the bottommost wall element are presented, including total (resultant) stress vs. strain relationships in the xy plane (Figure E1.5; element RCPanel recorders: panel_strain and panel_stress ), stress-strain relationships along the two concrete struts (Figure E1.6; element RCPanel recorders: strain_stress_concrete1 and strain_stress_concrete2 ), and stress-strain relationship along horizontal and vertical steel reinforcement (Figure E1.7; element RCPanel recorders: strain_stress_steelX and strain_stress_steelY ). Figure E1.5. Panel Total Stress vs. Strain Responses: a) Axial-Horizontal, b) Axial-Vertical, c) Shear Figure E1.6. Predicted Stress-Strain Behavior for Concrete: a) Strut 1, b) Strut 2 Figure E1.7. Predicted Stress-Strain Behavior for Steel: a) Horizontal (X), b) Vertical (Y) Example 2. Dynamic Analysis of a Coupled Wall-Frame System This example illustrates application of the SFI_MVLEM wall model for nonlinear dynamic analysis. Analytical model of a coupled wall-frame building system was generated and analyzed under a single ground motion time-history. Brief description of the building characteristics and the analytical model are provided in the following sections. E2.1. Building Description Plan and elevation/section views of the considered building are shown in Figure E2.1. The building footprint is 140 ft \u00d7 60 ft , with 20 ft long spans. Analysis is conducted for shaking in the transverse direction only, where the lateral-force-resisting elements include two identical one-bay frames located at the building perimeter (axis 1 and 8, Figure E2.1a) and two identical walls located near the center of the building (axis 4 and 5, Figure E2.1a). Structural design is performed for a residential building (I=1.0, risk category I, design category D; ASCE 7-10 S11.5 and S11.6) for uniformly distributed dead load of 150 psf and live load of 40 psf (ASCE 7-10, Table 4-1), as well as the earthquake lateral loading obtained using Equivalent Lateral Force Procedure of ASCE 7-10 (S12.8). The frame was designed to resist 25% of the earthquake lateral load (Dual System, ASCE 7-10). Concrete compressive strength of f\u2019<sub class=\u201csubscript\u201d>c</sub> = 5,000 psi and reinforcing steel (both longitudinal and transversal reinforcement) with yield strength f<sub class=\u201csubscript\u201d>y</sub> = 60,000 psi were used. Based on the structural design, cross-section dimensions of 12 in \u00d7 240 in (walls), 18 in \u00d7 32 in (beams; width \u00d7 depth), and 28 in \u00d7 28 in (columns) were adopted. Cross-sections of structural elements with the reinforcement detailing are provided in Figure E2.2. Figure E2.1. Building Views: a) Plan View, b) Frame Elevation, c) Wall Elevation Figure E2.2. Member Cross-Sections: a) Walls, b) Columns, c) Beams E2.2. Analytical Model Description Due to building symmetry and applied direction of the ground motion, a two-dimensional model consisting of one frame and one wall (Figure E2.3) is used to simulate the building behavior. The gravity system is not included in the model (ASCE 7-10) and the assumption of a rigid diaphragm is implemented within each story level. Tributary mass is assigned at the element nodes at each story level at locations of axes of the vertical elements (i.e., wall and columns), whereas gravity load (dead and live) was assigned according to corresponding tributary areas as either nodal load at wall-element nodes of each story or uniformly distributed load along the beams of the frame. As show on Figure E2.3, the RC wall is modeled using ten equal-length SFI_MVLEM elements along the wall height (i.e., two elements per story height). Wall discretization in horizontal direction was performed using six macro-fibers to represent the wall cross section, where two outer macro-fibers were used to represent the confined wall boundaries and the remaining four represent the unconfined wall web. Material models for steel and concrete are calibrated based on adopted material strengths to represent the behavior of confined and unconfined concrete and reinforcing steel. RC frame elements (i.e., beams and columns) are modeled using elastic beam-column elements by assuming the location of plastic hinges at the faces of beam-column joints (Figure E2.3a), the behavior of which was simulated using zero-length elements at locations of hinges and the elasto-plastic moment-rotation hysteretic model (Modified Ibarra Krawinkler Deterioration Model; Lignos and Krawinkler, 2011), with modeling parameters adopted according to beam and column flexural capacities and the ASCE 41 backbone relationships (Figure E2.3b). The reduction of flexural stiffness after cracking was considered using stiffness modifiers for elastic portions of beam and column elements according to ASCE 41 (Table 6.5). E2.3. Input Files Input files (. tcl ) used to build the model of a 5-story wall-frame system and perform gravity and dynamic analysis can be found in Example 2. SFI_MVLEM.zip : 5storyWF_SFI.tcl - model generation, definition of analysis parameters, gravity analysis Modal.tcl - modal analysis Dynamic.tcl - application of earthquake acceleration time-history (run this file) MCEScaledEQ1X.acc - earthquake acceleration time history file DisplayModel2D.tcl - display 2D model DisplayPlane.tcl - display plane Figure E2.3. Analytical Model of Building System: a) Modeling Approach, b) Plastic Hinge Model E2.4. Dynamic Analysis Results Results obtained using analytical model of the building described in the previous section are presented, including modal properties of the structure, wall global (i.e., lateral deformations, drifts, shear force, moments) and local (i.e., vertical strains and rotations) responses. Responses of the structural elements comprising the RC frame are not considered. E2.4.1. Dynamic Properties First two building fundamental periods and mode shapes are presented in Figure E2.4. Figure E2.4. Mode Shapes: a) 1st Mode, b) 2nd Mode E2.4.2. Time-history Responses Time histories of ground motion acceleration, wall top nodal displacement, and wall base shear force (bottom wall node reaction) are presented in Figure 2.5; the responses are obtained using globalForce and Reactions node recorders. Figure E2.5. Global Building Responses E2.4.3. Maximum Global Responses over the Wall Height Maximum envelopes of wall lateral displacements and interstory drifts, and shear force and bending moment are presented in Figure E2.6 and Figure E2.7, respectively. Wall lateral displacements and drifts are obtained using corresponding node recorders, disp and drift , whereas shear force and bending moments over the wall height are recorded using element recorders globalForce . Figure E2.6. Maximum Deformation Responses: a) Lateral Displacements, b) Interstory Drifts Figure E2.7. Maximum Shear Force and Bending Moment over Wall Height E2.4.4. Bottom Wall Element Responses Figure E2.8 plots the responses of the bottom wall element, including lateral load versus total, flexural and shear displacement, and moment versus curvature relationship obtained from the dynamic analysis. Note that wall element shear displacement and curvature time-histories are obtained using SFI_MVLEM element recorders ShearDef and Curvature , respectively, whereas shear force and bending moment are recorded using element recorder globalForce . Figure E2.8. Model Element Responses: a) Lateral Load vs. Displacement, b) Lateral Load vs. Flexural Deformation, Lateral Load vs. Shear Deformation, d) Moment vs. Curvature E2.4.5. Single RC Panel Responses Analytically-predicted strain-stress responses of a single RC panel (macro-fiber) located at the left wall boundary of the bottom wall element are presented. Global panel stress-strain relationships presented on Figure E2.9 are obtained using element recorder RCPanel with commands panel_strain and panel_stress ; the uniaxial behavior of concrete along the two concrete struts presented on Figure E2.10 are recorded using strain_stress_concrete1 and strain_stress_concrete2 commands; uniaxial stress-strain behavior of horizontal and vertical reinforcing steel presented on Figure E2.11 are obtained using strain_stress_steelX and strain_stress_steelY commands. Other panel responses described in Section 3 could be plotted in a similar manner. Figure E2.9. Panel Total Stress vs. Strain Responses: a) Axial-Horizontal, b) Axial-Vertical, c) Shear Figure E2.10. Predicted Stress-Strain Behavior for Concrete: a) Strut 1, b) Strut 2 Figure E2.11. Predicted Stress-Strain Behavior for Steel: a) Horizontal (X), b) Vertical (Y) Finally, vertical profiles of maximum vertical strains (Figure E2.12a) are obtained using element recorder with RCPanel and panel_strain recorder commands, whereas maximum wall rotations over the wall height (Figure E2.12b) are derived from element Curvature recorder. Similarly, the distribution of other wall responses could be plotted over the wall height (e.g., shear deformations, etc.). Figure E2.12. Local Responses - Vertical Profiles of Maximum: a) Vertical Strains, b) Rotations","title":"SFI MVLEM - Cyclic Shear-Flexure Interaction Model for RC Walls\n"},{"location":"contrib/modeling/element/612-SSPbrickUP%20Element/","text":"SSPbrickUP Element This command is used to construct a SSPbrickUP element object. element SSPbrickUP $eleTag $iNode $jNode $kNode $lNode $mNode $nNode $pNode $qNode $matTag $fBulk $fDen $k1 $k2 $k3 $void $alpha &lt; $b1 $b2 $b3 &gt; eleTag unique integer tag identifying element object $iNode $jNode $kNode $lNode $mNode $nNode $pNode \\(qNode</strong></p></td> <td><p>the eight nodes defining the element, input in counterclockwise order (same node numbering scheme as for the <a href=\"Brick_u-p_Element\" title=\"wikilink\"> brickUP Element</a>) (-ndm 3 -ndf 4)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fBulk</code></td> <td><p>bulk modulus of the pore fluid</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fDen</code></td> <td><p>mass density of the pore fluid</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) k1 $k2 \\(k3</strong></p></td> <td><p>permeability coefficients in global x-, y-, and z-directions, respectively</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">void</code></td> <td><p>voids ratio</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>spatial pressure field stabilization parameter (see discussion below for more information)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) b1 $b2 $b3 constant body forces in global x-, y-, and z-directions, respectively (optional, default = 0.0) - See Note 3 The SSPbrickUP element is an extension of the SSPbrick Element for use in dynamic 3D analysis of fluid saturated porous media. A mixed displacement-pressure (u-p) formulation is used, based upon the work of Biot as extended by Zienkiewicz and Shiomi (1984). The physical stabilization necessary to allow for reduced integration incorporates an enhanced assumed strain field, resulting in an element which is free from volumetric and shear locking. The elimination of shear locking results in greater coarse mesh accuracy in bending dominated problems, and the elimination of volumetric locking improves accuracy in nearly-incompressible problems. Analysis times are generally faster than corresponding full integration elements. Equal-order interpolation is used for the displacement and pressure fields, thus, the SSPbrickUP element does not inherently pass the inf-sup condition, and is not fully acceptable in the incompressible-impermeable limit (the brickUP Element has the same issue). A stabilizing parameter is employed to permit the use of equal-order interpolation for the SSPbrickUP element. This parameter alpha can be computed as alpha = h^2/(4 (Ks + (4/3) Gs)) where h is the element size, and Ks and Gs are the bulk and shear moduli for the solid phase. The alpha parameter should be a small number. With a properly defined alpha parameter, the SSPbrickUP element can produce comparable results to a higher-order element such as the 20_8_BrickUP Element at a significantly lower computational cost and with a greater ease in mesh generation. NOTES: The SSPbrickUP element will only work in dynamic analysis. For saturated soils, the mass density input into the associated nDMaterial object should be the saturated mass density. When modeling soil, the body forces input into the SSPbrickUP element should be the components of the gravitational vector, not the unit weight. Fixing the pore pressure degree-of-freedom (dof 4) at a node is a drainage boundary condition at which zero pore pressure will be maintained throughout the analysis. Leaving the fourth dof free allows pore pressures to build at that node. Valid queries to the SSPbrickUP element when creating an ElementalRecorder object correspond to those for the nDMaterial object assigned to the element (e.g., \u2018stress\u2019, \u2018strain\u2019). Material response is recorded at the single integration point located in the center of the element. The SSPbrickUP element was designed with intentions of duplicating the functionality of the brickUP Element . If an example is found where the SSPbrickUP element cannot do something that works for the brickUP Element , e.g., material updating, please contact the developers listed below so the bug can be fixed. EXAMPLES: SSPbrickUP element definition with element tag 1, nodes 1, 2, 3, 4, 5, 6, 7, and 8, material tag 1, bulk modulus of water (kPa), mass density of water (Mg/m^3), isotropic permeability of 1e-3, voids ratio of 0.7, alpha parameter of 6e-5, x- and y-directed body forces of zero, and z-directed body force of -9.81 element SSPbrickUP 1 1 2 3 4 5 6 7 8 1 2.2e6 1.0 1.0e-3 1.0e-3 1.0e-3 0.7 6.0e-5 0.0 0.0 -9.81 Elemental recorders for stress and strain when using the SSPbrickUP element (note the difference from the brickUP Element ) recorder Element -eleRange 1 $numElem -time -file stress.out stress recorder Element -eleRange 1 $numElem -time -file strain.out strain Pore pressure recorder for the SSPbrickUP element (pore pressure is the fourth degree-of-freedom) recorder Node -nodeRange 1 $numNode -time -file porePressure.out -dof 4 vel REFERENCES: Zienkiewicz, O.C. and Shiomi, T. (1984). \u201cDynamic behavior of saturated porous media; the generalized Biot formulation and its numerical solution.\u201d International Journal for Numerical Methods in Geomechanics , 8, 71-96. Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"SSPbrickUP Element\n"},{"location":"contrib/modeling/element/613-SSPbrick%20Element/","text":"SSPbrick Element This command is used to construct a SSPbrick element object. element SSPbrick $eleTag $iNode $jNode $kNode $lNode $mNode $nNode $pNode $qNode $matTag &lt; $b1 $b2 $b3 &gt; eleTag unique integer tag identifying element object $iNode $jNode $kNode $lNode $mNode $nNode $pNode \\(qNode</strong></p></td> <td><p>the eight nodes defining the element, input in counterclockwise order (same node numbering scheme as for the <a href=\"Standard_Brick_Element\" title=\"wikilink\"> stdBrick Element</a>) (-ndm 3 -ndf 3)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1 $b2 $b3 constant body forces in global x-, y-, and z-directions, respectively (optional, default = 0.0) The SSPbrick element is an eight-node hexahedral element using physically stabilized single-point integration (SSP \u2013> Stabilized Single Point). The stabilization incorporates an enhanced assumed strain field, resulting in an element which is free from volumetric and shear locking. The elimination of shear locking results in greater coarse mesh accuracy in bending dominated problems, and the elimination of volumetric locking improves accuracy in nearly-incompressible problems. Analysis times are generally faster than corresponding full integration elements. NOTES: Valid queries to the SSPbrick element when creating an ElementalRecorder object correspond to those for the nDMaterial object assigned to the element (e.g., \u2018stress\u2019, \u2018strain\u2019). Material response is recorded at the single integration point located in the center of the element. The SSPbrick element was designed with intentions of duplicating the functionality of the stdBrick Element . If an example is found where the SSPbrick element cannot do something that works for the stdBrick Element , e.g., material updating, please contact the developers listed below so the bug can be fixed. EXAMPLES: SSPbrick element definition with element tag 1, nodes 1, 2, 3, 4, 5, 6, 7, and 8, material tag 1, x- and y-directed body forces of zero, and z-directed body force of -10.0 element SSPbrick 1 1 2 3 4 5 6 7 8 1 0.0 0.0 -10.0 Elemental recorders for stress and strain when using the SSPbrick element (note the difference from the stdBrick Element ) recorder Element -eleRange 1 $numElem -time -file stress.out stress recorder Element -eleRange 1 $numElem -time -file strain.out strain Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"SSPbrick Element\n"},{"location":"contrib/modeling/element/614-SSPquadUP%20Element/","text":"SSPquadUP Element This command is used to construct a SSPquadUP element object. element SSPquadUP $eleTag $iNode $jNode $kNode $lNode $matTag $thick $fBulk $fDen $k1 $k2 $void $alpha &lt; $b1 $b2 &gt; eleTag unique integer tag identifying element object $iNode $jNode $kNode \\(lNode</strong></p></td> <td><p>the four nodes defining the element, input in counterclockwise order (-ndm 2 -ndf 3)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>thickness of the element in out-of-plane direction</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fBulk</code></td> <td><p>bulk modulus of the pore fluid</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">fDen</code></td> <td><p>mass density of the pore fluid</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) k1 \\(k2</strong></p></td> <td><p>permeability coefficients in global x- and y-directions, respectively</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">void</code></td> <td><p>voids ratio</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>spatial pressure field stabilization parameter (see discussion below for more information)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1 $b2 constant body forces in global x- and y-directions, respectively (optional, default = 0.0) - See Note 3 The SSPquadUP element is an extension of the SSPquad Element for use in dynamic plane strain analysis of fluid saturated porous media. A mixed displacement-pressure (u-p) formulation is used, based upon the work of Biot as extended by Zienkiewicz and Shiomi (1984). The physical stabilization necessary to allow for reduced integration incorporates an assumed strain field in which the volumetric dilation and the shear strain associated with the the hourglass modes are zero, resulting in an element which is free from volumetric and shear locking. The elimination of shear locking results in greater coarse mesh accuracy in bending dominated problems, and the elimination of volumetric locking improves accuracy in nearly-incompressible problems. Analysis times are generally faster than corresponding full integration elements. Equal-order interpolation is used for the displacement and pressure fields, thus, the SSPquadUP element does not inherently pass the inf-sup condition, and is not fully acceptable in the incompressible-impermeable limit (the QuadUP Element has the same issue). A stabilizing parameter is employed to permit the use of equal-order interpolation for the SSPquadUP element. This parameter alpha can be computed as alpha = 0.25 (h^2)/(den c^2) where h is the element size, c is the speed of elastic wave propagation in the solid phase, and den is the mass density of the solid phase. The alpha parameter should be a small number. With a properly defined alpha parameter, the SSPquadUP element can produce comparable results to a higher-order element such as the 9_4_QuadUP Element at a significantly lower computational cost and with a greater ease in mesh generation. The full formulation for the SSPquadUP element can be found in McGann et al. (2012) along with several example applications. NOTES: The SSPquadUP element will only work in dynamic analysis. For saturated soils, the mass density input into the associated nDMaterial object should be the saturated mass density. When modeling soil, the body forces input into the SSPquadUP element should be the components of the gravitational vector, not the unit weight. Fixing the pore pressure degree-of-freedom (dof 3) at a node is a drainage boundary condition at which zero pore pressure will be maintained throughout the analysis. Leaving the third dof free allows pore pressures to build at that node. Valid queries to the SSPquadUP element when creating an ElementalRecorder object correspond to those for the nDMaterial object assigned to the element (e.g., \u2018stress\u2019, \u2018strain\u2019). Material response is recorded at the single integration point located in the center of the element. The SSPquadUP element was designed with intentions of duplicating the functionality of the QuadUP Element . If an example is found where the SSPquadUP element cannot do something that works for the QuadUP Element , e.g., material updating, please contact the developers listed below so the bug can be fixed. EXAMPLES: SSPquadUP element definition with element tag 1, nodes 1, 2, 3, and 4, material tag 1, unit thickness, bulk modulus of water (kPa), mass density of water (Mg/m^3), horizontal and vertical permeabilities of 1e-3, voids ratio of 0.7, alpha parameter of 6e-5, horizontal body force of zero, and vertical body force of -9.81 element SSPquadUP 1 1 2 3 4 1 1.0 2.2e6 1.0 1.0e-3 1.0e-3 0.7 6.0e-5 0.0 -9.81 Elemental recorders for stress and strain when using the SSPquadUP element (note the difference from the QuadUP Element ) recorder Element -eleRange 1 $numElem -time -file stress.out stress recorder Element -eleRange 1 $numElem -time -file strain.out strain Pore pressure recorder for the SSPquadUP element (pore pressure is the third degree-of-freedom) recorder Node -nodeRange 1 $numNode -time -file porePressure.out -dof 3 vel REFERENCES: McGann, C. R., Arduino, P., and Mackenzie-Helnwein, P. (2012). \u201cStabilized single-point 4-node quadrilateral element for dynamic analysis of fluid saturated porous media.\u201d Acta Geotechnica , 7(4), 297-311. Zienkiewicz, O.C. and Shiomi, T. (1984). \u201cDynamic behavior of saturated porous media; the generalized Biot formulation and its numerical solution.\u201d International Journal for Numerical Methods in Geomechanics , 8, 71-96. Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"SSPquadUP Element\n"},{"location":"contrib/modeling/element/615-SSPquad%20Element/","text":"SSPquad Element This command is used to construct a SSPquad element object. element SSPquad $eleTag $iNode $jNode $kNode $lNode $matTag $type $thick &lt; $b1 $b2 &gt; eleTag unique integer tag identifying element object $iNode $jNode $kNode \\(lNode</strong></p></td> <td><p>the four nodes defining the element, input in counterclockwise order (-ndm 2 -ndf 2)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>thickness of the element in out-of-plane direction</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">type</code></td> <td><p>string to relay material behavior to the element, can be either \"PlaneStrain\" or \"PlaneStress\"</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>unique integer tag associated with previously-defined nDMaterial object</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1 $b2 constant body forces in global x- and y-directions, respectively (optional, default = 0.0) The SSPquad element is a four-node quadrilateral element using physically stabilized single-point integration (SSP \u2013> Stabilized Single Point). The stabilization incorporates an assumed strain field in which the volumetric dilation and the shear strain associated with the the hourglass modes are zero, resulting in an element which is free from volumetric and shear locking. The elimination of shear locking results in greater coarse mesh accuracy in bending dominated problems, and the elimination of volumetric locking improves accuracy in nearly-incompressible problems. Analysis times are generally faster than corresponding full integration elements. The formulation for this element is identical to the solid phase portion of the SSPquadUP element as described by McGann et al. (2012). NOTES: Valid queries to the SSPquad element when creating an ElementalRecorder object correspond to those for the nDMaterial object assigned to the element (e.g., \u2018stress\u2019, \u2018strain\u2019). Material response is recorded at the single integration point located in the center of the element. The SSPquad element was designed with intentions of duplicating the functionality of the Quad Element . If an example is found where the SSPquad element cannot do something that works for the Quad Element , e.g., material updating, please contact the developers listed below so the bug can be fixed. EXAMPLES: SSPquad element definition with element tag 1, nodes 1, 2, 3, and 4, material tag 1, plane strain conditions, unit thickness, horizontal body force of zero, and vertical body force of -10.0 element SSPquad 1 1 2 3 4 1 \u201cPlaneStrain\u201d 1.0 0.0 -10.0 Elemental recorders for stress and strain when using the SSPquad element (note the difference from the Quad Element ) recorder Element -eleRange 1 $numElem -time -file stress.out stress recorder Element -eleRange 1 $numElem -time -file strain.out strain REFERENCES McGann, C. R., Arduino, P., and Mackenzie-Helnwein, P. (2012). \u201cStabilized single-point 4-node quadrilateral element for dynamic analysis of fluid saturated porous media.\u201d Acta Geotechnica , 7(4), 297-311. Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington EXAMPLE ANALYSIS: The input file shown below creates a cantilever beam subject to a parabolic shear stress distribution at the free end. The beam is modeled with only one element over the height to test the coarse-mesh accuracy of the designated quadrilateral element. Anti-symmetry conditions hold, only the top half of the beam is modeled. Try running this with the SSPquad element and the Quad Element . Compare the results to each other and to the beam solution to see shear locking in action. Volumetric locking in the Quad Element can be observed by increasing Poisson\u2019s ratio to 0.49. </p> <ol> <li><ol> <li></li> </ol></li> <li>#</li> <li>Coarse-mesh cantilever beam analysis. The beam is #</li> <li>modeled with only 4 elements and uses anti-symmetry. #</li> <li>#</li> <li>---&gt; Basic units used are kN and meters #</li> <li># <ol> <li><ol> <li></li> </ol></li> </ol></li> </ol> <p>wipe</p> <p>model BasicBuilder -ndm 2 -ndf 2 </p> <ol> <li>beam dimensions</li> </ol> <p> set L 24.0 set D 3.0 </p> <ol> <li>define number and size of elements</li> </ol> <p> set nElemX 4 set nElemY 1 set nElemT [expr $nElemX * $nElemY ] set sElemX [expr $L / $nElemX ] set sElemY [expr $D / $nElemY ] </p> <p> set nNodeX [expr $nElemX + 1 ] set nNodeY [expr $nElemY + 1 ] set nNodeT [expr $nNodeX * $nNodeY ] </p> <ol> <li> create the nodes</li> </ol> <p> set nid 1 set count 0.0 for {set j 1 } { $j &lt;= $nNodeY } {incr j 1 } { for {set i 1 } { $i &lt;= $nNodeX } {incr i 1 } { node $nid [expr 0.0 + $count * $sElemX ] [expr ( $j -1 )* $sElemY ] set nid [expr $nid + 1 ] set count [expr $count + 1 ] } set count 0.0 } </p> <ol> <li>boundary conditions</li> </ol> <p>fix 1 1 1 fix [expr $nElemY * $nNodeX + 1 ] 1 0 for {set k 2 } { $k &lt;= $nNodeX } {incr k 1 } { fix $k 1 0 } </p> <ol> <li>define material</li> </ol> <p> set matID 1 set E 20000 set nu 0.25 nDMaterial ElasticIsotropic $matID $E $nu </p> <ol> <li> create elements</li> </ol> <p> set thick 1.0 set b1 0.0 set b2 0.0 set count 1 for {set j 1 } { $j &lt;= $nNodeY } {incr j 1 } { for {set i 1 } { $i &lt;= $nNodeX } {incr i 1 } { if { ( $i &lt; $nNodeX ) &amp;&amp; ( $j &lt; $nNodeY ) } { set nI [expr $i +( $j -1 )* $nNodeX ] set nJ [expr $i +( $j -1 )* $nNodeX + 1 ] set nK [expr $i + $j * $nNodeX + 1 ] set nL [expr $i + $j * $nNodeX ] element SSPquad $count $nI $nJ $nK $nL $matID \"PlaneStrain\" $thick $b1 $b2 </p> <p> set count [expr $count + 1 ] } } } </p> <ol> <li> create recorders</li> </ol> <p> set step 0.1 </p> <p>recorder Node -time -file results/d1p1m1.out -dT $step -nodeRange 1 $nNodeT -dof 1 2 disp recorder Element -eleRange 1 $nElemT -time -file results/s1p1m1.out -dT $step stress recorder Element -eleRange 1 $nElemT - time -file results/e1p1m1.out -dT $step strain</p> <ol> <li> create loading</li> </ol> <p> set P -300 .0 ;</p> <p>pattern Plain 3 { Series -time { 0 10 15 } -values { 0 1 1 } -factor 1 } { load $nNodeT 0.0 [expr 0.1875 * $P ] load $nNodeX 0.0 [expr 0.3125 * $P ] </p> <p> load [expr $nNodeX + 1 ] 0.0 [expr -0 .1875 * $P ] } </p> <ol> <li> create analysis</li> </ol> <p>integrator LoadControl 0.1 numberer RCM system SparseGeneral constraints Transformation test NormDispIncr 1e-5 40 1 algorithm Newton analysis Static</p> <p>analyze 105 </p> <p>wipe","title":"SSPquad Element\n"},{"location":"contrib/modeling/element/636-ShellDKGQ/","text":"ShellDKGQ This command is used to construct a ShellDKGQ element object, which is a quadrilateral shell element based on the theory of generalized conforming element. element ShellDKGQ $eleTag $iNode $jNode $kNode $lNode $secTag eleTag unique element object tag $iNode $jNode $kNode $lNode four nodes defining element boundaries, input in clockwise or counter-clockwise order around the element. secTag tag associated with previously-defined SectionForceDeformation object. Currently can be a PlateFiberSection, a ElasticMembranePlateSection and a LayeredShell section Code Developed by : Lisha Wang, Tsinghua University, Prof. Xinzheng Lu, Tsinghua University, Linlin Xie, Tsinghua University, Prof. Song Cen, Tsinghua University and Prof. Quan Gu, Xiamen University","title":"ShellDKGQ\n"},{"location":"contrib/modeling/element/637-ShellDKGT/","text":"ShellDKGT This command is used to construct a ShellDKGT element object, which is a triangular shell element based on the theory of generalized conforming element. element ShellDKGT $eleTag $iNode $jNode $kNode $secTag eleTag unique element object tag $iNode $jNode $kNode three nodes defining element boundaries, input in clockwise or counter-clockwise order around the element. tag associated with previously-defined SectionForceDeformation object. secTag currently can be a PlateFiberSection, a ElasticMembranePlateSection and a LayeredShell section Code Developed by : Shuhao Zhang, Tsinghua University, and Prof. Xinzheng Lu, Tsinghua University","title":"ShellDKGT\n"},{"location":"contrib/modeling/element/638-ShellNL/","text":"ShellNL This command is used to construct a ShellNL element object, a lagrangian nine-noded shell element. element ShellNL $eleTag $node1 $node2 ... $node9 $secTag eleTag unique element object tag $node1 \u2026 $node9 nine nodes defining element boundaries, input is the typical, firstly four corner nodes counter-clockwise, then mid-side nodes counter-clockwise and finally the central node. secTag tag associated with previously-defined SectionForceDeformation object. Currently must be either a PlateFiberSection, or ElasticMembranePlateSection NOTE: The valid queries to a Quad element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. Examples <pre> set t 10.0 model basic -ndm 3 -ndf 6 nDMaterial ElasticIsotropic 1 200000 0.3 nDMaterial PlateFiber 2 1 section PlateFiber 3 2 $t element ShellNL 1 1 27 29 3 14 28 16 2 15 3 </pre> REFERENCES: Zienkiewicz o.c., Taylor r.l. vol. 2. The finite element method. Solid mechanics. Elsevier 2000 Code Developed by: Leopoldo Tesser, Diego A. Talledo","title":"ShellNL\n"},{"location":"contrib/modeling/element/639-ShellNLDKGQ/","text":"ShellNLDKGQ This command is used to construct a ShellNLDKGQ element object accounting for the geometric nonlinearity of large deformation using the updated Lagrangian formula, which is developed based on the ShellDKGQ element. element ShellNLDKGQ $eleTag $iNode $jNode $kNode $lNode $secTag eleTag unique element object tag $iNode $jNode $kNode $lNode four nodes defining element boundaries, input in clockwise or counter-clockwise order around the element. secTag tag associated with previously-defined SectionForceDeformation object. Currently can be a PlateFiberSection, a ElasticMembranePlateSection and a LayeredShell section. NOTE: Three examples of this element can be found on the following URL http://www.luxinzheng.net/download/OpenSEES/Examples_of_NLDKGQ_element.htm References : [1] Lu XZ, Xie LL, Guan H, Huang YL, Lu X, A shear wall element for nonlinear seismic analysis of super-tall buildings using OpenSees, Finite Elements in Analysis & Design, 2015, 98: 14-25. Code Developed by : Lisha Wang, Tsinghua University, Prof. Xinzheng Lu, Tsinghua University, Linlin Xie, Tsinghua University, Prof. Song Cen, Tsinghua University and Prof. Quan Gu, Xiamen University","title":"ShellNLDKGQ\n"},{"location":"contrib/modeling/element/640-ShellNLDKGT/","text":"ShellNLDKGT This command is used to construct a ShellNLDKGT element object accounting for the geometric nonlinearity of large deformation using the updated Lagrangian formula, which is developed based on the ShellDKGT element. element ShellNLDKGT $eleTag $iNode $jNode $kNode $secTag eleTag unique element object tag $iNode $jNode $kNode three nodes defining element boundaries, input in clockwise or counter-clockwise order around the element. tag associated with previously-defined SectionForceDeformation object secTag currently can be a PlateFiberSection, a ElasticMembranePlateSection and a LayeredShell section Code Developed by : Shuhao Zhang, Tsinghua University, and Prof. Xinzheng Lu, Tsinghua University","title":"ShellNLDKGT\n"},{"location":"contrib/modeling/element/641-Shell%20Element/","text":"Shell Element This command is used to construct a ShellMITC4 element object, which uses a bilinear isoparametric formulation in combination with a modified shear interpolation to improve thin-plate bending performance. element ShellMITC4 $eleTag $iNode $jNode $kNode $lNode $secTag eleTag unique element object tag $iNode $jNode $kNode $lNode four nodes defining element boundaries, input in counter-clockwise order around the element. secTag tag associated with previously-defined SectionForceDeformation object. Currently must be either a PlateFiberSection, or ElasticMembranePlateSection NOTE: The valid queries to a Quad element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. It is a 3D element with 6 dofs and CAN NOT be used in 2D domain. Examples <pre> set t 100.0 model basic -ndm 3 -ndf 6 nDMaterial ElasticIsotropic 1 200000 0.3 nDMaterial PlateFiber 4 1 set secArgs \u201c7\u201d section PlateFiber $secArgs 4 $t set EleType ShellMITC4 block2D $n1 $n2 1 1 $EleType $secArgs { 1 0.0 0.0 0.0 2 0.0 10 0.0 3 1000 10 0.0 4 1000 0.0 0.0 } </pre> REFERENCES: Dvorkin,Bathe, A continuum mechanics based four node shell element for general nonlinear analysis, Eng.Comput.,1,77-88,1984 Original implementation: Ed \u201cC++\u201d Love Reimplementation by: Leopoldo Tesser, Diego A. Talledo, V\u00e9ronique Le Corvec","title":"Shell Element\n"},{"location":"contrib/modeling/element/643-SimpleContact2D/","text":"SimpleContact2D This command is used to construct a SimpleContact2D element object. element SimpleContact2D $eleTag $iNode $jNode $cNode $lNode $matTag $gTol $fTol eleTag unique integer tag identifying element object $iNode $jNode retained nodes (-ndm 2 -ndf 2) cNode constrained node (-ndm 2 -ndf 2) lNode Lagrange multiplier node (-ndm 2 -ndf 2) matTag unique integer tag associated with previously-defined nDMaterial object gTol gap tolerance fTol force tolerance The SimpleContact2D element is a two-dimensional node-to-segment contact element which defines a frictional contact interface between two separate bodies. The retained nodes are the nodes which define the endpoints of a line segment on the first body, and the constrained node is a node from the second body. The Lagrange multiplier node is required to enforce the contact condition. This node should not be shared with any other element in the domain. Information on the theory behind this element can be found in, e.g. Wriggers (2002). NOTE: The SimpleContact2D element has been written to work exclusively with the ContactMaterial2D nDMaterial object. The valid recorder queries for this element are: force - returns the contact force acting on the constrained node in vector form. frictionforce - returns the frictional force acting on the constrained node in vector form. forcescalar - returns the scalar magnitudes of the normal and tangential contact forces. The SimpleContact2D elements are set to consider frictional behavior as a default, but the frictional state of the SimpleContact2D element can be changed from the input file using the setParameter command. When updating, value of 0 corresponds to the frictionless condition, and a value of 1 signifies the inclusion of friction. An example command for this update procedure is provided below The SimpleContact2D element works well in static and pseudo-static analysis situations. In transient analysis, the presence of the contact constraints can effect the stability of commonly-used time integration methods in the HHT or Newmark family (e.g., Laursen, 2002). For this reason, use of alternative time-integration methods which numerically damp spurious high frequency behavior may be required. The TRBDF2 integrator is an effective method for this purpose. The Newmark integrator can also be effective with proper selection of the gamma and beta coefficients. The trapezoidal rule, i.e., Newmark with gamma = 0.5 and beta = 0.25, is particularly prone to instability related to the contact constraints and is not recommended. EXAMPLES: SimpleContact2D element with tag 1, connectivity with nodes 1, 2, 3, and 4, material with tag 1, and gap and force tolerances of 1.0e-10. element SimpleContact2D 1 1 2 3 4 1 1.0e-10 1.0e-10 Update all of the SimpleContact2D elements with tags between 10 and 20 to consider a frictionless interface setParameter -value 0 -eleRange 10 20 friction REFERENCES: Wriggers, P. (2002). Computational Contact Mechanics. John Wiley & Sons, Ltd, West Sussex, England. Laursen, T. A. (2002). Computational Contact and Impact Mechanics. Springer-Verlag, Berlin. Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"SimpleContact2D\n"},{"location":"contrib/modeling/element/644-SimpleContact3D/","text":"SimpleContact3D This command is used to construct a SimpleContact3D element object. element SimpleContact3D $eleTag $iNode $jNode $kNode $lNode $cNode $lNode $matTag $gTol $fTol eleTag unique integer tag identifying element object $iNode $jNode $kNode $lNode retained nodes (-ndm 3 -ndf 3) cNode constrained node (-ndm 3 -ndf 3) lNode Lagrange multiplier node (-ndm 3 -ndf 3) matTag unique integer tag associated with previously-defined nDMaterial object gTol gap tolerance fTol force tolerance The SimpleContact3D element is a three-dimensional node-to-surface contact element which defines a frictional contact interface between two separate bodies. The retained nodes are the nodes which define a surface of a hexahedral element on the first body, and the constrained node is a node from the second body. The Lagrange multiplier node is required to enforce the contact condition. This node should not be shared with any other element in the domain. Information on the theory behind this element can be found in, e.g. Wriggers (2002). NOTE: The SimpleContact3D element has been written to work exclusively with the ContactMaterial3D nDMaterial object. The valid recorder queries for this element are: force - returns the contact force acting on the constrained node in vector form. frictionforce - returns the frictional force acting on the constrained node in vector form. forcescalar - returns the scalar magnitudes of the single normal and two tangential contact forces. The SimpleContact3D elements are set to consider frictional behavior as a default, but the frictional state of the SimpleContact3D element can be changed from the input file using the setParameter command. When updating, value of 0 corresponds to the frictionless condition, and a value of 1 signifies the inclusion of friction. An example command for this update procedure is provided below The SimpleContact3D element works well in static and pseudo-static analysis situations. In transient analysis, the presence of the contact constraints can effect the stability of commonly-used time integration methods in the HHT or Newmark family (e.g., Laursen, 2002). For this reason, use of alternative time-integration methods which numerically damp spurious high frequency behavior may be required. The TRBDF2 integrator is an effective method for this purpose. The Newmark integrator can also be effective with proper selection of the gamma and beta coefficients. The trapezoidal rule, i.e., Newmark with gamma = 0.5 and beta = 0.25, is particularly prone to instability related to the contact constraints and is not recommended. EXAMPLE: SimpleContact3D element with tag 1, connectivity with nodes 1, 2, 3, 4, 5, 6, 7, and 8, material with tag 1, and gap and force tolerances of 1.0e-10. element SimpleContact3D 1 1 2 3 4 5 6 7 8 1 1.0e-10 1.0e-10 Update all of the SimpleContact3D elements with tags between 10 and 20 to consider a frictionless interface setParameter -value 0 -eleRange 10 20 friction REFERENCES: Wriggers, P. (2002). Computational Contact Mechanics. John Wiley & Sons, Ltd, West Sussex, England. Laursen, T. A. (2002). Computational Contact and Impact Mechanics. Springer-Verlag, Berlin. Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington","title":"SimpleContact3D\n"},{"location":"contrib/modeling/element/650-Single%20Concave%20Friction%20Pendulum%20Bearing%20Element/","text":"Single Concave Friction Pendulum Bearing Element This command is used to construct a singleFPBearing element object, which is defined by two nodes. The iNode represents the concave sliding surface and the jNode represents the articulated slider. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) friction properties (with post-yield stiffening due to the concave sliding surface) for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. To capture the uplift behavior of the bearing, the user-specified UniaxialMaterial in the axial direction is modified for no-tension behavior. P-Delta moments are entirely transferred to the concave sliding surface (iNode). It is important to note that rotations of the concave sliding surface (rotations at the iNode) affect the shear behavior of the bearing. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element singleFPBearing $eleTag $iNode $jNode $frnMdlTag $R $h $uy -P $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; For a three-dimensional problem: element singleFPBearing $eleTag $iNode $jNode $frnMdlTag $R $h $uy -P $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; eleTag unique element object tag $iNode $jNode end nodes frnMdlTag tag associated with previously-defined FrictionModel R radius of concave sliding surface h height of articulated slider uy yield displacement -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) m element mass (optional, default = 0.0) maxIter maximum number of iterations to undertake to satisfy element equilibrium (optional, default = 20) tol convergence tolerance to satisfy element equilibrium (optional, default = 1E-8) NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. The valid queries to a single concave friction pendulum bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples element singleFPBearing 1 1 2 1 37.28 2.60 0.01 -P 1 -Mz 2 -orient 0 1 0 -1 0 0; # for a 2D single concave friction pendulum bearing element singleFPBearing 1 1 2 1 37.28 2.60 0.01 -P 1 -T 2 -My 3 -Mz 4 -orient 0 0 1 -1 0 0; # for a 3D single concave friction pendulum bearing Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Single Concave Friction Pendulum Bearing Element\n"},{"location":"contrib/modeling/element/651-Single%20Friction%20Pendulum%20Bearing%20Element/","text":"Single Friction Pendulum Bearing Element This command is used to construct a singleFPBearing element object, which is defined by two nodes. The iNode represents the concave sliding surface and the jNode represents the articulated slider. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) friction properties (with post-yield stiffening due to the concave sliding surface) for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. To capture the uplift behavior of the bearing, the user-specified UniaxialMaterial in the axial direction is modified for no-tension behavior. By default (sDratio = 0.0) P-Delta moments are entirely transferred to the concave sliding surface (iNode). It is important to note that rotations of the concave sliding surface (rotations at the iNode) affect the shear behavior of the bearing. To avoid the introduction of artificial viscous damping in the isolation system (sometimes referred to as \u201cdamping leakage in the isolation system\u201d), the bearing element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. For a two-dimensional problem: element singleFPBearing $eleTag $iNode $jNode $frnMdlTag $Reff $kInit -P $matTag -Mz $matTag &lt;-orient $x1 $x2 $x3 $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; For a three-dimensional problem: element singleFPBearing $eleTag $iNode $jNode $frnMdlTag $Reff $kInit -P $matTag -T $matTag -My $matTag -Mz $matTag &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-shearDist $sDratio &gt; &lt;-doRayleigh&gt; &lt;-mass $m &gt; &lt;-iter $maxIter $tol &gt; eleTag unique element object tag $iNode $jNode end nodes frnMdlTag tag associated with previously-defined FrictionModel Reff effective radius of concave sliding surface kInit initial elastic stiffness in local shear direction -P $matTag tag associated with previously-defined UniaxialMaterial in axial direction -T $matTag tag associated with previously-defined UniaxialMaterial in torsional direction -My $matTag tag associated with previously-defined UniaxialMaterial in moment direction around local y-axis -Mz \\(matTag</strong></p></td> <td><p>tag associated with previously-defined UniaxialMaterial in moment direction around local z-axis</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) sDratio shear distance from iNode as a fraction of the element length (optional, default = 0.0) -doRayleigh to include Rayleigh damping from the bearing (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) maxIter maximum number of iterations to undertake to satisfy element equilibrium (optional, default = 20) tol convergence tolerance to satisfy element equilibrium (optional, default = 1E-8) SingleFPBearingFig01.png NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. Because the friction force is affected by both the axial force and the slip rate, the element can be sensitive numerically. It is recommended that for dynamic analysis a smaller time step is being used than what would be used for a comparable structure with no isolators. If there is uplift (and therefore impact) in the bearing element, it can be helpful to use an integration method that provides numerical damping. Providing some viscous damping for the material that is assigned to the axial direction can also be helpful in dissipating impact energy. The valid queries to a single concave friction pendulum bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples For a 2D single concave friction pendulum bearing: element singleFPBearing 1 1 2 1 34.68 250.0 -P 1 -Mz 2 -orient 0 1 0 -1 0 0; TestFPS2d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestFPS2d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestFPS2d_2.tcl models an isolated one story stick and the bearing element has finite length. TestFPS2d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestFPS2d_4.tcl models an isolated five story one bay building and the bearing element has finite length. For a 3D single concave friction pendulum bearing: element singleFPBearing 1 1 2 1 34.68 250.0 -P 1 -T 2 -My 3 -Mz 4 -orient 0 0 1 -1 0 0; TestFPS3d_0.tcl models a rigid isolated mass and the bearing element has zero length. It also tests the different friction models. TestFPS3d_1.tcl models a rigid isolated mass and the bearing element has finite length. TestFPS3d_2.tcl models an isolated one story stick and the bearing element has finite length. TestFPS3d_3.tcl models an isolated one story one bay building and the bearing element has finite length. TestFPS3d_4.tcl models an isolated five story one bay building and the bearing element has finite length. Download the GroundMotions.zip as a compressed file or download AllFPSExamples.zip as a compressed file. Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Single Friction Pendulum Bearing Element\n"},{"location":"contrib/modeling/element/66-Brick%20u-p%20Element/","text":"Brick u-p Element BrickUP is an 8-node hexahedral linear isoparametric element. Each node has 4 degrees-of-freedom (DOF): DOFs 1 to 3 for solid displacement (u) and DOF 4 for fluid pressure (p). This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a BrickUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element brickUP $eleTag $Node1 $Node2 $Node3 $Node4 $Node5 $Node6 $Node7 $Node8 $matTag $bulk $fmass $PermX $PermY \\(PermZ &lt;\\) bX=0 $bY=0 \\(bZ=0&gt;</strong></p></td> </tr> </tbody> </table> <p><a href=\"image:Brick.png\" title=\"wikilink\">image:Brick.png</a></p> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Node1,\u2026 \\(Node8</strong></p></td> <td><p>Eight element node (previously defined) numbers (see figure above for order of numbering).</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) permX, $permY, \\(permZ</strong></p></td> <td><p>Permeability coefficients in x, y, and z directions respectively.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) bX, $bY, $bZ Optional gravity acceleration components in x, y, and z directions directions respectively (defaults are 0.0) NOTE: This element requires 4 degrees-of-freedom (ndf=4), the 4th degree-of-freedom being pore pressure. The Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 4 vel The valid queries to a BrickUP element when creating an ElementRecorder are \u2018force\u2019, and \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. TYPICAL RANGE OF PERMEABILITY COEFFICIENT (cm/s) Gravel Sand Silty Sand Silt Clay >1.0x10-1 1.0x10-3 ~ 1.0x10-1 1.0x10-5 ~ 1.0x10-3 1.0x10-7 ~ 1.0x10-5 <1.0x10-7 Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"Brick u-p Element\n"},{"location":"contrib/modeling/element/662-Standard%20Brick%20Element/","text":"Standard Brick Element This element is used to construct an eight-node brick element object, which uses a trilinear isoparametric formulation. element stdBrick $eleTag $node1 $node2 $node3 $node4 $node5 $node6 $node7 $node8 $matTag &lt; $b1 $b2 $b3 &gt; eleTag unique element object tag $node1 \\(node2</strong></p> <p><strong>\\) node3 \\(node4</strong></p> <p><strong>\\) node5 \\(node6</strong></p> <p><strong>\\) node7 \\(node8</strong></p></td> <td><p>eight nodes defining element boundaries, input order is shown in the figure.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag of nDMaterial</p></td> </tr> <tr class=\"even\"> <td><p><strong>'\\) b1 $b2 $b3 body forces in global x,y,z directions Brick.gif NOTE: The valid queries to a Brick element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 (\u2018strains\u2019 version > 2.2.0) and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the isoparametric domain. This element can only be defined in -ndm 3 -ndf 3 Examples REFERENCES: Code Developed by: Edward Love, Sandia National Laboratories","title":"Standard Brick Element\n"},{"location":"contrib/modeling/element/673-SurfaceLoad%20Element/","text":"SurfaceLoad Element This command is used to construct a SurfaceLoad element object. element SurfaceLoad $eleTag $iNode $jNode $kNode $lNode $p eleTag unique integer tag identifying element object $iNode $jNode $kNode $lNode the four nodes defining the element, input in counterclockwise order (-ndm 3 -ndf 3) p applied pressure loading normal to the surface, outward is positive, inward is negative The SurfaceLoad element is a four-node element which can be used to apply surface pressure loading to 3D brick elements. The SurfaceLoad element applies energetically-conjugate forces corresponding to the input scalar pressure to the nodes associated with the element. As these nodes are shared with a 3D brick element, the appropriate nodal loads are therefore applied to the brick. NOTES: There are no valid ElementalRecorder queries for the SurfaceLoad element. Its sole purpose is to apply nodal forces to the adjacent brick element. The pressure loading from the SurfaceLoad element can be applied in a load pattern. See the analysis example below. EXAMPLES: SurfaceLoad element definition with element tag 1, nodes 1, 2, 3, and 4, and pressure of -10.0 element SurfaceLoad 1 1 2 3 4 -10.0 Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington EXAMPLE ANALYSIS: The example input file below involves applying a compressive 0.1 kPa loading to a four-element mesh of brick elements. The applied loading is increased linearly over the first 0.1 seconds of pseudo-time, then held constant. wipe</p> <p>model BasicBuilder -ndm 3 -ndf 3 </p> <ol> <li>nodes</li> </ol> <p>node 1 0.0 0.0 6.0 node 2 3.0 0.0 6.0 node 3 6.0 0.0 6.0 node 4 0.0 0.0 3.0 node 5 3.0 0.0 3.0 node 6 6.0 0.0 3.0 node 7 0.0 0.0 0.0 node 8 3.0 0.0 0.0 node 9 6.0 0.0 0.0 node 10 0.0 3.0 6.0 node 11 3.0 3.0 6.0 node 12 6.0 3.0 6.0 node 13 0.0 3.0 3.0 node 14 3.0 3.0 3.0 node 15 6.0 3.0 3.0 node 16 0.0 3.0 0.0 node 17 3.0 3.0 0.0 node 18 6.0 3.0 0.0 </p> <ol> <li>boundary conditions</li> </ol> <p>fix 1 1 1 1 fix 2 1 1 1 fix 3 1 1 1 fix 4 1 1 1 fix 5 1 1 1 fix 6 1 1 1 fix 7 1 1 1 fix 8 1 1 1 fix 9 1 1 1 </p> <ol> <li>material</li> </ol> <p>nDMaterial ElasticIsotropic 1 25000.0 0.0 </p> <ol> <li>brick elements</li> </ol> <p>element SSPbrick 1 1 2 5 4 10 11 14 13 1 element SSPbrick 2 2 3 6 5 11 12 15 14 1 element SSPbrick 3 4 5 8 7 13 14 17 16 1 element SSPbrick 4 5 6 9 8 14 15 18 17 1 </p> <ol> <li>surface load elements</li> </ol> <p>element SurfaceLoad 5 10 11 14 13 -0 .1 element SurfaceLoad 6 11 12 15 14 -0 .1 element SurfaceLoad 7 13 14 17 16 -0 .1 element SurfaceLoad 8 14 15 18 17 -0 .1 </p> <ol> <li>recorders</li> </ol> <p>recorder Node -file displacement.out -time -nodeRange 1 18 -dof 2 disp recorder Node -file reactions.out -time -nodeRange 1 18 -dof 2 reaction recorder Element -file stress.out -time -eleRange 1 4 stress</p> <ol> <li> load pattern</li> </ol> <p>pattern Plain 1 { Series -time { 0 0.1 10000 } -values { 0 1 1 } -factor 1 } { eleLoad -ele 5 -type -surfaceLoad eleLoad -ele 6 -type -surfaceLoad eleLoad -ele 7 -type -surfaceLoad eleLoad -ele 8 -type -surfaceLoad } </p> <ol> <li>analysis</li> </ol> <p>constraints Transformation test NormDispIncr 1e-5 50 1 algorithm Newton numberer Plain system SparseSPD integrator LoadControl 0.01 analysis Static</p> <p>analyze 105 </p> <p>wipe","title":"SurfaceLoad Element\n"},{"location":"contrib/modeling/element/710-Tri31%20Element/","text":"Tri31 Element This command is used to construct a constant strain triangular element (Tri31) which uses three nodes and one integration points. element tri31 $eleTag $iNode $jNode $kNode $thick $type $matTag &lt; $pressure $rho $b1 $b2 &gt; eleTag unique element object tag $iNode $jNode \\(kNode</strong></p></td> <td><p>three nodes defining element boundaries, input in counter-clockwise order around the element.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">thick</code></td> <td><p>element thickness</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">type</code></td> <td><p>string representing material behavior. The type parameter can be either \"PlaneStrain\" or \"PlaneStress.\"</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag of nDMaterial</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">pressure</code></td> <td><p>surface pressure (optional, default = 0.0)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">rho</code></td> <td><p>element mass density (per unit volume) from which a lumped element mass matrix is computed (optional, default=0.0; if rho=0.0, then materials are queried for mass density)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) b1 $b2 constant body forces defined in the domain (optional, default=0.0) NOTE: Consistent nodal loads are computed from the pressure and body forces. The valid queries to a Tri31 element when creating an ElementRecorder object are \u2018forces\u2019, \u2018stresses,\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum refers to the material object at the integration point corresponding to the node numbers in the domain. Code Developed by: Roozbeh G. Mikola , UC Berkeley and N. Sitar , UC Berkeley","title":"Tri31 Element\n"},{"location":"contrib/modeling/element/714-Triple%20Friction%20Pendulum%20Bearing%20Element/","text":"Triple Friction Pendulum Bearing Element This command is used to construct a Triple Friction Pendulum Bearing element object, which is defined by two nodes. The element can have zero length or the appropriate bearing height. The bearing has unidirectional (2D) or coupled (3D) friction properties (with post-yield stiffening due to the concave sliding surface) for the shear deformations, and force-deformation behaviors defined by UniaxialMaterials in the remaining two (2D) or four (3D) directions. To capture the uplift behavior of the bearing, the user-specified UniaxialMaterial in the axial direction is modified for no-tension behavior. P-Delta moments are entirely transferred to the concave sliding surface (iNode). It is important to note that rotations of the concave sliding surface (rotations at the iNode) affect the shear behavior of the bearing. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. TFP_backbone.gif element TFP $eleTag $iNode $jNode $R1 $R2 $R3 $R4 $D1 $D2 $D3 $D4 $d1 $d2 $d3 $d4 $mu1 $mu2 $mu3 $mu4 $h1 $h2 $h3 $h4 $H0 $colLoad &lt; $K &gt; eleTag unique element object tag $iNode $jNode end nodes R1 Radius of inner bottom sliding surface R2 Radius of inner top sliding surface R3 Radius of outer bottom sliding surface R4 Radius of outer top sliding surface D1 Diameter of inner bottom sliding surface D2 Diameter of inner top sliding surface D3 Diameter of outer bottom sliding surface D4 Diameter of outer top sliding surface d1 diameter of inner slider d2 diameter of inner slider d3 diameter of outer bottom slider d4 diameter of outer top slider mu1 friction coefficient of inner bottom sliding surface mu2 friction coefficient of inner top sliding surface mu3 friction coefficient of outer bottom sliding surface mu4 friction coefficient of outer top sliding surface h1 height from inner bottom sliding surface to center of bearing h2 height from inner top sliding surface to center of bearing h3 height from outer bottom sliding surface to center of bearing h4 height from inner top sliding surface to center of bearing H0 total height of bearing colLoad initial axial load on bearing (only used for first time step then load come from model) K optional, stiffness of spring in vertical dirn (dof 2 if ndm= 2, dof 3 if ndm = 3) (default=1.0e15) TFPwH0.gif TFP_displaced.gif NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. The valid queries to a triple friction pendulum bearing element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019, \u2018relativeDisp\u2019, \u2018plasticDisp\u2019, and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. relativeDisp returns relative displacements between the sliding components in the bearing. Relative displacements is the rotation (as shown in the figure above) multiplied by the respective radii. For each time step it returns 8 values; 4 for each horizontal direction. plasticDisp returns plastic displacements associated with relativeDisp Examples element TFP 1 1 2 12.0 12.0 88.0 88.0 12.0 12.0 44.0 44.0 8.0 8.0 12.5 12.5 0.02 0.02 0.09 0.12 3.0 3.0 4.5 4.5 12.5 45.0; REFERENCE: Becker, TC, Mahin, SA. \u201cExperimental and analytical study of the bi-directional behavior of the triple friction pendulum isolator,\u201d Earthquake Engineering and Structural Dynamics. (accepted for publication 03/11) read the paper Code Developed by: Tracy Becker, University of California, Berkeley.","title":"Triple Friction Pendulum Bearing Element\n"},{"location":"contrib/modeling/element/715-Triple%20Friction%20Pendulum%20Element/","text":"Triple Friction Pendulum Element This command is used to construct a Triple Friction Pendulum Bearing (TPB) (Figure 1) element object. The element is a 3-dimensional element with variable friction coefficient models [1] [2]. The element accounts for the vertical-horizontal coupling and the bidirectional coupling in horizontal behavior. The friction coefficient model is a general model that accounts for the variation of friction coefficient on velocity and vertical force. Other simplified friction coefficient models such as vertical-force-independent friction coefficient, velocity-independent friction coefficient and constant friction coefficient can also be defined. The element can also be used for modeling single friction pendulum bearings or double friction pendulum bearings by simplifying the general backbone curve of the TPB. TPB_Nhan_Fig1.jpg The horizontal normalized behavior of the element is an extension of the unidirectional behavior proposed by Fenz and Constantinou [3] and Morgan and Mahin [4]. The envelope normalized backbone curve for unidirectional behavior is in Figure 2 where effective radii are calculated from L_i=R_i- h_i, based on the bearing geometry in Figure 1. Displacements u_i^* and normalized forces f_i^* are evaluated according to [2], [3] or [4]. The Excel file for generating a backbone curve of a TPB can be downloaded here: Media:TPB_Nhan_BackboneCurve.xls TPB_Nhan_Fig2.jpg Overturning moment and torsion due to the eccentricity of internal forces are equally distributed to the 2 nodes of the element. In the vertical direction, the element is multi-linear elastic with different stiffnesses k_vc and k_vt in compression and tension, respectively. Even though a TPB has no resistance in tension, a small nonzero stiffness should be provided in tension for stability of the numerical procedure. The reasonable vertical stiffness in tension depends on the stiffness of the superstructure, but a value between 10 N/m to 100 N/m should work well in most cases. Very small ratio of k_vt/k_vc may cause the convergence difficulty when the superstructure is uplifted. element TripleFrictionPendulum $eleTag $iNode $jNode $frnTag1 $frnTag2 $frnTag3 $vertMatTag $rotZMatTag $rotXMatTag $rotYMatTag $L1 $L2 $L3 $d1 $d2 $d3 $W $uy $kvt $minFv $tol eleTag = unique element object tag $iNode \\(jNode</strong></p></td> <td><p>= end nodes</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) frnTag1, $frnTag2, \\(frnTag2</strong></p></td> <td><p>= tags associated with previously-defined <a href=\"http://opensees.berkeley.edu/wiki/index.php/FrictionModel_Command\">FrictionModels</a> at the three sliding interfaces</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">vertMatTag</code></td> <td><p>= Pre-defined material tag for COMPRESSION behavior of the bearing</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) rotZMatTag, $rotXMatTag, \\(rotYMatTag</strong></p></td> <td><p>= Pre-defined material tags for rotational behavior about 3-axis, 1-axis and 2-axis, respectively.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) L1, $L2, \\(L3</strong></p></td> <td><p>= effective radii. Li = R_i - h_i (see Figure 1)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) d1, $d2, \\(d3</strong></p></td> <td><p>= displacement limits of pendulums (Figure 1). Displacement limit of the bearing is 2\\) d1+ \\(d2+\\) d3+ \\(L1.\\) d3/ \\(L3-\\) L1. \\(d2/\\) L2 W = axial force used for the first trial of the first analysis step. uy = lateral displacement where sliding of the bearing starts. Recommended value = 0.25 to 1 mm. A smaller value may cause convergence problem. kvt = Tension stiffness k_vt of the bearing. $minFv (>=0) = minimum vertical compression force in the bearing used for computing the horizontal tangent stiffness matrix from the normalized tangent stiffness matrix of the element. $minFv is substituted for the actual compressive force when it is less than $minFv, and prevents the element from using a negative stiffness matrix in the horizontal direction when uplift occurs. The vertical nodal force returned to nodes is always computed from $kvc (or $kvt) and vertical deformation, and thus is not affected by $minFv. tol = relative tolerance for checking the convergence of the element. Recommended value = 1.e-10 to 1.e-3. SPECIAL CASES: Vertical-horizontal uncoupled bearing: Restrain vertical displacement of the 2 nodes and set $minFv = static vertical reaction of the bearing. Neglecting rotational stiffness: Rotational stiffness of the bearing can be neglected by defining a very small value for the $rotXMatTag, $rotYMatTag and \\(rotZMatTag. However, using a too small number may cause a numerical convergence problem. </dd> </dl> </dd> </dl> <p><strong>NOTES:</strong></p> <p>The current element requires 6 degree of freedoms at each node and defines the local coordinate system to be the same as the global coordinate system, where the vertical axis must be 3.</p> <p>Since the element accounts for the vertical-horizontal coupling behavior of TPBs, the time step size in analysis of vertically stiff structures should be small enough so that the high frequency components in responses can be captured.</p> <p>Rayleigh damping is automatically included when using Rayleigh command.</p> <p>The height of the bearing (for computing overturning moment from horizontal force) is computed from the vertical distance between the two end nodes.</p> <hr /> <p><strong>EXAMPLE:</strong></p> <p>frictionModel VelNormalFrcDep 1 [expr 0.012/pow(\\) W,0.8-1.0)] 0.8 [expr 0.018/pow( \\(W,0.7-1.0)] 0.7 25.0 0.0 0.0 3.0</p> <p>frictionModel VelNormalFrcDep 2 [expr 0.052/pow(\\) W,0.8-1.0)] 0.8 [expr 0.075/pow( \\(W,0.7-1.0)] 0.7 25.0 0.0 0.0 3.0</p> <p>frictionModel VelNormalFrcDep 3 [expr 0.12/pow(\\) W,0.8-1.0)] 0.8 [expr 0.16/pow($W,0.7-1.0)] 0.7 25.0 0.0 0.0 3.0 uniaxialMaterial Elastic 1 1.e6 uniaxialMaterial Elastic 2 100.; uniaxialMaterial Elastic 3 100.; uniaxialMaterial Elastic 4 10.; element TripleFrictionPendulum 1 1 2 1 2 3 1 4 2 3 0.36 1.25 1.25 0.1 0.2 0.2 1000.0 0.0005 1.0 0.1 1.E-5; REFERENCES: [1] Dao ND, Ryan KL, Sato E, Sasaki T. Predicting the displacement of triple pendulum\u2122 bearings in a full-scale shaking experiment using a three-dimensional element. Earthquake Engineering and Structural Dynamics, 2013. [2] Dao ND. Seismic Response of a Full-scale 5-story Steel Frame Building Isolated by Triple Pendulum Bearings under 3D Excitations. Dissertation, University of Nevada - Reno, 2012. [3] Fenz DM, Constantinou MC. Spherical sliding isolation bearings with adaptive behavior: Theory. Earthquake Engineering and Structural Dynamics 2008; 37(2):163-183. [4] Morgan TA, Mahin SA. The use of innovative base isolation systems to achieve complex seismic performance objectives. PEER-2011/06 2011. Code Developed by: Nhan D. Dao, University of Nevada - Reno. E-mail: nhan.unr@gmail.com . APPLICATION EXAMPLES Download these 3 ground motion files and change the extension \u201c.tcl\u201d to \u201c.ATH\u201d for EXAMPLES 2 to 7: Media:TCU065-E.tcl , Media:TCU065-N.tcl , Media:TCU065-V.tcl EXAMPLE 1 : Unidirectional static pushover of a TPB element with constant friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_StaticCyclicPushover.tcl Results: TPB_Nhan_Ex1a.png EXAMPLE 2 : Unidirectional dynamic seismic analysis of a single mass supported by a TPB element with constant friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_1DDynamics_ConstFriction.tcl Results: TPB_Nhan_Ex2_1Disp.png TPB_Nhan_Ex2_2DispTrace.png TPB_Nhan_Ex2_3Reaction.png TPB_Nhan_Ex2_4Loop.png EXAMPLE 3 : Unidirectional dynamic seismic analysis of a single mass supported by a TPB element with variable friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_1DDynamics_VariableFriction.tcl Results: TPB_Nhan_Ex3_1Disp.png TPB_Nhan_Ex3_2DispTrace.png TPB_Nhan_Ex3_3Reaction.png TPB_Nhan_Ex3_4Loop.png EXAMPLE 4 : Two-dimensional dynamic seismic analysis of a single mass supported by a TPB element with constant friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_2DDynamic_ConstFriction.tcl Results: TPB_Nhan_Ex4_1Disp.png TPB_Nhan_Ex4_2DispTrace.png TPB_Nhan_Ex4_3aReaction.png TPB_Nhan_Ex4_4Loop.png EXAMPLE 5 : Two-dimensional dynamic seismic analysis of a single mass supported by a TPB element with variable friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_2DDynamic_VariableFriction.tcl Results: TPB_Nhan_Ex5_1Disp.png TPB_Nhan_Ex5_2Trace.png TPB_Nhan_Ex5_3Reaction.png TPB_Nhan_Ex5_4aLoop.png EXAMPLE 6 : Three-dimensional dynamic seismic analysis of a single mass supported by a TPB element with constant friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_3DDynamic_ConstFriction.tcl Results: TPB_Nhan_Ex6_1Disp.png TPB_Nhan_Ex6_2DispTrace.png TPB_Nhan_Ex6_3Reaction.png TPB_Nhan_Ex6_4Loop.png EXAMPLE 7 : Three-dimensional dynamic seismic analysis of a single mass supported by a TPB element with variable friction coefficients. Tcl code: Media:CheckingTripleFrictionPendulum_3DDynamic_VariableFriction.tcl Results: TPB_Nhan_Ex7_1Disp.png TPB_Nhan_Ex7_2DispTrace.png TPB_Nhan_Ex7_3Reaction.png TPB_Nhan_Ex7_4Loop.png","title":"Triple Friction Pendulum Element\n"},{"location":"contrib/modeling/element/716-Truss2%20Element/","text":"Truss2 Element This command is used to construct a Truss2 or CorotTruss2 element object, a biaxial truss element designed to be used in conjunction with the ConcretewBeta material for accounting for biaxial effects in a uniaxial element. Truss: element Truss2 $eleTag $iNode $jNode $mGNode $nGNode $A $matTag &lt;-rho $rho &gt; &lt;-rayleigh $rflag &gt; Corotational Truss: element CorotTruss2 $eleTag $iNode $jNode $mGNode $nGNode $A $matTag &lt;-rho $rho &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes of the truss element</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) mGNode $nGNode end nodes for the zero-stiffness gauge element A cross-sectional area of truss element matTag tag of material used (see Note 1) Optional: rho mass per unit length, as in the Truss and CorotTruss Elements (default = 0.0) rFlag flag for Rayleigh damping, as in the Truss Element (default = 0; see Note 2) NOTES: If the material used does not use biaxial effects, the element will behave like the uniaxial counterpart ( Truss or CorotTruss ). For the ConcretewBeta material, the normal strain will be passed to the material to be used in calculation of the material response. Consistent with the implementation of the Truss element, the Truss2 element does not include Rayleigh damping by default. Rayleigh damping can be included by using the -rayleigh option with rFlag = 1. However, like the CorotTruss element, the CorotTruss2 element includes the Rayleigh damping by default so the -rayleigh option is not available to the CorotTruss2 element. At this time, there is no trussSection equivalent implementation of these biaxial trusses. Implementation thumb|upright=1.5|Equation 1. The above figure shows the layout of the truss and zero-stiffness gauge elements that make up the Truss2 Element object. The truss element part behaves identically to the Truss Element object (or the CorotTruss Element object for the case of CorotTruss2). The zero-stiffness gauge element is used to measure the strain in the direction of the gauge. The strain in the direction normal to the truss element is described by Equation 1, where &epsilon;<sub>truss</sub> is the strain calculated in the truss element, &epsilon;<sub>gauge</sub> is the strain calculated in the gauge element, and &theta;<sub>g</sub> is the angle between the truss and gauge elements. It is suggested to make &theta;<sub>g</sub> as close to 90&deg; as possible. thumb|center|upright=2.5|alt=Truss2 Figure 1 |Figure 1. Truss2 truss and gauge element layout based on input node values. References Lu, Y., and Panagiotou, M. (2013). \u201cThree-Dimensional Nonlinear Cyclic Beam-Truss Model for Reinforced Concrete Non-Planar Walls.\u201d Journal of Structural Engineering, published online. Panagiotou, M., Restrepo, J.I., Schoettler, M., and Kim G. (2012). \u201cNonlinear cyclic truss model for reinforced concrete walls.\u201d ACI Structural Journal, 109(2), 205-214. Code Developed by: Yuan Lu, UC Berkeley and Marios Panagiotou, UC Berkeley","title":"Truss2 Element\n"},{"location":"contrib/modeling/element/717-Truss%20Element/","text":"Truss Element This command is used to construct a truss element object. There are two ways to construct a truss element object: One way is to specify an area and a UniaxialMaterial identifier: element truss $eleTag $iNode $jNode $A $matTag &lt;-rho $rho &gt; &lt;-cMass $cFlag &gt; &lt;-doRayleigh $rFlag &gt; the other is to specify a Section identifier: element trussSection $eleTag $iNode $jNode $secTag &lt;-rho $rho &gt; &lt;-cMass $cFlag &gt; &lt;-doRayleigh $rFlag &gt; eleTag unique element object tag $iNode $jNode end nodes A cross-sectional area of element matTag tag associated with previously-defined UniaxialMaterial secTag tag associated with previously-defined Section rho mass per unit length, optional, default = 0.0 cFlag consistent mass flag, optional, default = 0 cFlag = 0 lumped mass matrix (default) cFlag = 1 consistent mass matrix rFlag Rayleigh damping flag, optional, default = 0 rFlag = 0 NO RAYLEIGH DAMPING (default) rFlag = 1 include Rayleigh damping NOTE: The truss element DOES NOT include geometric nonlinearities, even when used with beam-columns utilizing P-Delta or Corotational transformations. When constructed with a UniaxialMaterial object, the truss element considers strain-rate effects, and is thus suitable for use as a damping element. The valid queries to a truss element when creating an ElementRecorder object are \u2018axialForce,\u2019 \u2018forces,\u2019 \u2018localForce\u2019, deformations,\u2019 \u2018material matArg1 matArg2\u2026,\u2019 \u2018section sectArg1 sectArg2\u2026\u2019 There will be more queries after the interface for the methods involved have been developed further. For backward compatibility the command \u2019element truss $eleTag $iNode $jNode $secTag will still work and produce a TrussSection element. There was an inconsistency in the way damping was treated between element types before version 2.2.0. Before 2.2.0, a Truss DID NOT INCLUDE Rayleigh damping, a TrussSection did. By default they both DO NOT now include Rayleigh damping by default. Examples element truss 1 2 4 5.5 9; # truss element with tag 1 added between nodes 2 and 4 with area 5.5 that uses material 9 Code Developed by: fmk","title":"Truss Element\n"},{"location":"contrib/modeling/element/720-Twenty%20Eight%20Node%20Brick%20u-p%20Element/","text":"Twenty Eight Node Brick u-p Element Twenty_Eight_Node_BrickUP is a 20-node hexahedral isoparametric element. The eight corner nodes have 4 degrees-of-freedom (DOF) each: DOFs 1 to 3 for solid displacement (u) and DOF 4 for fluid pressure (p). The other nodes have 3 DOFs each for solid displacement. This element is implemented for simulating dynamic response of solid-fluid fully coupled material, based on Biot\u2019s theory of porous medium. Please click here for examples. OUTPUT INTERFACE: Pore pressure can be recorded at an element node using OpenSees Node Recorder: recorder Node <-file \\(fileName&gt; &lt;-time&gt; &lt;-node (\\) nod1 $nod2 \u2026)> -dof 3 vel See OpenSees command manual (McKenna and Fenves 2001) for nodal displacement, velocity, or acceleration recorders. The valid queries to a Twenty_Eight_Node_BrickUP element when creating an ElementRecorder are \u2018force\u2019, \u2018stiffness\u2019, or \u2018material matNum matArg1 matArg2 \u2026\u2019, where matNum represents the material object at the corresponding integration point. element 20_8_BrickUP $eleTag $Node1 \u2026 $Node20 $matTag $bulk $fmass $PermX $PermY \\(PermZ &lt;\\) bX=0 $bY=0 \\(bZ=0&gt;</strong></p></td> </tr> </tbody> </table> <figure> <img src=\"/OpenSeesRT/contrib/static/Elem20_8.png\" title=\"Elem20_8.png\" alt=\"Elem20_8.png\" /> <figcaption aria-hidden=\"true\">Elem20_8.png</figcaption> </figure> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>A positive integer uniquely identifying the element among all elements</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Node1,\u2026 \\(Node20</strong></p></td> <td><p>20 element node (previously defined) numbers (see figure above for order of numbering).</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Tag of an NDMaterial object (previously defined) of which the element is composed</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">bulk</code></td> <td><p>Combined undrained bulk modulus B&lt;sub&gt;c&lt;/sub&gt; relating changes in pore pressure and volumetric strain, may be approximated by:</p> <p>B&lt;sub&gt;c&lt;/sub&gt; &amp;asymp; B&lt;sub&gt;f&lt;/sub&gt;/n</p> <p>where B&lt;sub&gt;f&lt;/sub&gt; is the bulk modulus of fluid phase (2.2x10&lt;sup&gt;6&lt;/sup&gt; kPa (or 3.191x10&lt;sup&gt;5&lt;/sup&gt; psi) for water), and n the initial porosity.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fmass</code></td> <td><p>Fluid mass density</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) permX, $permY, \\(permZ</strong></p></td> <td><p>Permeability coefficients in x, y, and z directions respectively.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) bX, $bY, $bZ Optional gravity acceleration components in x, y, and z directions directions respectively (defaults are 0.0) Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"Twenty Eight Node Brick u-p Element\n"},{"location":"contrib/modeling/element/721-Two%20Node%20Link%20Element/","text":"Two Node Link Element This command is used to construct a twoNodeLink element object, which is defined by two nodes. The element can have zero or non-zero length. This element can have 1 to 6 degrees of freedom, where only the transverse and rotational degrees of freedom are coupled as long as the element has non-zero length. In addition, if the element length is larger than zero, the user can optionally specify how the P-Delta moments around the local x- and y-axis are distributed among a moment at node i, a moment at node j, and a shear couple. The sum of these three ratios is always equal to 1. In addition the shear center can be specified as a fraction of the element length from the iNode. The element does not contribute to the Rayleigh damping by default. If the element has non-zero length, the local x-axis is determined from the nodal geometry unless the optional x-axis vector is specified in which case the nodal geometry is ignored and the user-defined orientation is utilized. It is important to recognize that if this element has zero length, it does not consider the geometry as given by the nodal coordinates, but utilizes the user-defined orientation vectors to determine the directions of the springs. element twoNodeLink $eleTag $iNode $jNode -mat $matTags -dir \\(dirs &lt;-orient &lt;\\) x1 $x2 $x3> $y1 $y2 $y3> <-pDelta (4 $Mratio)> <-shearDist (2 $sDratios)> <-doRayleigh> <-mass \\(m&gt;</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>unique element object tag</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTags</code></td> <td><p>tags associated with previously-defined UniaxialMaterial objects</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">dirs</code></td> <td><p>material directions:</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p><em>2D-case</em>: 1,2 - translations along local x,y axes; 3 - rotation about local z axis</p></td> </tr> <tr class=\"even\"> <td></td> <td><p><em>3D-case</em>: 1,2,3 - translations along local x,y,z axes; 4,5,6 - rotations about local x,y,z axes</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) y1 $y2 $y3 vector components in global coordinates defining local y-axis (optional) Mratios P-Delta moment contribution ratios, size of ratio vector is 2 for 2D-case and 4 for 3D-case (entries: [My_iNode, My_jNode, Mz_iNode, Mz_jNode]) My_iNode + My_jNode <= 1.0, Mz_iNode + Mz_jNode <= 1.0. Remaining P-Delta moments are resisted by shear couples. (optional) sDratios shear distances from iNode as a fraction of the element length, size of ratio vector is 1 for 2D-case and 2 for 3D-case (entries: [dy_iNode, dz_iNode] (optional, default = [0.5 0.5]) -doRayleigh to include Rayleigh damping from the element (optional, default = no Rayleigh damping contribution) m element mass (optional, default = 0.0) TwoNodeLinkElement.png NOTE: If the element has zero length and optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the x- and y-vectors specified on the command line. The valid queries to a twoNodeLink element when creating an ElementRecorder object are \u2018force,\u2019 \u2018localForce,\u2019 \u2018basicForce,\u2019 \u2018localDisplacement,\u2019 \u2018basicDisplacement\u2019 and \u2018material $matNum matArg1 matArg2 \u2026\u2019 Where $matNum is the number associated with the material whose data is to be output. Examples 2D: element twoNodeLink 1 1 2 -mat 1 2 3 -dir 1 2 3; 3D: element twoNodeLink 1 1 2 -mat 1 2 3 -dir 1 2 6; Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"Two Node Link Element\n"},{"location":"contrib/modeling/element/74-CatenaryCableElement/","text":"CatenaryCableElement This command is used to construct a catenary cable element object. element CatenaryCable $tag $iNode $jNode $weight $E $A $L0 $alpha $temperature_change $rho $errorTol $Nsubsteps $massType eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes (3 dof per node)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">E</code></td> <td><p>elastic modulus of the cable material</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">A</code></td> <td><p>cross-sectional area of element</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">L0</code></td> <td><p>unstretched length of the cable</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>coefficient of thermal expansion</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">temperature_change</code></td> <td><p>temperature change for the element</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rho</code></td> <td><p>mass per unit length</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">errortol</code></td> <td><p>allowed tolerance for within-element equilbrium (Newton-Rhapson iterations)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Nsubsteps</code></td> <td><p>number of within-element substeps into which equilibrium iterations are subdivided (not number of steps to convergence)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">massType</code></td> <td><p>Mass matrix model to use (<strong>\\) massType = 0 lumped mass matrix, $massType = 1 rigid-body mass matrix (in development)) This cable is a flexibility-based formulation of the catenary cable. An iterative scheme is used internally to compute equilibrium. At each iteration, node i is considered fixed while node j is free. End-forces are applied at node-j and its displacements computed. Corrections to these forces are applied iteratively using a Newton-Rhapson scheme (with optional sub-stepping via Nsubsteps ) until nodal displacements are within the provided tolerance ( errortol ). When convergence is reached, a stiffness matrix is computed by inversion of the flexibility matrix and rigid-body mode injection. Notes: The stiffness of the cable comes from the large-deformation interaction between loading and cable shape. Therefore, all cables must have distributed forces applied to them. See example. Should not work for only nodal forces. Valid queries to the CatenaryCable element when creating an ElementalRecorder object correspond to \u2018forces\u2019, which output the end-forces of the element in global coordinates (3 for each node). Only the lumped-mass formulation is currently available. The element does up 100 internal iterations. If convergence is not achieved, will result in error and some diagnostic information is printed out. Code Developed by: Pablo Iba\u00f1ez and Jos\u00e9 A. Abell at Universidad de los Andes, Chile Examples </p> <ol> <li>This example implements a slight modification of the verification test from reference # 1. </li> <li></li> </ol> <p>model BasicBuilder -ndm 3 -ndf 3 </p> <p> set x 30. ; #Set to example from paper x = 30, 60, 80, 100. Will not work for x = 0.01 , system ill-conditioned.</p> <p>node 1 0.0 0.0 90.0 node 2 [expr $x / 2 ] 0.0 40.0 node 3 $x 60 30. </p> <p>fix 1 1 1 1 fix 2 0 1 0 fix 3 1 1 1 </p> <p> set w3 -0 .00001 set E 3 .e7 set A 1. set L0 100. set alfa 6.5e-6 set cambiodetemp 100. set rho [expr $w3 / 9.81 ] </p> <p> set errorTol 1e-6 set NSubSteps 20 </p> <p>element CatenaryCable 1 1 2 $w3 $E $A [expr $L0 / 2 ] $alfa $cambiodetemp $rho $errorTol $NSubSteps 0 element CatenaryCable 2 2 3 $w3 $E $A [expr $L0 / 2 ] $alfa $cambiodetemp $rho $errorTol $NSubSteps 0 </p> <p> set NSteps 10 timeSeries Linear 1 -factor 1 </p> <p>pattern Plain 2 1 { eleLoad -ele 1 2 -type -beamUniform 0. 0. -1 } </p> <p>recorder Node -file \"disp.txt\" -time -nodeRange 1 3 -dof 1 2 3 disp recorder Element -file \"forces.txt\" -time -eleRange 1 2 force</p> <p> system FullGeneral constraints Plain numberer Plain test NormDispIncr 1.0e-5 100 1 integrator LoadControl [expr 1.0 / $NSteps ] algorithm Newton analysis Static</p> <p>analyze $NSteps </p> <p>print -node 2 Results should be: Node: 2 Coordinates : 15 0 40 Disps: 8.58693 0 2.82578 unbalanced Load: 0 0 0 ID : 0 -1 1 Compare the forces.txt (for node 3) file with the results from reference [1]. References Salehi Ahmad Abad, M., Shooshtari, A., Esmaeili, V., & Naghavi Riabi, A. (2013). Nonlinear analysis of cable structures under general loadings. Finite Elements in Analysis and Design, 73, 11-19. https://doi.org/10.1016/j.finel.2013.05.002 Thai, H. T., & Kim, S. E. (2011). Nonlinear static and dynamic analysis of cable structures. Finite Elements in Analysis and Design, 47(3), 237-246. https://doi.org/10.1016/j.finel.2010.10.005","title":"CatenaryCableElement\n"},{"location":"contrib/modeling/element/743-VS3D4/","text":"VS3D4 This command is used to construct a four-node 3D viscous-spring boundary quad element object based on a bilinear isoparametric formulation. element VS3D4 $eleTag $node1 $node2 $node3 $node4 $E $G $rho $R $alphaN $alphaT eleTag unique element object tag \\(node1 ..\\) node3 4 end nodes E Young\u2019s Modulus of element material G Shear Modulus of element material rho Mass Density of element material R distance from the scattered wave source to the boundary alphaN correction parameter in the normal direction alphaT correction parameter in the tangential direction Reference: Liu J, Du Y, Du X, et al. 3D viscous-spring artificial boundary in time domain. Earthquake Engineering and Engineering Vibration, 2006, 5(1):93-102 Code Developed by: Quan Gu, Yichao Gao and Zhijian Qiu","title":"VS3D4\n"},{"location":"contrib/modeling/element/757-YamamotoBiaxialHDR%20Element/","text":"YamamotoBiaxialHDR Element This command is used to construct a YamamotoBiaxialHDR element object, which is defined by two nodes. This element can be used to represent the isotropic behavior of high-damping rubber bearing in the local y-z plane. element YamamotoBiaxialHDR $eleTag $iNode $jNode $Tp $DDo $DDi $Hr &lt;-coRS $cr $cs &gt; &lt;-orient &lt; $x1 $x2 $x3 &gt; $y1 $y2 $y3 &gt; &lt;-mass $m &gt; eleTag unique element object tag $inode \\(jnode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Tp</code></td> <td><p>compound type</p></td> </tr> <tr class=\"even\"> <td></td> <td><p>= <strong>1</strong> : X0.6R manufactured by Bridgestone corporation.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">DDo</code></td> <td><p>outer diameter [m]</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">DDi</code></td> <td><p>bore diameter [m]</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Hr</code></td> <td><p>total thickness of rubber layer [m]</p></td> </tr> <tr class=\"even\"> <td><p>Optional Data</p></td> <td></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) cr $cs coefficients for shear stress components of \\(\\tau_{r}\\) and <math>_{s}</math> $x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) yp1 $yp2 $yp3 vector components in global coordinates defining vector yp which lies in the local x-y plane for the element m element mass [kg] NOTES: The valid queries to a YamamotoBiaxialHDR element when creating an ElementRecorder object are \u2018globalForce\u2019, \u2018localForce\u2019, \u2018basicForce\u2019, \u2018localDisplacement\u2019 and \u2018basicDeformation\u2019. YamamotoBiaxialHDR_Model.png Examples element YamamotoBiaxialHDR 1 1 2 1 1.300 0.030 0.261 -orient 0 0 1 1 0 0 YamamotoBiaxialHDR_Sample.tcl , YamamotoBiaxialHDR_input_X.tcl , YamamotoBiaxialHDR_input_Y.tcl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REFERENCES: Masashi Yamamoto, Shigeo Minewaki, Harumi Yoneda and Masahiko Higashino, \u201cNonlinear behavior of high-damping rubber bearings under horizontal bidirectional loading: full-scale tests and analytical modeling\u201d, Earthquake Engineering and Structural Dynamics , 41 , 1845-1860, 2012. Code Developed by: mkiku","title":"YamamotoBiaxialHDR Element\n"},{"location":"contrib/modeling/element/759-ZeroLengthContactNTS2D/","text":"ZeroLengthContactNTS2D This command is used to construct a zeroLengthContactNTS2D element object. This is a Node-To-Segment (NTS) frictional contact element used in two dimensional analysis for contact between elements with 2 DOF nodes. element zeroLengtContactNTS2D $eleTag -cNdNum $cNdNum -rNdNum $rNdNum -Nodes $Nodes $Kn $kt $phi eleTag unique element object tag cNdNum Number of Constrained Nodes rNdNum Number of Retained nodes $Nodes \u2026 Constrained and Retained node tags respectively Kn Penalty in normal direction Kt Penalty in tangential direction phi Friction angle in degrees NOTES: The contact element is node-to-segment (NTS) contact. The relation follows Mohr-Coulomb frictional law: <math>T = N tan()</math>, where \\(T\\) is the tangential force, \\(N\\) is normal force across the interface and <math>,!</math> is friction angle. For 2D contact, constrained nodes and retained nodes must be 2 DOF and notice that the constrained and retained nodes must be entered in counterclockwise order. The resulting tangent from the contact element is non-symmetric. Switch to the non-symmetric matrix solver if convergence problem is experienced. As opposed to node-to-node contact, predefined normal vector for node-to-segment (NTS) element is not required because contact normal will be calculated automatically at each step. contact element is implemented to handle large deformations. EXAMPLE: zeroLengthContactNTS2Drc.png element zeroLengthContactNTS2D 1 -cNdNum 6 -rNdNum 6 - Nodes 5 10 12 3 9 11 1 4 2 8 7 6 1e8 1e8 16 Example 1: This example simply shows the two quadrilateral elements in normal contact. The top element is in normal downward uniform force. The Tcl script of this example can be found here . ZeroLengthContactNTS2D_fig2.jpg Example 2: This example shows two cantilever beams in contact. The beams were modeled using four-node quadrilateral elements and the end of top beam was subjected to a linearly increasing displacement. The Tcl scripts for this example can be found here . zeroLengthContactNTS2D_fig3.jpg The following Figure shows the deflections of the two beams. zeroLengthContactNTS2D_fig4.jpg REFERENCES: P. Wriggers, V.T. Vu and E. Stein, Finite-element formulation of large deformation impact-contact problems with friction, Comput. Struct. 37 (1990), pp. 319-331. Peter Wriggers. Computational Contact Mechanics. John Wiley & Sons Ltd. Chichester, 2002. Code Developed by: Roozbeh G. Mikola , UC Berkeley and N. Sitar , UC Berkeley","title":"ZeroLengthContactNTS2D\n"},{"location":"contrib/modeling/element/762-ZeroLengthContact%20Element/","text":"ZeroLengthContact Element This command is used to construct a zeroLengthContact2D element or a zeroLengthContact3D element, which are Node-to-node frictional contact element used in two dimensional analysis and three dimensional analysis: 2d analysis: element zeroLengthContact2D $eleTag $cNode $rNode $Kn $Kt $mu -normal $Nx $Ny 3d analysis: element zeroLengthContact3D $eleTag $cNode $rNode $Kn $Kt $mu $c $dir eleTag unique element object tag cNode Constrained node tag rNode Retained node tag Kn Penalty in normal direction Kt Penalty in tangential direction mu friction coefficient c cohesion (not available in 2D) dir Direction flag of the contact plane (3D), it can be: 1 Out normal of the retained plane pointing to +X direction 2 Out normal of the retained plane pointing to +Y direction 3 Out normal of the retained plane pointing to +Z direction ZeroLengthContact2.png NOTES: The contact element is node-to-node contact. Contact occurs between two contact nodes when they come close. The relation follows Mohr-coulomb law: T = $mu * N + $c, where T is tangential force and N is normal force across the interface. $mu is friction coefficient and $c is total cohesion (summed over the effective area of contact nodes) The contact node pair in node-to-node contact element is termed \u201cretained node\u201d and \u201cconstrained node\u201d, respectively. Retained/constrained plane is the contact plane which the retrained/constrained node belongs to. The discrimination is made solely for contact detection purpose. User need to specify the corresponding out normal of the master plane, and this direction is assumed to be unchanged during analysis. For simplicity, 3D contact only allows 3 options to specify the directions of the contact plane. The convention is: out normal of master plane always points to positive axial direction (+X or +Y, or +Z) For 2D contact, constrained nodes and retained nodes must be 2 DOF. For 3D contact, constrained nodes and retained nodes must be 3 DOF. The resulted tangent from the contact element is NON-SYMMETRIC . Switch to non-symmetric matrix solver. Examples Gang Wang to provide a smart example! REFERENCES: Code Developed by: Gang Wang, Geomatrix","title":"ZeroLengthContact Element\n"},{"location":"contrib/modeling/element/763-ZeroLengthImpact3D/","text":"ZeroLengthImpact3D This command constructs a node-to-node zero-length contact element in 3D space to simulate the impact/pounding and friction phenomena. element zeroLengthImpact3D $tag $cNode $rNode $direction $initGap $frictionRatio $Kt $Kn $Kn2 $Delta_y $cohesion tag Unique element object tag cNode Constrained node tag rNode Retained node tag direction 1 if out-normal vector of master plane points to +X direction 2 if out-normal vector of master plane points to +Y direction 3 if out-normal vector of master plane points to +Z direction initGap Initial gap between retained plane and constrained plane frictionRatio Friction ratio in two tangential directions (parallel to retained and constrained planes) Kt Penalty in two tangential directions Kn Penalty in normal direction (normal to retained and constrained planes) Kn2 Penalty in normal direction after yielding based on Hertz impact model Delta_y Yield deformation based on Hertz impact model cohesion Cohesion, if no cohesion, it is zero NOTES: This element has been developed on top of the \u201czeroLengthContact3D\u201d. All the notes available in \u201czeroLengthContact3D\u201d wiki page would apply to this element as well. It includes the definition of retained and constrained nodes, the number of degrees of freedom in the domain, etc. Regarding the number of degrees of freedom (DOF), the end nodes of this element should be defined in 3DOF domain. For getting information on how to use 3DOF and 6DOF domain together, please refer to OpenSees documentation and forums or see the zip file provided in the EXAMPLES section below. This element adds the capabilities of \u201cImpactMaterial\u201d to \u201czeroLengthContact3D.\u201d For simulating a surface-to-surface contact, the element can be defined for connecting the nodes on constrained surface to the nodes on retained surface. The element was found to be fast-converging and eliminating the need for extra elements and nodes in the modeling process. Examples The following zip file contains an example script and the corresponding input cyclic displacement: The following zip file contains an example script on how to use 6DOF domain and 3DOF domain together: <!\u2013 SAMPLE COMMAND (example scripts are available at bottom of this page): </p> <p> \u2013> REFERENCES: zeroLengthContact3D , ImpactMaterial CODE DEVELOPED BY: Dr. Arash E. Zaghi and Majid Cashany at University of Connecticut (UConn) APPLICATIONS: This element has been employed to simulate the bridge hinges including superstructure-abutment interaction at the University of Connecticut (UConn) and University of Nevada, Reno (UNR). It has been implemented in non-structural systems like suspended ceilings, simulating the impact/pounding and friction phenomena. <!\u2013 After running the example script, the following hysteresis loop is resulted in normal direction under cyclic excitation: \u2013>","title":"ZeroLengthImpact3D\n"},{"location":"contrib/modeling/element/764-ZeroLengthInterface2D/","text":"ZeroLengthInterface2D zeroLengthInterface2D is Node-to-Segment (NTS) frictional contact element used in two dimensional analysis for contact between elements. Please notice that any number of DOF (DOF>1) can be handled using this element (i.e. beam-solid, solid-solid as well as beam-beam contact) as oppose to zeroLengthContactNTS2D element). element zeroLengthInterface2D $eleTag -cNdNum $cNdNum -rNdNum $rNdNum -dof $cdof $rdof -Nodes $Nodes $Kn $Kt $phi eleTag unique element object tag cNdNum Number of Constrained Nodes rNdNum Number of Retained nodes $cdof \\(rdof</strong></p></td> <td><p>Constrained and Retained degree of freedom</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) Nodes \u2026 Constrained and Retained node tags respectively Kn Penalty in normal direction Kt Penalty in tangential direction phi Friction angle in degrees NOTES: The contact element is node-to-segment (NTS) contact. The relation follows Mohr-Coulomb frictional law: <math>T = N tan()</math>, where \\(T\\) is the tangential force, \\(N\\) is normal force across the interface and <math>,!</math> is friction angle. For 2D contact, constrained nodes and retained nodes must be 2 DOF and notice that the constrained and retained nodes must be entered in counterclockwise order. The resulting tangent from the contact element is non-symmetric. Switch to the non-symmetric matrix solver if convergence problem is experienced. As opposed to node-to-node contact, predefined normal vector for node-to-segment (NTS) element is not required because contact normal will be calculated automatically at each step. And also this element can handle contact between different DOFs such as beam-beam, beam-solid and solid-solid. contact element is implemented to handle large deformations. EXAMPLE: ZeroLengthInterface2Drc.png element zeroLengthInterface2D 1 -sNdNum 6 -mNdNum 6 -dof 2 3 -Nodes 5 10 12 3 9 11 1 4 2 8 7 6 1e8 1e8 16 Example 1: This example simply shows the quadrilateral elements in normal contact on top of beam element. The top element is in normal downward uniform force. The Tcl script of this example can be found here . ZeroLengthInterface2D_fig2.jpg Example 2: This example shows two cantilever beams in contact. The beams were modeled using four-node quadrilateral elements and the end of top beam was subjected to a linearly increasing displacement. The Tcl scripts for this example can be found here . zeroLengthContactNTS2D_fig3.jpg The following Figure shows the deflections of the two beams. zeroLengthContactNTS2D_fig4.jpg REFERENCES: P. Wriggers, V.T. Vu and E. Stein, Finite-element formulation of large deformation impact-contact problems with friction, Comput. Struct. 37 (1990), pp. 319-331. Peter Wriggers. Computational Contact Mechanics. John Wiley & Sons Ltd. Chichester, 2002. Code Developed by: Roozbeh G. Mikola , UC Berkeley and N. Sitar , UC Berkeley","title":"ZeroLengthInterface2D\n"},{"location":"contrib/modeling/element/767-ZeroLengthND%20Element/","text":"ZeroLengthND Element This command is used to construct a zeroLengthND element object, which is defined by two nodes at the same location. The nodes are connected by a single NDMaterial object to represent the force-deformation relationship for the element. element zeroLengthND $eleTag $iNode $jNode $matTag &lt; $uniTag &gt; &lt;-orient $x1 $x2 $x3 $yp1 $yp2 $yp3 &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>tag associated with previously-defined ndMaterial object</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">uniTag</code></td> <td><p>ag associated with previously-defined UniaxialMaterial object which may be used to represent uncoupled behavior orthogonal to the plane of the NDmaterial response. SEE NOTES 2 and 3.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) yp1 $yp2 $yp3 vector components in global coordinates defining vector yp which lies in the local x-y plane for the element. (optional) NOTE: The zeroLengthND element only represents translational response between its nodes If the NDMaterial object is of order two, the response lies in the element local x-y plane and the UniaxialMaterial object may be used to represent the uncoupled behavior orthogonal to this plane, i.e. along the local z-axis. If the NDMaterial object is of order three, the response is along each of the element local exes. If the optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the vectors x and yp vectors specified on the command line. The valid queries to a zero-length element when creating an ElementRecorder object are \u2018force\u2019, \u2018deformation\u2019, and \u2018material matArg1 matArg2 \u2026\u2019 Examples Code Developed by: Micheal Scott, Oregon State University.","title":"ZeroLengthND Element\n"},{"location":"contrib/modeling/element/768-ZeroLengthSection%20Element/","text":"ZeroLengthSection Element This command is used to construct a zero length element object, which is defined by two nodes at the same location. The nodes are connected by a single section object to represent the force-deformation relationship for the element. element zeroLengthSection $eleTag $iNode $jNode $secTag &lt;-orient $x1 $x2 $x3 $yp1 $yp2 $yp3 &gt; &lt;-doRayleigh $rFlag &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">secTag</code></td> <td><p>tag associated with previously-defined Section object</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) yp1 $yp2 $yp3 vector components in global coordinates defining vector yp which lies in the local x-y plane for the element. (optional) rFlag optional, default = 1 rFlag = 0 no Rayleigh damping rFlag = 1 include Rayleigh damping (default) NOTE: If the optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the vectors x and yp vectors specified on the command line. The section force-deformation response represented by section string P acts along the element local x-axis, and the response for code Vy along the local y-axis. The other modes of section response follow from this orientation. The valid queries to a zero-length element when creating an ElementRecorder object are \u2018force,\u2019 \u2018deformation,\u2019 \u2018stiff,\u2019 and \u2018section $secArg1 secArg2 \u2026\u2019. Examples element zeroLengthSection 1 2 4 6; # truss tag 1 between nodes 2 and 4 usinga type 6 section. element zeroLengthSection 1 1 2 1 -orient 0 1 0 0 0 -1; # element tag 1 between nodes 1 and 2 defined with section 1. Local direction x, perpendicular to element section, is aligned with the global Y axis and the vector yp is aligned with the negative global Z axis. Code Developed by: Micheal Scott, Oregon State University.","title":"ZeroLengthSection Element\n"},{"location":"contrib/modeling/element/769-ZeroLength%20Element/","text":"ZeroLength Element This command is used to construct a zeroLength element object, which is defined by two nodes at the same location. The nodes are connected by multiple UniaxialMaterial objects to represent the force-deformation relationship for the element. element zeroLength $eleTag $iNode $jNode -mat $matTag1 $matTag2 ... -dir $dir1 $dir2 ...&lt;-doRayleigh $rFlag &gt; &lt;-orient $x1 $x2 $x3 $yp1 $yp2 $yp3 &gt; eleTag unique element object tag $iNode \\(jNode</strong></p></td> <td><p>end nodes</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) matTag1 \\(matTag2 ...</strong></p></td> <td><p>tags associated with previously-defined UniaxialMaterials</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dir1 \\(dir2 ...</strong></p></td> <td><p>material directions:</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>1,2,3 - translation along local x,y,z axes, respectively;</p></td> </tr> <tr class=\"even\"> <td></td> <td><p>4,5,6 - rotation about local x,y,z axes, respectively</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) x1 $x2 \\(x3</strong></p></td> <td><p>vector components in global coordinates defining local x-axis (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) yp1 $yp2 $yp3 vector components in global coordinates defining vector yp which lies in the local x-y plane for the element. (optional) rFlag optional, default = 0 rFlag = 0 NO RAYLEIGH DAMPING (default) rFlag = 1 include rayleigh damping NOTE: If the optional orientation vectors are not specified, the local element axes coincide with the global axes. Otherwise the local z-axis is defined by the cross product between the vectors x and yp vectors specified on the command line. The valid queries to a zero-length element when creating an ElementRecorder object are \u2018force,\u2019 \u2018deformation,\u2019 and \u2018material $i matArg1 matArg2 \u2026\u2019 Where $i is an integer indicating which of the materials whose data is to be output (a 1 corresponds to $matTag1, a 2 to $matTag2, and so on). EXAMPLE: element zeroLength 1 2 4 -mat 5 6 -dir 1 2; # truss tag 1 between nodes 2 and 4 acting in directions 1 and 2 with materials 5 and 6 respectively. element zeroLength 1 1 2 -mat 1 -dir 1 -orient 1 1 0 -1 1 0; # truss tag 1 between nodes 1 and 2 acting in local direction 1 defined with material 1. Local direction 1 attains 45 degrees with global X axis element zeroLength 1 1 2 -mat 1 -dir 1 -doRayleigh 1 -orient 1 1 0 -1 1 0; # the same as the example above but also includes the stiffness of this element in calculation of the damping matrix if Rayleigh command is invoked later. Code Developed by: Gregory L. Fenves, University of Texas, Austin.","title":"ZeroLength Element\n"},{"location":"contrib/modeling/geomTransf/106-Corotational%20Transformation/","text":"Corotational This command is used to construct the Corotational Coordinate Transformation (CorotCrdTransf) object. Corotational transformation can be used in large displacement-small strain problems. NOTE: Currently the transformation does not deal with element loads and will ignore any that are applied to the element. For a two-dimensional problem: geomTransf Corotational $transfTag &lt;-jntOffset $dXi $dYi $dXj $dYj &gt; For a three-dimensional problem: geomTransf Corotational $transfTag $vecxzX $vecxzY $vecxzZ transfTag integer tag identifying transformation $vecxzX $vecxzY \\(vecxzZ</strong></p></td> <td><p>X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis.</p> <p>These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system.</p> <p>These items need to be specified for the three-dimensional problem.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) dXi \\(dYi</strong></p></td> <td><p>joint offset values -- absolute offsets specified with respect to the global coordinate system for element-end node i (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dXj $dYj joint offset values \u2013 absolute offsets specified with respect to the global coordinate system for element-end node j (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane \u2013 vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking cross product of x and new y. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif Examples ElementCrossSection.png ElementOrientation.png ElementVectors.png Element 1 : tag 1 : vecxZ = zaxis geomTransf Corotational 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf Corotational 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Corotational\n"},{"location":"contrib/modeling/geomTransf/370-Linear%20Transformation/","text":"Linear This command is used to construct a linear coordinate transformation (LinearCrdTransf) object, which performs a linear geometric transformation of beam stiffness and resisting force from the basic system to the global-coordinate system. For a two-dimensional problem: geomTransf Linear $transfTag &lt;-jntOffset $dXi $dYi $dXj $dYj &gt; For a three-dimensional problem: geomTransf Linear $transfTag $vecxzX $vecxzY $vecxzZ &lt;-jntOffset $dXi $dYi $dZi $dXj $dYj $dZj &gt; transfTag integer tag identifying transformation $vecxzX $vecxzY \\(vecxzZ</strong></p></td> <td><p>X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis.</p> <p>These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system.</p> <p>These items need to be specified for the three-dimensional problem.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) dXi $dYi \\(dZi</strong></p></td> <td><p>joint offset values -- offsets specified with respect to the global coordinate system for element-end node i (optional, the number of arguments depends on the dimensions of the current model).</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dXj $dYj $dZj joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node j (optional, the number of arguments depends on the dimensions of the current model). A refresher on Euclidean Geometry and Coordinate Systems: A single vector may be defined by two points. It has length, direction, and location in space. When this vector is used to define a coordinate axis, only its direction is important. Now any 2 vectors, Vr and Vs, not parallel, define a plane that is parallel to them both. The cross-product of these vectors define a third vector, Vt, that is perpendicular to both Vr and Vs and hence normal to the plane: Vt = Vr X Vs. The element coordinate system is specified as follows: The x-axis is a vector given by the two element nodes; The vector vecxz is a vector the user specifies that must not be parallel to the x-axis. The x-axis along with the vecxz Vector define the xz plane. The local y-axis is defined by taking the cross product of the x-axis vector and the vecxz vector (Vy = Vxz X Vx). The local z-axis is then found simply by taking the cross product of the y-axis and x-axis vectors (Vz = Vx X Vy). The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif NOTE: When in 2D, local x and y axes are in the X-Y plane, where X and Y are global axes. Local x axis is the axis connecting the two element nodes, and local y and z axes follow the right-hand rule (e.g., if the element is aligned with the positive Y axis, the local y axis is aligned with the negative X axis, and if the element is aligned with the positive X axis, the local y axis is aligned with the positive Y axis). Orientation of local y and z axes is important for definition of the fiber section. Examples ElementCrossSection.png ElementOrientation.png ElementVectors.png Element 1 : tag 1 : vecxZ = zaxis geomTransf Linear 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf Linear 2 0 1 0 If there was a rigid offset at the top of element 1: geomTransf Linear 1 0 0 -1 -jntOffset 0.0 0.0 0.0 0.0 -$Offset 0.0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Linear\n"},{"location":"contrib/modeling/geomTransf/480-PDelta%20Transformation/","text":"PDelta This command is used to construct the P-Delta Coordinate Transformation (PDeltaCrdTransf) object, which performs a linear geometric transformation of beam stiffness and resisting force from the basic system to the global coordinate system, considering second-order P-Delta effects. NOTE: P LARGE Delta effects do not include P small delta effects. For a two-dimensional problem: geomTransf PDelta $transfTag < -jntOffset $dXi $dY $dXj $dYj > For a three-dimensional problem: geomTransf PDelta $transfTag $vecxzX $vecxzY $vecxzZ < -jntOffset $dXi $dYi $dZi $dXj $dYj $dZj > transfTag integer tag identifying transformation $vecxzX $vecxzY $vecxzZ X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. dXi dYi dZi joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node i (the number of arguments depends on the dimensions of the current model). The offset vector is oriented from node i to node j as shown in a figure below. (optional) dXj dYj dZj joint offset values \u2013 offsets specified with respect to the global coordinate system for element-end node j (the number of arguments depends on the dimensions of the current model). The offset vector is oriented from node j to node i as shown in a figure below. (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane \u2013 vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking the cross-product of x and y vectors. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. ElementOrentation.gif RigidElementOffsets.gif Examples ElementCrossSection.png ElementOrientation.png ElementVectors.png Element 1 : tag 1 : vecxZ = zaxis geomTransf PDelta 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf PDelta 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"PDelta\n"},{"location":"contrib/modeling/ndmaterial/102-ContactMaterial2D/","text":"ContactMaterial2D This command is used to construct a ContactMaterial2D nDMaterial object. nDMaterial ContactMaterial2D $matTag $mu $G $c $t matTag unique integer tag identifying nDMaterial object mu interface frictional coefficient G interface stiffness parameter c interface cohesive intercept t interface tensile strength The ContactMaterial2D nDMaterial defines the constitutive behavior of a frictional interface between two bodies in contact. The interface defined by this material object allows for sticking, frictional slip, and separation between the two bodies in a two-dimensional analysis. A regularized Coulomb frictional law is assumed. Information on the theory behind this material can be found in, e.g. Wriggers (2002). NOTE: The ContactMaterial2D nDMaterial has been written to work with the SimpleContact2D and BeamContact2D element objects. There are no valid recorder queries for this material other than those which are listed with those elements. EXAMPLE: ContactMaterial2D nDmaterial with tag 1 nDMaterial ContactMaterial2D 1 0.1 1000.0 0.0 0.0 Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington References: Wriggers, P. (2002). Computational Contact Mechanics. John Wilely & Sons, Ltd, West Sussex, England.","title":"ContactMaterial2D\n"},{"location":"contrib/modeling/ndmaterial/103-ContactMaterial3D/","text":"ContactMaterial3D This command is used to construct a ContactMaterial3D nDMaterial object. nDMaterial ContactMaterial3D $matTag $mu $G $c $t matTag unique integer tag identifying nDMaterial object mu interface frictional coefficient G interface stiffness parameter c interface cohesive intercept t interface tensile strength The ContactMaterial3D nDMaterial defines the constitutive behavior of a frictional interface between two bodies in contact. The interface defined by this material object allows for sticking, frictional slip, and separation between the two bodies in a three-dimensional analysis. A regularized Coulomb frictional law is assumed. Information on the theory behind this material can be found in, e.g. Wriggers (2002). NOTE: The ContactMaterial3D nDMaterial has been written to work with the SimpleContact3D and BeamContact3D element objects. There are no valid recorder queries for this material other than those which are listed with those elements. EXAMPLE: ContactMaterial3D nDmaterial with tag 1 nDMaterial ContactMaterial3D 1 0.1 1000.0 0.0 0.0 Code Developed by: Kathryn Petek, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington References: Wriggers, P. (2002). Computational Contact Mechanics. John Wilely & Sons, Ltd, West Sussex, England.","title":"ContactMaterial3D\n"},{"location":"contrib/modeling/ndmaterial/111-CycLiqCPSP%20Material/","text":"CycLiqCPSP This command is used to construct a multi-dimensional material object based on a unified plasticity model for large post-liquefaction shear deformation of sand. nDmaterial CycLiqCPSP $matTag $G0 $kappa $h $M $dre1 $dre2 $rdr $alpha $dir $lambdac $ksi $e0 $np $nd $ein &lt; $rho &gt; CycLiqCPSP material is a constitutive model for sand with special considerations for cyclic behaviour and accumulation of large post-liquefaction shear deformation, and is implemented using a cutting plane algorithm. The model: (1) achieves the simulation of post-liquefaction shear deformation based on its physics, allowing the unified description of pre- and post-liquefaction behavior of sand; (2) directly links the cyclic mobility of sand with reversible and irreversible dilatancy, enabling the unified description of monotonic and cyclic loading; (3) introduces critical state soil mechanics concepts to achieve unified modelling of sand under different states. The critical, maximum stress ratio and reversible dilatancy surfaces follow a rounded triangle in the pi plane similar to the Matsuoka-Nakai criterion. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be non-linear elastic, with the updateMaterialStage command: updateMaterialStage -material $matTag -stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage -material $matTag -stage 1 If a linear elastic stage is required, it can be achieved through: updateMaterialStage -material $matTag -stage 2 matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus M Critical state stress ratio dre1 Coefficient for reversible dilatancy generation dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential lambdac Critical state constant ksi Critical state constant e0 Void ratio at pc=0 np Material constant for peak mobilized stress ratio nd Material constant for reversible dilatancy generation stress ratio ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCPSP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d. REFERENCES: Wang R., Zhang J.M., Wang G., 2014. A unified plasticity model for large post-liquefaction shear deformation of sand. Computers and Geotechnics. 59, 54-66. Code Developed by: Rui Wang, Tsinghua University","title":"CycLiqCPSP\n"},{"location":"contrib/modeling/ndmaterial/113-CycLiqCP%20Material%20%28Cyclic%20ElasticPlasticity%29/","text":"CycLiqCP Material (Cyclic ElasticPlasticity) This command is used to construct a multi-dimensional material object that that follows the constitutive behavior of a cyclic elastoplasticity model for large post- liquefaction deformation. nDmaterial CycLiqCP $matTag $G0 $kappa $h $Mfc $dre1 $Mdc $dre2 $rdr $alpha $dir $ein &lt; $rho &gt; CycLiqCP material is a cyclic elastoplasticity model for large post-liquefaction deformation, and is implemented using a cutting plane algorithm. The model is capable of reproducing small to large deformation in the pre- to post-liquefaction regime. The elastic moduli of the model are pressure dependent. The plasticity in the model is developed within the framework of bounding surface plasticity, with special consideration to the formulation of reversible and irreversible dilatancy. The model does not take into consideration of the state of sand, and requires different parameters for sand under different densities and confining pressures. The surfaces (i.e. failure and maximum pre-stress) are considered as circles in the pi plane. The model has been validated against VELACS centrifuge model tests and has used on numerous simulations of liquefaction related problems. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be linear elastic, with the updateMaterialStage command: updateMaterialStage -material $matTag -stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage -material $matTag -stage 1 matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus Mfc Stress ratio at failure in triaxial compression dre1 Coefficient for reversible dilatancy generation Mdc Stress ratio at which the reversible dilatancy sign changes dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d. NOTES: The elastic modulii are given by the following relations: CycLiqCp.GIF REFERENCES: Zhang J.M. and Wang G., 2012, \u201cLarge post-liquefaction deformation of sand, part I: physical mechanism, constitutive description and numerical algorithm\u201d, Acta Geotechnica. Code Developed by: Rui Wang, Tsinghua University","title":"CycLiqCP Material (Cyclic ElasticPlasticity)\n"},{"location":"contrib/modeling/ndmaterial/117-Cyclic%20ElastocPlasticity/","text":"Cyclic ElastocPlasticity This command is used to construct a multi-dimensional material object that that follows the constitutive behavior of a cyclic elastoplasticity model for large post- liquefaction deformation. nDmaterial CycLiqCP $matTag $G0 $kappa $h $Mfc $dre1 $Mdc $dre2 $rdr $alpha $dir $ein &lt; $rho &gt; CycLiqCP material is a cyclic elastoplasticity model for large post-liquefaction deformation, and is implemented using a cutting plane algorithm. The model is capable of reproducing small to large deformation in the pre- to post-liquefaction regime. The elastic moduli of the model are pressure dependent. The plasticity in the model is developed within the framework of bounding surface plasticity, with special consideration to the formulation of reversible and irreversible dilatancy. The model has been validated against VELACS centrifuge model tests and has used on numerous simulations of liquefaction related problems. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. When solid-fluid coupled elements (u-p elements and SSP u-p elements) are used, the model is able to simulate undrained and partially drained behavior of soil. During the application of gravity load (and static loads if any), the user is suggested to set the material behavior to be linear elastic, with the updateMaterialStage command: updateMaterialStage -material $matTag -stage 0 After the gravity load stage, the material stage should be updated to achieve the desired elastic-plastic stress-strain response. updateMaterialStage -material $matTag -stage 1 matTag integer tag identifying material G0 A constant related to elastic shear modulus kappa A constant related to elastic bulk modulus h Model parameter for plastic modulus Mfc Stress ratio at failure in triaxial compression dre1 Coefficient for reversible dilatancy generation Mdc Stress ratio at which the reversible dilatancy sign changes dre2 Coefficient for reversible dilatancy release rdr Reference shear strain length alpha Parameter controlling the decrease rate of irreversible dilatancy dir Coefficient for irreversible dilatancy potential ein Initial void ratio rho Saturated mass density The material formulations for the CycLiqCP object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d. REFERENCES: Zhang J.M. and Wang G., 2012, \u201cLarge post-liquefaction deformation of sand, part I: physical mechanism, constitutive description and numerical algorithm\u201d, Acta Geotechnica. Code Developed by: Rui Wang, Tsinghua University","title":"Cyclic ElastocPlasticity\n"},{"location":"contrib/modeling/ndmaterial/120-Damage2p/","text":"Damage2p This command is used to construct a three-dimensional material object that has a Drucker-Prager plasticity model coupled with a two-parameter damage model. nDMaterial Damage2p $matTag $fcc <-fct $fct> <-E $E> <-ni $ni> <-Gt $Gt> <-Gc $Gc> <-rho_bar $rho_bar> <-H $H> <-theta $theta> <-tangent $tangent> matTag integer tag identifying material fcc concrete compressive strength fct optional concrete tensile strength E optional Young modulus ni optional Poisson coefficient Gt optional tension fracture energy density Gc optional compression fracture energy density rho_bar ptional parameter of plastic volume change H optional linear hardening parameter for plasticity theta optional ratio between isotropic and kinematic hardening tangent optional integer to choose the computational stiffness matrix The material formulations for the Damage2p object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d NOTES Admissible values: The input parameters vary as follows: fcc negative real value (positive input is changed in sign automatically) fct positive real value (for concrete like materials is less than $fcc) Gt positive real value (integral of the stress-strain envelope in tension) Gc positive real value (integral of the stress-strain envelope after the peak in compression) rhoBar positive real value 0=rhoBar<sqrt(2/3) H positive real value (usually less than \\(E)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">theta</code></td> <td><p>positive real value 0=\\) theta=1 (with: 0 hardening kinematic only and 1 hardening isotropic only tangent 0: computational tangent; 1: damaged secant stiffness (hint: in case of strong nonlinearities use it with Krylov-Newton algorithm) Default values: The Damage2p object hve the following defualt parameters: fct = 0.1*abs(fcc) E = 4750*sqrt(abs(fcc)) if abs(fcc)<2000 because fcc is assumed in MPa (see ACI 318) = 57000*sqrt(abs(fcc)) if abs(fcc)>2000 because fcc is assumed in psi (see ACI 318) ni \u2019 = 0.15 (from comparison with tests by Kupfer Hilsdorf Rusch 1969) \u2019 \\(Gt</strong></p></td> <td><p>= 1840*fct*fct/E (from comparison with tests by Gopalaratnam and Shah 1985)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">Gc</code></td> <td><p>= 6250*fcc*fcc/E (from comparison with tests by Karsan and Jirsa 1969)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rhoBar</code></td> <td><p>= 0.2 (from comparison with tests by Kupfer Hilsdorf Rusch 1969)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">H</code></td> <td><p>= 0.25*E (from comparison with tests by Karsan and Jirsa 1969 and Gopalaratnam and Shah 1985)</p></td> </tr> <tr class=\"even\"> <td><p><strong>'\\) theta = 0.5 (from comparison with tests by Karsan and Jirsa 1969 and Gopalaratnam and Shah 1985) tangent = 0 Development Team This code has been Developed by: Leopoldo Tesser - Dept. DICEA - Univeristy of Padua - Italy , contact: leopoldo.tesser AT dicea.unipd.it References Tesser L.,\u201cEfficient 3-D plastic damage model for cyclic inelastic analysis of concrete structures\u201d, Report of the University of Padua, Italy, 2012. (soon available at paduareserach.cab.unipd.it) Petek K.A., \u201cDevelopment and application of mixed beam-solid models for analysis of soil-pile interaction problems\u201d, Ph.D. dissertation, Univerisity of Washington, USA, 2006","title":"Damage2p\n"},{"location":"contrib/modeling/ndmaterial/160-Drucker%20Prager/","text":"DruckerPrager This command is used to construct an multi dimensional material object that has a Drucker-Prager yield criterium. nDMaterial DruckerPrager $matTag $k $G $sigmaY $rho $rhoBar $Kinf $Ko $delta1 $delta2 $H $theta $density &lt; $atmPressure &gt; matTag integer tag identifying material k bulk modulus G shear modulus sigmaY yield stress rho frictional strength parameter rhoBar controls evolution of plastic volume change, \\(0 \\le \\texttt{rhoBar} \\le \\texttt{rho}\\) Kinf nonlinear isotropic strain hardening parameter, \\(\\texttt{Kinf} \\ge 0\\) Ko nonlinear isotropic strain hardening parameter, $Ko &ge; 0 delta1 nonlinear isotropic strain hardening parameter, $delta1 &ge; 0 delta2 tension softening parameter, \\(\\texttt{delta2} \\ge 0\\) H linear strain hardening parameter, \\(\\texttt{H} \\ge 0\\) theta controls relative proportions of isotropic and kinematic hardening, \\(0 \\le \\texttt{theta} \\le 1\\) density mass density of the material <$atmPressure> optional atmospheric pressure for update of elastic bulk and shear moduli (default = 101 kPa) The material formulations for the Drucker-Prager object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d This code has been Developed by: Peter Mackenzie, U Washington and the great Pedro Arduino, U Washington Theory The yield condition for the Drucker-Prager model can be expressed as \\[f\\left(\\mathbf{\\sigma}, q^{iso}, \\mathbf{q}^{kin}\\right) = \\left\\| \\mathbf{s} + \\mathbf{q}^{kin} \\right\\| + \\rho I_1 + \\sqrt{\\frac{2}{3}} q^{iso} - \\sqrt{\\frac{2}{3}} \\sigma_Y^{} \\leq 0 \\] in which \\[ \\mathbf{s} = \\mathrm{dev} (\\mathbf{\\sigma}) = \\mathbf{\\sigma} - \\frac{1}{3} I_1 \\mathbf{1} \\] is the deviatoric stress tensor, \\[ I_1 = \\mathrm{tr}(\\mathbf{\\sigma}) \\] is the first invariant of the stress tensor, and the parameters \\(\\rho_{}^{}\\) and \\(\\sigma_Y^{}\\) are positive material constants. The isotropic hardening stress is defined as \\[ q^{iso} = \\theta H \\alpha^{iso} + (K_{\\infty} - K_o) \\exp(-\\delta_1 \\alpha^{iso}) \\] The kinematic hardening stress (or back-stress) is defined as \\[ \\mathbf{q}^{kin} = -(1 - \\theta) \\frac{2}{3} H \\mathbb{I}^{dev} : \\mathbf{\\alpha}^{kin} \\] The yield condition for the tension cutoff yield surface is defined as \\[ f_2(\\mathbf{\\sigma}, q^{ten}) = I_1 + q^{ten} \\leq 0 \\] where \\[ q^{ten} = T_o \\exp(-\\delta_2^{} \\alpha^{ten}) \\] and \\[ T_o = \\sqrt{\\frac{2}{3}} \\frac{\\sigma_Y}{\\rho} \\] Further, general, information on theory for the Drucker-Prager yield criterion can be found at wikipedia here Notes The valid queries to the Drucker-Prager material when creating an ElementRecorder are \u2018strain\u2019 and \u2018stress\u2019 (as with all nDmaterial) as well as \u2018state\u2019. The query \u2018state\u2019 records a vector of state variables during a particular analysis. The columns of this vector are as follows. (Note: If the option \u2018-time\u2019 is included in the creation of the recorder, the first column will be the time variable for each recorded point and the columns below are shifted accordingly.) Column 1 - First invariant of the stress tensor, <math> I_1 = () </math>. Column 2 - The following tensor norm, <math> | + ^{kin} | </math>, where \\(\\mathbf{s}\\) is the deviatoric stress tensor and \\(\\mathbf{q}^{kin}\\) is the back-stress tensor. Column 3 - First invariant of the plastic strain tensor, <math> (^p) </math>. Column 4 - Norm of the deviatoric plastic strain tensor, <math> | ^p | </math>. The Drucker-Prager strength parameters \\(\\rho\\) and \\(\\sigma_Y\\) can be related to the Mohr-Coulomb friction angle, \\(\\phi\\) , and cohesive intercept, \\(c\\) , by evaluating the yield surfaces in a deviatoric plane as described by Chen and Saleeb (1994). By relating the two yield surfaces in triaxial compression, the following expressions are determined \\[ \\rho = \\frac{2 \\sqrt{2} \\sin \\phi}{\\sqrt{3} (3 - \\sin \\phi)} \\] \\[ \\sigma_Y = \\frac{6 c \\cos \\phi}{\\sqrt{2} (3 - \\sin \\phi)} \\] Example This example provides the input file and corresponding results for a confined triaxial compression (CTC) test using a single 8-node brick element and the Drucker-Prager constitutive model. A schematic representation of this test is shown below, (a) depicts the application of hydrostatic pressure, and (b) depicts the application of the deviator stress. Also shown is the stress path resulting from this test plotted on the meridian plane. As shown, the element is loaded until failure, at which point the model can no longer converge, as this is a stress-controlled analysis. # File is generated for the purposes of testing the # Drucker-Prager model -->; conventional triaxial # compression test # # Created: 03.16.2009 CRM # Updated: 12.02.2011 CRM #---> Basic units used are kN and meters ## # create the modelBuilder and build the model</li> wipe model BasicBuilder -ndm 3 -ndf 3 <ol> <li>-- create the nodes</li> </ol> <p>node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 </p> <ol> <li>--triaxial test boundary conditions</li> </ol> <p>fix 1 0 1 1 fix 2 0 0 1 fix 3 1 0 1 fix 4 1 1 1 fix 5 0 1 0 fix 6 0 0 0 fix 7 1 0 0 fix 8 1 1 0 </p> <ol> <li>--define material parameters for the model</li> <li>---bulk modulus</li> </ol> <p> set k 27777.78 </p> <ol> <li>---shear modulus</li> </ol> <p> set G 9259.26 </p> <ol> <li>---yield stress</li> </ol> <p> set sigY 5.0 </p> <ol> <li>---failure surface and associativity</li> </ol> <p> set rho 0.398 set rhoBar 0.398 </p> <ol> <li>---isotropic hardening</li> </ol> <p> set Kinf 0.0 set Ko 0.0 set delta1 0.0 </p> <ol> <li>---kinematic hardening</li> </ol> <p> set H 0.0 set theta 1.0 </p> <ol> <li>---tension softening</li> </ol> <p> set delta2 0.0 </p> <ol> <li>---mass density</li> </ol> <p> set mDen 1.7 </p> <ol> <li>--material models</li> <li> type tag k G sigY rho rhoBar Kinf Ko delta1 delta2 H theta density</li> </ol> <p>nDMaterial DruckerPrager 2 $k $G $sigY $rho $rhoBar $Kinf $Ko $delta1 $delta2 $H $theta $mDen </p> <ol> <li>-- create the element</li> <li> type tag nodes matID bforce1 bforce2 bforce3</li> </ol> <p>element stdBrick 1 1 2 3 4 5 6 7 8 2 0.0 0.0 0.0 </p> <p> puts \"model Built...\" </p> <ol> <li><hr /></li> <li> create the recorders</li> <li><hr /></li> </ol> <p> set step 0.1 </p> <ol> <li>record nodal displacements</li> </ol> <p>recorder Node -file displacements1.out -time -dT $step -nodeRange 1 8 -dof 1 2 3 disp</p> <ol> <li>record the element stress, strain, and state at one of the Gauss points</li> </ol> <p>recorder Element -ele 1 -time -file stress1.out -dT $step material 2 stress recorder Element -ele 1 -time -file strain1.out -dT $step material 2 strain recorder Element -ele 1 -time -file state1.out -dT $step material 2 state </p> <p> puts \"recorders set...\" </p> <ol> <li><hr /></li> <li> create the loading</li> <li><hr /></li> </ol> <ol> <li>--pressure magnitude</li> </ol> <p> set p 10.0 set pNode [expr - $p / 4 ] </p> <ol> <li>--loading object for hydrostatic pressure</li> </ol> <p>pattern Plain 1 { Series -time { 0 10 100 } -values { 0 1 1 } -factor 1 } { load 1 $pNode 0.0 0.0 load 2 $pNode $pNode 0.0 load 3 0.0 $pNode 0.0 load 5 $pNode 0.0 0.0 load 6 $pNode $pNode 0.0 load 7 0.0 $pNode 0.0 } </p> <ol> <li>--loading object deviator stress</li> </ol> <p>pattern Plain 2 { Series -time { 0 10 100 } -values { 0 1 5 } -factor 1 } { load 5 0.0 0.0 $pNode load 6 0.0 0.0 $pNode load 7 0.0 0.0 $pNode load 8 0.0 0.0 $pNode } </p> <ol> <li><hr /></li> <li> create the analysis</li> <li><hr /></li> </ol> <p>integrator LoadControl 0.1 numberer RCM system SparseGeneral constraints Transformation test NormDispIncr 1e-5 10 1 algorithm Newton analysis Static</p> <p> puts \"starting the hydrostatic analysis...\" set startT [clock seconds ] analyze 1000 </p> <p> set endT [clock seconds ] puts \"triaxial shear application finished...\" puts \"loading analysis execution time: [expr $ endT- $ startT] seconds.\" </p> <p>wipe References Drucker, D. C. and Prager, W., \u201cSoil mechanics and plastic analysis for limit design.\u201d Quarterly of Applied Mathematics, vol. 10, no. 2, pp. 157-165, 1952. Chen, W. F. and Saleeb, A. F., Constitutive Equations for Engineering Materials Volume I: Elasticity and Modeling. Elsevier Science B.V., Amsterdam, 1994.","title":"DruckerPrager\n"},{"location":"contrib/modeling/ndmaterial/188-Elastic%20Isotropic%20Material/","text":"Elastic Isotropic Material This command is used to construct an ElasticIsotropic material object. nDMaterial ElasticIsotropic $matTag $E $v &lt; $rho &gt; matTag integer tag identifying material E elastic Modulus v Poisson\u2019s ratio rho mass density, optional default = 0.0. The material formulations for the ElasticIsotropic object are \u201cThreeDimensional,\u201d \u201cPlaneStrain,\u201d \u201cPlane Stress,\u201d \u201cAxiSymmetric,\u201d and \u201cPlateFiber.\u201d Code Developed by: Micheal Scott, Oregon State University","title":"Elastic Isotropic Material\n"},{"location":"contrib/modeling/ndmaterial/191-Elastic%20Orthotropic%20Material/","text":"Elastic Orthotropic Material This command is used to construct an ElasticOrthotropic material object. nDMaterial ElasticOrthotropic $matTag $Ex $Ey $Ez $vxy $vyz $vzx $Gxy $Gyz $Gzx &lt; $rho &gt; matTag integer tag identifying material $Ex, $Ey, \\(Ez</strong></p></td> <td><p>elastic modulii in three mutually perpendicular directions (x, y, and z)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) vxy, $vyz, \\(vzx</strong></p></td> <td><p>Poisson's ratios</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) Gxy, $Gyz, $Gzx shear modulii rho mass density, optional default = 0.0. The material formulations for the ElasticOrthotropic object are \u201cThreeDimensional\u201d, \u201cPlaneStrain\u201d, \u201cPlane Stress\u201d, \u201cAxiSymmetric\u201d, \u201cBeamFiber\u201d, and \u201cPlateFiber\u201d. Code Developed by: Micheal Scott, Oregon State University","title":"Elastic Orthotropic Material\n"},{"location":"contrib/modeling/ndmaterial/235-FSAM%20-%202D%20RC%20Panel%20Constitutive%20Behavior/","text":"FSAM - 2D RC Panel Constitutive Behavior Developed and Implemented by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey Leonardo Massone<span style=\u201ccolor:black\u201d>, University of Chile, Santiago John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a nDMaterial FSAM (Fixed-Strut-Angle-Model, Figure 1, Kolozvari et al., 2015), which is a plane-stress constitutive model for simulating the behavior of RC panel elements under generalized, in-plane, reversed-cyclic loading conditions (Ulugtekin, 2010; Orakcal et al., 2012). In the FSAM constitutive model, the strain fields acting on concrete and reinforcing steel components of a RC panel are assumed to be equal to each other, implying perfect bond assumption between concrete and reinforcing steel bars. While the reinforcing steel bars develop uniaxial stresses under strains in their longitudinal direction, the behavior of concrete is defined using stress-strain relationships in biaxial directions, the orientation of which is governed by the state of cracking in concrete. Although the concrete stress-strain relationship used in the FSAM is fundamentally uniaxial in nature, it also incorporates biaxial softening effects including compression softening and biaxial damage. For transfer of shear stresses across the cracks, a friction-based elasto-plastic shear aggregate interlock model is adopted, together with a linear elastic model for representing dowel action on the reinforcing steel bars (Kolozvari, 2013). Note that FSAM constitutive model is implemented to be used with Shear-Flexure Interaction model for RC walls ( SFI_MVLEM ), but it could be also used elsewhere. Source: /usr/local/cvs/OpenSees/SRC/material/nD/reinforcedConcretePlaneStress/ Figure 1. FSAM for Converting In-Plane Strains to In-Plane Smeared Stresses on a RC Panel Element Input Format: nDMaterial FSAM $mattag $rho $sX $sY $conc $rouX $rouY $nu $alfadow mattag Unique nDMaterial tag rho Material density sX Tag of uniaxialMaterial simulating horizontal (x) reinforcement sY Tag of uniaxialMaterial simulating vertical (y) reinforcement conc Tag of uniaxialMaterial<sup class=\u201csuperscript\u201d>1</sup> simulating concrete rouX Reinforcing ratio in horizontal (x) direction (rouX = A<sub class=\u201csubscript\u201d>s,x</sub>/A<sub class=\u201csubscript\u201d>gross,x</sub>) rouY Reinforcing ratio in vertical (y) direction (rouY = A<sub class=\u201csubscript\u201d>s,y</sub>/A<sub class=\u201csubscript\u201d>gross,y</sub>) nu Concrete friction coefficient (0.0 < nu < 1.5) alfadow Stiffness coefficient of reinforcement dowel action (0.0 < alfadow < 0.05) <sup class=\u201csuperscript\u201d>1</sup>nDMaterial FSAM shall be used with uniaxialMaterial ConcreteCM Recommended values for parameter of a shear resisting mechanism ( nu and alfadow , Figure 2) are provided above. Details about the sensitivity of analytical predictions using SFI_MVLEM element to changes in these parameters are presented by Kolozvari (2013). Material Recorders: The following output is available from the FSAM RC panel model: panel_strain Strains \u03b5<sub class=\u201csubscript\u201d>x</sub>, \u03b5<sub class=\u201csubscript\u201d>y</sub>, &gamma;<sub class=\u201csubscript\u201d>xy</sub> (Figure 1) panel_stress Resulting panel stresses \u03c3<sub class=\u201csubscript\u201d>x</sub>, \u03c3<sub class=\u201csubscript\u201d>y</sub>, &tau;<sub class=\u201csubscript\u201d>xy</sub> (concrete and steel, Figure 1) panel_stress_concrete Resulting panel concrete stresses \u03c3<sub class=\u201csubscript\u201d>xc</sub>, \u03c3<sub class=\u201csubscript\u201d>yc</sub>, &tau;<sub class=\u201csubscript\u201d>xyc</sub> (Figure 2b) panel_stress_steel Resulting panel steel stresses \u03c3<sub class=\u201csubscript\u201d>xs</sub>, \u03c3<sub class=\u201csubscript\u201d>ys</sub>, &tau;<sub class=\u201csubscript\u201d>xys</sub> (Figure 2e) strain_stress_steelX Uniaxial strain and stress of horizontal reinforcement \u03b5<sub class=\u201csubscript\u201d>x</sub>, \u03c3<sub class=\u201csubscript\u201d>xxs</sub> (Figure 2f) strain_stress_steelY Uniaxial strain and stress of vertical reinforcement \u03b5<sub class=\u201csubscript\u201d>y</sub>, \u03c3<sub class=\u201csubscript\u201d>yys</sub> (Figure 2f) strain_stress_concrete1 Uniaxial strain and stress of concrete strut 1 \u03b5<sub class=\u201csubscript\u201d>c1</sub>, \u03c3<sub class=\u201csubscript\u201d>c1</sub> (Figure 2c) strain_stress_concrete2 Uniaxial strain and stress of concrete strut 2 \u03b5<sub class=\u201csubscript\u201d>c2</sub>, \u03c3<sub class=\u201csubscript\u201d>c2</sub> (Figure 2c) strain_stress_interlock1 Shear strain and stress in concrete along crack 1 \u03b5<sub class=\u201csubscript\u201d>cr1</sub>, &tau;<sub class=\u201csubscript\u201d>cr1</sub> (Figure 2d) strain_stress_interlock2 Shear strain and stress in concrete along crack 2 \u03b5<sub class=\u201csubscript\u201d>cr2</sub>, &tau;<sub class=\u201csubscript\u201d>cr2</sub> (Figure 2d) cracking_angles Orientation of concrete cracks Note that recorders for a RC panel (marco-fiber) are invoked as SFI_MVLEM element recorders using command RCPanel and one of the desired commands listed above. Currently, it is possible to output values only for one macro-fiber within one or multiple elements. Example: nDMaterial FSAM 1 0.0 1 2 4 0.0073 0.0606 0.1 0.01 Recorder Element -file MVLEM_panel_strain.out -time -ele 1 RCPanel 1 panel_strain Figure 2. Behavior and Input/Output Parameters of the FSAM Constitutive Model References: Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Kolozvari K. (2013). \u201cAnalytical Modeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls\u201d, PhD Dissertation, University of California, Los Angeles. Orakcal K., Massone L.M., and Ulugtekin D. (2012). \u201cConstitutive Modeling of Reinforced Concrete Panel Behavior under Cyclic Loading\u201d, Proceedings, 15th World Conference on Earthquake Engineering, Lisbon, Portugal. Ulugtekin D. (2010). \u201cAnalytical Modeling of Reinforced Concrete Panel Elements under Reversed Cyclic Loadings\u201d, M.S. Thesis, Bogazici University, Istanbul, Turkey.","title":"FSAM - 2D RC Panel Constitutive Behavior\n"},{"location":"contrib/modeling/ndmaterial/254-FluidSolidPorousMaterial/","text":"FluidSolidPorousMaterial FluidSolidPorousMaterial couples the responses of two phases: fluid and solid. The fluid phase response is only volumetric and linear elastic. The solid phase can be any NDMaterial. This material is developed to simulate the response of saturated porous media under fully undrained condition. OUTPUT INTERFACE: The following information may be extracted for this material at given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001): \u201cstress\u201d , \u201cstrain\u201d , \u201ctangent\u201d , or \u201cpressure\u201d . The \u201cpressure\u201d option records excess pore pressure and excess pore pressure ratio at a given material integration point. nDMaterial FluidSolidPorousMaterial $tag $nd $soilMatTag \\(combinedBulkModul &lt;\\) pa=101> Tag A positive integer uniquely identifying the element among all elements nd Number of dimensions, 2 for plane-strain, and 3 for general 3D analysis. soilMatTag The material number for the solid phase material (previously defined). combinBulkModul Combined undrained bulk modulus B<sub>c</sub> relating changes in pore pressure and volumetric strain, may be approximated by: B<sub>c</sub> &asymp; B<sub>f</sub> /n where B<sub>f</sub> is the bulk modulus of fluid phase (2.2x10<sup>6</sup> kPa (or 3.191x10<sup>5</sup> psi) for water), and n the initial porosity. $p<sub>a</sub> Optional atmospheric pressure for normalization (typically 101 kPa in SI units, or 14.65 psi in English units) NOTE: Buoyant unit weight (total unit weight - fluid unit weight) should be used in definition of the finite elements composed of a FluidSolidPorousMaterial . During the application of gravity (elastic) load, the fluid phase does not contribute to the material response. Fluid Solid Porous Material Examples: <table border=1 width=800> <tr> <td colspan=2 align=center ><b>Pressure Dependent Material in saturated, undrained elastic-plastic state (coupled with FluidSolidPorous Material)</b></td> </tr> <tr> <td> Example 1 </td> <td>Single quadrilateral element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 2 </td> <td>Single quadrilateral element, subjected to monotonic pushover</td> </tr> <tr> <td> Example 3 </td> <td>Single quadrilateral element (inclined by 4 degrees), subjected to msinusoidal base shaking</td> </tr> <tr> <td> Example 4 </td> <td>Single 3D BbarBrick element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 5 </td> <td>Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 6 </td> <td>A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> </table> Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"FluidSolidPorousMaterial\n"},{"location":"contrib/modeling/ndmaterial/338-InitialStateAnalysisWrapper/","text":"InitialStateAnalysisWrapper This command is used to construct an InitialStateAnalysisWrapper nDMaterial object. nDMaterial InitialStateAnalysisWrapper $matTag $nDMatTag $nDim eleTag unique integer tag identifying nDMaterial object nDMatTag the tag of the associated nDMaterial object nDim number of dimensions (2 for 2D, 3 for 3D) The InitialStateAnalysisWrapper nDMaterial allows for the use of the InitialStateAnalysis command for setting initial conditions. The InitialStateAnalysisWrapper can be used with any nDMaterial. This material wrapper allows for the development of an initial stress field while maintaining the original geometry of the problem. An example analysis is provided below to demonstrate the use of this material wrapper object. NOTES: There are no valid recorder queries for the InitialStateAnalysisWrapper. The InitialStateAnalysis off command removes all previously defined recorders. Two sets of recorders are needed if the results before and after this command are desired. See the example below for more. The InitialStateAnalysisWrapper material is somewhat tricky to use in dynamic analysis. Sometimes setting the displacement to zero appears to be interpreted as an initial displacement in subsequent steps, resulting in undesirable vibrations. EXAMPLES: InitialStateAnalysisWrapper definition with material tag 1, and associated nDMaterial tag 2 for a 2D analysis nDMaterial InitialStateAnalysisWrapper 1 2 2 Code Developed by: Chris McGann, Pedro Arduino, & Peter Mackenzie-Helnwein, at the University of Washington EXAMPLE ANALYSIS: The example input file below demonstrates an how the InitialStateAnalysis command can be used with the InitialStateAnalysisWrapper to generate a gravitational state of stress in a single element. As shown below, the use of the InitialStateAnalysis command necessitates the use of two sets of recorders, one to record results during the initial state analysis, and one for all subsequent steps. It is not required to record results during the initial state analysis, but the example below includes this data to demonstrate the effect of the InitialStateAnalysis command. At the end of the analysis, there should be non-zero stress and strain in the element with zero displacement. wipe</p> <p>model BasicBuilder -ndm 3 -ndf 3 </p> <ol> <li> create the nodes</li> </ol> <p>node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 </p> <ol> <li>boundary conditions</li> </ol> <p>fix 1 1 1 1 fix 2 1 1 1 fix 3 1 1 1 fix 4 1 1 1 fix 5 1 1 0 fix 6 1 1 0 fix 7 1 1 0 fix 8 1 1 0 </p> <ol> <li>define main material obeject</li> </ol> <p>nDMaterial ElasticIsotropic 1 25000 0.35 </p> <ol> <li>define material wrapper</li> </ol> <p>nDMaterial InitialStateAnalysisWrapper 2 1 3 </p> <ol> <li> create the element (NOTE: the material tag associated with this element is that of the wrapper)</li> </ol> <p>element SSPbrick 1 1 2 3 4 5 6 7 8 2 0.0 0.0 -17 .0 </p> <ol> <li> create the pre-gravity recorders</li> </ol> <p> set step 0.1 </p> <p>recorder Node -time -file Gdisp.out -dT $step -nodeRange 5 8 -dof 1 2 3 disp recorder Element -ele 1 -time -file Gstress.out -dT $step stress recorder Element -ele 1 -time -file Gstrain.out -dT $step strain</p> <ol> <li> create the gravity analysis</li> </ol> <p>integrator LoadControl 0.5 numberer RCM system SparseGeneral constraints Transformation test NormDispIncr 1e-5 40 1 algorithm Newton analysis Static</p> <ol> <li>turn on the initial state analysis feature</li> </ol> <p>InitialStateAnalysis on</p> <ol> <li>analyze four steps</li> </ol> <p>analyze 4 </p> <ol> <li>turn off the initial state analysis feature</li> </ol> <p>InitialStateAnalysis off</p> <ol> <li> create post -gravity recorders</li> </ol> <p>recorder Node -time -file disp.out -dT $step -nodeRange 5 8 -dof 1 2 3 disp recorder Element -ele 1 -time -file stress.out -dT $step stress recorder Element -ele 1 -time -file strain.out -dT $step strain</p> <ol> <li>analyze for three steps, should have non-zero stress and strain with zero displacement</li> </ol> <p>analyze 3 </p> <p>wipe","title":"InitialStateAnalysisWrapper\n"},{"location":"contrib/modeling/ndmaterial/348-J2%20Plasticity%20Material/","text":"J2 Plasticity Material This command is used to construct an multi dimensional material object that has a von Mises (J2) yield criterium and isotropic hardening. nDMaterial J2Plasticity $matTag $K $G $sig0 $sigInf $delta $H matTag integer tag identifying material K bulk modulus G shear modulus sig0 initial yield stress sigInf final saturation yield stress delta exponential hardening parameter H linear hardening parameter The material formulations for the J2 object are \u201cThreeDimensional,\u201d \u201cPlaneStrain,\u201d \u201cPlane Stress,\u201d \u201cAxiSymmetric,\u201d and \u201cPlateFiber.\u201d Theory The theory for the non hardening case can be found http://en.wikipedia.org/wiki/Von_Mises_yield_criterion J2 isotropic hardening material class Elastic Model <math> = K*trace(_e) + (2 G) dev(_e)</math> Yield Function <math> (,q) = || dev() || - (*q(xi)</math> Saturation Isotropic Hardening with linear term <math> q(xi) = 0 + ( - _0) exp(-delta ) + H*</math> Flow Rules <math> = </math> <math> = - </math> Linear Viscosity <math>= </math> ( if <math> > 0</math> ) Backward Euler Integration Routine Yield condition enforced at time n+1 set $= 0 $ for rate independent case Code Developed by: Ed Love","title":"J2 Plasticity Material\n"},{"location":"contrib/modeling/ndmaterial/378-Manzari%20Dafalias%20Material/","text":"Manzari Dafalias Material This command is used to construct a multi-dimensional Manzari-Dafalias(2004) material. nDmaterial ManzariDafalias $matTag $G0 $nu $e_init $Mc $c $lambda_c $e0 $ksi $P_atm $m $h0 $ch $nb $A0 $nd $z_max $cz $Den matTag integer tag identifying material G0 shear modulus constant nu poisson ratio e_init initial void ratio Mc critical state stress ratio c ratio of critical state stress ratio in extension and compression lambda_c critical state line constant e0 critical void ratio at p = 0 ksi critical state line constant P_atm atmospheric pressure m yield surface constant (radius of yield surface in stress ratio space) h0 constant parameter ch constant parameter nb bounding surface parameter, $nb &ge; 0 A0 dilatancy parameter nd dilatancy surface parameter $nd &ge; 0 z_max fabric-dilatancy tensor parameter cz fabric-dilatancy tensor parameter Den mass density of the material The material formulations for the Manzari-Dafalias object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d Code Developed by: Alborz Ghofrani, Pedro Arduino, U Washington Notes Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for <math></math> fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for <math></math> e.g. recorder Element -eleRange 1 $numElem -time -file stress.out stress Elastic or Elastoplastic response could be enforced by {| |Elastic: ||updateMaterialStage -material $matTag -stage 0 |- |Elastoplastic: ||updateMaterialStage -material $matTag -stage 1 |} Theory <math> p = () </math> <math> = () = - p </math> Elasticity Elastic moduli are considered to be functions of p and current void ratio: \\[ G = G_0 p_{atm}\\frac{\\left(2.97-e\\right)^2}{1+e}\\left(\\frac{p}{p_{atm}}\\right)^{1/2} \\] \\[K = \\frac{2(1+\\nu)}{3(1-2\\nu)} G \\] The elastic stress-strain relationship is: \\[ d\\mathbf{e}^\\mathrm{e} = \\frac{d\\mathbf{s}}{2G} \\] \\[ d\\varepsilon^\\mathrm{e}_v = \\frac{dp}{K} \\] Critical State Line A power relationship is assumed for the critical state line: \\[e_c = e_0 - \\lambda_c\\left(\\frac{p_c}{p_{atm}}\\right)^\\xi \\] where \\(e_0\\) is the void ratio at <math> p_c = 0 </math> and $_c $ and $$ constants. Yield Surface Yield surface is a stress-ratio dependent surface in this model and is defined as $$ | - p | - pm = 0 </math> with $ $ being the deviatoric back stress-ratio. Plastic Strain Increment The increment of the plastic strain tensor is given by \\[ d\\mathbf{\\varepsilon}^p = \\langle L \\rangle \\mathbf{R} \\] where $$ = + D </math> therefore $$ d^p = L </math> and $d^p_v = L D $ The hardening modulus in this model is defined as $$ K_p = p h (^b_{} - ): </math> where \\(\\mathbf{n}\\) is the deviatoric part of the gradient to yield surface. $$ ^b_{} = </math>, \\(\\Psi\\) being the state parameter. the hardening parameter $h $ is defined as $$ h = </math>, \\(\\mathbf{\\alpha_{in}}\\) is the value of \\(\\mathbf{\\alpha}\\) at initiation of loading cycle. \\[b_0 = G_0 h_0 (1-c_h e) \\left(\\frac{p}{p_{atm}}\\right)^{-1/2} \\] Also the dilation parameters are defined as \\[ D = A_d (\\mathbf{\\alpha}^d_{\\theta}-\\mathbf{\\alpha}) : \\mathbf{n} \\] \\[ \\mathbf{\\alpha}^d_{\\theta} = \\sqrt{\\frac{2}{3}} \\left[g(\\theta,c) M_c exp(n^d\\Psi) - m\\right] \\mathbf{n} \\] $$ A_d = A_0 (1+) </math>, where $ $ is the fabric tensor. The evolution of fabric and the back stress-ratio tensors are defined as \\[d\\mathbf{z} = - c_z \\langle -d\\varepsilon^p_v \\rangle (z_{max}\\mathbf{n}+\\mathbf{z}) \\] \\[ d\\mathbf{\\alpha} = \\langle L \\rangle (2/3) h (\\mathbf{\\alpha}^b_{\\theta} - \\mathbf{\\alpha}) \\] Example This example, provides an undrained confined triaxial compression test using one 8-node SSPBrickUP element and ManzariDafalias material model. </p> <ol> <li>HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH #</li> <li>3D Undrained Conventional Triaxial Compression Test Using One Element #</li> <li>University of Washington, Department of Civil and Environmental Eng #</li> <li>Geotechnical Eng Group, A. Ghofrani, P. Arduino - Dec 2013 #</li> <li>Basic units are m, Ton(metric), s #</li> <li>HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH #</li> </ol> <p>wipe</p> <ol> <li>------------------------ #</li> <li>Test Specific parameters #</li> <li>------------------------ #</li> <li>Confinement Stress</li> </ol> <p> set pConf -300 .0 </p> <ol> <li>Deviatoric strain</li> </ol> <p> set devDisp -0 .3 </p> <ol> <li>Permeablity</li> </ol> <p> set perm 1.0e-10 </p> <ol> <li>Initial void ratio</li> </ol> <p> set vR 0.8 </p> <ol> <li>Rayleigh damping parameter</li> </ol> <p> set damp 0.1 set omega1 0.0157 set omega2 64.123 set a1 [expr 2.0 * $damp /( $omega1 + $omega2 ) ] set a0 [expr $a1 * $omega1 * $omega2 ] </p> <ol> <li>HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH</li> <li>HHHHHHHHHHHHHHHHHHHHHHHHHHHCreate ModelHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH</li> <li>HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH</li> </ol> <ol> <li>Create a 3D model with 4 Degrees of Freedom</li> </ol> <p>model BasicBuilder -ndm 3 -ndf 4 </p> <ol> <li>Create nodes</li> </ol> <p>node 1 1.0 0.0 0.0 node 2 1.0 1.0 0.0 node 3 0.0 1.0 0.0 node 4 0.0 0.0 0.0 node 5 1.0 0.0 1.0 node 6 1.0 1.0 1.0 node 7 0.0 1.0 1.0 node 8 0.0 0.0 1.0 </p> <ol> <li>Create Fixities</li> </ol> <p>fix 1 0 1 1 1 fix 2 0 0 1 1 fix 3 1 0 1 1 fix 4 1 1 1 1 fix 5 0 1 0 1 fix 6 0 0 0 1 fix 7 1 0 0 1 fix 8 1 1 0 1 </p> <ol> <li>Create material</li> <li>ManzariDafalias tag G0 nu e_init Mc c lambda_c e0 ksi P_atm m h0 ch nb A0 nd z_max cz Den</li> </ol> <p>nDMaterial ManzariDafalias 1 125 0.05 $vR 1.25 0.712 0.019 0.934 0.7 100 0.01 7.05 0.968 1.1 0.704 3.5 4 600 1.42 </p> <ol> <li>Create element</li> <li>SSPbrickUP tag i j k l m n p q matTag fBulk fDen k1 k2 k3 void alpha &lt;b1 b2 b3&gt;</li> </ol> <p>element SSPbrickUP 1 1 2 3 4 5 6 7 8 1 2.2e6 1.0 $perm $perm $perm $vR 1.5e-9 </p> <ol> <li>Create recorders</li> </ol> <p>recorder Node -file disp.out -time -nodeRange 1 8 -dof 1 2 3 disp recorder Node -file press.out -time -nodeRange 1 8 -dof 4 vel recorder Element -file stress.out -time stress recorder Element -file strain.out - time strain recorder Element -file alpha.out -time alpha recorder Element -file fabric.out -time fabric</p> <ol> <li>Create analysis</li> </ol> <p>constraints Penalty 1.0e18 1.0e18 test NormDispIncr 1.0e-5 20 1 algorithm Newton numberer RCM system BandGeneral integrator Newmark 0.5 0.25 rayleigh $a0 0. $a1 0.0 analysis Transient</p> <ol> <li>Apply confinement pressure</li> </ol> <p> set pNode [expr $pConf / 4.0 ] pattern Plain 1 { Series -time { 0 10000 1e10 } -values { 0 1 1 } -factor 1 } { load 1 $pNode 0.0 0.0 0.0 load 2 $pNode $pNode 0.0 0.0 load 3 0.0 $pNode 0.0 0.0 load 4 0.0 0.0 0.0 0.0 load 5 $pNode 0.0 $pNode 0.0 load 6 $pNode $pNode $pNode 0.0 load 7 0.0 $pNode $pNode 0.0 load 8 0.0 0.0 $pNode 0.0 } analyze 100 100 </p> <ol> <li>Let the model rest and waves damp out</li> </ol> <p>analyze 50 100 </p> <ol> <li>Close drainage valves</li> </ol> <p> for {set x 1 } { $x &lt; 9 } {incr x } { remove sp $x 4 } analyze 50 100 </p> <ol> <li>Read vertical displacement of top plane</li> </ol> <p> set vertDisp [ nodeDisp 5 3 ] </p> <ol> <li>Apply deviatoric strain</li> </ol> <p> set lValues [list 1 [expr 1 + $devDisp / $vertDisp ] [expr 1 + $devDisp / $vertDisp ]] set ts \"{Series -time {20000 1020000 10020000} -values { $ lValues} -factor 1}\" </p> <ol> <li>loading object deviator stress</li> </ol> <p> eval \"pattern Plain 2 $ ts { sp 5 3 $ vertDisp sp 6 3 $ vertDisp sp 7 3 $ vertDisp sp 8 3 $ vertDisp }\" </p> <ol> <li>Set number and length of (pseudo) time steps</li> </ol> <p> set dT 100 set numStep 10000 </p> <ol> <li>Analyze and use substepping if needed</li> </ol> <p> set remStep $numStep set success 0 proc subStepAnalyze { dT subStep } { if { $subStep &gt; 10 } { return -10 } for {set i 1 } { $i &lt; 3 } {incr i } { puts \"Try dT = $ dT\" set success [ analyze 1 $dT ] if { $success != 0 } { set success [ subStepAnalyze [expr $dT / 2.0 ] [expr $subStep + 1 ]] if { $success == -10 } { puts \"Did not converge.\" return success } } else { if { $i == 1 } { puts \"Substep $ subStep : Left side converged with dT = $ dT\" } else { puts \"Substep $ subStep : Right side converged with dT = $ dT\" } } } return success } </p> <p> puts \"Start analysis\" set startT [clock seconds ] </p> <p> while { $success != -10 } { set subStep 0 set success [ analyze $remStep $dT ] if { $success == 0 } { puts \"Analysis Finished\" break } else { set curTime [ getTime ] puts \"Analysis failed at $ curTime . Try substepping.\" set success [ subStepAnalyze [expr $dT / 2.0 ] [incr subStep ]] set curStep [expr int(( $curTime -20000 )/ $dT + 1 ) ] set remStep [expr int( $numStep - $curStep ) ] puts \"Current step: $ curStep , Remaining steps: $ remStep\" } } set endT [clock seconds ] puts \"loading analysis execution time: [expr $ endT- $ startT] seconds.\" </p> <p>wipe References Dafalias YF, Manzari MT. \u201cSimple plasticity sand model accounting for fabric change effects\u201d. Journal of Engineering Mechanics 2004","title":"Manzari Dafalias Material\n"},{"location":"contrib/modeling/ndmaterial/405-MultiYieldSurfaceClay/","text":"MultiYieldSurfaceClay The \u2018MultiYieldSurfaceClay\u2019 is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is pressure independent. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. This material is available for sensitivity computation in both 2-D and 3-D models. It is another version of PressureIndependMultiYield material. However there are three differences between this model and PressureIndependMultiYield: This model uses the consistent tangent modulus instead of the continuum tangent modulus. This model does not support the \u2018updateMaterialStage\u2019 command. This model does not support further discretization of the strain increment in each iteration. nDmaterial MultiYieldSurfaceClay $matTag $nd $rho $G $K $cohesion $peakShearStrain matTag unique material object integer tag nd number of dimensions, 2 for 2-D analysis (plane-strain), and 3 for 3-D analysis rho saturated soil mass density G reference low-strain shear modulus K reference bulk modulus cohesion peak shear (apparent cohesion at zero effective confinement) peakShearStrain strain at peak shear, i.e., the octahedral shear strain at which the maximum shear strength is reached Note: For this material class, the sensitivity parameters can be: G, K, cohesion. Reference: Gu Q., Conte J.P., Elgamal A., Yang Z. (2009). \u201cFinite element response sensitivity analysis of multi-yield-surface J2 plasticity model by direct differentiation method.\u201d Computer Methods in Applied Mechanics and Engineering, 198(30-32):2272-2285.","title":"MultiYieldSurfaceClay\n"},{"location":"contrib/modeling/ndmaterial/487-PM4Sand%20Material/","text":"PM4Sand This page has been moved to the new OpenSees documentation site This command is used to construct a 2-dimensional PM4Sand material. nDmaterial PM4Sand $matTag $Dr $G0 $hpo $Den &lt; $patm $h0 $emax $emin $nb $nd $Ado $zmax $cz $ce $phic $nu $cgd $cdr $ckaf $Q $R $m $Fsed_min $p_sedo &gt; matTag integer tag identifying material Primary : Dr Relative density, in fraction G0 Shear modulus constant hpo Contraction rate parameter Den Mass density of the material Secondary : P_atm Optional , Atmospheric pressure h0 Optional , Variable that adjusts the ratio of plastic modulus to elastic modulus $emax and $emin Optional , Maximum and minimum void ratios nb Optional , Bounding surface parameter, $nb &ge; 0 nd Optional , Dilatancy surface parameter $nd &ge; 0 Ado Optional , Dilatancy parameter, will be computed at the time of initialization if input value is negative z_max Optional , Fabric-dilatancy tensor parameter cz Optional , Fabric-dilatancy tensor parameter ce Optional , Variable that adjusts the rate of strain accumulation in cyclic loading phic Optional , Critical state effective friction angle nu Optional , Poisson\u2019s ratio cgd Optional , Variable that adjusts degradation of elastic modulus with accumulation of fabric cdr Optional , Variable that controls the rotated dilatancy surface ckaf Optional , Variable that controls the effect that sustained static shear stresses have on plastic modulus Q Optional , Critical state line parameter R Optional , Critical state line parameter m Optional , Yield surface constant (radius of yield surface in stress ratio space) Fsed_min Optional , Variable that controls the minimum value the reduction factor of the elastic moduli can get during reconsolidation p_sedo Optional , Mean effective stress up to which reconsolidation strains are enhanced The material formulation for the PM4Sand object is \u201cPlaneStrain\u201d Code Developed by: Long Chen, Pedro Arduino, U Washington Notes This page has been moved to the new OpenSees documentation site Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for <math></math> fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for <math></math> e.g. recorder Element -eleRange 1 $numElem -time -file stress.out stress Elastic or Elastoplastic response could be enforced by {| |Elastic: ||updateMaterialStage -material $matTag -stage 0 |- |Elastoplastic: ||updateMaterialStage -material $matTag -stage 1 |} The program will use the default value of a secondary parameter if a negative input is assigned to that parameter, e.g. Ado = -1. However, FirstCall is mandatory when switching from elastic to elastoplastic if negative inputs are assigned to stress-dependent secondary parameters, e.g. Ado and zmax. FirstCall can be set as, setParameter -value 0 -ele $elementTag FirstCall $matTag Post-shake reconsolidation can be activated by setParameter -value 1 -ele $elementTag Postshake $matTag The user should check that the results are not sensitive to time step size. Example <table border=1 width=600> <tr> <td width=90> Example 1 </td> <td>2D undrained monotonic direct simple shear test using one element</td> </tr> <tr> <td> Example 2 </td> <td>2D undrained cyclic direct simple shear test using one element</td> </tr> </table> References R.W.Boulanger, K.Ziotopoulou. \u201cPM4Sand(Version 3.1): A Sand Plasticity Model for Earthquake Engineering Applications\u201d. Report No. UCD/CGM-17/01 2017","title":"PM4Sand\n"},{"location":"contrib/modeling/ndmaterial/488-PM4Silt%20Material%20%28Beta%29/","text":"PM4Silt Material (Beta) This page has been moved to the new OpenSees documentation site This command is used to construct a 2-dimensional PM4Silt material. nDMaterial PM4Silt $matTag $S_u $Su_Rat $G_o $h_po $Den &lt; $Su_factor $Patm $nu $nG $h0 $eInit $lambda $phicv $nb_wet $nb_dry $nd $Ado $ru_max $zmax $cz $ce $Cgd $ckaf $m_m $CG_consol &gt; matTag integer tag identifying material Primary : S_u Undrained shear strength Su_Rat Undrained shear strength ratio. If both S_u and Su_Rat values are specified, the value of S_u is used. G_o Shear modulus constant h_po Contraction rate parameter Den Mass density of the material Su_factor Optional , Undrained shear strength reduction factor P_atm Optional , Atmospheric pressure Secondary : nu Optional , Poisson\u2019s ratio. Default value is 0.3. nG Optional , Shear modulus exponent. Default value is 0.75. h0 Optional , Variable that adjusts the ratio of plastic modulus to elastic modulus. Default value is 0.5. eInit Optional , Initial void ratios. Default value is 0.90. lambda Optional , The slope of critical state line in e-ln(p) space. Default value is 0.060. phicv Optional , Critical state effective friction angle. Default value is 32 degrees. nb_wet Optional , Bounding surface parameter for loose of critical state conditions, 1.0 &ge; $nb_wet &ge; 0.01. Default value is 0.8. nb_dry Optional , Bounding surface parameter for dense of critical state conditions, $nb_dry &ge; 0. Default value is 0.5. nd Optional , Dilatancy surface parameter $nd &ge; 0. Default value is 0.3. Ado Optional , Dilatancy parameter. Default value is 0.8. ru_max Optional , Maximum pore pressure ratio based on p\u2019. z_max Optional , Fabric-dilatancy tensor parameter cz Optional , Fabric-dilatancy tensor parameter. Default value is 100.0. ce Optional , Variable that adjusts the rate of strain accumulation in cyclic loading cgd Optional , Variable that adjusts degradation of elastic modulus with accumulation of fabric. Default value is 3.0. ckaf Optional , Variable that controls the effect that sustained static shear stresses have on plastic modulus. Default value is 4.0. m_m Optional , Yield surface constant (radius of yield surface in stress ratio space). Default value is 0.01. CG_consol Optional , Reduction factor of elastic modulus for reconsolidation. $CG_consol &ge; 1. Default value is 2.0. The material formulation for the PM4Silt object is \u201cPlaneStrain\u201d Code Developed by: Long Chen, Pedro Arduino, U Washington Notes Valid Element Recorder queries are stress , strain alpha (or backstressratio ) for <math></math> fabric for \\(\\mathbf{z}\\) alpha_in (or alphain ) for <math></math> e.g. recorder Element -eleRange 1 $numElem -time -file stress.out stress Elastic or Elastoplastic response could be enforced by {| |Elastic: ||updateMaterialStage -material $matTag -stage 0 |- |Elastoplastic: ||updateMaterialStage -material $matTag -stage 1 |} If default values are used for secondary parameters, the model must be initialized after elastic gravity stage by setParameter -value 0 -ele $elementTag FirstCall $matTag Post-shake reconsolidation can be activated by setParameter -value 1 -ele $elementTag Postshake $matTag Example <table border=1 width=600> <tr> <td width=90> Example 1 </td> <td>2D undrained monotonic direct simple shear test using one element</td> </tr> <tr> <td> Example 2 </td> <td>2D undrained cyclic direct simple shear test using one element</td> </tr> </table> References R.W.Boulanger, K.Ziotopoulou. \u201cPM4Silt(Version 1): A Silt Plasticity Model for Earthquake Engineering Applications\u201d. Report No. UCD/CGM-18/01 2018","title":"PM4Silt Material (Beta)\n"},{"location":"contrib/modeling/ndmaterial/511-Plane%20Strain%20Material/","text":"Plane Strain Material This command is used to construct a plane-stress material wrapper which converts any three-dimensional material into a plane strain material by imposing plain strain conditions on the three-dimensional material. nDMaterial PlaneStrain $matTag $threeDtag matTag integer tag identifying material threeDTag integer tag of previously defined 3d ndMaterial material The material formulations for the PlaneStrain object are \u201c\u201cPlane Strain\u201d Code Developed by: Antonios Vytiniotis, MIT","title":"Plane Strain Material\n"},{"location":"contrib/modeling/ndmaterial/513-Plane%20Stress%20Material/","text":"Plane Stress Material This command is used to construct a plane-stress material wrapper which converts any three-dimensional material into a plane stress material via static condensation. nDMaterial PlaneStress $matTag $threeDtag matTag integer tag identifying material otherTag tag of perviously defined 3d ndMaterial material The material formulations for the PlaneStress object are \u201c\u201cPlane Stress\u201d Code Developed by: Ed Love","title":"Plane Stress Material\n"},{"location":"contrib/modeling/ndmaterial/514-Plate%20Fiber%20Material/","text":"Plate Fiber Material This command is used to construct a plate-fiber material wrapper which converts any three-dimensional material into a plate fiber material (by static condensation) appropriate for shell analysis. nDMaterial PlateFiber $matTag $threeDTag matTag integer tag identifying material threeDTag material tag for a previously-defined three-dimensional material","title":"Plate Fiber Material\n"},{"location":"contrib/modeling/ndmaterial/537-PressureDependMultiYield02%20Material/","text":"PressureDependMultiYield02 PressureDependMultiYield02 material is modified from PressureDependMultiYield material, with: additional parameters ($contrac3 and \\(dilat3) to account for K&amp;sigma; effect,</li> <li>a parameter to account for the influence of previous dilation history on subsequent contraction phase (\\) contrac2), and modified logic related to permanent shear strain accumulation ($liquefac1 and $liquefac2). nDMaterial PressureDependMultiYield02 $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $contrac1 $contrac3 $dilat1 \\(dilat3 &lt;\\) noYieldSurf=20 <$r1 $Gs1 \u2026> $contrac2=5. $dilat2=3. $liquefac1=1. $liquefac2=0. $e=0.6 $cs1=0.9 $cs2=0.02 $cs3=0.7 \\(pa=101 &lt;\\) c=0.1>> contrac3 A non-negative constant reflecting K&sigma; effect. dilat3 A non-negative constant reflecting K&sigma; effect. contrac2 A non-negative constant reflecting dilation history on contraction tendency. liquefac1 Damage parameter to define accumulated permanent shear strain as a function of dilation history. (Redefined and different from PressureDependMultiYield material). liquefac2 Damage parameter to define biased accumulation of permanent shear strain as a function of load reversal history. (Redefined and different from PressureDependMultiYield material). c Numerical constant (default value = 0.1 kPa) Others See PressureDependMultiYield material above. NOTE: The following values are suggested for the model parameters. Dr=30% Dr=40% Dr=50% Dr=60% Dr=75% rho 1.7 ton/m<sup>3</sup> or 1.59x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.8 ton/m<sup>3</sup> or 1.685x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.9 ton/m<sup>3</sup> or 1.778x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.0 ton/m<sup>3</sup> or 1.872x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.1 ton/m<sup>3</sup> or 1.965x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> refShearModul (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 6x10<sup>4</sup> kPa or 8.702x10<sup>3</sup> psi 9x10<sup>4</sup> kPa or 1.305x10<sup>4</sup> psi 10x10<sup>4</sup> kPa or 1.45x10<sup>4</sup> psi 11x10<sup>4</sup> kPa or 1.595x10<sup>4</sup> psi 13x10<sup>4</sup> kPa or 1.885x10<sup>4</sup> psi refBulkModu (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 16x10<sup>4</sup> kPa or 2.321x10<sup>4</sup> psi (K<sub>o</sub>=0.5) 22x10<sup>4</sup> kPa or 3.191x10<sup>4</sup> psi (K<sub>o</sub>=0.47) 23.3x10<sup>4</sup> kPa or 3.379x10<sup>4</sup> psi (K<sub>o</sub>=0.45) 24x10<sup>4</sup> kPa or 3.481x10<sup>4</sup> psi (K<sub>o</sub>=0.43) 26x10<sup>4</sup> kPa or 3.771x10<sup>4</sup> psi (K<sub>o</sub>=0.4) frictionAng 31 32 33.5 35 36.5 PTAng 31 26 25.5 26 26 peakShearStra (at p\u2019<sub>r</sub>=101 kPa or 14.65 psi) <center>0.1</center> refPress (p\u2019<sub>r</sub>,) <center>101 kPa or 14.65 psi</center> pressDependCoe <center>0.5</center> Contrac1 0.087 0.067 0.045 0.028 0.013 Contrac3 0.18 0.23 0.15 0.05 0.0 dilat1 0. 0.06 0.06 0.1 0.3 dilat3 0.0 0.27 0.15 0.05 0.0 e 0.85 0.77 0.7 0.65 0.55 Pressure Dependent MultiYield02 Material Examples: <table border=1 width=800> <tr> <td> Example 1 </td> <td>Single 2D 9-4 noded element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> <tr> <td> Example 2 </td> <td>Single 3D brick element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> <tr> <td> Example 3 </td> <td>Single 3D 20-8 noded element, subjected to sinusoidal base shaking (PressureDepend02 material)</td> </tr> </table> Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield02\n"},{"location":"contrib/modeling/ndmaterial/538-PressureDependMultiYield03%20Material/","text":"PressureDependMultiYield03 (The reference for PressureDependMultiYield03 material: Khosravifar, A., Elgamal, A., Lu, J., and Li, J. [2018]. \u201cA 3D model for earthquake-induced liquefaction triggering and post-liquefaction response.\u201d Soil Dynamics and Earthquake Engineering, 110, 43-52) PressureDependMultiYield03 is modified from PressureDependMultiYield02 material to comply with the established guidelines on the dependence of liquefaction triggering to the number of loading cycles, effective overburden stress (K&sigma;), and static shear stress (K&alpha;). Element drivers for single element simulations under undrained cyclic, undrained monotonic, drained cyclic and drained monotonic loading can be downloaded from here . nDMaterial PressureDependMultiYield03 $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $mType $ca $cb $cc $cd $ce $da $db \\(dc &lt;\\) noYieldSurf=20 <$r1 $Gs1 \u2026> $liquefac1=1. $liquefac2=0. \\(pa=101 &lt;\\) s0=1.73>> $ca, $cb, $cc, $cd, \\(ce</strong></p></td> <td><p>Non-negative constants defining the rate of contract or pore pressure buildup. See Tables 1 and 2 below for more information.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) da, $db, $dc A non-negative constant reflecting K&sigma; effect. contrac2 Non-negative constants defining the rate of dilation. See Tables 1 and 2 below for more information. mType 0: Triaxial Compression; 1: Triaxial Extension; 2: Direct Shear s0 Numerical constant (default value = 1.73 kPa). See Tables 1 and 2 below for more information. Others See PressureDependMultiYield02 material above and Tables 1 and 2 below. Table 1 provides the proposed calibrated input parameters for PressureDependMultiYield03 for four different relative densities. Table 2 provides a brief description for each parameter and the adopted calibration procedure. Table 1. Model Input Parameters Pdmy03_table1.png * These are not input parameters to the constitutive model, but rather parameters computed during model calibration. Table 2. Description of Calibration Parameters Pdmy03_table2.png Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield03\n"},{"location":"contrib/modeling/ndmaterial/539-PressureDependMultiYield%20Material/","text":"PressureDependMultiYield PressureDependMultiYield material is an elastic-plastic material for simulating the essential response characteristics of pressure sensitive soil materials under general loading conditions. Such characteristics include dilatancy (shear-induced volume contraction or dilation) and non-flow liquefaction (cyclic mobility), typically exhibited in sands or silts during monotonic or cyclic loading. When this material is employed in regular solid elements (e.g., FourNodeQuad, Brick), it simulates drained soil response. To simulate soil response under fully undrained condition, this material may be either embedded in a FluidSolidPorousMaterial , or used with one of the solid-fluid fully coupled elements ( Four Node Quad u-p Element , Nine Four Node Quad u-p Element , Brick u-p Element , Twenty Eight Node Brick u-p Element ) with very low permeability. To simulate partially drained soil response, this material should be used with a solid-fluid fully coupled element with proper permeability values. During the application of gravity load (and static loads if any), material behavior is linear elastic. In the subsequent dynamic (fast) loading phase(s), the stress-strain response is elastic-plastic (see updateMaterialStage ). Plasticity is formulated based on the multi-surface (nested surfaces) concept, with a non-associative flow rule to reproduce dilatancy effect. The yield surfaces are of the Drucker-Prager type. OUTPUT INTERFACE: The following information may be extracted for this material at a given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001)<sup> &reg; </sup>: \u201c stress \u201d, \u201c strain \u201d, \u201c backbone \u201d, or \u201c tangent \u201d. For 2D problems, the stress output follows this order: &sigma;<sub>xx</sub>, &sigma;<sub>yy</sub>, &sigma;<sub>zz</sub>, &sigma;<sub>xy</sub>, &eta;<sub>r</sub>, where &eta;<sub>r</sub> is the ratio between the shear (deviatoric) stress and peak shear strength at the current confinement (0<=&eta;<sub>r</sub><=1.0). The strain output follows this order: &epsilon;<sub>xx</sub>, &epsilon;<sub>yy</sub>, &gamma;<sub>xy</sub>. For 3D problems, the stress output follows this order: &sigma;<sub>xx</sub>, &sigma;<sub>yy</sub>, &sigma;<sub>zz</sub>, &sigma;<sub>xy</sub>, &sigma;<sub>yz</sub>, &sigma;<sub>zx</sub>, &eta;<sub>r</sub>, and the strain output follows this order: &epsilon;<sub>xx</sub>, &epsilon;<sub>yy</sub>, &epsilon;<sub>zz</sub>, &gamma;<sub>xy</sub>, &gamma;<sub>yz</sub>, &gamma;<sub>zx</sub>. The \u201c backbone \u201d option records (secant) shear modulus reduction curves at one or more given confinements. The specific recorder command is as follows: recorder Element -ele $eleNum -file $fName -dT $deltaT material $GaussNum backbone \\(p1 &lt;\\) p2 \u2026> where p1, p2, \u2026 are the confinements at which modulus reduction curves are recorded. In the output file, corresponding to each given confinement there are two columns: shear strain &gamma; and secant modulus G<sub>s</sub>. The number of rows equals the number of yield surfaces. nDMaterial PressureDependMultiYield $tag $nd $rho $refShearModul $refBulkModul $frictionAng $peakShearStra $refPress $pressDependCoe $PTAng $contrac $dilat1 $dilat2 $liquefac1 $liquefac2 \\(liquefac3 &lt;\\) noYieldSurf=20 <$r1 $Gs1 \u2026> $e=0.6 $cs1=0.9 $cs2=0.02 $cs3=0.7 \\(pa=101 &lt;\\) c=0.3>> PreDep_ss.png tag A positive integer uniquely identifying the material among all nDMaterials. nd Number of dimensions, 2 for plane-strain, and 3 for 3D analysis. rho Saturated soil mass density. \\(refShearModul (G&lt;sub&gt;r&lt;/sub&gt;)</strong></p></td> <td><p>Reference low-strain shear modulus, specified at a reference mean effective confining pressure refPress of p\u2019&lt;sub&gt;r&lt;/sub&gt; (see below).</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) refBulkModul (B<sub>r</sub>) Reference bulk modulus, specified at a reference mean effective confining pressure refPress of p\u2019<sub>r</sub> (see below). \\(frictionAng (&amp;Phi;)</strong></p></td> <td><p>Friction angle at peak shear strength, in degrees.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) peakShearStra (&gamma;<sub>max</sub>) An octahedral shear strain at which the maximum shear strength is reached, specified at a reference mean effective confining pressure refPress of p\u2019<sub>r</sub> (see below). Octahedral shear strain is defined as: PreDep_OctGamma.png\u200e \\(refPress (p\u2019&lt;sub&gt;r&lt;/sub&gt;)</strong></p></td> <td><p>Reference mean effective confining pressure at which Gr, Br, and &amp;gamma;&lt;sub&gt;max&lt;/sub&gt; are defined.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) pressDependCoe (d) A positive constant defining variations of G and B as a function of instantaneous effective confinement p\u2019: PreDep_pressDepCoe.png\u200e \\(PTAng (&amp;Phi;&lt;sub&gt;PT&lt;/sub&gt;)</strong></p></td> <td><p>Phase transformation angle, in degrees.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">contrac</code></td> <td><p>A non-negative constant defining the rate of shear-induced volume decrease (contraction) or pore pressure buildup. A larger value corresponds to faster contraction rate.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dilat1, \\(dilat2</strong></p></td> <td><p>Non-negative constants defining the rate of shear-induced volume increase (dilation). Larger values correspond to stronger dilation rate.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) liquefac1, $liquefac2, \\(liquefac3</strong></p></td> <td><p>Parameters controlling the mechanism of liquefaction-induced perfectly plastic shear strain accumulation, i.e., cyclic mobility. <strong>Set liquefac1 = 0 to deactivate this mechanism altogether.</strong> liquefac1 defines the effective confining pressure (e.g., 10 kPa in SI units or 1.45 psi in English units) below which the mechanism is in effect. Smaller values should be assigned to denser sands. Liquefac2 defines the maximum amount of perfectly plastic shear strain developed at zero effective confinement during each loading phase. Smaller values should be assigned to denser sands. Liquefac3 defines the maximum amount of biased perfectly plastic shear strain &amp;gamma;&lt;sub&gt;b&lt;/sub&gt; accumulated at each loading phase under biased shear loading conditions, as &amp;gamma;&lt;sub&gt;b&lt;/sub&gt;=liquefac2 x liquefac3. Typically, liquefac3 takes a value between 0.0 and 3.0. Smaller values should be assigned to denser sands. See the references listed at the end of this chapter for more information.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">noYieldSurf</code></td> <td><p>Number of yield surfaces, optional (must be less than 40, default is 20). The surfaces are generated based on the hyperbolic relation defined in Note 2 below.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) r, \\(Gs</strong></p></td> <td><p>Instead of automatic surfaces generation (Note 2), <strong>you can define yield surfaces directly based on desired shear modulus reduction curve.</strong> To do so, add a minus sign in front of noYieldSurf, then provide noYieldSurf pairs of shear strain (&amp;gamma;) and modulus ratio (G&lt;sub&gt;s&lt;/sub&gt;) values. For example, to define 10 surfaces: \u2026 -10&amp;gamma;&lt;sub&gt;1&lt;/sub&gt;G&lt;sub&gt;s1&lt;/sub&gt; \u2026 &amp;gamma;&lt;sub&gt;10&lt;/sub&gt;G&lt;sub&gt;s10&lt;/sub&gt; \u2026</p> <p>See Note 3 below for some important notes.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">e</code></td> <td><p>Initial void ratio, optional (default is 0.6).</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) cs1, $cs2, $cs3, $pa Parameters defining a straight critical-state line e<sub>c</sub> in e-p\u2019 space. If cs3=0, e<sub>c</sub> = cs1-cs2 log(p\u2019/p<sub>a</sub>) else (Li and Wang, JGGE, 124(12)), e<sub>c</sub> = cs1-cs2(p\u2019/p<sub>a</sub>)<sup>cs3</sup> where p<sub>a</sub> is atmospheric pressure for normalization (typically 101 kPa in SI units, or 14.65 psi in English units). All four constants are optional (default values: cs1=0.9, cs2=0.02, cs3=0.7, p<sub>a</sub> =101 kPa). c Numerical constant (default value = 0.3 kPa) NOTE: The friction angle &Phi; defines the variation of peak (octahedral) shear strength &tau;<sub>f</sub> as a function of current effective confinement p\u2019: Octahedral shear stress is defined as: (Automatic surface generation) At a constant confinement p\u2019, the shear stress &tau;(octahedral) - shear strain &gamma; (octahedral) nonlinearity is defined by a hyperbolic curve (backbone curve): where &gamma;<sub>r</sub> satisfies the following equation at p\u2019<sub>r</sub>: (User defined surfaces) The user specified friction angle &Phi; is ignored. Instead, &Phi; is defined as follows: where &sigma;<sub>m</sub> is the product of the last modulus and strain pair in the modulus reduction curve. Therefore, it is important to adjust the backbone curve so as to render an appropriate &Phi;. If the resulting &Phi; is smaller than the phase transformation angle &Phi;<sub>PT</sub>, &Phi;<sub>PT</sub> is set equal to &Phi;. Also remember that improper modulus reduction curves can result in strain softening response (negative tangent shear modulus), which is not allowed in the current model formulation. Finally, note that the backbone curve varies with confinement, although the variations are small within commonly interested confinement ranges. Backbone curves at different confinements can be obtained using the OpenSees element recorder facility (see OUTPUT INTERFACE above). The last five optional parameters are needed when critical-state response (flow liquefaction) is anticipated. Upon reaching the critical-state line, material dilatancy is set to zero. SUGGESTED PARAMETER VALUES For user convenience, a table is provided below as a quick reference for selecting parameter values. However, use of this table should be of great caution, and other information should be incorporated wherever possible. Parameters Loose Sand (15%-35%) Medium Sand (35%-65%) Medium-dense Sand (65%-85%) Dense Sand (85%-100%) rho 1.7 ton/m<sup>3</sup> or 1.59x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.9 ton/m<sup>3</sup> or 1.778x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.0 ton/m<sup>3</sup> or 1.872x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 2.1 ton/m<sup>3</sup> or 1.965x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> refShearModul (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 5.5x10<sup>4</sup> kPa or 7.977x10<sup>3</sup> psi 7.5x10<sup>4</sup> kPa or 1.088x10<sup>4</sup> psi 1.0x10<sup>5</sup> kPa or 1.45x10<sup>4</sup> psi 1.3x10<sup>5</sup> kPa or 1.885x10<sup>4</sup> psi refBulkModu (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 1.5x10<sup>5</sup> kPa or 2.176x10<sup>4</sup> psi 2.0x10<sup>5</sup> kPa or 2.9x10<sup>4</sup> psi 3.0x10<sup>5</sup> kPa or 4.351x10<sup>4</sup> psi 3.9x10<sup>5</sup> kPa or 5.656x10<sup>4</sup> psi frictionAng 29 33 37 40 peakShearStra (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 0.1 0.1 0.1 0.1 refPress (p\u2019<sub>r</sub>) 80 kPa or 11.6 psi 80 kPa or 11.6 psi 80 kPa or 11.6 psi 80 kPa or 11.6 psi pressDependCoe 0.5 0.5 0.5 0.5 PTAng 29 27 27 27 contrac 0.21 0.07 0.05 0.03 dilat1 0. 0.4 0.6 0.8 dilat2 0 2 3 5 liquefac1 10 kPa or 1.45 psi 10 kPa or 1.45 psi 5 kPa or 0.725 psi 0 liquefac2 0.02 0.01 0.003 0 liquefac3 1 1 1 0 e 0.85 0.7 0.55 0.45 Pressure Dependent Material Examples: <table border=1 width=800> <tr> <td colspan=2 align=center ><b>Material in elastic, drained (or dry) state</b></td> </tr> <tr> <td width=90> Example 1 </td> <td>Single quadrilateral element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 2 </td> <td>Single quadrilateral element, subjected to monotonic pushover ( English units version )</td> </tr> <tr> <td colspan=2 align=center ><b>Material in drained (or dry), elastic-plastic state</b></td> </tr> <tr> <td> Example 3 </td> <td>Single quadrilateral element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 4 </td> <td>Single quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 5 </td> <td>Single quadrilateral element, subjected to monotonic pushover</td> </tr> <tr> <td> Example 6 </td> <td>Single 3D BbarBrick element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 7 </td> <td>Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td colspan=2 align=center ><b>Material in saturated, undrained elastic-plastic state (coupled with FluidSolidPorous Material)</b></td> </tr> <tr> <td> Example 8 </td> <td>Single quadrilateral element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 9 </td> <td>Single quadrilateral element, subjected to monotonic pushover</td> </tr> <tr> <td> Example 10 </td> <td>Single quadrilateral element (inclined by 4 degrees), subjected to msinusoidal base shaking</td> </tr> <tr> <td> Example 11 </td> <td>Single 3D BbarBrick element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 12 </td> <td>Single 3D BbarBrick element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 13 </td> <td>A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td colspan=2 align=center ><b>Material in saturated, undrained elastic-plastic state (with user defined modulus reduction curve)</b></td> </tr> <tr> <td> Example 14 </td> <td>A column of quadrilateral element (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> <tr> <td colspan=2 align=center ><b>Solid-Fluid fully coupled elements - quadUP element</b></td> </tr> <tr> <td> Example 15 </td> <td>A column (2D plane strain quadUP element) of saturated, undrained Pressure Dependent material (inclined by 4 degrees), subjected to sinusoidal base shaking</td> </tr> </table> Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureDependMultiYield\n"},{"location":"contrib/modeling/ndmaterial/540-PressureIndependMultiYield%20Material/","text":"PressureIndependMultiYield PressureIndependMultiYield material is an elastic-plastic material in which plasticity exhibits only in the deviatoric stress-strain response. The volumetric stress-strain response is linear-elastic and is independent of the deviatoric response. This material is implemented to simulate monotonic or cyclic response of materials whose shear behavior is insensitive to the confinement change. Such materials include, for example, organic soils or clay under fast (undrained) loading conditions. During the application of gravity load (and static loads if any), material behavior is linear elastic. In the subsequent dynamic (fast) loading phase(s), the stress-strain response is elastic-plastic (see MATERIAL STAGE UPDATE below). Plasticity is formulated based on the multi-surface (nested surfaces) concept, with an associative flow rule. The yield surfaces are of the Von Mises type. OUTPUT INTERFACE: The following information may be extracted for this material at a given integration point, using the OpenSees Element Recorder facility (McKenna and Fenves 2001)<sup> &reg; </sup>: \u201c stress \u201d, \u201c strain \u201d, \u201c backbone \u201d, or \u201c tangent \u201d. For 2D problems, the stress output follows this order: &sigma;<sub>xx</sub>, &sigma;<sub>yy</sub>, &sigma;<sub>zz</sub>, &sigma;<sub>xy</sub>, &eta;<sub>r</sub>, where &eta;<sub>r</sub> is the ratio between the shear (deviatoric) stress and peak shear strength at the current confinement (0<=&eta;<sub>r</sub><=1.0). The strain output follows this order: &epsilon;<sub>xx</sub>, &epsilon;<sub>yy</sub>, &gamma;<sub>xy</sub>. For 3D problems, the stress output follows this order: &sigma;<sub>xx</sub>, &sigma;<sub>yy</sub>, &sigma;<sub>zz</sub>, &sigma;<sub>xy</sub>, &sigma;<sub>yz</sub>, &sigma;<sub>zx</sub>, &eta;<sub>r</sub>, and the strain output follows this order: &epsilon;<sub>xx</sub>, &epsilon;<sub>yy</sub>, &epsilon;<sub>zz</sub>, &gamma;<sub>xy</sub>, &gamma;<sub>yz</sub>, &gamma;<sub>zx</sub>. The \u201c backbone \u201d option records (secant) shear modulus reduction curves at one or more given confinements. The specific recorder command is as follows: recorder Element -ele $eleNum -file $fName -dT $deltaT material $GaussNum backbone \\(p1 &lt;\\) p2 \u2026> where p1, p2, \u2026 are the confinements at which modulus reduction curves are recorded. In the output file, corresponding to each given confinement there are two columns: shear strain &gamma; and secant modulus G<sub>s</sub>. The number of rows equals the number of yield surfaces. nDmaterial PressureIndependMultiYield $tag $nd $rho $refShearModul $refBulkModul $cohesi \\(peakShearStra &lt;\\) frictionAng=0. $refPress=100. $pressDependCoe=0. \\(noYieldSurf=20 &lt;\\) r1 \\(Gs1 \u2026&gt; &gt;</strong></p></td> </tr> </tbody> </table> <hr /> <figure> <img src=\"/OpenSeesRT/contrib/static/PreDep_ss.png\" title=\"PreDep_ss.png\" alt=\"PreDep_ss.png\" /> <figcaption aria-hidden=\"true\">PreDep_ss.png</figcaption> </figure> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">tag</code></td> <td><p>A positive integer uniquely identifying the material among all nDMaterials.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">nd</code></td> <td><p>Number of dimensions, 2 for plane-strain, and 3 for 3D analysis.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">rho</code></td> <td><p>Saturated soil mass density.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) refShearModul (G<sub>r</sub>) Reference low-strain shear modulus, specified at a reference mean effective confining pressure refPress of p\u2019<sub>r</sub> (see below). \\(refBulkModul (B&lt;sub&gt;r&lt;/sub&gt;)</strong></p></td> <td><p>Reference bulk modulus, specified at a reference mean effective confining pressure refPress of p\u2019&lt;sub&gt;r&lt;/sub&gt; (see below).</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) cohesi (c) Apparent cohesion at zero effective confinement. \\(peakShearStra (&amp;gamma;&lt;sub&gt;max&lt;/sub&gt;)</strong></p></td> <td><p>An octahedral shear strain at which the maximum shear strength is reached, specified at a reference mean effective confining pressure refPress of p\u2019&lt;sub&gt;r&lt;/sub&gt; (see below).</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) frictionAng (&Phi;) Friction angle at peak shear strength in degrees, optional (default is 0.0). \\(refPress (p\u2019&lt;sub&gt;r&lt;/sub&gt;)</strong></p></td> <td><p>Reference mean effective confining pressure at which Gr, Br, and &amp;gamma;&lt;sub&gt;max&lt;/sub&gt; are defined, optional (default is 100. kPa).</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) pressDependCoe (d) A positive constant defining variations of G and B as a function of instantaneous effective confinement p\u2019(default is 0.0):: PreDep_pressDepCoe.png\u200e If &Phi;=0, d is reset to 0.0. noYieldSurf Number of yield surfaces, optional (must be less than 40, default is 20). The surfaces are generated based on the hyperbolic relation defined in Note 2 below. $r, $Gs Instead of automatic surfaces generation (Note 2), you can define yield surfaces directly based on desired shear modulus reduction curve. To do so, add a minus sign in front of noYieldSurf, then provide noYieldSurf pairs of shear strain (&gamma;) and modulus ratio (G<sub>s</sub>) values. For example, to define 10 surfaces: \u2026 -10&gamma;<sub>1</sub>G<sub>s1</sub> \u2026 &gamma;<sub>10</sub>G<sub>s10</sub> \u2026 See Note 3 below for some important notes. NOTE: The friction angle &Phi; and cohesion c define the variation of peak (octahedral) shear strength &tau;<sub>f</sub> as a function of current effective confinement p\u2019<sub>i</sub>: Automatic surface generation: at a constant confinement p\u2019, the shear stress &tau;(octahedral) - shear strain &gamma; (octahedral) nonlinearity is defined by a hyperbolic curve (backbone curve): where &gamma;<sub>r</sub> satisfies the following equation at p\u2019<sub>r</sub>: (User defined surfaces) The user specified friction angle &Phi; = 0. cohesion c will be ignored. Instead, c is defined by c=sqrt(3)*&sigma;<sub>m</sub>/2, where &sigma;<sub>m</sub> is the product of the last modulus and strain pair in the modulus reduction curve. Therefore, it is important to adjust the backbone curve so as to render an appropriate c. If the user specifies &Phi; > 0, this &Phi; will be ignored. Instead, &Phi;is defined as follows: If the resulting &Phi; <0, we set &Phi;=0 and c=sqrt(3)*&sigma;<sub>m</sub>/2. Also remember that improper modulus reduction curves can result in strain softening response (negative tangent shear modulus), which is not allowed in the current model formulation. Finally, note that the backbone curve varies with confinement, although the variation is small within commonly interested confinement ranges. Backbone curves at different confinements can be obtained using the OpenSees element recorder facility (see OUTPUT INTERFACE above). SUGGESTED PARAMETER VALUES For user convenience, a table is provided below as a quick reference for selecting parameter values. However, use of this table should be of great caution, and other information should be incorporated wherever possible. Parameters Soft Clay Medium Clay Stiff Clay rho 1.3 ton/m<sup>3</sup> or 1.217x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.5 ton/m<sup>3</sup> or 1.404x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> 1.8 ton/m<sup>3</sup> or 1.685x10<sup>-4</sup> (lbf)(s<sup>2</sup>)/in<sup>4</sup> refShearModul 1.3x10<sup>4</sup> kPa or 1.885x10<sup>3</sup> psi 6.0x10<sup>4</sup> kPa or 8.702x10<sup>4</sup> psi 1.5x10<sup>5</sup> kPa or 2.176x10<sup>4</sup> psi refBulkModu 6.5x10<sup>4</sup> kPa or 9.427x10<sup>3</sup> psi 3.0x10<sup>5</sup> kPa or 4.351x10<sup>4</sup> psi 7.5x10<sup>5</sup> kPa or 1.088x10<sup>5</sup> psi cohesi 18 kPa or 2.611 psi 37 kPa or 5.366 psi 75 kPa or 10.878 psi peakShearStra (at p\u2019<sub>r</sub>=80 kPa or 11.6 psi) 0.1 0.1 0.1 frictionAng 0 0 0 pressDependCoe 0 0 0 Pressure Independent Material Examples: <table border=1 width=800> <tr> <td colspan=2 align=center ><b>Material in elastic state</b></td> </tr> <tr> <td width=90> Example 1 </td> <td>Single 2D plane-strain quadrilateral element, subjected to sinusoidal base shaking</td> </tr> <tr> <td> Example 2 </td> <td>Single 2D quadrilateral element, subjected to monotonic pushover ( English units version )</td> </tr> </table> Code Developed by: UC San Diego (Dr. Zhaohui Yang) : UC San Diego Soil Model:","title":"PressureIndependMultiYield\n"},{"location":"contrib/modeling/ndmaterial/65-Bounding%20Cam%20Clay/","text":"Bounding Cam Clay This command is used to construct a multi-dimensional bounding surface Cam Clay material object after Borja et al. (2001). nDMaterial BoundingCamClay $matTag $massDensity $C $bulkMod $OCR $mu_o $alpha $lambda $h $m matTag integer tag identifying material massDensity mass density C ellipsoidal axis ratio (defines shape of ellipsoidal loading/bounding surfaces) bulkMod initial bulk modulus OCR overconsolidation ratio mu_o initial shear modulus alpha pressure-dependency parameter for modulii (greater than or equal to zero) lambda soil compressibility index for virgin loading h hardening parameter for plastic response inside of bounding surface (if h = 0, no hardening) m hardening parameter (exponent) for plastic response inside of bounding surface (if m = 0, only linear hardening) The material formulations for the BoundingCamClay object are \u201cThreeDimensional\u201d and \u201cPlaneStrain\u201d Code Developed by Chris McGann & Pedro Arduino , at the University of Washington General Information This nDMaterial object provides the bounding surface plasticity model of Borja et al. (2001) in which the bounding surface model is represented using modified Cam-Clay theory (Schofield and Wroth 1968). In addition to the standard capabilities of the Cam-Clay family of models (e.g., pressure dependence, hardening with plastic volumetric contraction, softening with plastic dilation, and coupled deviatoric and volumetric plastic deformation), the Borja et al. (2001) model has been enhanced to include an anisotropic bounding surface formulation that allows for consideration of hysteretic behaviour under cyclic loading. This bounding surface Cam-Clay model is coupled with a nonlinear hyperelastic model that considered pressure-dependency in the bulk and shear modulus. The full theory of this model is discussed in great detail in Borja et al. (2001). Notes The ellipsoidal axis ratio parameter $C is defined such that the ellipsoidal surfaces are C times as wide in the deviatoric direction as they are along the hydrostatic axis. When $C = 1, the surfaces are spherical. The overconsolidation ratio (input parameter $OCR) defines the relationship between the loading surface and bounding surface. The radius of the bounding surface, R, is equal to the product of the OCR and the radius of the loading surface, r. When the soil is normally consolidated and $OCR = 1, the bounding and loading surfaces are coincident and virgin loading will occur. When the hyperelastic pressure-dependency parameter (input parameter $alpha) is set to zero, the elastic shear modulus will be constant with a value equal to the initial shear modulus (input parameter $mu_o) and the deviatoric and volumetric responses are uncoupled in the elastic regime. The virgin compressibility parameter (input parameter $lambda) describes the relationship between the specific volume v = 1 + e and the logarithm of the mean effective stress (where e is the void ratio). This is is related to the compression index C_c that describes the relationship between the void ratio and the logarithm of the mean effective stress in consolidation testing. Usage Examples The following usage example provides the input parameters used in the single element examples of Borja et al. (2001). The initial bulk modulus is determined from the initial mean stress desired in the test (in this case p = 100 kPa) divided by the recompressibilty index kappa = 0.018. The units of this analysis are kN and m, thus the prescribed initial shear modulus of 5.4 MPa is input as 5400 kPa. The hardening parameter $h has the same units as the moduli. define parameters for the model set rho 1.8 set c 1.0 set bulk 5555.56 set OCR 1.5 set mu_o 5.4e3 set alpha 0.0 set lambda 0.13 set h 5.0e3 set m 1.5 nDMaterial BoundingCamClay 1 $rho $c $bulk $OCR $mu_o $alpha $lambda $h $m References Borja, R.I., Lin, C.-H., and Montans, F.J. (2001) \u2018Cam-Clay plasticity, Part IV: Implicit integration of anisotropic bounding surface model with nonlinear hyperelasticity and ellipsoidal loading function,\u2019 Computer Methods in Applied Mechanics and Engineering, 190(26), 3293-3323, doi: 10.1016/S0045-7825(00)00301-7. Schofield, A. and Wroth, P. (1968) Critical State Soil Mechanics, McGraw Hill, New York. Example Analysis","title":"Bounding Cam Clay\n"},{"location":"contrib/modeling/ndmaterial/671-Stress%20Density%20Material/","text":"Stress Density Material This command is used to construct a multi-dimensional stress density material object for modeling sand behaviour following the work of Cubrinovski and Ishihara (1998a,b). Note that as of January 2020 this material is still undergoing verification testing for more complex loading and initial conditions. nDMaterial stressDensity $matTag $mDen $eNot $A $n $nu $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot $muCyc $sc $M $patm &lt; $ssl1 $ssl2 $ssl3 $ssl4 $ssl5 $ssl6 $ssl7 $hsl $pmin &gt; matTag integer tag identifying material mDen mass density eNot initial void ratio A constant for elastic shear modulus n pressure dependency exponent for elastic shear modulus nu Poisson\u2019s ratio a1 peak stress ratio coefficient (etaMax = a1 + b1*Is) b1 peak stress ratio coefficient (etaMax = a1 + b1*Is) a2 max shear modulus coefficient (Gn_max = a2 + b2*Is) b2 max shear modulus coefficient (Gn_max = a2 + b2*Is) a3 min shear modulus coefficient (Gn_min = a3 + b3*Is) b3 min shear modulus coefficient (Gn_min = a3 + b3*Is) fd degradation constant muNot dilatancy coefficient (monotonic loading) muCyc dilatancy coefficient (cyclic loading) sc dilatancy strain M critical state stress ratio patm atmospheric pressure (in appropriate units) Optional steady state line parameters (default values shown for each, be careful with units) <$ssl1> void ratio of quasi steady state (QSS-line) at pressure \\(pmin (default = 0.877)</p></td> </tr> <tr class=\"even\"> <td><p><strong>&lt;\\) ssl2> void ratio of quasi steady state (QSS-line) at 10 kPa (default = 0.877) < \\(ssl3&gt;</strong></p></td> <td><p>void ratio of quasi steady state (QSS-line) at 30 kPa (default = 0.873)</p></td> </tr> <tr class=\"even\"> <td><p><strong>&lt;\\) ssl4> void ratio of quasi steady state (QSS-line) at 50 kPa (default = 0.870) < \\(ssl5&gt;</strong></p></td> <td><p>void ratio of quasi steady state (QSS-line) at 100 kPa (default = 0.860)</p></td> </tr> <tr class=\"even\"> <td><p><strong>&lt;\\) ssl6> void ratio of quasi steady state (QSS-line) at 200 kPa (default = 0.850) < \\(ssl7&gt;</strong></p></td> <td><p>void ratio of quasi steady state (QSS-line) at 400 kPa (default = 0.833)</p></td> </tr> <tr class=\"even\"> <td><p><strong>&lt;\\) hsl> void ratio of upper reference state (UR-line) for all pressures (default = 0.895) <$pmin> pressure corresponding to $ssl1 (default = 1.0 kPa) The material formulations for the stressDensity object are \u201cPlaneStrain\u201d Code Developed by Saumyashuchi Das, University of Canterbury. Maintained by Chris McGann General Information This nDMaterial object provides the stress density model for sands under monotonic and cyclic loading as set forth by Cubrinovski and Ishihara (1998a,b). The original formulation for this model was applicable to plane strain conditions and this is the only currently available formulation. Notes Usage Examples The following usage example provides the input parameters for dry pluviated Toyura sand (with initial void ratio e = 0.73) after Cubrinovski and Ishihara (1998b). The units of this analysis are Mg, kN, s, and m. mass density set mDen 1.8 atmospheric pressure set patm 98.1 stress density model parameters set eNot 0.730 set A 250.0 set n 0.60 set a1 0.58 set b1 0.023 set a2 230.0 set b2 65.0 set a3 79.0 set b3 16.0 set fd 4.0 set muNot 0.22 set muCyc 0.0 set sc 0.0055 set M 0.607 nDMaterial stressDensity 1 $mDen $eNot $A $n $nu $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot $ muCyc $sc $M \\(patm</p> <h3 id=\"references\">References</h3> <p>Cubrinovski, M. and Ishihara K. (1998a) 'Modelling of sand behaviour based on state concept,' <em>Soils and Foundations,</em> 38(3), 115-127.</p> <p>Cubrinovski, M. and Ishihara K. (1998b) 'State concept and modified elastoplasticity for sand modelling,' <em>Soils and Foundations,</em> 38(4), 213-225.</p> <hr /> <h2 id=\"example_analysis\">Example Analysis</h2> <p>Element test with pure shear loading starting from isotropic initial state of stress.</p> <p> ```tcl </p> <ol> <li>intended number of cycles in the test</li> </ol> <p>set nCycles 120</p> <ol> <li>shear strain increment for the test</li> </ol> <p>set dg 0.0001 set wg [expr 2.0*\\) dg] max number of steps set maxStep 20000 initial confinement pressure (kPa) set pNot -95.0 max/min shear stress in the test (kPa) set CSR 0.2 set maxShear [expr - \\(CSR*\\) pNot] wipe model BasicBuilder -ndm 2 -ndf 2 Create nodes node 1 0.0 0.0 node 2 1.0 0.0 node 3 1.0 1.0 node 4 0.0 1.0 Create fixities fix 1 1 1 fix 2 1 1 fix 3 1 1 fix 4 1 1 atmospheric pressure set patm 98.1 mass density set mDen 1.8 steady state line void ratio set ssl1 0.832 set ssl2 0.832 set ssl3 0.810 set ssl4 0.796 set ssl5 0.776 set ssl6 0.756 set ssl7 0.735 hydrostatic state line void ratio set hsl 0.852 reference pressures for state lines set p1 1.0 stress density model parameters set A 250.0 set m 0.60 set nu 0.20 set a1 0.592 set b1 0.021 set a2 291.0 set b2 55.0 set a3 98.0 set b3 13.0 set fd 4.0 set muNot 0.15 set sc 0.0055 set M 0.607 initial void ratio set emax 0.885 set emin 0.541 set Dr 0.54 set eNot [expr $emax - \\(Dr*(\\) emax-$emin)] set muCyc 0.0 Create material nDMaterial stressDensity 2 $mDen $eNot $A $m $nu $a1 $b1 $a2 $b2 $a3 $b3 $fd $muNot \\(muCyc \\ \\) sc $M $patm $ssl1 $ssl2 $ssl3 $ssl4 $ssl5 $ssl6 $ssl7 $hsl $p1 nDMaterial InitStress 1 2 $pNot 2 Create element element SSPquad 1 1 2 3 4 1 PlaneStrain 1.0 0.0 0.0 Create recorders recorder Element -file stress.out -time stress recorder Element -file strain.out -time strain recorder Node -file disp.out -time -dof 1 2 disp set dt 0.1 Create analysis constraints Penalty 1.0e18 1.0e18 algorithm Linear numberer RCM system ProfileSPD integrator LoadControl \\(dt analysis Static</p> <p>set dMax [expr 0.6/\\) wg] eval \u201ctimeSeries Path 400 -time {0 0.1 0.2 300.2} -values {0 0 0 $dMax} -factor 1.0\u201d pattern Plain 400 400 { sp 3 1 $wg sp 4 1 \\(wg } analyze 1</p> <p>setParameter -value 1 -ele 1 materialState</p> <p>analyze 1</p> <ol> <li>counter for max number of steps</li> </ol> <p>set count 0 set cCount 0 set cyc 1 puts \"Beginning of Cycle 1\"</p> <ol> <li>loop through the total number of cycles</li> </ol> <p>for {set i 1} {\\) i <= [expr 2* \\(nCycles]} {incr i} { if {\\) cCount == 2} { set cyc [expr $cyc+1] puts \u201cBeginning of Cycle \\(cyc\" set cCount 0 }</p> <ol> <li>loop within each cycle</li> </ol> <p>for {set j 1} {\\) j < 5000} {incr j} { abort if count is greater than max number of steps if {$count >= $maxStep} {break} analyze single step and get the current stress analyze 1 set count [expr $count + 1] get stress from element set stress [eleResponse 1 stress] shear stress is component 2 set tau [lindex \\(stress 2]</p> <ol> <li>signal change in loading direction if needed</li> </ol> <p>if {[expr abs(\\) tau)] >= $maxShear} { get strain from element set strain [eleResponse 1 strain] set gamma [lindex $strain 2] puts \u201cdirection change required: tau = $tau; gamma = $gamma\u201d get current displacements of shearing nodes set f [expr 2.0 [nodeDisp 3 1]] set b [expr 2.0 [nodeDisp 4 1]] puts \u201ccurrent displacement of front row is $f\u201d puts \u201ccurrent displacement of back row is \\(b\"</li> </ol> <ol> <li>get number of steps required to reach current disp from zero</li> </ol> <p>set nStep [expr round(abs(\\) b/$wg))] puts \u201cthere are $nStep steps needed to get back to neutral loading\u201d get current time set cTime [getTime] puts \u201ccurrent time is $cTime\u201d set an end time for the load patterns set zTime [expr $cTime + \\(nStep*\\) dt] set eTime [expr \\(zTime + 100.0*\\) nStep] puts \u201cend time for the new load pattern is \\(eTime\"</li> </ol> <p>remove loadPattern [expr 400+\\) i-1] eval \u201ctimeSeries Path [expr 400+ \\(i] -time {\\) cTime \\(eTime 1e10} -values {1 -1000 -1000}\" pattern Plain [expr 400+\\) i] [expr 400+$i] { sp 3 1 $b sp 4 1 $b } set cCount [expr $cCount + 1] break } } } wipe ```","title":"Stress Density Material\n"},{"location":"contrib/modeling/ndmaterial/727-UVCmultiaxial%20%28Updated%20Voce-Chaboche%29/","text":"UVCmultiaxial (Updated Voce-Chaboche) This command is used to construct an Updated Voce-Chaboche (UVC) material for general multiaxial stress states (e.g., for solid/brick elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The plane-stress (e.g., for quad/plate/shell elements) and uniaxial (e.g., for beam elements) versions are also available. The plane-stress and uniaxial implementations have the exact same hardening rules as this general multiaxial model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. nDMaterial UVCmultiaxial $matTag $E $nu $fy $QInf $b $DInf $a $N $C1 $gamma1 &lt; $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 &gt; matTag Integer tag identifying the material. E Elastic modulus of the steel material. nu Poisson\u2019s ratio for the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <$C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples, validation, and UVC model parameters For the user, the only practical difference between the uniaxial and multiaxial/plane-stress implementations is the specification of Poisson\u2019s ratio in the list of input parameters. Further information on the UVC model is centralized at the UVCuniaxial web page. On the UVCuniaxial page you will find examples validating the model, and UVC model parameters for common structural steels that are applicable for all stress states. References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cConstitutive Modeling of Structural Steels: A Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCmultiaxial (Updated Voce-Chaboche)\n"},{"location":"contrib/modeling/ndmaterial/728-UVCplanestress%20%28Updated%20Voce-Chaboche%29/","text":"UVCplanestress (Updated Voce-Chaboche) This command is used to construct an Updated Voce-Chaboche (UVC) material for plane-stress stress states (e.g., for quad/plate/shell elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The multiaxial (e.g., for solid/brick elements) and uniaxial (e.g., for beam elements) versions are also available. The multiaxial and uniaxial implementations have the exact same hardening rules as this plane-stress model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. nDMaterial UVCplanestress $matTag $E $nu $fy $QInf $b $DInf $a $N $C1 $gamma1 &lt; $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 &gt; matTag Integer tag identifying the material. E Elastic modulus of the steel material. nu Poisson\u2019s ratio for the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <$C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples, validation, and UVC model parameters For the user, the only practical difference between the uniaxial and multiaxial/plane-stress implementations is the specification of Poisson\u2019s ratio in the list of input parameters. Further information on the UVC model is centralized at the UVCuniaxial web page. On the UVCuniaxial page you will find examples validating the model, and UVC model parameters for common structural steels that are applicable for all stress states. References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cConstitutive Modeling of Structural Steels: A Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCplanestress (Updated Voce-Chaboche)\n"},{"location":"contrib/modeling/uniaxialMaterial/158-DoddRestrepo/","text":"DoddRestrepo This command is used to construct a Dodd-Restrepo steel material uniaxialMaterial Dodd_Restrepo $tag $Fy $Fsu $ESH $ESU $Youngs $ESHI $FSHI &lt; $OmegaFac &gt; matTag Integer tag identifying material Fy Yield strength Fsu Ultimate tensile strength (UTS) ESH Tensile strain at initiation of strain hardening ESU Tensile strain at the UTS Youngs Modulus of elasticity ESHI Tensile strain for a point on strain hardening curve, recommended range of values for ESHI: [ (ESU + 5 ESH)/6, (ESU + 3 ESH)/4] FSHI Tensile stress at point on strain hardening curve corresponding to ESHI OmegaFac Roundedness factor for Bauschinger curve in cycle reversals from the strain hardening curve. Range: [0.75, 1.15]. Largest value tends to near a bilinear Bauschinger curve. Default = 1.0. Note: Stresses and strains are defined in engineering terms, as they are reported in a tensile test. Examples: References : Code Developed by : L.L. Dodd & J.I. Restrepo Dodd, L. L. and Restrepo-Posada, J. I. (1995). Model for Predicting Cyclic Behaviour of Reinforcing Steel. ASCE Journal of Structural Engineering, V.121, No 3, pp. 433-445.","title":"DoddRestrepo\n"},{"location":"contrib/modeling/uniaxialMaterial/177-Elastic-No%20Tension%20Material/","text":"Elastic-No Tension This command is used to construct a uniaxial elastic-no tension material object. uniaxialMaterial ENT $matTag $E matTag integer tag identifying material E tangent ENT.gif Code Developed by: fmk","title":"Elastic-No Tension\n"},{"location":"contrib/modeling/uniaxialMaterial/178-Elastic-Perfectly%20Plastic%20Gap%20Material/","text":"Elastic-Perfectly Plastic Gap This command is used to construct an elastic perfectly-plastic gap uniaxial material object. uniaxialMaterial ElasticPPGap $matTag $E $Fy $gap < $eta > < damage > matTag integer tag identifying material E tangent Fy stress or force at which material reaches plastic state gap initial gap (strain or deformation) eta hardening ratio (=Eh/E), which can be negative damage an optional string to specify whether to accumulate damage or not in the material. With the default string, \u201cnoDamage\u201d the gap material will re-center on load reversal. If the string \u201cdamage\u201d is provided this recentering will not occur and gap will grow. ElasticPPGap.gif Examples _ElasticPPGap.tcl <tcl>ElasticPPGap.tcl</tcl> Code Developed by: Kevin Mackie, University of Central Florida","title":"Elastic-Perfectly Plastic Gap\n"},{"location":"contrib/modeling/uniaxialMaterial/179-Elastic-Perfectly%20Plastic%20Material/","text":"Elastic-Perfectly Plastic This command is used to construct an elastic perfectly-plastic uniaxial material object. uniaxialMaterial ElasticPP $matTag $E $epsyP < $epsyN $eps0 > matTag integer tag identifying material E tangent epsyP strain or deformation at which material reaches plastic state in tension epsyN strain or deformation at which material reaches plastic state in compression. (optional, default is tension value) eps0 initial strain (optional, default: zero) ElasticPP.gif Code Developed by: fmk","title":"Elastic-Perfectly Plastic\n"},{"location":"contrib/modeling/uniaxialMaterial/180-ElasticBilin%20Material/","text":"ElasticBilin This command is used to construct an elastic bilinear uniaxial material object. Unlike all other bilinear materials, the unloading curve follows the loading curve exactly. uniaxialMaterial ElasticBilin $matTag $EP1 $EP2 $epsP2 < $EN1 $EN2 $epsN2 > matTag integer tag identifying material EP1 tangent in tension for stains: 0 <= strains <= epsP2 EP2 tangent when material in tension with strains epsP2 epsP2 strain at which material changes tangent in tension. EN1 optional, default = EP1 . tangent in compression for stains: 0 < strains <= epsN2 EN2 optional, default = EP2 . tangent in compression with strains < $epsN2 epsN2 optional, default = -epsP2. strain at which material changes tangent in compression. ElasticPP.gif NOTE: eps0 can not be controlled. It is always zero. Code Developed by: fmk","title":"ElasticBilin\n"},{"location":"contrib/modeling/uniaxialMaterial/181-ElasticMultiLinear%20Material/","text":"ElasticMultiLinear This command is used to construct a multi-linear elastic uniaxial material object. The nonlinear stress-strain relationship is given by a multi-linear curve that is define by a set of points. The behavior is nonlinear but it is elastic. This means that the material loads and unloads along the same curve, and no energy is dissipated. The slope given by the last two specified points on the positive strain axis is extrapolated to infinite positive strain. Similarly, the slope given by the last two specified points on the negative strain axis is extrapolated to infinite negative strain. The number of provided strain points needs to be equal to the number of provided stress points. uniaxialMaterial ElasticMultiLinear $matTag &lt; $eta &gt; -strain $strainPoints -stress $stressPoints matTag integer tag identifying material eta damping tangent (optional, default=0.0) strainPoints array of strain points along stress-strain curve stressPoints array of stress points along stress-strain curve ElasticMultiLinear.png Examples uniaxialMaterial ElasticMultiLinear 1 -strain -0.045 -0.04 -0.02 0.0 0.02 0.04 0.045 -stress 10 -100 -10 0 50 55 100 Code Developed by: Andreas Schellenberg, University of California, Berkeley.","title":"ElasticMultiLinear\n"},{"location":"contrib/modeling/uniaxialMaterial/189-Elastic%20Material/","text":"Elastic This command is used to construct a linear elastic uniaxial material object (with optional material damping) uniaxialMaterial Elastic $matTag $E &lt; $eta &gt; matTag unique material object integer tag E elastic stiffness eta damping stiffness (optional, default=0.0) Note: For this material class, the sensitivity parameters can be: E, eta","title":"Elastic\n"},{"location":"contrib/modeling/uniaxialMaterial/195-Elastic%20Uniaxial%20Material/","text":"Elastic This command is used to construct an elastic uniaxial material object. uniaxialMaterial Elastic $matTag $E &lt; $eta &gt; &lt; $Eneg &gt; matTag integer tag identifying material E tangent eta damping tangent (optional, default=0.0) Eneg tangent in compression (optional, default=E) Code Developed by: fmk","title":"Elastic\n"},{"location":"contrib/modeling/uniaxialMaterial/210-Engineered%20Cementitious%20Composites%20Material/","text":"ECC01 This command is used to construct a uniaxial Engineered Cementitious Composites (ECC)material object based on the ECC material model of Han, et al. (see references). Reloading in tension and compression is linear. uniaxialMaterial ECC01 $matTag $sigt0 $epst0 $sigt1 $epst1 $epst2 $sigc0 $epsc0 $epsc1 $alphaT1 $alphaT2 $alphaC $alphaCU $betaT $betaC matTag integer tag identifying material sigt0 tensile cracking stress epst0 strain at tensile cracking stress sigt1 peak tensile stress epst1 strain at peak tensile stress sigt2 ultimate tensile strain sigc0 compressive strength (see NOTES) epsc0 strain at compressive strength (see NOTES) epsc1 ultimate compressive strain (see NOTES) alphaT1 exponent of the unloading curve in tensile strain hardening region alphaT2 exponent of the unloading curve in tensile softening region alphaC exponent of the unloading curve in the compressive softening alphaCU exponent of the compressive softening curve (use 1 for linear softening) betaT parameter to determine permanent strain in tension betaC parameter to determine permanent strain in compression NOTES Compressive ECC parameters should be input as negative values. ECC01.gif eccTensile.gif eccCompression.gif REFERENCES: Han TS, Feenstra PH, Billington SL, \u201cSimulation of Highly Ductile Fiber-Reinforced Cement-Based Composite Components Under Cyclic Loading,\u201d ACI Structural Journal, V. 100, No. 6, pp. 749-757. Code Developed by: Won Lee, Stanford and Sara Billington, Stanford","title":"ECC01\n"},{"location":"contrib/modeling/uniaxialMaterial/234-FRPConfinedConcrete/","text":"FRPConfinedConcrete This command is used to construct a uniaxial Megalooikonomou-Monti-Santini concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength. uniaxialMaterial FRPConfinedConcrete $matTag $fpc1 $fpc2 $epsc0 $D $c $Ej $Sj $tj $eju $S $fyl $fyh $dlong $dtrans $Es $vo $k $useBuck matTag integer tag identifying material. fpc1 concrete core compressive strength. fpc2 concrete cover compressive strength. epsc0 strain corresponding to unconfined concrete strength. D diameter of the circular section. c dimension of concrete cover (until the outer edge of steel stirrups) Ej elastic modulus of the fiber reinforced polymer (FRP) jacket. Sj clear spacing of the FRP strips - zero if FRP jacket is continuous. tj total thickness of the FRP jacket. eju rupture strain of the FRP jacket from tensile coupons. S spacing of the steel spiral/stirrups. fyl yielding strength of longitudinal steel bars. fyh yielding strength of the steel spiral/stirrups. dlong diameter of the longitudinal bars of the circular section. dtrans diameter of the steel spiral/stirrups. Es elastic modulus of steel. vo initial Poisson\u2019s coefficient for concrete. k reduction factor for the rupture strain of the FRP jacket, recommended values 0.5-0.8. useBuck FRP jacket failure criterion due to buckling of longitudinal compressive steel bars (0 = not include it, 1= to include it). NOTES: \u2022 IMPORTANT: The units of the input parameters should be in MPa, N, mm. \u2022 Concrete compressive strengths and the corresponding strain should be input as positive values. \u2022 When rupture of FRP jacket occurs due to dilation of concrete (lateral concrete strain exceeding reduced rupture strain of FRP jacket), the analysis is not terminated. Only a message \u201cFRP Rupture\u201d is plotted on the screen. \u2022 When $useBuck input parameter is on (equal to 1) and the model\u2019s longitudinal steel buckling conditions are fulfilled, a message \u201cInitiation of Buckling of Long.Bar under Compression\u201d is plotted on the screen. \u2022 When rupture of FRP jacket occurs due to its interaction with buckled longitudinal compressive steel bars, the analysis is not terminated. Only a message \u201cFRP Rupture due to Buckling of Long.Bar under compression\u201d is plotted on the screen. Typical Hysteretic Stress-Strain Relation for FRPConfinedConcrete. Figure_1_.jpg EXAMPLES: Example: Cantilever FRP-Confined Circular Reinforced Concrete Column under Cyclic Lateral Loading Cantilever Column Model Definition. Figure_2.jpg\u200e The cantilever column was modeled by a linear beam element with its stiffness corresponding to flexural yielding and by a fiber element at the plastic hinge which is used in order to capture the flexural hysteretic behavior. The length of the fiber element was assumed to be half of the column\u2019s diameter. A rotational spring at the bottom of the column represents the longitudinal bar pullout from the footing and was assumed to have an elastic stiffness. According to FRPConfinedConcrete model, the averaged response of the two different regions - concrete core (confined by both the FRP & the existing reinforcement) and concrete cover (confined only with the FRP wrap) - in the cross-section allows the assignment of a unique stress-strain law (FRPConfinedConcrete) to all the concrete fibers/layers of the circular section. Input Files: For Tcl Interpreter: For Python Interpreter: Please change the file type to ExampleFRP.py to run it with Python Interpreter. Response of Cantilever FRP-Confined Circular Reinforced Concrete Column under Cyclic Lateral Loading. Figure_3.jpg REFERENCES: \u2022 MEGALOOIKONOMOU K.G., MONTI G., SANTINI S., \u201cConstitutive Model for Fiber -Reinforced Polymer - and Tie - Confined Concrete\u201d, ACI Structural Journal, Vol. 109, No. 4, July 2012, pp. 569-578. https://doi.org/10.14359/51683876 \u2022 KARSAN, I.D., JIRSA, J.O., \u201cBehaviour of concrete under compressive loadings\u201d, Journal of Structural Division ASCE, Vol. 95, No. 12, 1969, pp. 2543-2563. https://doi.org/10.1061/JSDEAG.0002424 \u2022 MEGALOOIKONOMOU K.G., \u201cSeismic Assessment and Retrofit of Reinforced Concrete Columns\u201d, Cambridge Scholars Publishing, ISBN (10): 1-5275-2785-9, ISBN (13): 978-1-5275-2785-0, 2019, p. 387. https://www.cambridgescholars.com/product/978-1-5275-2785-0 \u2022 MEGALOOIKONOMOU K.G., MONTI G., \u201cNumerical Modeling of FRP-Retrofitted Circular RC Columns Including Shear\u201d, In Proceedings of: 5th International Conference on Computational Methods in Structural Dynamics and Earthquake Engineering (COMPDYN 2015), Crete Island, Greece, May 25 - 27, 2015. https://doi.org/10.7712/120115.3663.400 \u2022 MEGALOOIKONOMOU K.G. (2019, December). Modeling the behavior of shear-critical reinforced concrete columns under lateral loads. Ph.D. Thesis, Department of Civil and Environmental Engineering, Faculty of Engineering, University of Cyprus, Nicosia, Cyprus. https://doi.org/10.12681/eadd/47504 \u2022 GALLARDO - ZAFRA R., KAWASHIMA, K., \u201cAnalysis of CFRP RC Bridge Columns under Lateral Cyclic Loading\u201d, Journal of Earthquake Engineering, Vol. 13, 2009, pp. 129-154. https://doi.org/10.1080/13632460802347455 Code Developed By: Dr.-Ing. Konstantinos G. Megalooikonomou, Onassis Foundation Scholar, University of Cyprus (Webpage: https://bigeconomy.gr/en/ ).","title":"FRPConfinedConcrete\n"},{"location":"contrib/modeling/uniaxialMaterial/239-Fatigue%20Material/","text":"Fatigue The fatigue material uses a modified rainflow cycle counting algorithm to accumulate damage in a material using Miner\u2019s Rule. Element stress/strain relationships become zero when fatigue life is exhausted. uniaxialMaterial Fatigue $matTag $tag &lt;-E0 $E0 &gt; &lt;-m $m &gt; &lt;-min $min &gt; &lt;-max $max &gt; matTag integer tag identifying material tag Unique material object integer tag for the material that is being wrapped E0 Value of strain at which one cycle will cause failure (default 0.191) m Slope of Coffin-Manson curve in log-log space (default -0.458) min Global minimum value for strain or deformation (default -1e16) max Global maximum value for strain or deformation (default 1e16) Description This material model accounts for the effects of low cycle fatigue. A modified rainflow cycle counter has been implemented to track strain amplitudes. This cycle counter is used in concert with a linear strain accumulation model (i.e. Miner\u2019s Rule), based on Coffin-Manson log-log relationships describing low cycle fatigue failure. This material wraps around another material and does not influence the stress-strain (or force-deformation) relationship of the parent material. Once the Fatigue material model reaches a damage level of 1.0, the force (or stress) of the parent material becomes zero (1.0x10-8 times the call to the material). If failure is triggered in compression, the material stress is dropped at the next zero-force crossing (i.e. compression force never drops to zero). The Fatigue material assumes that each point is the last point of the history, and tracks damage with this assumption. If failure is not triggered, this pseudo-peak is discarded. The material also has the ability to trigger failure based on a maximum or minimum strain (i.e. not related to fatigue). The default for these values is set to very large numbers. The default values are calibrated parameters from low cycle fatigue tests of European steel sections Ballio and Castiglioni (1995), for more information about how material was calibrated, the user is directed to Uriz (2005). Valid recorder objects for the material are \u2018stress\u2019,\u2019tangent\u2019, \u2018strain\u2019, \u2018stressStrain\u2019, and \u2018damage\u2019. The stress, strain, and tangent recorder options must be available in the material that you are wrapping. NOTE: Here you can find more information of how to create \u2018damage\u2019 recorders: link Example: Click to Download Media:FatigueExample.tcl Media:RandomStrainHstory.tcl DamageExample.jpg References: Uriz, Patxi (2005) \u201cTowards Earthquake Resistant Design of Concentrically Braced Steel Structures,\u201d Doctoral Dissertation, Structural Engineering, Mechanics, and Materials, Department of Civil and Environmental Engineering, University of California, Berkeley, December 2005 Ballio, G., and Castiglioni, C. A. (1995). \u201cA Unified Approach for the Design of Steel Structures under Low and/or High Cycle Fatigue.\u201d Journal of Constructional Steel Research, 34, 75-101. Code Developed by: Patxi Uriz, Exponent","title":"Fatigue\n"},{"location":"contrib/modeling/uniaxialMaterial/26-AxialSpHD%20Material/","text":"AxialSpHD This command is used to construct a uniaxial AxialSpHD material object. This material model produces axial stress-strain curve of elastomeric bearings including hardening behavior. uniaxialMaterial AxialSpHD $matTag $sce $fty $fcy &lt; $bte $bty $bth $bcy $fcr $ath &gt; matTag integer tag identifying material sce compressive modulus $fty \\(fcy</strong></p></td> <td><p>yield stress under tension (<code class=\"tcl-variable\">fty</code>) and compression (<code class=\"tcl-variable\">fcy</code>) (see note 1)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) bte $bty $bth $bcy reduction rate for tensile elastic range ( bte ), tensile yielding ( bty ), tensile hardening ( bth ) and compressive yielding ( bcy ) (see note 1) fcr target point stress (see note 1) ath hardening strain ratio to yield strain (see note 1) NOTES: Input parameters are required to satisfy followings. fcy < 0.0 < fty 0.0 <= bty < bth < bte <= 1.0 0.0 <= bcy <= 1.0 fcy <= fcr <= 0.0 1.0 <= ath &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Examples AxialSpHD_sample.tcl AxialSpHD_StressStrain.png Code Developed by: mkiku","title":"AxialSpHD\n"},{"location":"contrib/modeling/uniaxialMaterial/27-AxialSp%20Material/","text":"AxialSp This command is used to construct a uniaxial AxialSp material object. This material model produces axial stress-strain curve of elastomeric bearings. uniaxialMaterial AxialSp $matTag $sce $fty $fcy &lt; $bte $bty $bcy $fcr &gt; matTag integer tag identifying material sce compressive modulus $fty \\(fcy</strong></p></td> <td><p>yield stress under tension (<code class=\"tcl-variable\">fty</code>) and compression (<code class=\"tcl-variable\">fcy</code>) (see note 1)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) bte $bty $bcy reduction rate for tensile elastic range ( bte ), tensile yielding ( bty ) and compressive yielding ( bcy ) (see note 1) fcr target point stress (see note 1) NOTES: Input parameters are required to satisfy followings. fcy < 0.0 < fty 0.0 <= bty < bte <= 1.0 0.0 <= bcy <= 1.0 fcy <= fcr <= 0.0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Examples AxialSp_sample.tcl AxialSp_StressStrain.png Code Developed by: mkiku","title":"AxialSp\n"},{"location":"contrib/modeling/uniaxialMaterial/29-BARSLIP%20Material/","text":"BarSlip This command is used to construct a uniaxial material that simulates the bar force versus slip response of a reinforcing bar anchored in a beam-column joint. The model exhibits degradation under cyclic loading. Cyclic degradation of strength and stiffness occurs in three ways: unloading stiffness degradation, reloading stiffness degradation, strength degradation. uniaxialMaterial BarSlip $matTag $fc $fy $Es $fu $Eh $db $ld $nb $depth $height &lt; $ancLratio &gt; $bsFlag $type &lt; $damage $unit &gt; matTag unique material object integer tag fc positive floating point value defining the compressive strength of the concrete in which the reinforcing bar is anchored fy positive floating point value defining the yield strength of the reinforcing steel Es floating point value defining the modulus of elasticity of the reinforcing steel fu positive floating point value defining the ultimate strength of the reinforcing steel Eh floating point value defining the hardening modulus of the reinforcing steel ld floating point value defining the development length of the reinforcing steel db point value defining the diameter of reinforcing steel nb an integer defining the number of anchored bars depth floating point value defining the dimension of the member (beam or column) perpendicular to the dimension of the plane of the paper height floating point value defining the height of the flexural member, perpendicular to direction in which the reinforcing steel is placed, but in the plane of the paper ancLratio floating point value defining the ratio of anchorage length used for the reinforcing bar to the dimension of the joint in the direction of the reinforcing bar (optional, default: 1.0) bsFlag string indicating relative bond strength for the anchored reinforcing bar (options: \u201cStrong\u201d or \u201cWeak\u201d) type string indicating where the reinforcing bar is placed. (options: \u201cbeamtop\u201d, \u201cbeambot\u201d or \u201ccolumn\u201d) damage string indicating type of damage:whether there is full damage in the material or no damage (optional, options: \u201cDamage\u201d, \u201cNoDamage\u201d ; default: Damage) unit string indicating the type of unit system used (optional, options: \u201cpsi\u201d, \u201cMPa\u201d, \u201cPa\u201d, \u201cpsf\u201d, \u201cksi\u201d, \u201cksf\u201d) (default: \u201cpsi\u201d / \u201cMPa\u201d)* NOTES Model Characteristics: The uniaxial material model uses the Pinching4 material model (Ref. Pinching4 material model). The response envelope for the bar-slip springs does not represent strength deterioration, but once the slip demand exceeds 3mm (0.12 in), strength deterioration due to cyclic loading initiates. As a result the bond-slip springs always exhibit positive stiffness, but strength deterioration upon reloading to a previously observed slip demand. Reloading and Unloading Stiffness deterioration are also simulated. The damage index for unloading and reloading stiffness degradation is evaluated the same say as the Pinching4 material (ref. Pinching4 material doc.) but the index for strength degradation is specified as With degradation model parameters gF*. It should be noted in here that the deterioration parameters for unloading, reloading stiffness and strength degradation cannot be modified by the user and are defined to represent observed behavior. The model includes predefined bond strengths, so there is the necessity to include in Units in this material model. For default one can specify units in psi (i.e. pounds/inch2) or in MPa (i.e. N/mm2). The code detects units in psi if the compressive strength of concrete is greater than 1000 otherwise it takes it as MPa system. The optional variable $unit will help the user to specify other different types of unit systems according to one\u2019s choice, but currently it is limited to the unit systems as specified above. The user should also take care to specify the units of length in the corresponding matching units. (note: Pa = N/m2; ksf = kilo-pound/ft2) Code Developed by: Nilanjan Mitra, CalPoly State University","title":"BarSlip\n"},{"location":"contrib/modeling/uniaxialMaterial/322-Hardening%20Material/","text":"Hardening This command is used to construct a uniaxial material object with combined linear kinematic and isotropic hardening. The model includes optional visco-plasticity using a Perzyna formulation. uniaxialMaterial Hardening $matTag $E $sigmaY $H_iso $H_kin &lt; $eta &gt; matTag integer tag identifying material E tangent stiffness sigmaY yield stress or force H_iso isotropic hardening Modulus H_kin kinematic hardening Modulus eta visco-plastic coefficient (optional, default=0.0) HardeningMaterial.gif Code Developed by: Micheal H. Scott, Oregon State University Image Developed by: Silvia Mazzoni","title":"Hardening\n"},{"location":"contrib/modeling/uniaxialMaterial/33-BWBN%20Material/","text":"BWBN This command is used to construct a uniaxial Bouc-Wen pinching hysteretic material object. This material model is an extension of the original Bouc-Wen model that includes pinching (Baber and Noori (1986) and Foliente (1995)). uniaxialMaterial BWBN $matTag $alpha $ko $n $gamma $beta $Ao $q $zetas $p $Shi $deltaShi $lambda $tol $maxIter matTag integer tag identifying material alpha ratio of post-yield stiffness to the initial elastic stiffenss (0< <math></math> <1) ko initial elastic stiffness n parameter that controls transition from linear to nonlinear range (as n increases the transition becomes sharper; n is usually grater or equal to 1) $gamma $beta parameters that control shape of hysteresis loop; depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated (look at the BoucWen Material ) Ao parameter that controls tangent stiffness $q $zetas $p $Shi $deltaShi $lambda parameters that control pinching tol tolerance maxIter maximum iterations BWBN_YSPD.jpg\u200e Fig. Cyclic force displacement relationship of the YSPDs generated using the BWBN material model PARAMETER ESTIMATION: BWBNParameterEstimation Examples BWBNExample REFERENCES: Hossain, M. R., Ashraf, M., & Padgett, J. E. (2013). \u201cRisk-based seismic performance assessment of Yielding Shear Panel Device.\u201d Engineering Structures, 56, 1570-1579. Hossain, M. R., & Ashraf, M. (2012). \u201cMathematical modelling of yielding shear panel device.\u201d Thin-Walled Structures, 59, 153-161. Baber, T. T., & Noori, M. N. (1986). \u201cModeling general hysteresis behavior and random vibration application.\u201d Journal of Vibration Acoustics Stress and Reliability in Design, 108, 411. Foliente, G. C. (1995). Hysteresis modeling of wood joints and structural systems. Journal of Structural Engineering, 121(6), 1013-1022. DEVELOPED BY: Raquib Hossain , The University of Queensland (UQ), Australia & Bangladesh University of Engineering and Technology (BUET), Bangladesh.","title":"BWBN\n"},{"location":"contrib/modeling/uniaxialMaterial/331-Hyperbolic%20Gap%20Material/","text":"HyperbolicGapMaterial This command is used to construct a hyperbolic gap material object. uniaxialMaterial HyperbolicGapMaterial $matTag $Kmax $Kur $Rf $Fult $gap matTag integer tag identifying material Kmax initial stiffness Kur unloading/reloading stiffness Rf failure ratio Fult ultimate (maximum) passive resistance* gap initial gap* NOTES: This material is implemented as a compression-only gap material. Fult and gap should be input as negative values. Recomended Values: Kmax = 20300 kN/m of abutment width Kcur = $Kmax Rf = 0.7 Fult = -326 kN per meter of abutment width gap = -2.54 cm DESCRIPTION: This file contains the class implementation for HyperbolicGapMaterial. This material is based on abutment stiffness models for bridge simulation proposed by Patrick Wilson and Ahmed Elgamal at UCSD. The abutment stiffness models are based on large-scale abutment tests performed on the outdoor shaking table at UCSD. The model is described for a 1.68 meter (5.5 ft) tall backwall height (typical size) and a 1 meter wide section along the width of the abutment (to be scaled accordingly). The hyperbolic force-displacement model is based on work by Duncan and Mokwa (2001) and Shamsabadi et al. (2007) with calibrated parameters from UCSD abutment tests. This model matches very well with test data up to 7.64 cm of longitudinal displacement. \\[F(x) = \\frac{x}{\\frac{1}{K_\\text{max}} + R_f \\frac{x}{F_\\text{ult}}}\\] HyperbolicGapA.png HyperbolicGapB.png REFERENCES: Duncan, J. M., and Mokwa, R. L. (2001). \u201cPassive earth pressures: theories and tests.\u201d Journal of Geotechnical and Geoenvironmental Engineering, 127(3), 248-257. Shamsabadi, A., Rollins, K. M., and Kapuskar, M. (2007). \u201cNonlinear soil-abutment-bridge structure interaction for seismic performance-based design.\u201d Journal of Geotechnical and Geoenvironmental Engineering, 133(6), 707-720. Wilson, P and Elgamal, A (2006). \u201cLarge scale measurement of lateral earth pressure on bridge abutment back-wall subjected to static and dynamic loading.\u201d Proceedings of the New Zealand Workshop on Geotechnical Earthquake Engineering, University of Canterbury, Christchurch, New Zealand: pp 307-315. Code Developed by: Mathew Dryden, UC Berkeley and Patrick Wilson, UCSD","title":"HyperbolicGapMaterial\n"},{"location":"contrib/modeling/uniaxialMaterial/332-Hysteretic%20Material/","text":"Hysteretic This command is used to construct a uniaxial bilinear hysteretic material object with pinching of force and deformation, damage due to ductility and energy, and degraded unloading stiffness based on ductility. uniaxialMaterial Hysteretic $matTag $s1p $e1p $s2p $e2p &lt; $s3p $e3p &gt; $s1n $e1n $s2n $e2n &lt; $s3n $e3n &gt; $pinchX $pinchY $damage1 $damage2 &lt; $beta &gt; matTag integer tag identifying material $s1p \\(e1p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at first point of the envelope in the positive direction</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s2p \\(e2p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at second point of the envelope in the positive direction</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) s3p \\(e3p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at third point of the envelope in the positive direction (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s1n \\(e1n</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at first point of the envelope in the negative direction</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) s2n \\(e2n</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at second point of the envelope in the negative direction</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s3n $e3n stress and strain (or force & deformation) at third point of the envelope in the negative direction (optional) pinchx pinching factor for strain (or deformation) during reloading pinchy pinching factor for stress (or force) during reloading damage1 damage due to ductility: D1(mu-1) damage2 damage due to energy: D2(Eii/Eult) beta power used to determine the degraded unloading stiffness based on ductility, mu-beta (optional, default=0.0) Hysteretic.gif Hysteretic2.png NOTE: In cases $s3p > \\(s2p and abs(\\) s3n) > abs($s2n), the envelope of the hysteretic material after $e3p or $e3n follows the slope defined by 2nd and 3rd point of the envelope. In cases $s3p <= \\(s2p and abs(\\) s3n) <= abs($s2n) the envelope of the hysteretic material after $e3p or $e3n is a flat line with a constant stress (or force) equal to $s3p or $s3n. Examples Effects of Hysteretic-Material Parameters 1 Code Developed by: Michael Scott (Oregon State University) & Filip Filippou (UC Berkeley) Images Developed by: Silvia Mazzoni","title":"Hysteretic\n"},{"location":"contrib/modeling/uniaxialMaterial/334-Impact%20Material/","text":"ImpactMaterial This command is used to construct an impact material object uniaxialMaterial ImpactMaterial $matTag $K1 $K2 $\u03b4y \\(gap</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>integer tag identifying material</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">K1</code></p></td> <td><p>initial stiffness</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">K2</code></p></td> <td><p>secondary stiffness</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) \u03b4y yield displacement gap initial gap* NOTES: This material is implemented as a compression-only gap material. Delta_y and gap should be input as negative values. DESCRIPTION: This material is based on an approximation to the Hertz contact model proposed by Muthukumar (See REFERENCES below). The energy dissipated during impact is: E = kh * \u03b4m^(n+1) * (1-e^2) / (N+1) where kh is the impact stiffness parameter, with a typical value of EA/L or 25,000 k-in.-3/2; n is typically taken as 3/2 for the exponent associated with the Hertz power rule; e is the coefficient of restitution, with typical values from 0.6-0.8; and \u03b4m is the maximum penetration during the pounding event. The effective stiffness, Keff, is: Keff = kh * sqrt(\u03b4m) The yield displacement is: \u03b4y = a * \u03b4m where a is typically taken as 0.1. The initial stiffness, K1, and secondary stiffness, K2, are then selected such that the Impact model dissipates an amount of energy during a pounding event that is consistent with the associated energy dissipated in the Hertz model. K1 = Keff + E / (a*\u03b4m^2) K2 = Keff - E / ((1-a)*\u03b4m^2) Response of Impact Material during a pounding event. ImpactA.gif Response of Impact Material for displacement cycles of increasing amplitude. ImpactB.gif Examples REFERENCES: Muthukumar, S., and DesRoches, R. (2006). \u201cA Hertz Contact Model with Non-linear Damping for Pounding Simulation.\u201d Earthquake Engineering and Structural Dynamics, 35, 811-828. Muthukumar, S. (2003). \u201cA Contact Element Approach with Hysteresis Damping for the Analysis and Design of Pounding in Bridges.\u201d PhD Thesis, Georgia Institute of Technology. http://smartech.gatech.edu/ Nielson, B. (2005). \u201cAnalytical Fragility Curves for Highway Bridges in Moderate Seismic Zones.\u201d PhD Thesis, Georgia Institute of Technology. http://smartech.gatech.edu/ Code Developed by: Mathew Dryden, UC Berkeley","title":"ImpactMaterial\n"},{"location":"contrib/modeling/uniaxialMaterial/339-Initial%20Strain%20Material/","text":"InitialStrainMaterial This command is used to construct an Initial Strain material object. The stress-strain behaviour for this material is defined by another material. Initial Strain Material enables definition of initial strains for the material under consideration. The stress that corresponds to the initial strain will be calculated from the other material. uniaxialMaterial InitStrainMaterial $matTag $otherTag $initStrain matTag integer tag identifying material otherTag tag of the other material initStrain initial strain","title":"InitialStrainMaterial\n"},{"location":"contrib/modeling/uniaxialMaterial/340-Initial%20Stress%20Material/","text":"Initial Stress Material This command is used to construct an Initial Stress material object. The stress-strain behaviour for this material is defined by another material. Initial Stress Material enables definition of initial stress for the material under consideration. The strian that corresponds to the initial stress will be calculated from the other material. uniaxialMaterial InitStressMaterial $matTag $otherTag $initStress matTag integer tag identifying material otherTag tag of the other material initStress initial stress","title":"Initial Stress Material\n"},{"location":"contrib/modeling/uniaxialMaterial/351-KikuchiAikenHDR%20Material/","text":"KikuchiAikenHDR This command is used to construct a uniaxial KikuchiAikenHDR material object. This material model produces nonlinear hysteretic curves of high damping rubber bearings (HDRs). uniaxialMaterial KikuchiAikenHDR $matTag $tp $ar $hr &lt;-coGHU $cg $ch $cu &gt; &lt;-coMSS $rs $rf &gt; matTag integer tag identifying material tp rubber type (see note 1) ar area of rubber [unit: m^2] (see note 2) hr total thickness of rubber [unit: m] (see note 2) $cg $ch \\(cu</strong></p></td> <td><p>correction coefficients for equivalent shear modulus (<code class=\"tcl-variable\">cg</code>), equivalent viscous daming ratio (<code class=\"tcl-variable\">ch</code>), ratio of shear force at zero displacement (<code class=\"tcl-variable\">cu</code>).</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) rs $rf reduction rate for stiffness ( rs ) and force ( rf ) (see note 3) NOTES: Following rubber types for tp are available: X0.6 Bridgestone X0.6, standard compressive stress, up to 400% shear strain X0.6-0MPa Bridgestone X0.6, zero compressive stress, up to 400% shear strain X0.4 Bridgestone X0.4, standard compressive stress, up to 400% shear strain X0.4-0MPa Bridgestone X0.4, zero compressive stress, up to 400% shear strain X0.3 Bridgestone X0.3, standard compressive stress, up to 400% shear strain X0.3-0MPa Bridgestone X0.3, zero compressive stress, up to 400% shear strain This material uses SI unit in calculation formula. ar and hr must be converted into [m^2] and [m] , respectively. rs and rf are\u3000available if this material is applied to multipleShearSpring (MSS) element. Recommended values are rs =1/sum(i=0,n-1){ sin(pi i/n)^2} and rf =1/sum(i=0,n-1){sin(pi i/n)}, where n is the number of springs in the MSS. For example, when n=8, $rs=0.2500, $rf=0.1989. Examples KikuchiAikenHDR_sample.tcl KikuchiAikenHDR_StressStrain.png Code Developed by: mkiku","title":"KikuchiAikenHDR\n"},{"location":"contrib/modeling/uniaxialMaterial/352-KikuchiAikenLRB%20Material/","text":"KikuchiAikenLRB This command is used to construct a uniaxial KikuchiAikenLRB material object. This material model produces nonlinear hysteretic curves of lead-rubber bearings. uniaxialMaterial KikuchiAikenLRB $matTag $type $ar $hr $gr $ap $tp $alph $beta &lt;-T $temp &gt; &lt;-coKQ $rk $rq &gt; &lt;-coMSS $rs $rf &gt; matTag integer tag identifying material type rubber type (see note 1) ar area of rubber [unit: m^2] hr total thickness of rubber [unit: m] gr shear modulus of rubber [unit: N/m^2] ap area of lead plug [unit: m^2] tp yield stress of lead plug [unit: N/m^2] alph shear modulus of lead plug [unit: N/m^2] beta ratio of initial stiffness to yielding stiffness temp temperature [unit: &deg;C] $rk \\(rq</strong></p></td> <td><p>reduction rate for yielding stiffness (<code class=\"tcl-variable\">rk</code>) and force at zero displacement (<code class=\"tcl-variable\">rq</code>)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) rs $rf reduction rate for stiffness ( rs ) and force ( rf ) (see note 3) NOTES: Following rubber types for type are available: 1 lead-rubber bearing, up to 400% shear strain [Kikuchi et al., 2010 & 2012] This material uses SI unit in calculation formula. Input arguments must be converted into [m] , [m^2] , [N/m^2] . rs and rf are available if this material is applied to multipleShearSpring (MSS) element. Recommended values are rs =1/sum(i=0,n-1){ sin(pi i/n)^2} and rf =1/sum(i=0,n-1){sin(pi i/n)}, where n is the number of springs in the MSS. For example, when n=8, $rs=0.2500 and $rf=0.1989. Examples KikuchiAikenLRB_sample.tcl KikuchiAikenLRB_ForceStrain.png REFERENCES: M. Kikuchi, T. Nakamura, I. D. Aiken, \u201cThree-dimensional analysis for square seismic isolation bearings under large shear deformations and high axial loads\u201d, Earthquake Engineering and Structural Dynamics , Vol. 39, 1513-1531, 2010. M. Kikuchi , I. D. Aiken, A. Kasalanati , \u201cSimulation analysis for the ultimate behavior of full-scale lead-rubber seismic isolation bearings\u201d, 15th World Conference on Earthquake Engineering , No. 1688, 2012. Code Developed by: mkiku","title":"KikuchiAikenLRB\n"},{"location":"contrib/modeling/uniaxialMaterial/367-Limit%20State%20Material/","text":"LimitState This command is used to construct a uniaxial hysteretic material object with pinching of force and deformation, damage due to ductility and energy, and degraded unloading stiffness based on ductility. Failure of the material is defined by the associated Limit Curve . uniaxialMaterial LimitState $matTag $s1p $e1p $s2p $e2p $s3p $e3p $s1n $e1n $s2n $e2n $s3n $e3n $pinchX $pinchY $damage1 $damage2 $beta $curveTag $curveType . matTag integer tag identifying material $s1p \\(e1p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at first point of the envelope in the positive direction</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s2p \\(e2p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at second point of the envelope in the positive direction</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) s3p \\(e3p</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at third point of the envelope in the positive direction</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s1n \\(e1n</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at first point of the envelope in the negative direction*</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) s2n \\(e2n</strong></p></td> <td><p>stress and strain (or force &amp; deformation) at second point of the envelope in the negative direction*</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) s3n $e3n stress and strain (or force & deformation) at third point of the envelope in the negative direction* pinchX pinching factor for strain (or deformation) during reloading pinchY pinching factor for stress (or force) during reloading damage1 damage due to ductility: D1(m-1) damage2 damage due to energy: D2(Ei/Eult) beta power used to determine the degraded unloading stiffness based on ductility, m-b (optional, default=0.0) curveTag an integer tag for the Limit Curve defining the limit surface curveType an integer defining the type of LimitCurve (0 = no curve, 1 = axial curve, all other curves can be any other integer) NOTES: negative backbone points should be entered as negative numeric values Examples Original version of example: LimitStateMaterialExample Debugged version of example: LimitStateMaterialExampleDebugged Manual for the example: Limit State Material - Example Manual DESCRIPTION: Modeling Failures in Existing Reinforced Concrete Columns by Ken Elwood: file:ElwoodCJCE2004.pdf REFERENCES: Elwood, K.J and Moehle, J.P., \u201cShake Table Tests and Analystical Studies on the Gravity Load Collapse of Reinforced Concrete Frames\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, CA. PEER 2003/01. Code Developed by: Ken Elwood, University of British Columbia","title":"LimitState\n"},{"location":"contrib/modeling/uniaxialMaterial/381-Maxwell%20Material/","text":"Maxwell This command is used to construct a ViscousDamper material, which represents the Maxwell Model (linear spring and nonlinear dashpot in series). The ViscousDamper material simulates the hysteretic response of nonlinear viscous dampers. An adaptive iterative algorithm has been implemented and validated to solve numerically the constitutive equations within a nonlinear viscous damper with a high-precision accuracy. uniaxialMaterial ViscousDamper $matTag $K $Cd $alpha &lt; $LGap &gt; &lt; $NM $RelTol $AbsTol $MaxHalf &gt; matTag integer tag identifying material K Elastic stiffness of linear spring to model the axial flexibility of a viscous damper (e.g. combined stiffness of the supporting brace and internal damper portion) Cd Damping coefficient alpha Velocity exponent LGap Gap length to simulate the gap length due to the pin tolerance NM Employed adaptive numerical algorithm (default value NM = 1; 1 = Dormand-Prince54, 2=6th order Adams-Bashforth-Moulton, 3=modified Rosenbrock Triple) RelTol Tolerance for absolute relative error control of the adaptive iterative algorithm (default value 10^-6) AbsTol Tolerance for absolute error control of adaptive iterative algorithm (default value 10^-10) MaxHalf Maximum number of sub-step iterations within an integration step (default value 15) Examples: 1. Input parameters: Assume a viscous damper with axial stiffness K=300.0kN/mm, damping coefficient Cd=280.3kN(s/mm)<sup>0.3</sup>, and exponent a=0.30. The input parameters for the material should be as follows: uniaxialMaterial ViscousDamper 1 300 280.3 0.30 Using these properties, Figure 1 shows the hysteretic response of this damper for sinusoidal displacement increments of 12, 24 and 36mm and a frequency f = 0.5Hz. The sensitivity of the viscous damper with respect to its velocity exponent is shown in Figures 2 to 4 for the following set of parameters: Viscous Damper with various input parameter variations 2. Single story single bay frame with viscous damper References : [1] Akcelyan, S., Lignos, D. G., Hikino, T., and Nakashima, M. (2016). \u201cEvaluation of simplified and state-of-the-art analysis procedures for steel frame buildings equipped with supplemental damping devices based on E-Defense full-scale shake table tests.\u201d Journal of Structural Engineering, 142(6), 04016024. 1 [2] Oohara, K., and Kasai, K. (2002), \u201cTime-History Analysis Models for Nonlinear Viscous Dampers\u201d, Proc. Structural Engineers World Congress (SEWC), Yokohama, JAPAN, CD-ROM, T2-2-b-3 (in Japanese). [3] Kasai K, Oohara K. \u201cAlgorithm and Computer Code To Simulate Response of Nonlinear Viscous Damper\u201d Passively Controlled Structure Symposium 2001, Yokohama, Japan (in Japanese). Code Developed and Implemented by : Sarven Akcelyan & Prof. Dimitrios G. Lignos , (McGill University)","title":"Maxwell\n"},{"location":"contrib/modeling/uniaxialMaterial/386-MinMax%20Material/","text":"MinMax This command is used to construct a MinMax material object. This stress-strain behaviour for this material is provided by another material. If however the strain ever falls below or above certain threshold values, the other material is assumed to have failed. From that point on, values of 0.0 are returned for the tangent and stress. uniaxialMaterial MinMax $matTag $otherTag &lt;-min $minStrain &gt; &lt;-max $maxStrain &gt; matTag integer tag identifying material otherTag tag of the other material minStrain minimum value of strain. optional default = -1.0e16. maxStrain max value of strain. optional default = 1.0e16. Code Developed by: Micheal Scott, Oregon State.","title":"MinMax\n"},{"location":"contrib/modeling/uniaxialMaterial/395-Modified%20Ibarra-Medina-Krawinkler%20Deterioration%20Model%20with%20Bilinear%20Hysteretic%20Response%20%28Bilin%20Material%29/","text":"ModIMKBilin This command is used to construct a bilin material. The bilin material simulates the modified Ibarra-Krawinkler deterioration model with bilinear hysteretic response. Note that the hysteretic response of this material has been calibrated with respect to more than 350 experimental data of steel beam-to-column connections and multivariate regression formulas are provided to estimate the deterioration parameters of the model for different connection types. These relationships were developed by Lignos and Krawinkler (2009, 2011) and have been adopted by PEER/ATC (2010). The input parameters for this component model can be computed interactively from this [link: http://resslabtools.epfl.ch/ ]. Use the module Component Model . uniaxialMaterial Bilin $matTag $K0 $as_Plus $as_Neg $My_Plus $My_Neg $Lamda_S $Lamda_C $Lamda_A $Lamda_K $c_S $c_C $c_A $c_K $theta_p_Plus $theta_p_Neg $theta_pc_Plus $theta_pc_Neg $Res_Pos $Res_Neg $theta_u_Plus $theta_u_Neg $D_Plus $D_Neg &lt; $nFactor &gt; matTag integer tag identifying material K0 elastic stiffness as_Plus strain hardening ratio for positive loading direction as_Neg strain hardening ratio for negative loading direction My_Plus effective yield strength for positive loading direction My_Neg effective yield strength for negative loading direction (negative value) Lamda_S Cyclic deterioration parameter for strength deterioration [E_t=Lamda_S*M_y; set Lamda_S = 0 to disable this mode of deterioration] Lamda_C Cyclic deterioration parameter for post-capping strength deterioration [E_t=Lamda_C*M_y; set Lamda_C = 0 to disable this mode of deterioration] Lamda_A Cyclic deterioration parameter for acceleration reloading stiffness deterioration (is not a deterioration mode for a component with Bilinear hysteretic response) [Input value is required, but not used; set Lamda_A = 0]. Lamda_K Cyclic deterioration parameter for unloading stiffness deterioration [E_t=Lamda_K*M_y; set Lamda_k = 0 to disable this mode of deterioration] c_S rate of strength deterioration. The default value is 1.0. c_C rate of post-capping strength deterioration. The default value is 1.0. c_A rate of accelerated reloading deterioration. The default value is 1.0. c_K rate of unloading stiffness deterioration. The default value is 1.0. theta_p_Plus pre-capping rotation for positive loading direction (often noted as plastic rotation capacity) theta_p_Neg pre-capping rotation for negative loading direction (often noted as plastic rotation capacity) (positive value) theta_pc_Plus post-capping rotation for positive loading direction theta_pc_Neg post-capping rotation for negative loading direction (positive value) Res_Pos residual strength ratio for positive loading direction Res_Neg residual strength ratio for negative loading direction (positive value) theta_u_Plus ultimate rotation capacity for positive loading direction theta_u_Neg ultimate rotation capacity for negative loading direction (positive value) D_Plus rate of cyclic deterioration in the positive loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. D_Neg rate of cyclic deterioration in the negative loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. nFactor elastic stiffness amplification factor, mainly for use with concentrated plastic hinge elements (optional, default = 0). ModIKModel.PNG Image from: Lignos et al. (2011) The deterioration model parameters can be calibrated based on actual experimental data of steel components. Instead, a user can determine the same parameters with predictive equations that have been developed by Lignos and Krawinkler (2009, 2011). These equations relate deterioration modelling parameters with geometric and material properties of steel components and have been developed with multivariate regression analysis after extensive calibration of a recently developed steel component database of more than 300 steel specimens (Lignos and Krawinkler 2007, 2009, 2011). References : [1] Ibarra L.F., and Krawinkler, H. (2005). \u201cGlobal collapse of frame structures under seismic excitations\u201d, Rep. No. TB 152, The John A. Blume Earthquake Engineering Center, Stanford University, Stanford, CA. [2] Ibarra L.F., Medina R. A., and Krawinkler H. (2005). \u201cHysteretic models that incorporate strength and stiffness deterioration\u201d, Earthquake Engineering and Structural Dynamics, 34(12), 1489-1511. [3] Karavasilis T.L., Ricles J.M., Sause R. (2009). \u201cImplementation of deterioration elements in OpenSEES for collapse simulations\u201d ATLSS Engineering Research Center, Rep. No. 09-11. [4] Lignos, D.G., and Krawinkler, H. (2007), \u201cA database in support of modeling of component deterioration for collapse prediction of steel frame structures\u201d, Proc. ASCE Structures Congress, Long Beach CA, SEI institute. [5] Lignos, D.G. and Krawinkler, H. (2012). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Rep.No.TB 177, The John A. Blume Earthquake Engineering Research Center, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] [6] Lignos, D. G., Krawinkler, H. and Whittaker, A.S. (2011). \u201cPrediction and validation of sidesway collapse of two scale models of a 4-story steel moment frame\u201d, Earthquake Engineering and Structural Dynamics, EESD, Vol. 40 (7), 807-825. [7] Lignos, D.G., and Krawinkler, H. (2010). \u201cA steel database for component deterioration of tubular hollow square steel columns under varying axial load for collapse assessment of steel structures under earthquakes\u201d, Proc. 7th International Conference on Urban Earthquake Engineering (7CUEE), March 3-5, Tokyo, Japan. [8] Lignos, D.G., and Krawinkler, H. (2011). \u201cDeterioration modeling of steel components in support of collapse prediction of steel moment frames under earthquake loading\u201d, Journal of Structural Engineering, ASCE, Vol. 137 (11), 1291-1302. [9] PEER/ATC (2010). \u201cModeling and acceptance criteria for seismic design and analysis of tall buildings\u201d, PEER/ATC-72-1, prepared by the Applied Technology Council in cooperation with the Pacific Earthquake Engineering Research Center, Redwood City, CA.. [10] Lignos, D.G., Hartloper, A.R., Elkady, A.M.A., Deirlein, G.G., Hamburger, R. (2019). \u201cProposed Updates to the ASCE 41 Nonlinear Modeling Parameters for Wide-Flange Steel Columns in Support of Performance-Based Seismic Engineering\u201d, Journal of Structural Engineering, 04019083, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002353 . Code Developed by : by Dr. Dimitrios G. Lignos, McGill University and was implemented by Dr. Theodore Karavasilis, Oxford University nFactor Implemented by: by Dr. Andre R. Barbosa, Oregon State University and Mr. Filipe L.A. Ribeiro, Universidade Nova de Lisboa","title":"ModIMKBilin\n"},{"location":"contrib/modeling/uniaxialMaterial/396-Modified%20Ibarra-Medina-Krawinkler%20Deterioration%20Model%20with%20Peak-Oriented%20Hysteretic%20Response%20%28ModIMKPeakOriented%20Material%29/","text":"ModIMKPeakOriented This command is used to construct a ModIMKPeakOriented material. This material simulates the modified Ibarra-Medina-Krawinkler deterioration model with peak-oriented hysteretic response. Note that the hysteretic response of this material has been calibrated with respect to 200 experimental data of RC beams in order to estimate the deterioration parameters of the model. This information was developed by Lignos and Krawinkler (2012). NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. . A youtube video presents a summary of this model including the way to be used within openSees (http://youtu.be/YHBHQ-xuybE). uniaxialMaterial ModIMKPeakOriented $matTag $K0 $as_Plus $as_Neg $My_Plus $My_Neg $Lamda_S $Lamda_C $Lamda_A $Lamda_K $c_S $c_C $c_A $c_K $theta_p_Plus $theta_p_Neg $theta_pc_Plus $theta_pc_Neg $Res_Pos $Res_Neg $theta_u_Plus $theta_u_Neg $D_Plus $D_Neg matTag integer tag identifying material K0 elastic stiffness as_Plus strain hardening ratio for positive loading direction as_Neg strain hardening ratio for negative loading direction My_Plus effective yield strength for positive loading direction My_Neg effective yield strength for negative loading direction (negative value) Lamda_S Cyclic deterioration parameter for strength deterioration [E_t=Lamda_S*M_y, see Lignos and Krawinkler (2011); set Lamda_S = 0 to disable this mode of deterioration] Lamda_C Cyclic deterioration parameter for post-capping strength deterioration [E_t=Lamda_C*M_y, see Lignos and Krawinkler (2011); set Lamda_C = 0 to disable this mode of deterioration] Lamda_A Cyclic deterioration parameter for accelerated reloading stiffness deterioration [E_t=Lamda_A*M_y, see Lignos and Krawinkler (2011); set Lamda_A = 0 to disable this mode of deterioration] Lamda_K Cyclic deterioration parameter for unloading stiffness deterioration [E_t=Lamda_K*M_y, see Lignos and Krawinkler (2011); set Lamda_K = 0 to disable this mode of deterioration] c_S rate of strength deterioration. The default value is 1.0. c_C rate of post-capping strength deterioration. The default value is 1.0. c_A rate of accelerated reloading deterioration. The default value is 1.0. c_K rate of unloading stiffness deterioration. The default value is 1.0. theta_p_Plus pre-capping rotation for positive loading direction (often noted as plastic rotation capacity) theta_p_Neg pre-capping rotation for negative loading direction (often noted as plastic rotation capacity) (must be defined as a positive value) theta_pc_Plus post-capping rotation for positive loading direction theta_pc_Neg post-capping rotation for negative loading direction (must be defined as a positive value) Res_Pos residual strength ratio for positive loading direction Res_Neg residual strength ratio for negative loading direction (must be defined as a positive value) theta_u_Plus ultimate rotation capacity for positive loading direction theta_u_Neg ultimate rotation capacity for negative loading direction (must be defined as a positive value) D_Plus rate of cyclic deterioration in the positive loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. D_Neg rate of cyclic deterioration in the negative loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. ModIMKPeakOrientedDefinitionFigure.png Image from: Lignos and Krawinkler (2012) The deterioration model parameters can be calibrated based on actual experimental data of RC beams in terms of load - displacement or moment - rotation. Examples of such calibrations can be found in Lignos (2008) and Lignos and Krawinkler (2012). References : [1] Lignos, D.G., Krawinkler, H. (2012). \u201cDevelopment and Utilization of Structural Component Databases for Performance-Based Earthquake Engineering\u201d, Journal of Structural Engineering, ASCE, doi: 10.1061/(ASCE)ST.1943-541X.0000646. [2] Lignos, D.G., and Krawinkler, H. (2011). \u201cDeterioration modeling of steel components in support of collapse prediction of steel moment frames under earthquake loading\u201d, Journal of Structural Engineering, ASCE, Vol. 137 (11), 1291-1302. [3] Lignos, D.G. and Krawinkler, H. (2012). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Rep.No.TB 177, The John A. Blume Earthquake Engineering Research Center, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] [4] Lignos, D.G. (2008). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Ph.D. Dissertation, Department of Civil and Environmental Engineering, Stanford University, Stanford, CA. [5] Ibarra L.F., and Krawinkler, H. (2005). \u201cGlobal collapse of frame structures under seismic excitations\u201d, Rep. No. TB 152, The John A. Blume Earthquake Engineering Center, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] [6] Ibarra L.F., Medina R. A., and Krawinkler H. (2005). \u201cHysteretic models that incorporate strength and stiffness deterioration\u201d, Earthquake Engineering and Structural Dynamics, 34(12), 1489-1511. Code Developed by : by Dr. Dimitrios G. Lignos, McGill University","title":"ModIMKPeakOriented\n"},{"location":"contrib/modeling/uniaxialMaterial/397-Modified%20Ibarra-Medina-Krawinkler%20Deterioration%20Model%20with%20Pinched%20Hysteretic%20Response%20%28ModIMKPinching%20Material%29/","text":"ModIMKPinching This command is used to construct a ModIMKPinching material. This material simulates the modified Ibarra-Medina-Krawinkler deterioration model with pinching hysteretic response. NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. A youtube video presents a summary of this model including the way to be used within openSees (http://youtu.be/YHBHQ-xuybE). uniaxialMaterial ModIMKPinching $matTag $K0 $as_Plus $as_Neg $My_Plus $My_Neg $FprPos $FprNeg $A_pinch $Lamda_S $Lamda_C $Lamda_A $Lamda_K $c_S $c_C $c_A $c_K $theta_p_Plus $theta_p_Neg $theta_pc_Plus $theta_pc_Neg $Res_Pos $Res_Neg $theta_u_Plus $theta_u_Neg $D_Plus $D_Neg matTag integer tag identifying material K0 elastic stiffness as_Plus strain hardening ratio for positive loading direction as_Neg strain hardening ratio for negative loading direction My_Plus effective yield strength for positive loading direction My_Neg effective yield strength for negative loading direction (Must be defined as a negative value) FprPos Ratio of the force at which reloading begins to force corresponding to the maximum historic deformation demand (positive loading direction) FprNeg Ratio of the force at which reloading begins to force corresponding to the absolute maximum historic deformation demand (negative loading direction) A_Pinch Ratio of reloading stiffness Lamda_S Cyclic deterioration parameter for strength deterioration [E_t=Lamda_S*M_y, see Lignos and Krawinkler (2011); set Lamda_S = 0 to disable this mode of deterioration] Lamda_C Cyclic deterioration parameter for post-capping strength deterioration [E_t=Lamda_C*M_y, see Lignos and Krawinkler (2011); set Lamda_C = 0 to disable this mode of deterioration] Lamda_A Cyclic deterioration parameter for accelerated reloading stiffness deterioration [E_t=Lamda_A*M_y, see Lignos and Krawinkler (2011); set Lamda_A = 0 to disable this mode of deterioration] Lamda_K Cyclic deterioration parameter for unloading stiffness deterioration [E_t=Lamda_K*M_y, see Lignos and Krawinkler (2011); set Lamda_K = 0 to disable this mode of deterioration] c_S rate of strength deterioration. The default value is 1.0. c_C rate of post-capping strength deterioration. The default value is 1.0. c_A rate of accelerated reloading deterioration. The default value is 1.0. c_K rate of unloading stiffness deterioration. The default value is 1.0. theta_p_Plus pre-capping rotation for positive loading direction (often noted as plastic rotation capacity) theta_p_Neg pre-capping rotation for negative loading direction (often noted as plastic rotation capacity) (must be defined as a positive value) theta_pc_Plus post-capping rotation for positive loading direction theta_pc_Neg post-capping rotation for negative loading direction (must be defined as a positive value) Res_Pos residual strength ratio for positive loading direction Res_Neg residual strength ratio for negative loading direction (must be defined as a positive value) theta_u_Plus ultimate rotation capacity for positive loading direction theta_u_Neg ultimate rotation capacity for negative loading direction (must be defined as a positive value) D_Plus rate of cyclic deterioration in the positive loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. D_Neg rate of cyclic deterioration in the negative loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. ModIMKDefinitionFigure.png Image from: Lignos and Krawinkler (2012) The deterioration model parameters can be calibrated based on actual experimental data of RC beams in terms of load - displacement or moment - rotation. Examples of such calibrations can be found in Lignos (2008) and Lignos and Krawinkler (2012). References : [1] Lignos, D.G., Krawinkler, H. (2012). \u201cDevelopment and Utilization of Structural Component Databases for Performance-Based Earthquake Engineering\u201d, Journal of Structural Engineering, ASCE, doi: 10.1061/(ASCE)ST.1943-541X.0000646. [2] Lignos, D.G., and Krawinkler, H. (2011). \u201cDeterioration modeling of steel components in support of collapse prediction of steel moment frames under earthquake loading\u201d, Journal of Structural Engineering, ASCE, Vol. 137 (11), 1291-1302. [3] Lignos, D.G. and Krawinkler, H. (2012). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Rep.No.TB 177, The John A. Blume Earthquake Engineering Research Center, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] [4] Lignos, D.G. (2008). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Ph.D. Dissertation, Department of Civil and Environmental Engineering, Stanford University, Stanford, CA. [5] Ibarra L.F., and Krawinkler, H. (2005). \u201cGlobal collapse of frame structures under seismic excitations\u201d, Rep. No. TB 152, The John A. Blume Earthquake Engineering Center, Stanford University, Stanford, CA. [electronic version: https://blume.stanford.edu/tech_reports ] [6] Ibarra L.F., Medina R. A., and Krawinkler H. (2005). \u201cHysteretic models that incorporate strength and stiffness deterioration\u201d, Earthquake Engineering and Structural Dynamics, 34(12), 1489-1511. Code Developed by : by Dr. Dimitrios G. Lignos, McGill University","title":"ModIMKPinching\n"},{"location":"contrib/modeling/uniaxialMaterial/404-MultiLinear%20Material/","text":"MultiLinear This command is used to construct a uniaxial multilinear material object. uniaxialMaterial MultiLinear $matTag $u1 $f1 $u2 $f2 $u3 $f3 $u4 $f4 ... matTag integer tag identifying material $u1 \\(f1</strong></p></td> <td><p>strain and stress (or deformation &amp; force) at first point of the envelope</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) u2 \\(f2</strong></p></td> <td><p>strain and stress (or deformation &amp; force) at second point of the envelope</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) u3 \\(f3</strong></p></td> <td><p>strain and stress (or deformation &amp; force) at third point of the envelope</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) u4 $f4 strain and stress (or deformation & force) at fourth point of the envelope MultiLinear_Material2.png MultiLinear Material \u2013 Hysteretic Behavior Code Developed by: Frank Mckenna, UC Berkeley Images Developed by: Vesna Terzic","title":"MultiLinear\n"},{"location":"contrib/modeling/uniaxialMaterial/489-Parallel%20Material/","text":"Parallel This command is used to construct a parallel material object made up of an arbitrary number of previously-constructed UniaxialMaterial objects. uniaxialMaterial Parallel $matTag $tag1 $tag2 ... &lt;-factors $fact1 $fact2 ...&gt; matTag integer tag identifying material $tag1 \\(tag2 ...</strong></p></td> <td><p>identification tags of materials making up the material model</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) fact1 $fact2 \u2026 factors to create a linear combination of the specified materials. Factors can be negative to subtract one material from an other. (optional, default = 1.0) The parallel material is represented graphically: In a parallel model, strains are equal and stresses and stiffnesses are additive: Code Developed by: fmk Images Developed by: Silvia Mazzoni","title":"Parallel\n"},{"location":"contrib/modeling/uniaxialMaterial/504-Pinching4%20Material/","text":"Pinching4 This command is used to construct a uniaxial material that represents a \u2018pinched\u2019 load-deformation response and exhibits degradation under cyclic loading. Cyclic degradation of strength and stiffness occurs in three ways: unloading stiffness degradation, reloading stiffness degradation, strength degradation. uniaxialMaterial Pinching4 $matTag $ePf1 $ePd1 $ePf2 $ePd2 $ePf3 $ePd3 $ePf4 $ePd4 < $eNf1 $eNd1 $eNf2 $eNd2 $eNf3 $eNd3 $eNf4 $eNd4 > $rDispP $rForceP $uForceP < $rDispN $rForceN $uForceN > $gK1 $gK2 $gK3 $gK4 $gKLim $gD1 $gD2 $gD3 $gD4 $gDLim $gF1 $gF2 $gF3 $gF4 $gFLim $gE $dmgType matTag integer tag identifying material ePf1 ePf2 ePf3 ePf4 floating point values defining force points on the positive response envelope ePd1 ePd2 ePd3 ePd4 floating point values defining deformation points on the positive response envelope eNf1 eNf2 eNf3 eNf4 floating point values defining force points on the negative response envelope eNd1 eNd2 eNd3 eNd4 floating point values defining deformation points on the negative response envelope rDispP floating point value defining the ratio of the deformation at which reloading occurs to the maximum historic deformation demand fFoceP floating point value defining the ratio of the force at which reloading begins to force corresponding to the maximum historic deformation demand uForceP floating point value defining the ratio of strength developed upon unloading from negative load to the maximum strength developed under monotonic loading rDispN floating point value defining the ratio of the deformation at which reloading occurs to the minimum historic deformation demand fFoceN floating point value defining the ratio of the force at which reloading begins to force corresponding to the minimum historic deformation demand uForceN floating point value defining the ratio of strength developed upon unloading from negative load to the minimum strength developed under monotonic loading gK1 gK2 gK3 gK4 gKLim floating point values controlling cyclic degradation model for unloading stiffness degradation gD1 gD2 gD3 gD4 gDLim floating point values controlling cyclic degradation model for reloading stiffness degradation gF1 gF2 gF3 gF4 gFLim floating point values controlling cyclic degradation model for strength degradation gE floating point value used to define maximum energy dissipation under cyclic loading. Total energy dissipation capacity is defined as this factor multiplied by the energy dissipated under monotonic loading. dmgType string to indicate type of damage (option: \u201ccycle\u201d, \u201cenergy\u201d) NOTES: Piinching4.jpg Damage Models: Stiffness and strength are assumed to deteriorate due to the imposed \u201cload\u201d history. The same basic equations are used to describe deterioration in strength, unloading stiffness and reloading stiffness: \\[k_i = k_0(1 -\\delta k_i)\\] where \\(k_i\\) is the unloading stiffness at time \\(t_i\\) , \\(k_0\\) is the initial unloading stiffness (for the case of no damage), and \\(\\delta k_i\\) (defined below) is the value of the stiffness damage index at time \\(t_i\\) . \\[d_{\\text{max i}} = d_{\\text{max 0}}(1 -\\delta d_i)\\] where \\(d_{\\text{max i}}\\) is the deformation demand that defines the end of the reload cycle for increasing deformation demand, $d_{} $ is the maximum historic deformation demand (which would be the deformation demand defining the end of the reload cycle if degradation of reloading stiffness is ignored), and \\(\\delta d_i\\) (defined below) is the value of reloading stiffness damage index at time \\(t_i\\) . \\[f_{\\text{max i}} = f_{\\text{max 0}}(1 -\\delta f_i)\\] where \\(f_{\\text{max i}}\\) is the current envelope maximum strength at time \\(t_i\\) , $f_{} $ is the initial envelope maximum strength for the case of no damage, and \\(\\delta f_i\\) (defined below) is the value of strength value index at time \\(t_i\\) . The damage indices \\(\\delta k_i\\) , \\(\\delta d_i\\) , and \\(\\delta f_i\\) , may be defined to be a function of displacement history only ( dmgType = \"cycle\" ) or displacement history and energy accumulation ( dmgType = \"energy\" ). For either case, all of the damage indices are computed using the same basic equation. If the damage indices are assumed to be a function of displacement history and energy accumulation, the unloading stiffness damage index, \\(\\delta k_i\\) is computed as follows: \\[\\delta k_i = \\left( \\text{gK1} (d_{max})^\\text{gK3} + \\text{gK2} \\left (\\frac{E_i}{E_\\text{monotonic}} \\right )^\\text{gK3} \\right ) &lt;= \\text{gKLim}\\] where \\[(d_{max} = \\text{max} \\left[ \\frac{d_\\text{max i}}{\\text{def}_\\text{max}}, \\frac{d_\\text{min i}}{\\text{def}_\\text{min}} \\right ]\\] Examples Pinching4MaterialExample DESCRIPTION: Stiffness and strength are assumed to deteriorate due to the imposed \u201cload\u201d history. The same basic equations are used to describe deterioration in strength, unloading stiffness and reloading stiffness: REFERENCES: PEER 2003/10 Code Developed by: Nilinjan Mitra, University of Washington","title":"Pinching4\n"},{"location":"contrib/modeling/uniaxialMaterial/506-Pinching%20Limit%20State%20Material/","text":"Pinching Limit State Material This command is used to construct a uniaxial material that simulates a pinched load-deformation response and exhibits degradation under cyclic loading. This material works with the RotationShearCurve limit surface that can monitor a key deformation and/or a key force in an associated frame element and trigger a degrading behavior in this material when a limiting value of the deformation and/or force are reached. The material can be used in two modes: 1) direct input mode, where pinching and damage parameters are directly input; and 2) calibrated mode for shear-critical concrete columns, where only key column properties are input for model to fully define pinching and damage parameters. MODE 1: Direct Input uniaxialMaterial PinchingLimitStateMaterial $matTag $nodeT $nodeB $driftAxis $Kelas $crvTyp \\(crvTag</strong> <strong>\\) YpinchUPN $YpinchRPN \\(XpinchRPN</strong> <strong>\\) YpinchUNP $YpinchRNP \\(XpinchRNP</strong> <strong>\\) dmgStrsLimE \\(dmgDispMax</strong> <strong>\\) dmgE1 $dmgE2 $dmgE3 $dmgE4 \\(dmgELim</strong> <strong>\\) dmgR1 $dmgR2 $dmgR3 $dmgR4 \\(dmgRLim</strong> <code class=\"tcl-variable\">dmgRCyc</code> <strong>\\) dmgS1 $dmgS2 $dmgS3 $dmgS4 $dmgSLim dmgSCyc matTag unique material object integer tag nodeT integer node tag to define the first node at the extreme end of the associated flexural frame member (L3 or D5 in Figure) nodeB integer node tag to define the last node at the extreme end of the associated flexural frame member (L2 or D2 in Figure) driftAxis integer to indicate the drift axis in which lateral-strength degradation will occur. This axis should be orthogonal to the axis of measured rotation (see $rotAxis in Rotation Shear Curve definition) driftAxis = 1 - Drift along the x-axis driftAxis = 2 - Drift along the y-axis driftAxis = 3 - Drift along the z-axis Kelas floating point value to define the initial material elastic stiffness (Kelastic); Kelas > 0 crvTyp integer flag to indicate the type of limit curve associated with this material. crvTyp = 0 - No limit curve crvTyp = 1 - axial limit curve crvTyp = 2 - RotationShearCurve crvTag integer tag for the unique limit curve object associated with this material YpinchUPN floating point unloading force pinching factor for loading in the negative direction Note: This value must be between zero and unity YpinchRPN floating point reloading force pinching factor for loading in the negative direction Note: This value must be between negative one and unity XpinchRPN floating point reloading displacement pinching factor for loading in the negative direction Note: This value must be between negative one and unity YpinchUNP floating point unloading force pinching factor for loading in the positive direction Note: This value must be between zero and unity YpinchRNP floating point reloading force pinching factor for loading in the positive direction Note: This value must be between negative one and unity XpinchRNP floating point reloading displacement pinching factor for loading in the positive direction Note: This value must be between negative one and unity dmgStrsLimE floating point force limit for elastic stiffness damage (typically defined as the lowest of shear strength or shear at flexrual yielding). This value is used to compute the maximum deformation at flexural yield (\u03b4max Eq. 1) and using the initial elastic stiffness (Kelastic) the monotonic energy (Emono Eq. 1) to yield. Input 1 if this type of damage is not required and set $dmgE1, $dmgE2, $dmgE3, $dmgE4, and $dmgELim to zero dmgDispMax floating point for ultimate drift at failure (\u03b4max Eq. 1) and is used for strength and stiffness damage. This value is used to compute the monotonic energy at axial failure (Emono Eq. 2) by computing the area under the backbone in the positive loading direction up to \u03b4max. Input 1 if this type of damage is not required and set $dmgR1, $dmgR2, $dmgR3, $dmgR4, and $dmgRLim to zero for reloading stiffness damage. Similarly set $dmgS1, $dmgS2, $dmgS3, $dmgS4, and \\(dmgSLim to zero if reloading strength damage is not required</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dmgE1 $dmgE2 $dmgE3 \\(dmgE4</strong></p></td> <td><p>floating point elastic stiffness damage factors <em>\u03b11,\u03b12,\u03b13,\u03b14</em> shown in Eq. 1</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">dmgELim</code></td> <td><p>floating point elastic stiffness damage limit <em>Dlim</em> shown in Eq. 1; Note: This value must be between zero and unity</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dmgR1 $dmgR2 $dmgR3 \\(dmgR4</strong></p></td> <td><p>floating point reloading stiffness damage factors <em>\u03b11,\u03b12,\u03b13,\u03b14</em> shown in Eq. 1</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">dmgRLim</code></td> <td><p>floating point reloading stiffness damage limit <em>Dlim</em> shown in Eq. 1; Note: This value must be between zero and unity</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">dmgRCyc</code></td> <td><p>floating point cyclic reloading stiffness damage index; Note: This value must be between zero and unity</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) dmgS1 $dmgS2 $dmgS3 $dmgS4 floating point backbone strength damage factors \u03b11,\u03b12,\u03b13,\u03b14 shown in Eq. 1 dmgSLim floating point backbone strength damage limit Dlim shown in Eq. 1; Note: This value must be between zero and unity dmgSCyc floating point cyclic backbone strength damage index; Note: This value must be between zero and unity MODE 2: Calibrated Model for Shear-Critical Concrete Columns uniaxialMaterial PinchingLimitStateMaterial $matTag $nodeT $nodeB $driftAxis $Kelas $crvTyp $crvTag $eleTag $b $d $h $a $st $As $Acc $ld $db $rhot $f\u2019c $fy $fyt matTag unique material object integer tag nodeT integer node tag to define the first node at the extreme end of the associated flexural frame member (L3 or D5 in Figure) nodeB integer node tag to define the last node at the extreme end of the associated flexural frame member (L2 or D2 in Figure) driftAxis integer to indicate the drift axis in which lateral-strength degradation will occur. This axis should be orthogonal to the axis of measured rotation (see \\(rotAxis in Rotation Shear Curve definition)</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>driftAxis = 1 - Drift along the x-axis driftAxis = 2 - Drift along the y-axis driftAxis = 3 - Drift along the z-axis</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Kelas</code></td> <td><p>floating point value to define the shear stiffness (Kelastic) of the shear spring prior to shear failure</p></td> </tr> <tr class=\"odd\"> <td></td> <td><p>Kelas = -4 - Shear stiffness calculated assuming double curvature and shear springs at both column element ends</p> <p>Kelas = -3 - Shear stiffness calculated assuming double curvature and a shear spring at one column element end</p> <p>Kelas = -2 - Shear stiffness calculated assuming single curvature and shear springs at both column element ends</p> <p>Kelas = -1 - Shear stiffness calculated assuming single curvature and a shear spring at one column element end</p> <p>Kelas &gt; 0 - Shear stiffness is the input value</p> <p>Note: integer inputs allow the model to know whether column height equals the shear span (cantelever) or twice the shear span (double curvature). For columns in frames, input the value for the case that best approximates column end conditions or manually input shear stiffness (typically double curvature better estimates framed column behavior)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">crvTag</code></td> <td><p>integer tag for the unique limit curve object associated with this material</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>integer element tag to define the associated beam-column element used to extract axial load</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">b</code></td> <td><p>floating point column width (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">d</code></td> <td><p>floating point column depth (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">h</code></td> <td><p>floating point column height (inches)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">a</code></td> <td><p>floating point shear span length (inches)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">st</code></td> <td><p>floating point transverse reinforcement spacing (inches) along column height</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">As</code></td> <td><p>floating point total area (inches squared) of longitudinal steel bars in section</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Acc</code></td> <td><p>floating point gross confined concrete area (inches squared) bounded by the transverse reinforcement in column section</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ld</code></td> <td><p>floating point development length (inches) of longitudinal bars using ACI 318-11 Eq. 12-1 and Eq. 12-2</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">db</code></td> <td><p>floating point diameter (inches) of longitudinal bars in column section</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">rhot</code></td> <td><p>floating point transverse reinforcement ratio (Ast/st.db)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) f\u2019c floating point concrete compressive strength (ksi) fy floating point longitudinal steel yield strength (ksi) fyt floating point transverse steel yield strength (ksi) DESCRIPTION: PinchingLimitStateMaterial2.png PinchingLimitStateMaterial1-2.jpg The material model coupled with the RotationShearCurve limit surface: 1) has the ability to continually monitor forces and deformations in the flexural elements for conditions that trigger lateral-strength degradation, 2) has a built-in function that compensates for flexural deformation offsets that arise from the degrading behavior of the material in shear springs, and 3) is able to trigger lateral-strength degradation through either a limiting lateral force or element deformations (whichever is reached first). The material introduces several functionalities that give users a high degree of control over the triggering of strength degradation and the ensuing cyclic degrading behavior. Damage algorithms are implemented to control the degrading behavior through elastic stiffness, reloading stiffness, and backbone strength degradation (Fig. 2). The rate of damage accumulation can be controlled by energy-, displacement-, and cycle-based damage computation algorithms. During the degrading behavior, the model automatically adjusts reloading stiffness to achieve a symmetric global-element lateral load-vs lateral displacement behavior. The model does so by automatically adjusting the reloading stiffness and backbone curve of the material model to compensate for dissymmetry introduced by the unloading of the flexural elements in series with shear springs governed by the model. DAMAGE: Damage accumulations effects based on numbers of cycles can be introduced to reloading stiffness and backbone strength through the simple parameters $dmgRCyc and $dmgSCyc with values ranging from 0 to 1. Elastic stiffness, reloading stiffness, and strength can be adjusted using the following energy and displacement damage model (from Mitra and Lowes (2007)): PinchingLimitStateMaterialEq1.png Examples PinchingLimitStateMaterial Example REFERENCES: LeBorgne M. R., 2012, \u201cModeling the Post Shear Failure Behavior of Reinforced Concrete Columns.\u201d Austin, Texas: University of Texas at Austin, PhD, 301. LeBorgne, M.R., Ghannoum, W.M., 2014, \u201cAnalytical Element for Simulating Lateral-Strength Degradation in Reinforced Concrete Columns and Other Frame Members,\u201d Journal of Structural Engineering, V. 140, No. 7, pp. 04014038 1-12. LeBorgne, M.R., Ghannoum, W.M., 2014, \u201cCalibrated Analytical Element for Lateral-Strength Degradation of Reinforced Concrete Columns,\u201d Engineering Structures, V. 81, pp. 35-48. Ghannoum W. M., Moehle J. P., 2012, \u201cRotation-Based Shear Failure Model for Lightly Confined Reinforced Concrete Columns,\u201d Journal of Structural Engineering, V. 138, No. 10, 1267-78. Mitra Nilanjan, Lowes Laura N., 2007, \u201cEvaluation, Calibration, and Verification of a Reinforced Concrete Beam\u2013Column Joint Model,\u201d Journal of Structural Engineering, V. 133, No. 1, 105-20. Code Developed by: Matthew Leborgne and Wassim M. Ghannoum, University of Texas at Austin","title":"Pinching Limit State Material\n"},{"location":"contrib/modeling/uniaxialMaterial/512-Plane%20Stress%20Concrete%20Materials/","text":"ReinforcedConcretePlaneStress WARNING .. AT PRESENT CODE AS SUBMITTED DOES NOT APPEAR TO WORK .. LOOK AT CONVERGENCE IN EXAMPLE A number of Reinforced and Prestressed Concrete Plane Stress Materials are available. The ones on this page have been provided the University of Houston and are based on the Cyclic Softened Membrane Model (CSMM). They are capable of modeling the cyclic shear behavior of prestressed and reinforced concrete membranes. This code has been developed at the University of Houston by: A. Laskar , J. Zhong , Y.L. Mo , and Thomas T.C. Hsu , This command is used to construct a Reinforced Concrete Plane Stress material object based on Rotating Angle Theory with steel along two directions. nDMaterial ReinforcedConcretePlaneStress matTag? rho? s1? s2? c1? c2? angle1? angle2? rou1? rou2? fpc? fy? E0? epsc0? This command is used to construct a Reinforced Concrete Plane Stress material object based on Fixed Angle theory with steel along two directions. nDMaterial FAReinforcedConcretePlaneStress matTag? rho? s1? s2? c1? c2? angle1? angle2? rou1? rou2? fpc? fy? E0? epsc0? This command is used to construct a Reinforced Concrete Plane Stress material object based on Rotating Angle theory with steel along four directions. nDMaterial RAFourSteelRCPlaneStress matTag? rho? UniaxiaMatTag1? UniaxiaMatTag2? UniaxiaMatTag3? UniaxiaMatTag4? UniaxiaMatTag5? UniaxiaMatTag6? angle1? angle2? angle3? angle4? rou1? rou2? rou3? rou4? fpc? fy? E0? epsc0? This command is used to construct a Reinforced Concrete Plane Stress material object based on Fixed Angle theory with steel along four directions. nDMaterial FAFourSteelRCPlaneStress matTag? rho? UniaxiaMatTag1? UniaxiaMatTag2? UniaxiaMatTag3? UniaxiaMatTag4? UniaxiaMatTag5? UniaxiaMatTag6? angle1? angle2? angle3? angle4? rou1? rou2? rou3? rou4? fpc? fy? E0? epsc0? This command is used to construct a Prestressed Concrete Plane Stress material object based on Rotating Angle Theory with steel along two directions. nDMaterial PrestressedConcretePlaneStress matTag? rho? t1? s1? c1? c2? angle1? angle2? rou1? rou2? pstrain? fpc? fyT? fy2? E0? epsc0? This command is used to construct a Prestressed Concrete Plane Stress material object based on Fixed Angle theory with steel along two directions. nDMaterial FAPrestressedConcretePlaneStress matTag? rho? t1? s2? c1? c2? angle1? angle2? rou1? rou2? pstrain? fpc? fyT? fy? E0? epsc0? This command is used to construct a Prestressed Concrete Plane Stress material object based on Rotating Angle Theory with steel along four directions. nDMaterial RAFourSteelPCPlaneStress matTag? rho? UniaxiaMatTag1? UniaxiaMatTag2? UniaxiaMatTag3? UniaxiaMatTag4? angle1? angle2? rou1? rou2? pstrain? fpc? fyT? fy? E0? epsc0? This command is used to construct a Prestresed Concrete Plane Stress material object based on Fixed Angle theory with steel along four directions. nDMaterial FAFourSteelPCPlaneStress matTag? rho? t1? t2? s3? s4? c1? c2? angle1? angle2? angle3? angle4? rou1? rou2? rou3? rou4? pstrain1? pstrain2? fpc? fyT? fy? E0? epsc0? matTag integer tag identifying material rho material density $t1 \\(t2</strong></p></td> <td><p>material tags for uniaxial materials of type <strong>TendonL01</strong></p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) s1 \\(s2 ..</strong></p></td> <td><p>material tags for uniaxial materials of type <strong>SteelZ01</strong></p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) c1 \\(c2</strong></p></td> <td><p>material tags for uniaxial materials of type <strong>ConcreteL01, ConcreteZ01</strong></p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) angle1 \\(angle2 ...</strong></p></td> <td><p>angle of i'th (steel or tendon) layer to x coordinate</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) rou1 \\(rou2 ...</strong></p></td> <td><p>steel ratio of the i'th layer.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) pstrain1 $pstrain2 initial strain in tendons fpc compressive strength of concrete fyT yield strength of tendons fy yield strength of steel E0 initial stiffness of steel (Young\u2019s Modulus) epsc0 compressive strain of concrete A number of special uniaxial materials are needed for these materials. These materials are created using the following uniaxialMaterial commands. uniaxialMaterial SteelZ01 tag ? fy? E0? fpc? rou? &lt;ac?&gt; &lt;rc?&gt; uniaxialMaterial TendonL01 tag ? fpy? Eps? fpc? rou? epsp? &lt;ac?&gt; &lt;rc?&gt; uniaxialMaterial ConcreteL01 tag ? fpc? epsc0? uniaxialMaterial ConcreteZ01 tag ? fpc? epsc0? tag unique uniaxial integer tag identifying material fy yield strength bare steel E0 initial stiffness fpc compressive strength of concrete epsc0 strain at compressive strength rou steel ratio epsp prestress strain ac unloading path parameter (default = 1.9) rc reloading path parameter (default = 10.0) EXAMPLE N_FSW13.tcl REFERENCES T.T.C. Hsu and Y.L. Mo, \u201cUnified Theory of Concrete Structures\u201d, Wiley, COMING APRIL 2010 Y.L. Mo, J. Zhong, T.T.C. Hsu, \u201cSeismic simulation of RC wall-type structures\u201d,Engineering Structures, 30(11), 3167-3175, 2008.","title":"ReinforcedConcretePlaneStress\n"},{"location":"contrib/modeling/uniaxialMaterial/556-PyLiq1%20Material/","text":"PyLiq1 This command constructs a uniaxial p-y material that incorporates liquefaction effects. This p y material is used with a zeroLength element to connect a pile (beam-column element) to a 2 D plane-strain FE mesh or displacement boundary condition. The p-y material obtains the average mean effective stress (which decreases with increasing excess pore pressure) either from two specified soil elements, or from a time series. Currently, the implementation requires that the specified soil elements consist of FluidSolidPorousMaterials in FourNodeQuad elements, or PressureDependMultiYield or PressureDependMultiYield02 materials in FourNodeQuadUP or NineFourQuadUP elements. There are two possible forms: uniaxialMaterial PyLiq1 $matTag $soilType $pult $Y50 $Cd $c $pRes $ele1 $ele2 OR uniaxialMaterial PyLiq1 $matTag $soilType $pult $Y50 $Cd $c $pRes -timeSeries $tag matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects pRes sets the minimum (or residual) peak resistance that the material retains as the adjacent solid soil elements liquefy $ele1 $ele2 are the eleTag (element numbers) for the two solid elements from which PyLiq1 will obtain mean effective stresses and excess pore pressures seriesTag Alternatively, mean effective stress can be supplied by a time series by specifying the text string -timeSeries and the tag of the seriesm $seriesTag. NOTES: To model the effects of liquefaction with PyLiq1, it is necessary to use the material stage updating command: <pre> updateMaterialStage -material matNum -stage sNum </pre> where the argument matNum is the material number (for PyLiq1) and the argument sNum is the desired stage (valid values are 0 & 1). With sNum=0, the PyLiq1 behavior will be independent of any pore pressure in the specified solidElem\u2019s. When updateMaterialStage first sets sNum=1, PyLiq1 will obtain the average mean effective stress in the two solidElem\u2019s and treat it as the initial consolidation stress prior to undrained loading. Thereafter, the behavior of PyLiq1 will depend on the mean effective stresses (and hence excess pore pressures) in the solidElem\u2019s. The default value of sNum is 0 (i.e., sNum=0 if updateMaterialStage is not called). Note that the updateMaterialStage command is used with some soil material models, and that sNum=0 generally corresponds to the application of gravity loads (e.g., elastic behavior with no excess pore pressure development) and sNum=1 generally corresponds to undrained loading (e.g., plastic behavior with excess pore pressure development). The analysis for gravity loading cannot use the \u201calgorithm Linear\u201d command because the relevant soil materials do not currently work properly with this command. Instead, the \u201calgorithm Newton\u201d or some other option must be used. EQUATIONS and EXAMPLE RESPONSES: The PyLiq1 material inherits the PySimple1 material, and behaves identically to the PySimple1 material if there is no excess pore water pressure (i.e., sNum = 0). The constitutive equations for the PySimple1 material are given in separate documentation and not repeated here. The PyLiq1 material modifies the p-y behavior in response to the average mean effective stress (p\u2032), as affected by the excess pore water pressures, in two specified solid soil elements. The PyLiq1 material is used within a zeroLength element, and that zeroLength element generally shares a node with some solid soil elements (e.g., most commonly 1, 2, or 4 solid elements in a 2D mesh). Specifying two solid soil elements allows the PyLiq1 material to depend on pore pressures above and below its nodal position (essentially covering its full tributary length). The mean effective stress is affected by changes in mean total stress and excess pore pressure. For modeling purposes, an excess pore water pressure ratio is calculated as ru = 1-p\u2032/pc\u2032, where pc\u2032= mean effective consolidation stress prior to undrained loading. The average value of ru is obtained from the specified solid soil elements and used within PyLiq1. The constitutive response of PyLiq1 is then taken as the constitutive response of PySimple1 scaled in proportion to the mean effective stress within the specified solid soil elements. This means that the ultimate capacity (pult) and tangent modulus are scaled by a factor of (1-ru). Two additional constraints are then placed on the constitutive response. The first is that the scaled ultimate capacity cannot fall below the specified residual capacity of the material (i.e., pRes). The second constraint applies to the situation where the mean effective stress in the adjacent solid soil elements is incrementally increasing [e.g., the pore pressures decrease as the soils are incrementally dilatant (phase transformation)]. In this \u201chardening\u201d situation, the loading path from the p-y relation at time \u201ci\u201d to time \u201ci+1\u201d is bounded by the material\u2019 elastic stiffness (i.e., the unload/reloading stiffness); e.g., the incremental loading path cannot be steeper than the elastic stiffness. Note that the above approach only provides a first-order approximation for the softening effects of liquefaction on p y behavior. Two simple examples of PyLiq1 behavior are presented in the following figures. In these examples, there is a single FourNodeQuad element containing a FluidSolidPorousMaterial with a PressureDependMultiYield soil material. This solid element is connected to an elastic pile via a single \u201cp-y\u201d element (i.e., a zeroLength element containing a PyLiq1 material). The solid element is an order of magnitude stiffer than the p-y element, and is subjected to transient cyclic simple shear loading. In the first example (first Figure), the adjacent soil element is subjected to uniform cyclic loading that produces triggering of liquefaction (ru = 100%) in about 7 cycles. The cyclic shear stress ratio (CSR), excess pore water pressure ratio (ru), and shear strain (\u03b3) versus cycle number for the solid soil element are plotted on the left side of the Figure. The soil element experiences uniform cyclic deformations; e.g., lateral spreading does not develop because the horizontal cyclic loading has no static bias in either direction. The pile is set as relatively rigid. Two different cases are then presented for the p-y element response. In the first case, sNum=0 such that the p-y element is independent of changes in mean effective stress (or excess pore pressure) in the soil element. The resulting behavior is shown in the upper right-hand plot of the Figure. In the second case, sNum was set to 1 prior to cyclic loading, and thus the resulting behavior is dependent on the excess pore pressure in the soil element (lower right-hand plot of the Figure). The p-y element exhibits the overall softening that is expected when the adjacent soil element liquefies, and also shows temporary stiffening (hardening) when the adjacent soil goes through phase transformation (with its associated drop in excess pore pressure). In these plots, the \u201cp\u201d is normalized by the pult for drained monotonic loading. In the second example (second Figure), the adjacent soil element is subjected to a static shear load plus uniform cyclic loading such that triggering of liquefaction is accompanied by progressive lateral deformation in the direction of the static load bias (i.e., lateral spreading). Again, the left side of the Figure shows the CSR, ru and \u03b3 versus cycle number for the solid soil element. sNum was set to 1 prior to cyclic loading such that the p-y behavior is dependent on the excess pore pressure in the soil element. The residual capacity (pRes) of the p-y material is 10% of the drained ultimate capacity. Two different cases are then presented. In the first case, the pile is set as relatively rigid. The resulting behavior is shown in the upper right-hand plot of the Figure. The peak \u201cp\u201d occurs just as triggering of liquefaction occurs in the soil element, and is about 0.49 times the drained monotonic capacity pult. Subsequent peaks in \u201cp\u201d drop a bit to about 0.46 times pult. In the second case, the pile has a finite elastic stiffness such that it\u2019s peak elastic deflection in this example is equal in magnitude to about 10 times the y50 value for the p-y element. The resulting behavior is shown in the lower right-hand plot of the Figure. Again, the peak \u201cp\u201d occurs just as triggering of liquefaction occurs in the soil element, being about 0.18pult in this case. Subsequent peaks in \u201cp\u201d drop by about 20% to about 0.14pult. The inclusion of pile flexibility reduced, by a factor of about 3, the peak values of \u201cp\u201d that developed in the p-y element as the soil progressively spread past the pile. During each cycle of loading, the soil element cyclically ratchets in the direction of the static load bias and alternates between being extremely soft (ru = 100%) and then stiffening when it goes through phase transformation (ru drops). As the soil stiffens, the p-y element gains strength, transferring load onto the pile and causing the pile to elastically deform in the direction of loading. Then when the soil is unloaded and ru becomes 100% again, the p-y element loses strength, unloading the pile and allowing the pile to elastically return closer to its undeformed position. In each cycle of loading and progressive spreading of the soil, the magnitude of \u201cp\u201d that develops against the pile depends on the pile\u2019s flexibility relative to the displacement range over which the soil goes through phase transformation. PyLiq1NoSpreading.png PyLiq1WithSpreading.png Examples <pre> model basic -ndm 2 -ndf 2 node 1 0.0 0.0 node 2 0.0 0.0 fix 2 1 1 fix 1 0 1 timeSeries Path 1 -fileTime time.txt -filePath meanStress.txt -factor -1.0 uniaxialMaterial PyLiq1 1 2 1.0 0.0001 10.0 0.0 0.10 -timeSeries 1 element zeroLength 1 1 2 -mat 1 -dir 1 uniaxialMaterial TzLiq1 2 1 1.0 0.0001 0.0 -timeSeries 1 element zeroLength 2 1 2 -mat 2 -dir 1 updateMaterialStage -material 1 -stage 1 updateMaterialStage -material 2 -stage 1 recorder Element -file PY1.txt -time -ele 1 force recorder Element -file TZ1.txt -time -ele 2 force recorder Node -file NodalDisps1.txt -time -node 1 -dof 1 2 disp pattern Plain 1 \u201cSine 0.0 10.0 1.0 -factor 1.0\u201d { sp 1 1 0.001 } system ProfileSPD test NormDispIncr 1.0E-8 25 0 constraints Penalty 1.e18 1.e18 algorithm Newton numberer RCM integrator Newmark 0.6 0.30 analysis VariableTransient analyze 1000 0.01 0.0001 0.01 15 </pre> REFERENCES: \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.w., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Journal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis This command is used to construct a PySimple1 uniaxial material object:","title":"PyLiq1\n"},{"location":"contrib/modeling/uniaxialMaterial/557-PySimple1%20Material/","text":"PySimple1 This command is used to construct a PySimple1 uniaxial material object: uniaxialMaterial PySimple1 $matTag $soilType $pult $Y50 $Cd &lt; $c &gt; matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects NOTES: In general the HHT algorithm is preferred over a Newmark algorithm when using this material. This is due to the numerical oscillations that can develop with viscous damping forces under transient loading with certain solution algorithms and damping ratios. EQUATIONS and EXAMPLE RESPONSES: The equations describing PySimple1 behavior are described in Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Only minor changes have been made in its implementation for OpenSees. The nonlinear \\(p-y\\) behavior is conceptualized as consisting of elastic (p-ye), plastic (p-yp), and gap \\((p-y^g)\\) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component \\((p-ye)\\) of the displacement rate. The gap component consists of a nonlinear closure spring (pc-yg) in parallel with a nonlinear drag spring \\((p^d-y^g)\\) . Note that \\(y = y^e + y^p + y^g\\) , and that <math>p = p^d + p^c</math>. The plastic component has an initial range of rigid behavior between \\[-C_r p_\\text{ult} &lt; p &lt; C_r p_\\text{ult}\\] with \\(C_r\\) = the ratio of $p/p_ $ when plastic yielding first occurs in virgin loading. The rigid range of \\(p\\) , which is initially \\(2 C_r p_\\text{ult}\\) , translates with plastic yielding (kinematic hardening). The rigid range of \\(p\\) can be constrained to maintain a minimum size on both the positive and negative loading sides (e.g., 25% of <math>p</math>), and this is accomplished by allowing the rigid range to expand or contract as necessary. Beyond the rigid range, loading of the plastic \\((p-y^p)\\) component is described by: <math>p = p_{} - (p_{} - p_o) ^n </math> where \\(p_\\text{ult}\\) = the ultimate resistance of the \\(p-y\\) material in the current loading direction, \\(p_o = p\\) at the start of the current plastic loading cycle, \\(y^p_o = y_p\\) at the start of the current plastic loading cycle, \\(c\\) = constant to control the tangent modulus at the start of plastic yielding, and n = an exponent to control sharpness of the \\(p-y^p\\) curve. The closure \\((p^c-y^g)\\) spring is described by: \\[p^c = 1.8 p_{\\text{ult}} \\left [\\frac{y_{50}}{y_{50} + 50(y_o^\\text{+} - y^g)} - \\frac{y_{50}}{y_{50} + 50(y_o^\\text{-} - y^g)} \\right ] \\] where \\(y_o^+\\) = memory term for the positive side of the gap, \\(y_o^-\\) = memory term for the negative side of the gap. The initial values of \\(y_o^+\\) and \\(y_o^-\\) were set as \\(y_{50}/100\\) and <math>- y_{50}/100</math>, respectively. The factor of 1.8 brings \\(p^c\\) up to \\(p_\\text{ult}\\) during virgin loading to \\(y_o^+\\) (or <math>y_o^-</math>). Gap enlargement follows logic similar to that of Matlock et al. (1978). The gap grows on the positive side when the plastic deformation occurs on the negative loading side. Consequently, the \\(y_o^+\\) value equals the opposite value of the largest past negative value of, <math>y^p + y^g + 1.5 y_{50}</math> where the \\(1.5y_{50}\\) represents some rebounding of the gap. Similarly, the \\(y_o^-\\) value equals the opposite value of the largest past positive value of <math>y p+y g-1.5y_{50}</math>. This closure spring allows for a smooth transition in the load displacement behavior as the gap opens or closes. The nonlinear drag \\((p^d-y^g)\\) spring is described by: <math>p^d = C_d p_{} - (C_d p_{} - p^d_o) ^n </math> where \\(C_d =\\) ratio of the maximum drag force to the ultimate resistance of the p-y material, <math>d^p_o =p^d</math> at the start of the current loading cycle, and \\(y^g_o = y^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different p-y backbone relations. Matlock\u2019s (1970) recommended backbone for soft clay is closely approximated using <math>c = 10</math>, \\(n = 5\\) , and <math>C_r = 0.35</math>. API\u2019s (1993) recommended backbone for drained sand is closely approximated using \\(c = 0.5\\) , <math>n = 2</math>, and \\(C_r = 0.2\\) . PySimple1 is currently implemented to allow use of these two default sets of values. Values of \\(p_\\text{ult}\\) , <math>y_{50}</math>, and \\(C_d\\) must then be specified to define the \\(p-y\\) material behavior. Viscous damping on the far-field (elastic) component of the p-y material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap. In addition, the total force across the p-y material is restricted to pult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like PySimple1. PySimple1A.gif PySimple1B.gif Examples REFERENCES: \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.w., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis This command is used to construct a PySimple1 uniaxial material object:","title":"PySimple1\n"},{"location":"contrib/modeling/uniaxialMaterial/565-QzSimple1%20Material/","text":"QzSimple1 This command is used to construct a QzSimple1 uniaxial material object: uniaxialMaterial QzSimple1 $matTag $qzType $qult $Z50 < $suction $c > matTag integer tag identifying material qzType qzType = 1 Backbone of q-z curve approximates Reese and O\u2019Neill\u2019s (1987) relation for drilled shafts in clay. qzType = 2 Backbone of q-z curve approximates Vijayvergiya\u2019s (1977) relation for piles in sand. qult Ultimate capacity of the q-z material. SEE NOTE 1. Z50 Displacement at which 50% of qult is mobilized in monotonic loading. SEE NOTE 2. suction Uplift resistance is equal to suction qult. Default = 0.0. The value of suction must be 0.0 to 0.1. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). Default = 0.0. Nonzero c values are used to represent radiation damping effects.* NOTES: \\(qult: Ultimate capacity of the q-z material. Note that \"q\" or \"qult\" are stresses [force per unit area of pile tip] in common design equations, but are both loads for this uniaxialMaterial [i.e., stress times tip area].</li> <li>\\) Y50: Displacement at which 50% of pult is mobilized in monotonic loading. Note that Vijayvergiya\u2019s relation (qzType=2) refers to a \u201ccritical\u201d displacement (zcrit) at which qult is fully mobilized, and that the corresponding z50 would be 0. 125zcrit. optional args $suction and $c must either both be omitted or both provided. EQUATIONS and EXAMPLE RESPONSES: The equations describing QzSimple1 behavior are similar to those for p-y materials by Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Modifications were required for representing the different responses of a \\(q-z\\) material in compression versus uplift. The nonlinear q-z behavior is conceptualized as consisting of elastic (q-<math>z^e</math>), plastic (q-<math>z^p</math>), and gap (<math>q-z^g</math>) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component (<math>q-z^e</math>) of the displacement rate. The gap component consists of a bilinear closure spring (<math>q c-z g</math>) in parallel with a nonlinear drag spring (<math>q d-z g</math>). Note that <math>z = z^e + z^p + z^g</math>, and that <math>q = q^d + q^c</math>. The plastic component has an initial range of rigid behavior between \\[-C_r q_\\text{ult} &lt; q &lt; C_r q_\\text{ult}\\] with \\(C_r\\) = the ratio of \\(\\frac{q}{q_{\\text{ult}}}\\) when plastic yielding first occurs in virgin loading. The rigid range of q, which is initially <math>2 C_r q_</math>, translates and grows with plastic yielding. The rigid range of q is constrained to a maximum size of \\(0.7q_{\\text{ult}}\\) . Beyond the rigid range, loading of the plastic (<math>q-z^p</math>) component is described by: <math>q = q_{} - (q_{} - q_0) </math> where \\(q_ult\\) = the ultimate resistance of the \\(q-z\\) material in the current loading direction, \\(q_o = q\\) at the start of the current plastic loading cycle, p \\(z^p_o = z^p\\) at the start of the current plastic loading cycle, and c and n are constants that control the shape of \\(q-z^p\\) curve. The closure (<math>q c-z g</math>) component is simply a bilinear elastic spring, which is relatively rigid in compression and extremely flexible in tension (uplift). The nonlinear drag (<math>q d-z g</math>) component is used to allow thethe specification of some minimum \u201csuction\u201d on the pile tip during uplift. It is described by: <math>q^d = C_d q_ - (C_d q_{} - q^d_0) </math> where \\(C_d\\) = ratio of the maximum drag (suction) force to the ultimate resistance of the \\(q-z\\) material, <math>q^d_o = q^d</math> at the start of the current loading cycle, and \\(z^g_o = z^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different q-z backbone relations. Reese and O\u2019Neill\u2019s (1987) recommended backbone for drilled shafts in clay is closely approximated using <math>c = 0.35</math>, \\(n = 1.2\\) , and <math>C_r = 0.2</math>. Vijayvergiya\u2019s (1977) recommended backbone for piles in sand is closely approximated using <math>c = 12.3</math>, \\(n = 5.5\\) , and <math>C_r = 0.3</math>. QzSimple1 is currently implemented to allow use of these two default sets of values. Values of \\(q_\\text{ult}\\) , <math>z_50</math>, and suction (i.e., <math>C_d</math>) must then be specified to define the \\(q-z\\) material behavior. Viscous damping on the far-field (elastic) component of the \\(q-z\\) material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap in uplift. In addition, the total force across the \\(q-z\\) material is restricted to \\(q_\\text{ult}\\) in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like QzSimple1. Examples of the monotonic backbones and cyclic loading response of QzSimple1 are given in the following plots. QzSimple1A.gif QzSimple1B.gif Examples REFERENCES: \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis This command is used to construct a PySimple1 uniaxial material object:","title":"QzSimple1\n"},{"location":"contrib/modeling/uniaxialMaterial/569-RambergOsgoodSteel%20Material/","text":"RambergOsgoodSteel This command is used to construct a Ramberg-Osgood steel material object. uniaxialMaterial RambergOsgoodSteel $matTag $fy $E0 $a $n matTag fy E0 a n Introduction to the Ramberg-Osgood\u2019s Material Model: In earthquake engineering, Ramberg-Osgood functions are often used to model the behavior of structural steel materials and components. These functions are obtained when the power is normalized to an arbitrary strain, \u03b50, for which the plastic component of the strain, \u03b5plastic, is not zero. Generally the yield strain, \u03b5y, provides a good choice for normalization of strain, the Ramberg-Osgood function is expressed as [1]: RambergOsgoodSteel04.png Where E0 is the initial elastic modulus and \u03c30 is equal to E\u03b50. More explanation about parameter \u201ca\u201d (yielding offset) The value \u201ca\u201d which is equal to \u03b1\u03c3/E_0 can be seen as a yield offset, as shown in Fig.1. This comes from the fact that RambergOsgoodSteel05.png when \u03c3=\u03c30. Accordingly (see Fig.1): RambergOsgoodSteel03.png Values for \u03b1 can also be found by means of fitting to experimental data, although for some materials, it can be fixed in order to have the yield offset equal to the accepted value of strain of 0.2%, which means [2]: Fig. 1: Generic representation of the Stress-Strain curve by means of the Ramberg-Osgood equation. Strain corresponding to the yield point is the sum of the elastic and plastic components. Fig. 2: RambergOsgoodSteel Material \u2013 Hysteretic Behavior of Model REFERENCE: [1] Michel Bruneau , Chia-Ming Uang Andrew Whittaker. \u201cDuctile Design of Steel Structures\u201d McGraw-Hill Professional, 1997, ISBN: 0070085803 - 978-0070085800 [2] Ramberg, W., & Osgood, W. R. (1943). \u201cDescription of stress-strain curves by three parameters.\u201d Technical Note No. 902, National Advisory Committee For Aeronautics, Washington DC. Contact Authors: Reza Rahimi, Graduate Research Assistant of Structural Engineering, Dalhousie University, reza.rahimi@dal.ca Reza Sepasdar, Graduate Research Assistant of Structural Engineering, Dalhousie University, reza.sepasdar@dal.ca Mohammad Reza Banan, Associate Professor of Civil Engineering, Department of Civil and Environmental Engineering, Shiraz University, Shiraz, Iran, banan@shirazu.ac.ir","title":"RambergOsgoodSteel\n"},{"location":"contrib/modeling/uniaxialMaterial/58-Bilin%20Material/","text":"IMKBilin This command is used to construct a bilin material. The bilin material simulates the modified Ibarra-Medina-Krawinkler deterioration model with bilinear hysteretic response. Note that the hysteretic response of this material has been calibrated with respect to more than 350 experimental data of steel beam-to-column connections and multivariate regression formulas are provided to estimate the deterioration parameters of the model for different connection types. These relationships were developed by Lignos and Krawinkler (2009, 2011) and have been adopted by PEER/ATC (2010). uniaxialMaterial IMKBilin $matTag $K0 $as_Plus $as_Neg $My_Plus $My_Neg $Lamda_S $Lamda_C $Lamda_A $Lamda_K $c_S $c_C $c_A $c_K $theta_p_Plus $theta_p_Neg $theta_pc_Plus $theta_pc_Neg $Res_Pos $Res_Neg $theta_u_Plus $theta_u_Neg $D_Plus $D_Neg &lt; $nFactor &gt; matTag integer tag identifying material K0 elastic stiffness as_Plus strain hardening ratio for positive loading direction as_Neg strain hardening ratio for negative loading direction My_Plus effective yield strength for positive loading direction My_Neg effective yield strength for negative loading direction (negative value) Lamda_S Cyclic deterioration parameter for strength deterioration Lamda_C Cyclic deterioration parameter for post-capping strength deterioration Lamda_A Cyclic deterioration parameter for acceleration reloading stiffness deterioration (is not a deterioration mode for a component with Bilinear hysteretic response). Lamda_K Cyclic deterioration parameter for unloading stiffness deterioration c_S rate of strength deterioration. The default value is 1.0. c_C rate of post-capping strength deterioration. The default value is 1.0. c_A rate of accelerated reloading deterioration. The default value is 1.0. c_K rate of unloading stiffness deterioration. The default value is 1.0. theta_p_Plus pre-capping rotation for positive loading direction (often noted as plastic rotation capacity) theta_p_Neg pre-capping rotation for negative loading direction (often noted as plastic rotation capacity) (positive value) theta_pc_Plus post-capping rotation for positive loading direction theta_pc_Neg post-capping rotation for negative loading direction (positive value) Res_Pos residual strength ratio for positive loading direction Res_Neg residual strength ratio for negative loading direction (positive value) theta_u_Plus ultimate rotation capacity for positive loading direction theta_u_Neg ultimate rotation capacity for negative loading direction (positive value) D_Plus rate of cyclic deterioration in the positive loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. D_Neg rate of cyclic deterioration in the negative loading direction (this parameter is used to create assymetric hysteretic behavior for the case of a composite beam). For symmetric hysteretic response use 1.0. nFactor elastic stiffness amplification factor, mainly for use with concentrated plastic hinge elements (optional, default = 0). ModIKModel.PNG Image from: Lignos et al. (2011) The deterioration model parameters can be calibrated based on actual experimental data of steel components. Instead, a user can determine the same parameters with predictive equations that have been developed by Lignos and Krawinkler (2009, 2011). These equations relate deterioration modelling parameters with geometric and material properties of steel components and have been developed with multivariate regression analysis after extensive calibration of a recently developed steel component database of more than 300 steel specimens (Lignos and Krawinkler 2007, 2009, 2011). References : [1] Ibarra L.F., and Krawinkler, H. (2005). \u201cGlobal collapse of frame structures under seismic excitations\u201d, Rep. No. TB 152, The John A. Blume Earthquake Engineering Center, Stanford University, Stanford, CA. [2] Ibarra L.F., Medina R. A., and Krawinkler H. (2005). \u201cHysteretic models that incorporate strength and stiffness deterioration\u201d, Earthquake Engineering and Structural Dynamics, 34(12), 1489-1511. [3] Karavasilis T.L., Ricles J.M., Sause R. (2009). \u201cImplementation of deterioration elements in OpenSEES for collapse simulations\u201d ATLSS Engineering Research Center, Rep. No. 09-11. [4] Lignos, D.G., and Krawinkler, H. (2007), \u201cA database in support of modeling of component deterioration for collapse prediction of steel frame structures\u201d, Proc. ASCE Structures Congress, Long Beach CA, SEI institute. [5] Lignos, D.G., Krawinkler, H. (2009). \u201cSidesway collapse of deteriorating structural systems under seismic excitations,\u201d Rep.No.TB 172, The John A. Blume Earthquake Engineering Research Center, Stanford University, Stanford, CA. [6] Lignos, D. G., Krawinkler, H. and Whittaker, A.S. (2011). \u201cPrediction and validation of sidesway collapse of two scale models of a 4-story steel moment frame\u201d, Earthquake Engineering and Structural Dynamics, EESD, Vol. 40 (7), 807-825. [7] Lignos, D.G., and Krawinkler, H. (2010b). \u201cA steel database for component deterioration of tubular hollow square steel columns under varying axial load for collapse assessment of steel structures under earthquakes\u201d, Proc. 7th International Conference on Urban Earthquake Engineering (7CUEE), March 3-5, Tokyo, Japan. [8] Lignos, D.G., and Krawinkler, H. (2011). \u201cDeterioration modeling of steel components in support of collapse prediction of steel moment frames under earthquake loading\u201d, Journal of Structural Engineering, ASCE, Vol. 137 (11), 1291-1302. [9] PEER/ATC (2010). \u201cModeling and acceptance criteria for seismic design and analysis of tall buildings\u201d, PEER/ATC-72-1, prepared by the Applied Technology Council in cooperation with the Pacific Earthquake Engineering Research Center, Redwood City, CA.. Code Developed by : by Dr. Dimitrios G. Lignos, McGill University and was implemented by Dr. Theodore Karavasilis, Oxford University nFactor Implemented by: by Dr. Andre R. Barbosa, Oregon State University and Mr. Filipe L.A. Ribeiro, Universidade Nova de Lisboa","title":"IMKBilin\n"},{"location":"contrib/modeling/uniaxialMaterial/587-Reinforcing%20Steel%20Material/","text":"ReinforcingSteel Contact Authors: Jon Mohle M.S., P.E. Sashi Kunnath: http://cee.engr.ucdvis.edu/faculty/kunnath/kunnath.htm This command is used to construct a ReinforcingSteel uniaxial material object. This object is intended to be used in a reinforced concrete fiber section as the steel reinforcing material. uniaxialMaterial ReinforcingSteel $matTag $fy $fu $Es $Esh $esh $eult < -GABuck $lsr $beta $r $gama > < -DMBuck $lsr < $alpha > > < -CMFatigue $Cf $alpha $Cd > < -IsoHard < $a1 < $limit > > > matTag Material tag. fy yield stress. fu Es Esh esh eult -GABuck lsr Slenderness Ratio (see Figure 2) beta Amplification factor for the buckled stress strain curve. (see Figure 3) r Buckling reduction factor r can be a real number between [0.0 and 1.0] r=1.0 full reduction (no buckling) r=0.0 no reduction 0.0<r<1.0 linear interpolation between buckled and unbuckled curves gamma Buckling constant (see Figures 3 and 4) -DMBuck Buckling model based on Dhakal and Maekawa (2002) lsr Slenderness Ratio (see Figure 2) alpha Adjustment Constant usually between 0.75 and 1.0 Default: alpha=1.0, this parameter is optional. -CMFatigue Coffin-Manson Fatigue and Strength Reduction Cf Coffin-Manson constant C (see Figure 5) alpha Coffin-Manson constant a (see Figure 5) $C d Cyclic strength reduction constant (see Figure 6 and Equation 3) -IsoHard Isotropic Hardening / Diminishing Yield Plateau a1 Hardening constant (default = 4.3) limit Limit for the reduction of the yield plateau. % of original plateau length to remain (0.01 < limit < 1.0 ) Limit =1.0, then no reduction takes place (default =0.01) -MPCurveParams Menegotto and Pinto Curve Parameters see Fig 6b R1 (default = 0.333) R2 (default = 18) R3 (default = 4) NOTE: This simulation is based on the Chang and Mander(1994) uniaxial steel model. The simulation has incorporated additional reversal memory locations to better control stress overshooting (default is 10 branches but this can be easily modified by changing the variable \u201c LastRule_RS \u201d within the header file \u201c ReinforcingSteel.h \u201d). The cycle counting method implemented in the routine achieves the same result as rainflow counting. Fatigue parameters are based on the Coffin-Manson equation for plastic strain amplitude as indicated in Figure 6a. The buckling simulations incorporated consist of a variation on Gomes and Appleton (1997) and Dhakal and Maekawa (2002). The buckling and fatigue portions of this simulation are still being further enhanced and refined. Additional buckling and fatigue options should be available in the near future. ReinfSteel2430.png Figure 1: Material Constants BACKBONE CURVE: The backbone curve shown in Figure 1 is used as a bounding surface for the reinforcing bar simulation. This backbone curve is shifted as described by Chang and Mander (1994) to account for Isotropic hardening. This backbone can be obtained by utilizing simple tension test data. Within the material class, the backbone curve is transformed from engineering stress space to natural stress space (accounting for change in area as the bar is stressed.) This allows the single backbone to represent both tensile and compressive stress-strain relations. The tension and compression backbone curves are not the same in engineering stress space for this model! This transformation assumes small strain relations described by Dodd and Restrepo-Posada (1995) The softening region (strain greater than eult), shown in Figure 1, is a localization effect due to necking and is a function of the gage length used during measurement. This geometric effect is ignored in this simulation. In this simulation, it is assumed that there is no softening in natural stress space. Because the simulation always converts back to engineering stress space, you will observe some softening in the tension response due to the reduction in area, however this will be much smaller than that shown in the original backbone curve proposed by Chang and Mander. DIMINISHING YIELD PLATEAU: It has been observed that when a reinforcing bar is subjected to plastic strain reversals within the yield plateau, strain hardening will initiate at a lower strain that that of the same bar loaded monotonically. Additionally, isotropic hardening can result from repeated strain reversals and is commonly related to accumulated plastic strain. These two aspects of the stress-strain behavior of steel bars are somewhat related and that by shortening the yield plateau as a function of accumulated plastic strain, the model will have some capability to simulate both the diminishing yield plateau and isotropic hardening. The Chang and Mander model, on which this formulation is based, models only anisotropic hardening by shifting the backbone curves and by targeting previous reversal points on the backbone curves. By adding a component of isotropic hardening, the model has additional capabilities and is able to more accurately simulate test data. Accumulated plastic strain is tracked within the material model for each branch, plateau adjustments are made only in the outer branches for simplicity. The plastic strain due to the backbone curve is ignored so that a monotonically loaded sample can be calibrated to a monotonic test sample more easily. ReinfSteel2431.png Figure 2: Slenderness Defined ReinfSteel2432.png Figure 3: Buckling Parameters GOMES AND APPLETON BUCKLED CURVE: Figure 3 describes the use of the buckling parameters modified from Gomes and Appleton(1997). \u00df is an amplification factor that allows the user to scale the buckling curve. This is useful to adjust the location of the bifurcation point. The r factor is used to adjust the curve between the buckled curve and the unbuckled curve. The variable r can only be a real number between 0.0 and 1.0. The g factor is the positive stress location about which the buckling factor is initiated. This factor was introduced to avoid kinks in the reloading branch. The implementation of the g factor is shown in Figure 3. The basic idea is that the stress strain curves are reduced toward the positive stress g<em class=\u201cemphasis\u201d>f</em> su . g should be between 0.0 and 1.0. A g of 0.0 will factor to the zero stress axis. This will usually produce a kink in the reloading curve at the zero stress location. Good results have been obtained using the following values for the buckling constants. or Figure 4 displays the buckling behavior due to the variation of the different constants. The response shown on the upper left is the unbuckled case. In each of the other cases, buckling behavior is defined by the constants shown. ReinfSteel2435.png Figure 4: Effect of Sample Parameters in the Gomes and Appleton Buckling Model DHAKAL AND MAEKAWA BUCKLED CURVE: The buckling model described in this section is based on Dhakal and Maekawa(2002). This model takes two terms, lsr and a. lsr is the slenderness ratio as described in Figure 2 and a is an amplification factor. Dhakal and Maekawa suggest a value of a =1.0 for linear strain hardening and a =0.75 for elastic perfectly plastic material behavior. The material model in this implementation is neither linear strain hardening nor elastic perfectly plastic. However, since the material model does include strain hardening a=1.0 has been assumed as the default value. Figure 5 shows the unbuckled vs buckled stress strain response curves. ReinfSteel2436.png Figure 5: Effect of Suggested Parameters in the Dhakal and Maekawa Buckling Model CYCLIC DEGRADATION: C f and a are factors used to relate the number of half cycles to fracture to the half cycle plastic strain amplitude (Figure 6a). Plastic strain half cycle amplitude is defined by Equation 1. The total half cycle strain amplitude,, is shown in Figure 6b as the change in strain from reversal A to reversal B. C f and a are used to define a cumulative damage factor, D, as described in Equation 2. Figure 6a: Coffin-Manson Constants Figure 6b: Half Cycle Terms Defined (1) (2) The cumulative damage factor is zero at no damage and 1.0 at fracture. Once a bar has been determined to have fractured, the strength is rapidly degraded to zero. ReinfSteel2442.png Figure 7: Strength Reduction A degrade constant, K 1 , is used to describe loss in strength due to damage or other phenomenon resulting in softening due to plastic reversals. The degradation is currently assumed to have a simple linear relationship with D. This is used to correlate strength degradation to the cumulative damage factor. This linear relationship is shown in Equation 3. (3) Alternately this simple linear equation can be rewritten in a way that makes the strength degradation independent of the number of half cycles to failure. Keeping the failure and degradation terms independent is convenient for calibration. Equation 3 is rewritten below utilizing the strength degradation constant C d . (4) The constants K 1 , and C d can be related as shown in Equation 5. (5) Suggested starting values have been obtained from data reported by Brown and Kunnath (2000) for bars with a slenderness of 6. Keep in mind that this experimental data is limited and additional calibration may be necessary to capture realistic behavior in a reinforcing bar embedded in concrete and influenced by other factors such as confinement. a: 0.506 C f : 0.26 C d : 0.389 Sample Simulations of Degradation behavior a is best obtained from calibration of test results. a is used to relate damage from one strain range to an equivalent damage at another strain range. This is usually constant for a material type. C f is the ductility constant used to adjust the number of cycles to failure. A higher value for C f will result in a lower damage for each cycle. A higher value C f translates to a larger number of cycles to failure.</p> C d is the strength reduction constant. A larger value for C d will result in a lower reduction of strength for each cycle. The four charts shown in Figure 8 demonstrate the effect that some of the variables have on the cyclic response. ReinfSteel2446.png Figure 8: Fatigue and Degradation Parameter Examples In Figure 8, the upper left response contains no strength degradation by setting the C d variable to 0.0. The upper right response shows strength degradation due to the suggested values of C f , a, and C d . The response shown on the lower left demonstrates the change in the response when the suggested values of C f and a are used with C d =0.6. Making the value of C d larger results in less strength reduction due to damage. The response on the lower right once again returns to the suggested values but C f is changed to 0.15. This results in a more rapid accumulation of damage causing the bar to fail sooner. Note however that the strength degradation is unaffected by the more rapid accumulation of damage. The strength reduction and failure are not interdependent making the model easier to calibrate. References Chang, G. and Mander, J. (1994). \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I - Evaluation of Seismic Capacity.\u201d NCEER Technical Report 94-0006. Dodd, L. and Restrepo-Posada, J. (1995). \u201cModel for Predicting Cyclic Behavior of Reinforcing Steel\u201d J. Struct. Eng., 121(3), 433-445. Gomes, A., and Appleton, J. (1997). \u201cNonlinear Cyclic Stress-Strain Relationship of Reinforcing Bars Including Buckling.\u201d Eng. Struct., 19(10), 822-826. Brown, J. and Kunnath, S.K. (2000). \u201cLow Cycle Fatigue Behavior of Longitudinal Reinforcement in Reinforced Concrete Bridge Columns.\u201d NCEER Technical Report 00-0007. Dhakal, R. and Maekawa, K. (2002). \u201cModeling for Postyield Buckled of Reinforcement\u201d J. Struct. Eng., 128(9), 1139-1147.","title":"ReinforcingSteel\n"},{"location":"contrib/modeling/uniaxialMaterial/59-BilinearOilDamper%20Material/","text":"BilinearOilDamper This command is used to construct a BilinearOilDamper material, which simulates the hysteretic response of bilinear oil dampers with relief valve. Two adaptive iterative algorithms have been implemented and validated to solve numerically the constitutive equations within a bilinear oil damper with a high-precision accuracy. uniaxialMaterial BilinearOilDamper $matTag $K $Cd &lt; $Fr $p &gt; &lt; $LGap &gt; &lt; $NM $RelTol $AbsTol $MaxHalf &gt; matTag integer tag identifying material K Elastic stiffness of linear spring to model the axial flexibility of an oil damper (brace and damper portion) Cd Viscous damping coefficient of an oil damper (before relief) Fr Damper relief load (default=1.0, Damper property) p Post-relief viscous damping coefficient ratio (default=1.0, linear oil damper) LGap gap length to simulate the gap length due to the pin tolerance (default=0.0: zero tolerance) NM Employed adaptive numerical algorithm (default value NM = 1; 1 = Dormand-Prince54, 2=adaptive finite difference) RelTol Tolerance for absolute relative error control of the adaptive iterative algorithm (default value 10^-6) AbsTol Tolerance for absolute error control of adaptive iterative algorithm (default value 10^-10) MaxHalf Maximum number of sub-step iterations within an integration step (default value 15) Examples: 1. Input parameters: Assume a bilinear oil damper with axial stiffness K=200.0kN/mm, viscous damping coefficient C=6.0KN/(mm/s), relief load Fr=1000.0KN, p=0.1. The input parameters for the material should be as follows: uniaxialMaterial BilinearOilDamper 1 200.0 6.0 1000 0.1 Using these properties, Figure 1c shows the hysteretic response of this damper for sinusoidal displacement increments of 12, 24 and 36mm and a frequency f = 1.0Hz. Figures 1a-1d show the damper hysteresis with varying post-relief viscous damping coefficient ratio (p=1.0, 0.5, 0.1, 0.0). Figure 1.Oil Damper with various post-relief viscous damping coefficient ratios Assume a bilinear oil damper with axial stiffness K=200.0kN/mm, viscous damping coefficient C=6.0KN/(mm/s), relief load Fr=1000.0KN, p=0.1 and LGap = 0.5mm due to the pin tolerance at the damper ends. The input parameters for the material should be as follows: uniaxialMaterial BilinearOilDamper 1 200.0 6.0 1000 0.1 0.5 Using these properties, Figure 2c shows the hysteretic response of this damper for sinusoidal displacement increments of 0.5, 1 and 1.5mm and a frequency f = 1.0Hz. Figures 2a-2d show the damper hysteresis with varying gap length (LGap = 0.0, 0.2. 0.5. 1.0 mm) Figure 2.Oil Damper with various gap lengths References : [1] Akcelyan, S., Lignos, D. G., Hikino, T. (2018). \u201cAdaptive Numerical Method Algorithms for Nonlinear Viscous and Bilinear Oil Damper Models Subjected to Dynamic Loading.\u201d Soil Dynamics and Earthquake Engineering, 113, 488-502. 1 . [2] Akcelyan, S. (2017). \u201cSeismic retrofit of existing steel tall buildings with supplemental damping devices.\u201d Ph.D. Dissertation, McGill University, Canada. Code Developed and Implemented by : Sarven Akcelyan & Prof. Dimitrios G. Lignos , (McGill University)","title":"BilinearOilDamper\n"},{"location":"contrib/modeling/uniaxialMaterial/609-SAWS%20Material/","text":"SAWS This file contains the class definition for SAWSMaterial. SAWSMaterial provides the implementation of a one-dimensional hysteretic model develeped as part of the CUREe Caltech wood frame project. uniaxialMaterial SAWS $tag $F0 $FI $DU $S0 $R1 $R2 $R3 $R4 $alph $beta matTag integer tag identifying material F0 Intercept strength of the shear wall spring element for the asymtotic line to the envelope curve F0 > FI > 0 FI Intercept strength of the spring element for the pinching branch of the hysteretic curve. (FI > 0). DU Spring element displacement at ultimate load. (DU > 0). S0 Initial stiffness of the shear wall spring element (S0 > 0). R1 Stiffness ratio of the asymptotic line to the spring element envelope curve. The slope of this line is R1 S0. (0 < R1 < 1.0). R2 Stiffness ratio of the descending branch of the spring element envelope curve. The slope of this line is R2 S0. ( R2 < 0). R3 Stiffness ratio of the unloading branch off the spring element envelope curve. The slope of this line is R3 S0. ( R3 1). R4 Stiffness ratio of the pinching branch for the spring element. The slope of this line is R4 S0. ( R4 > 0). alpha Stiffness degradation parameter for the shear wall spring element. (ALPHA > 0). beta Stiffness degradation parameter for the spring element. (BETA > 0). Notes: Refer to the figure below for more information, and the reference provided at the end of this page for complete details about modeling assumptions. FolzFigure.gif Example Files: Click to download files Media:Test.tcl Media:SAWSZeroLength.tcl Example: Hysteresis TestHysteresis.jpg References Reference: Folz, B. and Filiatrault, A. (2001). \u201cSAWS - Version 1.0, A Computer Program for the Seismic Analysis of Woodframe Structures\u201d, Structural Systems Research Project Report No. SSRP-2001/09, Dept. of Structural Engineering, UCSD, La Jolla, CA . Code Developed by: Patxi Uriz, Exponent (Converted from FORTRAN code originally written by Bryan Folz)","title":"SAWS\n"},{"location":"contrib/modeling/uniaxialMaterial/623-SelfCentering%20Material/","text":"SelfCentering This command is used to construct a uniaxial self-centering (flag-shaped) material object with optional non-recoverable slip behaviour and an optional stiffness increase at high strains (bearing behaviour). This material is primarily used to model a self-centering energy-dissipative (SCED) brace (Christopoulos et al., 2008) with the option to model the slippage of an external friction fuse (which causes non-recoverable deformation above a given brace strain). In practice, the external friction fuse is used to limit the amount of force in the brace (since the post-activation stiffness is generally non-zero). The bearing option is used to approximately model the effect of bolt bearing in the brace or external fuse mechanisms, which causes a steep increase in the stiffness of the brace. For self-centering energy-dissipative brace design, this bearing effect model may be used to impose a limit on slip or activation strain based on the anticipated available strain capacity of the mechanism. Note that this bearing effect is only intended to be a flag to indicate the existence of bearing; the SCED brace system should be designed such that the brace will not experience such bearing in practice. This material type could potentially be used for any comparable self-centering system that exhibits a flag-shaped hysteretic response (for example: rocking wall systems if the uniaxial material is used as a moment/rotation hysteresis). uniaxialMaterial SelfCentering $matTag $k1 $k2 $sigAct $beta &lt; $epsSlip &gt; &lt; $epsBear &gt; &lt;rBear&gt; matTag integer tag identifying material k1 Initial Stiffness k2 Post-Activation Stiffness (0< \\(k2&lt;\\) k1) sigAct Forward Activation Stress/Force beta Ratio of Forward to Reverse Activation Stress/Force epsSlip slip Strain/Deformation (if $epsSlip = 0, there will be no slippage) epsBear Bearing Strain/Deformation (if $epsBear = 0, there will be no bearing) rBear Ratio of Bearing Stiffness to Initial Stiffness $k1 SC1.png REFERENCES: Christopoulos, C., Tremblay, R., Kim, H.-J., and Lacerte, M. (2008). \u201cSelf-Centering Energy Dissipative Bracing System for the Seismic Resistance of Structures: Development and Validation\u201d Journal of Structural Engineering ASCE, 134(1), 96-107. Tremblay, R., Lacerte, M., and Christopoulos, C. (2008). \u201cSeismic Response of Multistory Buildings with Self-Centering Energy Dissipative Steel Braces\u201d Journal of Structural Engineering ASCE, 134(1), 108-120. Code Developed by: Jeff Erochko, University of Toronto","title":"SelfCentering\n"},{"location":"contrib/modeling/uniaxialMaterial/63-Bond%20SP01%20-%20-%20Strain%20Penetration%20Model%20for%20Fully%20Anchored%20Steel%20Reinforcing%20Bars/","text":"BondSP01 This command is used to construct a uniaxial material object for capturing strain penetration effects at the column-to-footing, column-to-bridge bent caps, and wall-to-footing intersections. In these cases, the bond slip associated with strain penetration typically occurs along a portion of the anchorage length. This model can also be applied to the beam end regions, where the strain penetration may include slippage of the bar along the entire anchorage length, but the model parameters should be chosen appropriately. uniaxialMaterial Bond_SP01 $matTag $Fy $Sy $Fu $Su $b $R This model is for fully anchored steel reinforcement bars that experience bond slip along a portion of the anchorage length due to strain penetration effects, which are usually the case for column and wall longitudinal bars anchored into footings or bridge joints matTag integer tag identifying material Fy Yield strength of the reinforcement steel Sy Rebar slip at member interface under yield stress. (see NOTES below) Fu Ultimate strength of the reinforcement steel Su Rebar slip at the loaded end at the bar fracture strength b Initial hardening ratio in the monotonic slip vs. bar stress response (0.3~0.5) R Pinching factor for the cyclic slip vs. bar response (0.5~1.0) Monotonic bar stress vs. slip response as modelled in Bond_SP01 BondSPMonotonic.png Cyclic bar stress vs. slip response as modelled in Bond_SP01 BondSPCyclic.png Pinching effect represented by $R in Bond_SP01 BondSPPinching.png NOTES: Sy Rebar slip at member interface under yield stress and may be obtained from BondSP_Sy1.png or BondSP_Sy2.bmp where: db is rebar diameter Fy is yield strength of the reinforcement steel fc \u2019 is concrete compressive strength of the adjoining connection member alpha is a parameter used in the local bond-slip relation and can be taken as 0.4 in accordance with CEB-FIP Model Code 90 Model background: Capturing the structural response and associated damage require accurate modeling of localized inelastic deformations occurring at the member end regions as identified by shaded areas in Figure 4. These member end deformations consist of two components: 1) the flexural deformation that causes inelastic strains in the longitudinal bars and concrete, and 2) the member end rotation, as indicated by arrows in Figure 4, due to reinforcement slip. The slip considered here is the result of strain penetration along a portion of the fully anchored bars into the adjoining concrete members (e.g., footings and joints) during the elastic and inelastic response of a structure. Ignoring the strain penetration component may appear to produce satisfactory force-displacement response of the structural system by compromising strain penetration effects with greater contribution of the flexural action at a given lateral load. However, this approach will appreciably overestimate the strains and section curvatures in the critical inelastic regions of the member, and thereby overestimate the structural damage. Figure 4: Expected inelastic regions at the column and wall ends The zero-length section element available in OpenSees may be used to accurately model the strain penetration effects (or the fixed end rotations shown in Figure 4). Zero-length section elements have been generally used for section analyses to calculate the moment corresponding to a given curvature. To model the fixed-end rotation, the zero-length section element should be placed at the intersection between the flexural member and an adjoining member representing a footing or joint as shown in Figure 5. A duplicate node is also required between a fiber-based beam-column element and the adjoining concrete element as shown in Figure 5. The translational degree-of-freedom of this new node (i.e., node j in Figure 5) should be constrained to the other node (i.e., node i in Figure 5) to prevent sliding of the beam-column element under lateral loads because the shear resistance is not included in the zero-length section element. Figure 5: Adding a zero-length section element to a beam-column element The zero-length section element in OpenSees is assumed to have a unit length such that the element deformations (i.e., elongation and rotation) are equal to the section deformations (i.e., axial strain and curvature). The material model for the steel fibers in the zero-length section element represents the bar slip instead of strain for a given bar stress. The uniaxial material model Bond_SP01 is developed for steel fibers in the zero-length section elements. Note on Material Model for Concrete Fibers Similar to the model proposed for the steel fibers, a material model describing the monotonic response and hysteretic rules is also required for the concrete fibers. The combination of using the zero-length section element and enforcing the plane section assumption at the end of a flexural member impose high deformations to the extreme concrete fibers in the zero-length element. These deformations would likely correspond to concrete compressive strains significantly greater than the strain capacity stipulated by typical confined concrete models. Such high compressive strains at the end of flexural members are possible because of additional confinement effects expected from the adjoining members and because of complex localized deformation at the member end. Without further proof, it is suggested that the concrete fibers in the zero-length section element follow a concrete model in OpenSees (e.g., Concrete02). To accommodate the large deformations expected to the extreme concrete fibers in the zero-length element, this concrete model may be assumed to follow a perfectly plastic behavior once the concrete strength reduces to 80% of the confined compressive strength. A parametric study has indicated that the simulation results would not be very sensitive to the compressive strain chosen to trigger the perfectly plastic behavior for the concrete fibers in the zero-length section element. REFERENCES: Zhao, J., and S. Sritharan. (2007) Modeling of strain penetration effects in fiber-based analysis of reinforced concrete structures. ACI Structural Journal, 104(2), pp. 133-141. WEBSITE: http://www.uwm.edu/~jzhao/Bond_SP01_pages/Bond_index.html Code Developed by: Jian Zhao, University of Wisconsin, Milwakee and Sri Sritharan, Iowa State University","title":"BondSP01\n"},{"location":"contrib/modeling/uniaxialMaterial/632-Series%20Material/","text":"Series This command is used to construct a series material object made up of an arbitrary number of previously-constructed UniaxialMaterial objects. uniaxialMaterial Series $matTag $tag1 $tag2 ... matTag integer tag identifying material $tag1 $tag2 \u2026 identification tags of materials making up the material model The series material is represented graphically: In a series model, stresses are equal and strains and flexibilities are additive: Code Developed by: Micheal Scott, Oregon State University Images Developed by: Silvia Mazzoni","title":"Series\n"},{"location":"contrib/modeling/uniaxialMaterial/64-BoucWen%20Material/","text":"BoucWen This command is used to construct a uniaxial Bouc-Wen smooth hysteretic material object. This material model is an extension of the original Bouc-Wen model that includes stiffness and strength degradation (Baber and Noori (1985)). uniaxialMaterial BoucWen $matTag $alpha $ko $n $gamma $beta $Ao $deltaA $deltaNu $deltaEta matTag integer tag identifying material alpha ratio of post-yield stiffness to the initial elastic stiffenss (0< <math></math> <1) ko initial elastic stiffness n parameter that controls transition from linear to nonlinear range (as n increases the transition becomes sharper; n is usually grater or equal to 1) $gamma $beta parameters that control shape of hysteresis loop; depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated (look at the NOTES) $Ao \\(deltaA</strong></p></td> <td><p>parameters that control tangent stiffness</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) deltaNu $deltaEta parameters that control material degradation NOTES: Parameter \\(\\gamma\\) is usually in the range from -1 to 1 and parameter \\(\\beta\\) is usually in the range from 0 to 1. Depending on the values of \\(\\gamma\\) and \\(\\beta\\) softening, hardening or quasi-linearity can be simulated. The hysteresis loop will exhibit softening for the following cases: (a) <math></math> + <math></math> > 0 and \\(\\beta\\) - \\[\\gamma&lt;/math&gt; &gt; 0, (b) &lt;math&gt;\\beta&lt;/math&gt;+&lt;math&gt;\\gamma&lt;/math&gt; &gt;0 and &lt;math&gt;\\beta&lt;/math&gt;-&lt;math&gt;\\gamma&lt;/math&gt; &lt;0, and (c) &lt;math&gt;\\beta&lt;/math&gt;+&lt;math&gt;\\gamma\\] >0 and \\(\\beta\\) -<math></math> = 0. The hysteresis loop will exhibit hardening if <math></math>+<math></math> < 0 and \\(\\beta\\) -<math></math> > 0, and quasi-linearity if <math></math>+<math></math> = 0 and <math></math>-<math></math> > 0. The material can only define stress-strain relationship. REFERENCES: Haukaas, T. and Der Kiureghian, A. (2003). \u201cFinite element reliability and sensitivity methods for performance-based earthquake engineering.\u201d REER report, PEER-2003/14 1 . Baber, T. T. and Noori, M. N. (1985). \u201cRandom vibration of degrading, pinching systems.\u201d Journal of Engineering Mechanics, 111(8), 1010-1026. Bouc, R. (1971). \u201cMathematical model for hysteresis.\u201d Report to the Centre de Recherches Physiques, pp16-25, Marseille, France. Wen, Y.-K. (1976). for random vibration of hysteretic systems.\u201d Journal of Engineering Mechanics Division, 102(EM2), 249-263.","title":"BoucWen\n"},{"location":"contrib/modeling/uniaxialMaterial/656-SmoothPSConcrete%20Material/","text":"SmoothPSConcrete This command is used to construct a uniaxial smoothed Popovics-Saenz concrete material object. uniaxialMaterial SmoothPSConcrete $matTag $fc $fu $Ec $epso $epsu $eta matTag unique material object integer tag fc concrete compressive strength (positive for compression) fu concrete crushing strength (positive for compression Ec initial tangent stiffness epsco concrete strain at maximum strength (positive for compression) epsu concrete strain at crushing strength (positive for compression) eta smoothing parameter (default value = 0.2). Note: For this material class, the sensitivity parameters can be: fc, fu, Ec, epsco, epscu, eta","title":"SmoothPSConcrete\n"},{"location":"contrib/modeling/uniaxialMaterial/664-Steel01%20Material/","text":"Steel01 This command is used to construct a uniaxial bilinear steel material object with kinematic hardening and optional isotropic hardening described by a non-linear evolution equation (REF: Fedeas). uniaxialMaterial Steel01 $matTag $Fy $E0 $b < $a1 $a2 $a3 $a4 > matTag integer tag identifying material Fy yield strength E0 initial elastic tangent b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent) a1 isotropic hardening parameter, increase of compression yield envelope as proportion of yield strength after a plastic strain of \\(a2*(\\) Fy/E0). (optional) a2 isotropic hardening parameter (see explanation under $a1). (optional). a3 isotropic hardening parameter, increase of tension yield envelope as proportion of yield strength after a plastic strain of \\(a4*(\\) Fy/E0). (optional) a4 isotropic hardening parameter (see explanation under $a3). (optional) Steel01.gif Steel01 Material \u2013 Hysteretic Behavior of Model w/o Isotropic Hardening Steel01HystereticA.jpg Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Compression Steel01HystereticB.jpg Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Tension Steel01HystereticC.jpg NOTES: If strain-hardening ratio is zero and you do not expect softening of your system use BandSPD solver. Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Steel01\n"},{"location":"contrib/modeling/uniaxialMaterial/666-Steel02%20Material%20--%20Giuffr%C3%A9-Menegotto-Pinto%20Model%20with%20Isotropic%20Strain%20Hardening/","text":"Steel02 This command is used to construct a uniaxial Giuffre-Menegotto-Pinto steel material object with isotropic strain hardening. uniaxialMaterial Steel02 $matTag $Fy $E $b $R0 $cR1 $cR2 &lt; $a1 $a2 $a3 $a4 $sigInit &gt; matTag integer tag identifying material Fy yield strength E0 initial elastic tangent b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent) $R0 $CR1 $CR2 parameters to control the transition from elastic to plastic branches. Recommended values: R0 =between 10 and 20, cR1 =0.925, cR2 =0.15 a1 isotropic hardening parameter, increase of compression yield envelope as proportion of yield strength after a plastic strain of \\(a2*(\\) Fy/E0). (optional) a2 isotropic hardening parameter (see explanation under $a1). (optional default = 1.0). a3 isotropic hardening parameter, increase of tension yield envelope as proportion of yield strength after a plastic strain of \\(a4*(\\) Fy/E0). (optional default = 0.0) a4 isotropic hardening parameter (see explanation under \\(a3). (optional default = 1.0)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">sigInit</code></td> <td><p>Initial Stress Value (optional, default: 0.0) the strain is calculated from epsP=\\) sigInit/$E if (sigInit!= 0.0) { double epsInit = sigInit/E; eps = trialStrain+epsInit; } else eps = trialStrain; more on OpenSees uniaxialMaterial Arguments \u2013 Steel02 REFERENCE: Filippou, F. C., Popov, E. P., Bertero, V. V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints\u201d. Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Steel02 Material \u2013 Material Parameters of Monotonic Envelope Steel02Monotonic.jpg Steel02 Material \u2013 Hysteretic Behavior of Model w/o Isotropic Hardening Steel02HystereticA.jpg Steel02 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Compression Steel02HystereticB.jpg Steel01 Material \u2013 Hysteretic Behavior of Model with Isotropic Hardening in Tension Steel02HystereticC.jpg Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Steel02\n"},{"location":"contrib/modeling/uniaxialMaterial/667-Steel4%20Material/","text":"Steel4 This command is used to construct a general uniaxial material with combined kinematic and isotropic hardening and optional non-symmetric behavior. uniaxialMaterial Steel4 $matTag $f_y $E_0 < -asym > < -kin $b_k $R_0 $r_1 $r_2 < $b_kc $R_0c $r_1c $r_2c > > < -iso $b_i $rho_i $b_l $R_i $l_yp < $b_ic $rho_ic $b_lc $R_ic > > < -ult $f_u $R_u < $f_uc $R_uc > > < -init $sig_init > < -mem $cycNum > Parameters matTag unique material object integer tag f_y yield strength (assumed identical in tension and compression) E_0 initial stiffness (Young\u2019s modulus) optional features: -kin apply kinematic hardening <blockquote> colspan = \u201c2\u201d style=\u201ctext-align: justify\u201d | Kinematic hardening is based on the Menegotto-Pinto model. The parameters and their use is identical to those of the Steel02 material. rowspan = \u201c7\u201d | b_k hardening ratio (E_k/E_0) R_0 control the exponential transition from linear elastic to hardening asymptote recommended values: $R_0 = 20 $r_1 = 0.90 \\(r_2 = 0.15</em></p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">r_1</code></p></td> <td></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">r_2</code></p></td> <td></td> </tr> <tr class=\"odd\"> <td></td> <td></td> </tr> </tbody> </table> <p>&lt;/blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-iso</code></p></td> <td><p>apply isotropic hardening</p></td> </tr> </tbody> </table> <p>&lt;blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | Isotropic hardening increases the yield strength of the material. The applied increase is calculated as a function of the accumulated plastic strain. The following parameters control that function.</p></td> <td><p>rowspan = \"9\" | <img src=\"/OpenSeesRT/contrib/static/Steel4_param_iso.png\" title=\"Steel4_param_iso.png\" width=\"400\" alt=\"Steel4_param_iso.png\" /></p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">b_i</code></td> <td><p>initial hardening ratio (E_i/E_0)</p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">b_l</code></td> <td><p>saturated hardening ratio (E_is/E_0)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">rho_i</code></td> <td><p>specifies the position of the intersection point between initial and saturated hardening asymptotes</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">R_i</code></td> <td><p>control the exponential transition from initial to saturated asymptote</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">l_yp</code></td> <td><p>length of the yield plateau in eps_y0 = f_y / E_0 units</p></td> </tr> <tr class=\"odd\"> <td></td> <td></td> </tr> </tbody> </table> <p>&lt;/blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-ult</code></p></td> <td><p>apply an ultimate strength limit</p></td> </tr> </tbody> </table> <p>&lt;blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | The ultimate strength limit serves as an upper limit of material resistance. After the limit is reached the material behaves in a perfectly plastic manner. Exponential transition is provided from the kinematic hardening to the perfectly plastic asymptote.</p></td> <td><p>rowspan = \"6\" | <img src=\"/OpenSeesRT/contrib/static/Steel4_param_ult.png\" title=\"Steel4_param_ult.png\" width=\"400\" alt=\"Steel4_param_ult.png\" /></p></td> </tr> <tr class=\"even\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | Note that isotropic hardening is also limited by the ultimate strength, but the transition from the isotropic hardening to the perfectly plastic asymptote is instantaneous.</p></td> <td></td> </tr> <tr class=\"odd\"> <td></td> <td></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">f_u</code></td> <td><p>ultimate strength</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">R_u</code></td> <td><p>control the exponential transition from kinematic hardening to perfectly plastic asymptote</p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> </tbody> </table> <p>&lt;/blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-asym</code></p></td> <td><p>assume non-symmetric behavior</p></td> </tr> </tbody> </table> <p>&lt;blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | If non-symmetric behavior is assumed, material response under tension and compression will be controlled by two different parameter sets. The normal parameters control behavior under tension. Additional parameters shall be specified to describe behavior under compression. The following parameters are expected after the normal parameters when the options below are used.</p></td> <td><p>rowspan = \"6\" | <img src=\"/OpenSeesRT/contrib/static/Steel4_param_asymk.png\" title=\"Steel4_param_asymk.png\" width=\"400\" alt=\"Steel4_param_asymk.png\" /></p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-kin</code></p></td> <td><p><em>\\) b_kc $R_0c $r_1c \\(r_2c</em></p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-flag\">-iso</code></p></td> <td><p><em>\\) b_ic $rho_ic $b_lc \\(R_ic</em></p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-ult</code></p></td> <td><p><em>\\) f_uc \\(R_uc</em></p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td></td> <td></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> </tbody> </table> <p>&lt;/blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-init</code></p></td> <td><p>apply initial stress</p></td> </tr> </tbody> </table> <p>&lt;blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | Initial stress is assumed at 0 strain at the beginning of the loading process. The absolute value of the initial stress is assumed to be less than the yield strength of the material.</p></td> <td><p>rowspan = \"4\" | <img src=\"/OpenSeesRT/contrib/static/Steel4_param_init.png\" title=\"Steel4_param_init.png\" width=\"400\" alt=\"Steel4_param_init.png\" /></p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">sig_init</code></td> <td><p>initial stress value</p></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> </tbody> </table> <p>&lt;/blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-mem</code></p></td> <td><p>configure the load history memory</p></td> </tr> </tbody> </table> <p>&lt;blockquote&gt;</p> <table> <tbody> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | The load history memory is a database of preceding load cycles. It is updated at every load reversal point during the loading process. It is turned on by default. Turning it off will reduce the memory consumption of Steel4.</p></td> <td><p>rowspan = \"8\" | <img src=\"/OpenSeesRT/contrib/static/Steel4_param_mem.png\" title=\"Steel4_param_mem.png\" width=\"400\" alt=\"Steel4_param_mem.png\" /></p></td> </tr> <tr class=\"even\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | The available data on preceding cycles is currently used to correct a typical error in the Steel02 material. The error stems from the formulation of the Menegotto-Pinto kinematic hardening model. It leads to overestimation of the stress response after small unloading-reloading cycles. This phenomenon is important, because the seismic response of structures typically includes a large number of such small cycles. The error is avoided by forcing the kinematic hardening component of the response to converge to previous load cycles.</p></td> <td></td> </tr> <tr class=\"odd\"> <td><p>colspan = \"2\" style=\"text-align: justify\" | The load history memory can be used in the future to describe other characteristics of the response that depend on preceding load cycles.</p></td> <td></td> </tr> <tr class=\"even\"> <td></td> <td></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">cycNum</code></td> <td><p>expected number of half-cycles during the loading process</p></td> </tr> <tr class=\"even\"> <td></td> <td><p>Efficiency of the material can be slightly increased by correctly setting this value. The default value is <em>\\) cycNum = 50 Load history memory can be turned off by setting $cycNum = 0 . </blockquote> Examples Coming soon\u2026 Author: Adam Zsarn\u00f3czay: zsarnoczay@vbt.bme.hu","title":"Steel4\n"},{"location":"contrib/modeling/uniaxialMaterial/668-SteelMPF%20-%20Menegotto%20and%20Pinto%20%281973%29%20Model%20Extended%20by%20Filippou%20et%20al.%20%281983%29/","text":"SteelMPF Developed and Implemented by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial SteelMPF (Kolozvari et al., 2015), which represents the well-known uniaxial constitutive nonlinear hysteretic material model for steel proposed by Menegotto and Pinto (1973), and extended by Filippou et al. (1983) to include isotropic strain hardening effects. The relationship is in the form of curved transitions (Figure 1), each from a straight-line asymptote with slope E<sub class=\u201csubscript\u201d>0</sub> (modulus of elasticity) to another straight-line asymptote with slope E<sub class=\u201csubscript\u201d>1</sub> = bE<sub class=\u201csubscript\u201d>0</sub> (yield modulus) where b is the strain hardening ratio. The curvature of the transition curve between the two asymptotes is governed by a cyclic curvature parameter R , which permits the Bauschinger effect to be represented, and is dependent on the absolute strain difference between the current asymptote intersection point and the previous maximum or minimum strain reversal point depending on whether the current strain is increasing or decreasing, respectively. The strain and stress pairs (\u03b5<sub class=\u201csubscript\u201d>r</sub>,\u03c3<sub class=\u201csubscript\u201d>r</sub>) and (\u03b5<sub class=\u201csubscript\u201d>0</sub>,\u03c3<sub class=\u201csubscript\u201d>0</sub>) shown on Figure 1 are updated after each strain reversal. The model allows calibration of isotropic hardening parameters in both compression and tension through optional input variables a<sub class=\u201csubscript\u201d>1</sub> and a<sub class=\u201csubscript\u201d>2</sub> for isotropic strain hardening in compression, and a<sub class=\u201csubscript\u201d>3</sub> and a<sub class=\u201csubscript\u201d>4</sub> for isotropic strain hardening tension, and uses default values of a<sub class=\u201csubscript\u201d>1</sub> = a<sub class=\u201csubscript\u201d>3</sub> = 0.0 and a<sub class=\u201csubscript\u201d>2</sub> = a<sub class=\u201csubscript\u201d>4</sub> = 1.0 that yield no isotropic strain hardening for either compression or tension. To incorporate isotropic strain hardening in compression, the recommended parameters are a<sub class=\u201csubscript\u201d>1</sub> = 0.01 and a<sub class=\u201csubscript\u201d>2</sub> = 7.0. To incorporate isotropic strain hardening in tension, the recommended parameters are a<sub class=\u201csubscript\u201d>3</sub> = 0.01 and a<sub class=\u201csubscript\u201d>4</sub> = 7.0. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Figure 1. Constitutive Model for Steel (Menegotto and Pinto, 1973) Input Format: uniaxialMaterial SteelMPF $mattag $fyp $fyn $E0 $bp $bn $R0 $cR1 $cR2 &lt; $a1 $a2 $a3 $a4 &gt; mattag Unique uniaxialMaterial tag fyp Yield strength in tension (positive loading direction) fyn Yield strength in compression (negative loading direction) E0 Initial tangent modulus bp Strain hardening ratio in tension (positive loading direction) bn Strain hardening ratio in compression (negative loading direction) R0 Initial value of the curvature parameter R (R0 = 20 recommended) cR1 Curvature degradation parameter (a1 = 0.925 recommended) cR2 Curvature degradation parameter (a2 = 0.15 or 0.0015 recommended) a1 Isotropic hardening in compression parameter (optional, default = 0.0). Shifts compression yield envelope by a proportion of compressive yield strength after a maximum plastic tensile strain of \\(a2(\\) fyp/$E0) a2 Isotropic hardening in compression parameter (optional, default = 1.0). See explanation of a1. a3 Isotropic hardening in tension parameter (optional, default = 0.0). Shifts tension yield envelope by a proportion of tensile yield strength after a maximum plastic compressive strain of \\(a3(\\) fyn/$E0). a4 Isotropic hardening in tension parameter (optional, default = 1.0). See explanation of a3. Example: uniaxialMaterial SteelMPF 1 60 60 29000 0.02 0.02 20.0 0.925 0.15 Discussion: Although the Menegotto-Pinto model is already available in OpenSees (e.g., [ http://opensees.berkeley.edu/wiki/index.php/Steel02_Material_\u2013_Giuffr%C3%A9-Menegotto-Pinto_Model_with_Isotropic_Strain_Hardening Steel02 ]), the formulation of SteelMPF introduces several distinctive features compared to existing models. For example, the model allows definition of different yield stress values and strain hardening ratios for tension and compression, and it considers degradation of cyclic curvature parameter R for strain reversals in both pre- and post- yielding regions, which could produce more accurate predictions of yield capacity for some RC wall specimens ( element MVLEM , Example 1), whereas Steel02 considers the degradation in post-yielding region only. Strain-stress relationships obtained using SteelMPF and Steel02 are compared in Figure 2 for a strain history that includes strain reversals at strain values equal to one-half of the yield strain (i.e., \u03b5<sub class=\u201csubscript\u201d>r</sub> = \u00b10.001 = \u03b5<sub class=\u201csubscript\u201d>y</sub>/2). Figure 2. Comparing the degradation of cyclic curvature in the pre-yielding region for Steel02 and SteelMPF Furthermore, it has been observed from the strain-stress relationships obtained from quasi-static or dynamic analyses using existing steel models in OpenSees (e.g., Steel02 ) that after partial unloading occurs in a model element caused by dynamic loading or stress re-distribution under quasi-static loading due to concrete cracking or crushing, the Menegotto-Pinto formulation produces stress overshooting in the cyclic stress-strain behavior of reinforcing steel. This overshooting effect is not behavioral and causes non-physical hardening in the stress-strain behavior, upon reloading from the partial unloading loop. This phenomenon is illustrated in Figure 3 for the Steel02 model in OpenSees. This anomaly results in overestimation of steel stresses predicted by the Steel02 model upon return from partial unloading, yielding strain-stress curve that may not represent the physical constitutive behavior of reinforcing steel under cyclic loading. This limitation in the Menegotto-Pinto model formulation has also been acknowledged by Filippou et al. (1983). The overshooting effect observed in the existing OpenSees material model for reinforcing steel (e.g., Steel02 ) has been remedied in SteelMPF , via manipulating the model formulation so that reloading behavior after partial unloading cannot overshoot the previous loading loop in the cyclic stress-strain behavior. The comparison between strain-stress relationships obtained using SteelMPF and Steel02 for a strain history that includes low-amplitude unloading followed by reloading is presented in Figure 3. Figure 3. Comparing the stress overshooting upon reloading from low-amplitude unloading for Steel02 and SteelMPF References: Filippou F.C., Popov, E.P., and Bertero, V.V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints\u201d. Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Menegotto, M., and Pinto, P.E. (1973). Method of analysis of cyclically loaded RC plane frames including changes in geometry and non-elastic behavior of elements under normal force and bending. Preliminary Report IABSE, vol 13.","title":"SteelMPF\n"},{"location":"contrib/modeling/uniaxialMaterial/670-SteelMP%20Material/","text":"SteelMP This command is used to construct a uniaxial Menegotto-Pinto steel material object. uniaxialMaterial SteelMP $matTag $sigmaY $E $b matTag unique material object integer tag sigmaY yield stress or force E initial tangent stiffness b strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent) Note: For this material class, the sensitivity parameters can be: sigmaY, E, b Reference: Barbato M., Conte J.P. (2006). \u201cFinite element structural response sensitivity and reliability analyses using smooth versus non-smooth material constitutive models.\u201d International Journal of Reliability and Safety, 1(1-2):3-39.","title":"SteelMP\n"},{"location":"contrib/modeling/uniaxialMaterial/69-CFSSSWP/","text":"CFSSSWP This command is used to construct a uniaxialMaterial model that simulates the hysteresis response (Shear strength-lateral Displacement) of a Steel-Sheathed Cold-Formed Steel Shear Wall Panel (CFS-SWP). The hysteresis model has smooth curves and takes into account the strength and stiffness degradation, as well as pinching effect. This uniaxialMaterial gives results in Newton and Meter units, for strength and displacement, respectively. NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. uniaxialMaterial CFSSSWP $tag $height $width $fuf $fyf $tf $Af $fus $fys $ts $np $ds $Vs $sc $dt $openingArea $openingLength matTag Integer identifier used to tag the material model height SWP\u2019s height (mm) width SWP\u2019s width (mm) fuf Tensile strength of framing members (MPa) fyf Yield strength of framing members (MPa) tf Framing thickness (mm) Af Framing cross section area (mm\u00b2) fus Tensile strength of steel sheet sheathing (MPa) fys Yield strength of steel sheet sheathing (MPa) ts Sheathing thickness (mm) np Sheathing number (one or two sides sheathed) ds Screws diameter (mm) Vs Screws shear strength (N) sc Screw spacing on the SWP perimeter (mm) dt Anchor bolt\u2019s diameter (mm) openingArea Total area of openings (mm\u00b2) openingLength Cumulative length of openings (mm) DESCRIPTION: The uniaxial hysteresis model of Cold-Formed Steel Shear Wall Panel (CFS-SWP) consists of three parts: backbone curves of the hysteresis loops (states 1 and 2), hysteresis criteria (unloading-reloading path: states 3 and 4) (Fig.2) and deterioration criteria. The following paragraphs will respectively introduce the terms of the three parts. Maximum lateral shear strength and the associated displacement are assessed using an analytical method for steel sheathed CFS SWP proposed by Yanari N and Yu C (2013) which takes into account a wide range of factors that affect the behaviour and strength of a CFS SWP, namely: material properties, thickness and geometry of sheathing and framing, spacing of studs, construction details such as size and spacing of sheathing-to-framing connections. The associated displacement is evaluated using the equation C2.1-1 given by AISI S213-07 code. In addition to the envelope curve, the proposed hysteresis model requires the introduction of parameters that define the strength and stiffness deterioration, as well as the pinching effect under cyclic loading. Compared to the monotonic test result, the hysteresis response of CFS SWP exhibits strength deterioration; even if the displacement associated to peak strength has not been reached yet. The stiffness deterioration of the proposed model is positively related to strength degraded degree, and is defined in a same way as the strength deterioration. In order to account for the overall lateral stiffness and strength of the SWP, an equivalent simple non-linear zeroLength element connected to rigid truss elements which transmit the force to the boundary studs that resist the uniaxial tension and compression stress is used (Fig.3). This modeling tip leads to a considerable reduction in terms of elements number constituting the CFS SWP. The boundary members form a mechanism and the lateral stiffness and strength are derived directly from the zeroLength element. The CFS SWP details, as well as a schematic representation of the finite element model are illustrated in Fig.3. Fig. 3: Cold-Formed Steel Shear Wall Panel details and equivalent OpenSees finite element model EXAMPLES: Cold-Formed Steel Steel Sheathed Shear Wall Panel examples REFERENCES: Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022 . Smail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014. Smail Kechidi and N Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- OPD 2014, 3-4 July 2014, Porto, Portugal. L.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003. Yanagi N, Yu C. Effective strip method for the design of cold-formed steel framed shear wall with steel sheet sheathing. Journal of Structural Engineering, ASCE 2014; 140(4). Nisreen Balh, Development of seismic design provisions for steel sheathed shear walls, Master Thesis, McGill University, Canada, 2010. Code Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact: Smail Kechidi , PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com Nouredine Bourahla , Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz","title":"CFSSSWP\n"},{"location":"contrib/modeling/uniaxialMaterial/70-CFSWSWP/","text":"CFSWSWP This command is used to construct a uniaxialMaterial model that simulates the hysteresis response (Shear strength-Lateral displacement) of a wood-sheathed cold-formed steel shear wall panel (CFS-SWP). The hysteresis model has smooth curves and takes into account the strength and stiffness degradation, as well as pinching effect. This uniaxialMaterial gives results in Newton and Meter units, for strength and displacement, respectively. NOTE: before you use this material make sure that you have downloaded the latest OpenSees version. uniaxialMaterial CFSWSWP $tag $height $width $fut $tf $Ife $Ifi $ts $np $ds $Vs $sc $nc $type $openingArea $openingLength matTag Integer identifier used to tag the material model height SWP\u2019s height (mm) width SWP\u2019s width (mm) fuf Tensile strength of framing members (MPa) tf Framing thickness (mm) Ife Moment of inertia of the double end-stud (mm4) Ifi Moment of inertia of the intermediate stud (mm4) ts Sheathing thickness (mm) np Sheathing number (one or two sides sheathed) ds Screws diameter (mm) Vs Screws shear strength (N) sc Screw spacing on the SWP perimeter (mm) nc Total number of screws located on the SWP perimeter type Integer identifier used to define wood sheathing type (DFP=1, OSB=2, CSP=3) openingArea Total area of openings (mm\u00b2) openingLength Cumulative length of openings (mm) DESCRIPTION: The uniaxial hysteresis model of Cold-Formed Steel Shear Wall Panel (CFS-SWP) consists of three parts: backbone curves of the hysteresis loops (states 1 and 2), hysteresis criteria (unloading-reloading path: states 3 and 4) (Fig.2) and deterioration criteria. The following paragraphs will respectively introduce the terms of the three parts. Maximum lateral shear strength and the associated displacement are assessed using an analytical method for wood sheathed CFS SWP proposed by Xu L and Martinez J (2007) which takes into account a wide range of factors that affect the behaviour and strength of a CFS SWP, namely: material properties, thickness and geometry of sheathing and framing, spacing of studs, construction details such as size and spacing of sheathing-to-framing connections. In addition to the envelope curve, the proposed hysteresis model requires the introduction of parameters that define the strength and stiffness deterioration, as well as the pinching effect under cyclic loading. Compared to the monotonic test result, the hysteresis response of CFS SWP exhibits strength deterioration; even if the displacement associated to peak strength has not been reached yet. The stiffness deterioration of the proposed model is positively related to strength degraded degree, and is defined in a same way as the strength deterioration. In order to account for the overall lateral stiffness and strength of the SWP, an equivalent simple non-linear zeroLength element connected to rigid truss elements which transmit the force to the boundary studs that resist the uniaxial tension and compression stress is used (Fig.3). This modeling tip leads to a considerable reduction in terms of elements number constituting the CFS SWP. The boundary members form a mechanism and the lateral stiffness and strength are derived directly from the zeroLength element. The CFS SWP details, as well as a schematic representation of the finite element model are illustrated in Fig.3. Fig. 3: Cold-Formed Steel Shear Wall Panel details and equivalent OpenSees finite element model. EXAMPLES: Cold-Formed Steel Wood Sheathed Shear Wall Panel examples REFERENCES: Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on its physical and mechanical characteristics, Journal of Thin-Walled Structures (2016), pp.421-430. DOI:10.1016/j.tws.2015.09.022 . Smail Kechidi, Hysteresis model development for cold-formed steel shear wall panel based on physical and mechanical characteristics, Master Thesis, University of Blida 1, Algeria, 2014. Smail Kechidi and Nouredine Bourahla, Deteriorating hysteresis model for cold-formed steel shear wall panel based on physical and mechanical characteristics, OpenSees Days Portugal 2014- Workshop on Multi-Hazard Analysis of Structures using OpenSees, Porto 3-4, Portugal, July 2014. L.N. Lowes, A. Altoontash, Modelling reinforced-concrete beam-column joints subjected to cyclic loading, Journal of Structural Engineering, 129(12):1686-1697, 2003. A.E. Branston, Y.C. Chen, F.A. Boudreault and C.A. Rogers, Testing of light-gauge steel frame wood structural panel shear walls, Canadian Journal of Civil Engineering, 33(9):561-572, 2006. J. Martinez and L. Xu, Strength and stiffness determination of shear wall panels in cold-formed steel framing, Thin-Walled Structures, 44(10):1084-1095, 2006. Code Developed by: Smail Kechidi and Nouredine Bourahla, University of Blida 1, Algeria Images Developed by: Smail Kechidi, University of Blida 1, Algeria Authors contact: Smail Kechidi , PhD student at University of Blida 1, Algeria, s_kechidi@univ-blida.dz, skechidi@yahoo.com Nouredine Bourahla , Professor at University of Blida 1, Algeria, nbourahla@univ-blida.dz","title":"CFSWSWP\n"},{"location":"contrib/modeling/uniaxialMaterial/722-TzLiq1%20Material/","text":"TzLiq1 The command constructs a uniaxial t-z material that incorporates liquefaction effects. This t z material is used with a zeroLength element to connect a pile (beam-column element) to a 2 D plane-strain FE mesh. The t-z material obtains the average mean effective stress (which decreases with increasing excess pore pressure) from two specified soil elements. Currently, the implementation requires that the specified soil elements consist of FluidSolidPorousMaterials in FourNodeQuad elements. uniaxialMaterial TzLiq1 $matTag $tzType $tult $z50 $c $ele1 $ele2 OR uniaxialMaterial TzLiq1 $matTag $tzType $tult $z50 $c -timeSeries $seriesTag matTag integer tag identifying material soilType soilType = 1 Backbone of t-z curve approximates Reese and O\u2019Neill (1987). soilType = 2 Backbone of t-z curve approximates Mosher (1984) relation. tult Ultimate capacity of the t-z material. SEE NOTE 1. Z50 Displacement at which 50% of tult is mobilized in monotonic loading. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). $ele1 $ele2 are the eleTag (element numbers) for the two solid elements from which PyLiq1 will obtain mean effective stresses and excess pore pressures seriesTag Alternatively, mean effective stress can be supplied by a time series by specifying the text string -timeSeries and the tag of the seriesm $seriesTag. NOTES: The argument tult is the ultimate capacity of the t-z material. Note that \u201ct\u201d or \u201ctult\u201d are shear stresses [force per unit area of pile surface] in common design equations, but are both loads for this uniaxialMaterial [i.e., shear stress times the tributary area of the pile]. Nonzero c values are used to represent radiation damping effects To model the effects of liquefaction with TzLiq1, it is necessary to use the material stage updating command: <pre> updateMaterialStage -material matNum -stage sNum </pre> where the argument matNum is the material number (for TzLiq1) and the argument sNum is the desired stage (valid values are 0 & 1). With sNum=0, the TzLiq1 behavior will be independent of any pore pressure in the specified solidElem\u2019s. When updateMaterialStage first sets sNum=1, TzLiq1 will obtain the average mean effective stress in the two solidElem\u2019s and treat it as the initial consolidation stress prior to undrained loading. Thereafter, the behavior of TzLiq1 will depend on the mean effective stress (and hence excess pore pressures) in the solidElem\u2019s. The default value of sNum is 0 (i.e., sNum=0 if updateMaterialStage is not called). Note that the updateMaterialStage command is used with some soil material models, and that sNum=0 generally corresponds to the application of gravity loads (e.g., elastic behavior with no excess pore pressure development) and sNum=1 generally corresponds to undrained loading (e.g., plastic behavior with excess pore pressures development). The analysis for gravity loading cannot use the \u201calgorithm Linear\u201d command because the relevant soil materials do not currently work properly with this command. Instead, the \u201calgorithm Newton\u201d or some other option must be used. TzLiq1 inherits TzSimple1 and modifies its response based on the mean effective stresses (and hence excess pore pressures) in the specified solid soil elements. The logic and implementation are the same as for how PyLiq1 inherits and modifies PySimple1. Therefore, the reader is referred to the documentation of PyLiq1 for details. Examples REFERENCES: \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis","title":"TzLiq1\n"},{"location":"contrib/modeling/uniaxialMaterial/723-TzSimple1%20Material/","text":"TzSimple1 This command is used to construct a TzSimple1 uniaxial material object: uniaxialMaterial TzSimple1 $matTag $tzType $tult $z50 &lt; $c &gt; matTag integer tag identifying material soilType soilType = 1 Backbone of t-z curve approximates Reese and O\u2019Neill (1987). soilType = 2 Backbone of t-z curve approximates Mosher (1984) relation. tult Ultimate capacity of the t-z material. SEE NOTE 1. Z50 Displacement at which 50% of tult is mobilized in monotonic loading. c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). See NOTE 2. NOTES: The argument tult is the ultimate capacity of the t-z material. Note that \u201ct\u201d or \u201ctult\u201d are shear stresses [force per unit area of pile surface] in common design equations, but are both loads for this uniaxialMaterial [i.e., shear stress times the tributary area of the pile]. Nonzero c values are used to represent radiation damping effects EQUATIONS and EXAMPLERESPONSES: The equations describing PySimple1 behavior are described in Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759. Only minor changes have been made in its implementation for OpenSees. The nonlinear t-z behavior is conceptualized as consisting of elastic (<math>t-z^e</math>) and plastic (<math>t-z^p</math>) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component (<math>t-z^e</math>) of the displacement rate. Note that <math>z = z^e + z^p</math>, and that <math>t = t^e = t^p</math>. The plastic component is described by: <math>t^p = t_{} - (t_{} - t^p_0) </math> where $t_{ult} = $ the ultimate resistance of the t-z material in the current loading direction, <math>t^p_o = t^p</math> at the start of the current plastic loading cycle, \\(z^p_0 = z^P\\) at the start of the current plastic loading cycle, and c = a constant and n = an exponent that define the shape of the \\(t-z^p\\) curve. The elastic component can be conveniently expressed as: \\[t^e = C_e \\frac{t_{\\text{ult}}}{z_{50}} z^e\\] where \\(C_e\\) = a constant that defines the normalized elastic stiffness. The value of \\(C_e\\) is not an independent parameter, but rather depends on the constants c & n (along with the fact that <math>t = 0.5 t_{}</math> at \\(z = z_{50}\\) ). The flexibility of the above equations can be used to approximate different t-z backbone relations. Reese and O\u2019Neill\u2019s (1987) recommended backbone for drilled shafts is closely approximated using c = 0.5, n = 1.5, and Ce = 0.708. Mosher\u2019s (1984) recommended backbone for axially loaded piles in sand is closely approximated using c = 0.6, n = 0.85, and Ce = 2.05. TzSimple1 is currently implemented to allow use of these two default sets of values. Values of tult and z50 must then be specified to define the t-z material behavior. Viscous damping on the far-field (elastic) component of the t-z material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (displacement rate) that developed in the far-field elastic component of the material. In addition, the total force across the t-z material is restricted to tult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like TzSimple1. Examples of the cyclic loading response of TzSimple1 are given in the following plots. Note that the response for tzType = 2 has greater nonlinearity at smaller displacements (and hence greater hysteretic damping) and that it approaches tult more gradually (such that t/tult is still well below TzSimple1.gif Examples REFERENCES: \u201cSeismic Soil-pile-strcture interaction experiments and analysis\u201d, Boulanger, R.W., Curras, C.J., Kutter, B.L., Wilson, D.W., and Abghari, A. (1990). Jornal of Geotechnical and Geoenvironmental Engineering, ASCS, 125(9):750-759. Code Developed by: Ross Boulanger, UC Davis","title":"TzSimple1\n"},{"location":"contrib/modeling/uniaxialMaterial/73-CastFuse%20Material/","text":"CastFuse This command is used to construct a CastFuse uniaxial material. The CastFuse material simulates the hysteretic response a cast yielding fuse (CSF) for concentrically braced frames. The details of a CSF-brace are discussed in Gray et al. [1,2]. Isotropic hardening is modeled with the rules developed by Filippou et al. [3]. uniaxialMaterial Cast $matTag $n $bo $h $fy $E $L $b $Ro $cR1 $cR2 &lt; $a1 $a2 $a3 $a4 &gt; matTag integer tag identifying material n Number of yield fingers of the CSF-brace bo Width of an individual yielding finger at its base of the CSF-brace h Thickness of an individual yielding finger fy Yield strength of the steel material of the yielding finger E Modulus of elasticity of the steel material of the yielding finger L Height of an individual yielding finger b Strain hardening ratio Ro Parameter that controls the Bauschinger effect. Recommended Values for $Ro=between 10 to 30 cR1 Parameter that controls the Bauschinger effect. Recommended Value $cR1=0.925 cR2 Parameter that controls the Bauschinger effect. Recommended Value $cR2=0.150 a1 isotropic hardening parameter, increase of compression yield envelope as proportion of yield strength after a plastic deformation of $a2*(P<sub>p</sub>/K<sub>p</sub>) a2 isotropic hardening parameter (see explanation under $a1). (optional default = 1.0) a3 isotropic hardening parameter, increase of tension yield envelope as proportion of yield strength after a plastic deformation of $a4*(P<sub>p</sub>/K<sub>p</sub>) a4 isotropic hardening parameter (see explanation under $a3). (optional default = 1.0) Gray et al. [1] showed that the monotonic backbone curve of a CSF-brace with known properties (n, b<sub>o</sub>, h, L, fy, E) after yielding can be expressed as a close-form solution that is given by, P = P<sub>p</sub>/cos(2d/L), in which d is the axial deformation of the brace at increment i and P<sub>p</sub> is the yield strength of the CSF-brace and is given by the following expression P<sub>p</sub> = nb<sub>o</sub>h<sup>2</sup>f<sub>y</sub>/4L The elastic stiffness of the CSF-brace is given by, K<sub>p</sub> = nb<sub>o</sub>Eh<sup>3</sup>f<sub>y</sub>/6L<sup>3</sup> Examples: References : [1] Gray, M.G., Christopoulos, C., Packer, J.A., (2010). \u201cCast Steel Yielding Fuse for Concentrically Braced Frames,\u201d Proceedings of the 9th U.S. National and 10th Canadian Conference on Earthquake Engineering, July 25-29, 2010, Toronto, Ontario, Canada, paper No. 595. [2] Gray, M.G., Christopoulos, C., Packer, J.A., Lignos, D.G. (2012). \u201cDevelopment, Validation and Modeling of the New Cast Steel Yielding Brace System,\u201d Proceedings ASCE Structures Congress, March 29th-31st, Chicago, IL, USA, SEI institute. [3] Filippou, F. C., Popov, E. P., Bertero, V. V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints,\u201d Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Code Developed by : by Dr. Dimitrios G. Lignos, (McGill University)","title":"CastFuse\n"},{"location":"contrib/modeling/uniaxialMaterial/730-UVCuniaxial%20%28Updated%20Voce-Chaboche%29/","text":"UVCuniaxial This command is used to construct an Updated Voce-Chaboche (UVC) material for uniaxial stress states (e.g., beam elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The multiaxial (e.g., for solid/brick elements) and plane-stress (e.g., for quad/plate/shell elements) versions are also available. The multiaxial and plane-stress implementations have the exact same hardening rules as this uniaxial model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. uniaxialMaterial UVCuniaxial $matTag $E $fy $QInf $b $DInf $a $N $C1 $gamma1 &lt; $C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8 &gt; matTag Integer tag identifying the material. E Elastic modulus of the steel material. fy Initial yield stress of the steel material. QInf Maximum increase in yield stress due to cyclic hardening (isotropic hardening). b Saturation rate of QInf, b > 0. DInf Decrease in the initial yield stress, to neglect the model updates set DInf = 0. a Saturation rate of DInf, a > 0. If DInf == 0, then a is arbitrary (but still a > 0). N Number of backstresses to define, N >= 1. C1 Kinematic hardening parameter associated with backstress component 1. gamma1 Saturation rate of kinematic hardening associated with backstress component 1. <C2 gamma2 C3 gamma3 \u2026 C8 gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples 1. Validation with Abaqus: This first example compares the response of the UVC model with the built-in nonlinear isotropic/kinematic material model in Abaqus v6.14. For this validation the model updates are neglected by simply setting DInf = 0.0 and a = 1.0. The model parameters are: E = 179800 MPa, fy = 318.5 MPa, QInf = 100.7 MPa, b = 8.0, DInf = 0.0 MPa, a = 1.0, C1 = 11608.2 MPa, gamma1 = 145.2, C2 = 1026.3 MPa, gamma2 = 4.7 Figure 1 shows that the UVC implementation in OpenSees agrees with the built-in Abaqus model to the level of machine precision. Therefore, you can use the UVC model in place of the nonlinear isotropic/kinematic hardening material model provided in Abaqus and many other finite element simulation platforms. The finite element models used to validate the Abaqus and OpenSees responses can be found at https://github.com/ahartloper/UVC_MatMod . Figure 1. Validation of UVC model with built-in nonlinear isotropic/kinematic material in Abaqus. 2. Comparison with structural steels: The applicability of the UVC material model for structural steels is demonstrated through two comparisons with experimental data from uniaxial coupon tests. A comparison with a North American steel, A992 Gr. 50 (nominal fy = 345 MPa), is shown in Figure 2. A comparison with a European steel, S355J2+N (nominal fy = 355 MPa), is shown in Figure 3. In both cases the UVC model is able to represent well the initial yield stress as well as the material behavior in later loading cycles. The parameters used for the A992 Gr. 50 and S355J2+N steels, along with other common structural steels, are provided and discussed in the next section. <center> <gallery widths=400px heights=300px> File:A992_flange_UVC.png | Figure 2. Comparison of UVC model with uniaxial coupon test data from the A992 Gr. 50 W14X82 flange data set. File:S355j2_UVC.png | Figure 3. Comparison of UVC model with uniaxial coupon test data from the S355J2+N 25 mm plate data set. </gallery> </center> UVC model parameters for structural steels Below is a list of UVC model parameters for twelve structural steels from Reference [1] using two backstresses. These parameters are applicable for all implementations of the UVC model (uniaxial, plane-stress, multiaxial). References [1,3] contain detailed information on the calibration procedure used to obtain the model parameters. All of the parameters provided in the table below were obtained by minimizing the total squared-strain energy across at least five uniaxial coupon tests of distinct strain histories subject to the constraint that the material response is non-softening. Therefore, the UVC material model parameters should be representative of steel material behavior for arbitrarily imposed strains. Note that although the parameters in this table are considered representative of a specific sample of each material, significant variations can exist between different samples of the same material. All the parameters in the table are obtained through the UVC model calibration procedure implemented in the open-source Python package RESSPyLab . The RESSPyLab package can be used to generate UVC model parameters for other steel materials if the data is available. Details and examples on the calibration are provided on the RESSPyLab web page. Note that the parameters provided in the table below were calibrated using the true stress-strain definition, i.e., e_true = ln(1+(L-L_0)/L_0) and s_true = F/A_0 * (1 + (L-L_0)/L_0). UVC Material Parameters Material - S355J2+N (25 mm plate) S355J2+N (50 mm plate) S355J2+N (HEB500 flange) S355J2+N (HEB500 web) S460NL (25 mm plate) S690QL (25 mm plate) A992 Gr. 50 (W14X82 web) A992 Gr. 50 (W14X82 flange) A500 Gr. B (HSS305X16) BCP325 (22 mm plate) BCR295 (HSS350X22) HYP400 (27mm plate) References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. \u201cConstitutive Modeling of Structural Steels: Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCuniaxial\n"},{"location":"contrib/modeling/uniaxialMaterial/732-UniaxialJ2Plasticity%20Material/","text":"UniaxialJ2Plasticity This command is used to construct a uniaxial J2 Plasticity material object with isotropic and kinematic hardening. uniaxialMaterial UniaxialJ2Plasticity $matTag $E $sigmaY $Hkin $Hiso matTag unique material object integer tag E initial tangent stiffness sigmaY yield stress (or force) Hkin kinematic hardening Modulus Hiso isotropic hardening Modulus Note: For this material class, the sensitivity parameters can be: E, sigmaY, Hkin, Hiso Reference: Conte J.P., Vijalapura P., Meghella M. (2003). \u201cConsistent finite element response sensitivities analysis.\u201d Journal of Engineering Mechanics (ASCE), 129(12):1380-1393.","title":"UniaxialJ2Plasticity\n"},{"location":"contrib/modeling/uniaxialMaterial/748-ViscousDamper%20Material/","text":"ViscousDamper This command is used to construct a ViscousDamper material, which represents the Maxwell Model (linear spring and nonlinear dashpot in series). The ViscousDamper material simulates the hysteretic response of nonlinear viscous dampers. An adaptive iterative algorithm has been implemented and validated to solve numerically the constitutive equations within a nonlinear viscous damper with a high-precision accuracy. uniaxialMaterial ViscousDamper $matTag $K $Cd $alpha &lt; $LGap &gt; &lt; $NM $RelTol $AbsTol $MaxHalf &gt; matTag integer tag identifying material K Elastic stiffness of linear spring to model the axial flexibility of a viscous damper (e.g. combined stiffness of the supporting brace and internal damper portion) Cd Damping coefficient alpha Velocity exponent LGap Gap length to simulate the gap length due to the pin tolerance NM Employed adaptive numerical algorithm (default value NM = 1; 1 = Dormand-Prince54, 2=6th order Adams-Bashforth-Moulton, 3=modified Rosenbrock Triple) RelTol Tolerance for absolute relative error control of the adaptive iterative algorithm (default value 10^-6) AbsTol Tolerance for absolute error control of adaptive iterative algorithm (default value 10^-10) MaxHalf Maximum number of sub-step iterations within an integration step (default value 15) Examples: 1. Input parameters: Assume a viscous damper with axial stiffness K=300.0kN/mm, damping coefficient Cd=280.3kN(s/mm)<sup>0.3</sup>, and exponent a=0.30. The input parameters for the material should be as follows: uniaxialMaterial ViscousDamper 1 300 280.3 0.30 Using these properties, Figure 1 shows the hysteretic response of this damper for sinusoidal displacement increments of 12, 24 and 36mm and a frequency f = 0.5Hz. The sensitivity of the viscous damper with respect to its velocity exponent is shown in Figures 2 to 4 for the following set of parameters: Viscous Damper with various input parameter variations 2. Single story single bay frame with viscous damper References : [1] Akcelyan, S., Lignos, D. G., Hikino, T., and Nakashima, M. (2016). \u201cEvaluation of simplified and state-of-the-art analysis procedures for steel frame buildings equipped with supplemental damping devices based on E-Defense full-scale shake table tests.\u201d Journal of Structural Engineering, 142(6), 04016024. 1 [2] Akcelyan, S., Lignos, D. G., Hikino, T. (2018). \u201cAdaptive Numerical Method Algorithms for Nonlinear Viscous and Bilinear Oil Damper Models Subjected to Dynamic Loading.\u201d Soil Dynamics and Earthquake Engineering, 113, 488-502. 2 . [3] Akcelyan, S. (2017). \u201cSeismic retrofit of existing steel tall buildings with supplemental damping devices.\u201d Ph.D. Dissertation, McGill University, Canada. [4] Oohara, K., and Kasai, K. (2002), \u201cTime-History Analysis Models for Nonlinear Viscous Dampers\u201d, Proc. Structural Engineers World Congress (SEWC), Yokohama, JAPAN, CD-ROM, T2-2-b-3 (in Japanese). [5] Kasai K, Oohara K. \u201cAlgorithm and Computer Code To Simulate Response of Nonlinear Viscous Damper\u201d Passively Controlled Structure Symposium 2001, Yokohama, Japan (in Japanese). Code Developed and Implemented by : Sarven Akcelyan & Prof. Dimitrios G. Lignos , (McGill University)","title":"ViscousDamper\n"},{"location":"contrib/modeling/uniaxialMaterial/749-Viscous%20Material/","text":"Viscous This command is used to construct a uniaxial viscous material object. stress =C(strain-rate)^alpha uniaxialMaterial Viscous $matTag $C $alpha matTag integer tag identifying material C damping coeficient alpha power factor (=1 means linear damping) NOTES: This material can only be assigned to truss and zeroLength elements. This material can not be combined in parallel/series with other materials. When defined in parallel with other materials it is ignored. REFERENCES: See Eqn 9 in G. Pekcan, J.B.Mander abd S.S. Chen, \u201cFundamental Considerations for the Design of Non-Linear Viscous Dampers\u201d, Earthqauke Engineering & Structural Dynamics 28,1405-1425 (1999) Code Developed by: Mehrdad Sasani, NEU","title":"Viscous\n"},{"location":"contrib/modeling/uniaxialMaterial/87-Concrete01%20Material/","text":"Concrete01 This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength (refer to http://peer.berkeley.edu ). uniaxialMaterial Concrete01 $matTag $fc $epsco $fcu $epscu matTag unique material object integer tag fc concrete compressive strength (with positive value) epsco concrete strain at maximum strength (with positive value) fcu concrete crushing strength (with positive value) epscu concrete strain at crushing strength (with positive value) Note: For this material class, the sensitivity parameters can be: fc, epsco, fcu, epscu","title":"Concrete01\n"},{"location":"contrib/modeling/uniaxialMaterial/88-Concrete01%20Material%20--%20Zero%20Tensile%20Strength/","text":"Concrete01 This command is used to construct a uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength. (REF: Fedeas). uniaxialMaterial Concrete01 $matTag $fpc $epsc0 $fpcu $epsU matTag integer tag identifying material fpc concrete compressive strength at 28 days (compression is negative)* epsc0 concrete strain at maximum strength* fpcu concrete crushing strength * epsU concrete strain at crushing strength* NOTE: Compressive concrete parameters should be input as negative values (if input as positive, they will be converted to negative internally). The initial slope for this model is (2* \\(fpc/\\) epsc0) Concrete01.gif Typical Hysteretic Stress-Strain Relation for material Examples uniaxialMaterial Concrete01 1 -4.0 -0.002 0.0 -0.005; # the concrete material with tag 1 reaches compressive strength of 4.0 at strain of 0.002 and reaches ultimate strength of 0.0 at strain of 0.005. Concrete01Hysteretic.jpg Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Concrete01\n"},{"location":"contrib/modeling/uniaxialMaterial/89-Concrete01%20Material%20With%20Stuff%20in%20the%20Cracks/","text":"Concrete01WithSITC This command is used to construct a modified uniaxial Kent-Scott-Park concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and no tensile strength. The modification is to model the effect of Stuff In The Cracks (SITC). The command is as follows: uniaxialMaterial Concrete01WithSITC $matTag $fpc $epsc0 $fpcu $epsU &lt; $endStrainSITC &gt; matTag integer tag identifying material fpc concrete compressive strength at 28 days (compression is negative)* epsc0 concrete strain at maximum strength* fpcu concrete crushing strength * epsU concrete strain at crushing strength* endStrainSITC optional, default = 0.03 NOTE: Compressive concrete parameters should be input as negative values. The initial slope for this model is (2* \\(fpc/\\) epsc0) REFERENCES: J.F. Stanton and H.D. McNiven, \u201cThe Development of a Mathematical Model to Predict the Flexural Response of Reinforced Concrete Beams to Cyclic Loads, Using System Identification\u201d, EERC Report Number 79/02, January 1979. Code Developed by: Won Lee, Stanford","title":"Concrete01WithSITC\n"},{"location":"contrib/modeling/uniaxialMaterial/90-Concrete02%20Material%20--%20Linear%20Tension%20Softening/","text":"Concrete02 uniaxialMaterial Concrete02 $matTag $fpc $epsc0 $fpcu $epsU $lambda $ft $Ets matTag integer tag identifying material fpc concrete compressive strength at 28 days (compression is negative)* epsc0 concrete strain at maximum strength* fpcu concrete crushing strength * epsU concrete strain at crushing strength* lambda ratio between unloading slope at \\(epscu and initial slope</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">ft</code></td> <td><p>tensile strength</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Ets</code></td> <td><p>tension softening stiffness (absolute value) (slope of the linear tension softening branch)</p></td> </tr> </tbody> </table> <p>NOTE:</p> <ul> <li>Compressive concrete parameters should be input as negative values.</li> </ul> <ul> <li>The initial slope for this model is (2*\\) fpc/$epsc0) REFERENCE: Mohd Hisham Mohd Yassin, \u201cNonlinear Analysis of Prestressed Concrete Structures under Monotonic and Cycling Loads\u201d, PhD dissertation, University of California, Berkeley, 1994. Concrete02.jpg Comparison of Hysteretic Stress-Strain Relation for Concerete01 versus Concrete02 materials. Concrete02Hysteretic.jpg Code Developed by: Filip Filippou, UC Berkeley Images Developed by: Silvia Mazzoni","title":"Concrete02"},{"location":"contrib/modeling/uniaxialMaterial/91-Concrete04%20Material%20--%20Popovics%20Concrete%20Material/","text":"Concrete04 This command is used to construct a uniaxial Popovics concrete material object with degraded linear unloading/reloading stiffness according to the work of Karsan-Jirsa and tensile strength with exponential decay. uniaxialMaterial Concrete04 $matTag $fc $ec $ecu $Ec &lt; $fct $et &gt; &lt; $beta &gt; matTag integer tag identifying material fc floating point values defining concrete compressive strength at 28 days (compression is negative)* ec floating point values defining concrete strain at maximum strength* ecu floating point values defining concrete strain at crushing strength* Ec floating point values defining initial stiffness** fct floating point value defining the maximum tensile strength of concrete et floating point value defining ultimate tensile strain of concrete beta loating point value defining the exponential curve parameter to define the residual stress (as a factor of $ft) at $etu NOTE: Compressive concrete parameters should be input as negative values. The envelope of the compressive stress-strain response is defined using the model proposed by Popovics (1973). If the user defines Ec = 57000*sqrt(|fcc|)(in psi) \u2019 then the envelope curve is identical to proposed by Mander et al. (1988). Model Characteristic: For loading in compression, the envelope to the stress-strain curve follows the model proposed by Popovics (1973) until the concrete crushing strength is achieved and also for strains beyond that corresponding to the crushing strength. For unloading and reloading in compression, the Karsan-Jirsa model (1969) is used to determine the slope of the curve. For tensile loading, an exponential curve is used to define the envelope to the stress-strain curve. For unloading and reloading in tensile, the secant stiffness is used to define the path. Concrete04A.png Concrete0B.png REFERENCES: Reference: Mander, J. B., Priestley, M. J. N., and Park, R. (1988). \u201cTheoretical stress-strain model for confined concrete.\u201d Journal of Structural Engineering ASCE, 114(8), 1804-1825. Popovics, S. (1973). \u201d A numerical approach to the complete stress strain curve for concrete.\u201d Cement and concrete research, 3(5), 583-599. Karsan, I. D., and Jirsa, J. O. (1969). \u201cBehavior of concrete under compressive loading.\u201d Journal of Structural Division ASCE, 95(ST12). Code Developed by: Laura Lowes, University of Washington and Michael Berry, University of Washington Images Developed by: Silvia Mazzoni","title":"Concrete04"},{"location":"contrib/modeling/uniaxialMaterial/92-Concrete06%20Material/","text":"Concrete06 This command is used to construct a uniaxial concrete material object with tensile strength, nonlinear tension stiffening and compressive behavior based on Thorenfeldt curve. uniaxialMaterial Concrete06 $matTag $fc $e0 $n $k $alpha1 $fcr $ecr $b $alpha2 matTag integer tag identifying material fc concrete compressive strength (compression is negative)* e0 strain at compressive strength* n compressive shape factor k post-peak compressive shape factor alpha1 \\(\\alpha_1\\) parameter for compressive plastic strain definition fcr tensile strength ecr tensile strain at peak stress ( fcr ) b exponent of the tension stiffening curve alpha2 \\(\\alpha_2\\) parameter for tensile plastic strain definition Concrete06C.png NOTE: Compressive concrete parameters should be input as negative values. Examples uniaxialMaterial Concrete06 1 -3 -0.002 2 1 0.32 0.3 0.00008 4 0.08 DISCUSSION: The concrete material, Concrete06 (Fig. 2), keeps the simplicity of previous formulations (Concrete01 to Concrete03). However, envelope curves have been modified to represent concrete behavior in membrane elements. Compressive constitutive material law (?c-?c) is defined as the Thorenfeldt-base curve, which is similar to Popovic (1973) definition: <math>_c = f^\u2019_c </math> where f\u2019c is the compressive strength, \\(\\epsilon_0\\) is the strain at peak compressive stress, and n and k are parameters. The tensile envelope uses the tension stiffening equation by Belarbi and Hsu (1994) with a general exponent b. \\[\\epsilon_c \\le \\epsilon_{\\text{cr}}, \\sigma_c = \\left ( \\frac{f_\\text{cr}}{\\epsilon_\\text{cr}} \\right ) \\epsilon_c\\] \\[\\epsilon_c &gt; \\epsilon_{\\text{cr}}, \\sigma_c = f_\\text{cr} \\left ( \\frac{\\epsilon_\\text{cr}}{\\epsilon_\\text{c}} \\right )^b \\] where \\(f_\\text{cr}\\) is the tensile strength, \\(\\epsilon_\\text{cr}\\) is the strain at tensile strength and b is a parameter. Concrete06A.png Hysteretic rules in compression are held similarly as defined in Concrete03, with linear unloading and reloading paths (constant stiffness). The unloading and reloading paths in compression are connected through unloading/reloading paths with initial elastic stiffness (Fig. 2 and 3). The unloading path in compression has a stiffness of 7.1% of the initial elastic stiffness (0.071Ec) as adopted by Palermo and Vecchio (2003). The plastic compressive strain <math>(^p_c</math>), defined as the residual unrecoverable compressive strain obtained after full unloading (zero stress) is characterized by: \\[\\epsilon^c_p = \\epsilon^c_m \\left (1 - e ^{-\\frac{\\epsilon^c_m}{\\epsilon_\\text{cr}} \\alpha_1} \\right ) \\] where \\(\\epsilon_m^c\\) is the maximum (absolute value) compressive strain attained previously on the envelope (stored value by the uniaxial material), and \\(\\alpha_1\\) is a parameter. A origin-oriented hysteretic rule for tension may introduce inaccuracies in the analysis. In this case, stresses are linear and recover the initial strain (from previous cycle) when reducing to zero. However, after opening of cracks, under unloading from tension, the uneven and rough surface of the crack tend to initiate contact before the initial strain from previous cycle is attained. This effect known as gap closure improves the dissipating characteristic of the hysteretic rule, reducing the pinching. For this reason, the hysteretic rule for concrete in tension in this model considers a plastic strain (different from zero or the strain from previous cycle) such that when going from tensile stresses to compressive stresses the gap closure effect is modeled by a linear path. Such consideration requires also keeping track of previous stiffness and maximum tensile stress, and the previous tensile plastic strain. This is required, since when going in a posterior cycle from compressive stresses to tensile stresses the compressive plastic strain will become the new origin of the tensile behavior, creating a shifting in the stress-strain curve in tension (Fig. 3). From that strain a linear path will be followed using the previous unloading stiffness in tension until the previous attained maximum tensile stress is reached. In tension, the unloading and reloading paths are the same, and are defined by the tensile plastic strain <math>(_p^t)</math>. A similar equation is used to characterize the tensile plastic strain as in compression: \\[\\epsilon^t_p = \\epsilon^t_m \\left (1 - e ^{-\\frac{\\epsilon^t_m}{\\epsilon_\\text{cr}} \\alpha_2} \\right ) \\] where \\(\\epsilon_m^t\\) is the maximum tensile strain attained previously on the envelope (stored value by the uniaxial material), and \\(\\alpha_2\\) is a parameter. Even though the equation for plastic strain (tension or compression) can be generally used, an internal checking is included in the model such that the unloading/reloading paths have as maximum stiffness the initial stiffness. Concrete06B.png REFERENCES: Popovics, S., 1973, \u201cA Numerical Approach to the Complete Stress-Strain Curve of Concrete\u201d, Cement and Concrete Research, V. 3, No. 4, pp. 583-599. Belarbi, H. and Hsu, T.C.C., 1994, \u201cConstitutive Laws of Concrete in Tension and Reinforcing Bars Stiffened by Concrete\u201d, ACI Structural Journal, V. 91, No. 4, pp. 465-474. Palermo, D., and Vecchio, F. J., 2003, \u201cCompression Field Modeling of Reinforced Concrete Subjected to Reversed Loading: Formulation\u201d, ACI Structural Journal, V. 100, No. 5, pp. 616 - 625. Code Developed by: Leo Massone, University of Chile","title":"Concrete06\n"},{"location":"contrib/modeling/uniaxialMaterial/93-Concrete07%20-%20Chang%20%26amp%3B%20Mander%E2%80%99s%201994%20Concrete%20Model/","text":"Concrete07 Concrete07 is an implementation of Chang & Mander\u2019s 1994 concrete model with simplified unloading and reloading curves. Additionally the tension envelope shift with respect to the origin proposed by Chang and Mander has been removed. The model requires eight input parameters to define the monotonic envelope of confined and unconfined concrete in the following form: uniaxialMaterial Concrete07 $matTag $fc $ec $Ec $ft $et $xp $xn $r matTag integer tag identifying material fc concrete compressive strength (compression is negative)* ec concrete strain at maximum compressive strength* Ec Initial Elastic modulus of the concrete ft tensile strength of concrete (tension is positive) et tensile strain at max tensile strength of concrete xp Non-dimensional term that defines the strain at which the straight line descent begins in tension xn Non-dimensional term that defines the strain at which the straight line descent begins in compression r Parameter that controls the nonlinear descending branch check this page! NOTES: Compressive concrete parameters should be input as negative values. Unconfined Concrete For unconfined concrete, the peak compressive strength fc in the above figure is f\u2019c0 and corresponding strain ec is e\u2019c0. Assuming that the compressive strength for unconfined concrete is readily available, the key parameters required for the model can be found using the following recommendations which include: US_Customary_Units.png SI_Metric_Units.png Confined Concrete Confinement increases the strength and ductility of concrete. These effects are accounted in the above figure by replaceing the peak compressive strength and the corresponding strain with f\u2019 cc and e\u2019cc, respectively. The value of r is also decreased. The recommended approach to define all critical parameters needed to model the confined concrete under compression are as follows: Confined_Concrete.png where: Confined_Concrete_Parameters.png The monotonic envelope for the tension side of the confined concrete follows the same curve that is used for unconfined concrete. Cyclic Behavior The hysteretic rules for cyclic behavior of confined and unconfined concrete is built into the model and requires no further input from the user. These rules generally follow the recommendations of Chang and Mander, which was established based on statistical regression analysis on the experimental data from cyclic compression tests of a number of researchers. However, three simplifications were made to the rules proposed by Chang and Mander which are: Instead of the power function for unloading and reloading paths, Concrete07 uses tri-linear paths for unloading and reloading. The reason for this change is to increase the computational efficiency of the model, as well as numerical stability. The original model shifts the tension envelope as compression reloading after a reversal occurs. This shift is deemed unnecessary and not implemented in Concrete07. The original model requires an additional strain be applied beyond the unloading strain to rejoin the monotonic envelope. The Concrete07 rejoins the envelope at the unloading strain; this simplification increases the numerical stability and computational efficiency. A full description of the Concrete07 material model, modifications to the Chang and Mander concrete model, and the effects of Concrete07 in improving the simulation capacity of OpenSees is given in Waugh (2007). A comparison of the cyclic behavior of Concrete07 and Concrete03 is shown in below; a magnified view of the tension region is shown separately. A confined concrete is used in this illustration so that the differences between the models behavior is more pronounced. Hysteretic_behavior_of_Concrete07.png Concrete07 gives larger residual displacements than Concrete03. Concrete07 also has a higher initial stiffness compared with Concrete03 and has a much slower softening post-peak in tension. Chang and Mander state that the abrupt loss of capacity shown in Concrete03 in tension is due to testing conditions and not representative of the true material behavior. Comp1.png Comp2.png Axial Load If the material model is used in a section that is going to be subjected to cyclic loading, problems can occur if there is no axial load on the section. The section should be subjected to axial load due to the self weight of the element. If the material is loaded into tension without any compression strain, and then reversed, the model will target -0.00002 strain if cracking has not occurred or 5% of the peak strain if cracking has occurred. The increased value after cracking is due to material being wedged in the open cracks. Users are encouraged to apply some axial load to the section equal to the self weight of the element or a small amount if the user does want minimal axial load. Less than 0.05% of f\u2019cAg is adequate to ensure a stable response. This will then be used instead of the default behavior described above. REFERENCES: Chang, G.A., and Mander, J.B., (1994) \u201cSeismic Energy Based Fatigue Damage Ananlysis of Bridge Columns:Part 1 - Evaluation of Seismic Capacity,\u201d NCEER Technical Report No. NCEER-94-0006 State University of New York, Buffalo, N.Y. Waugh, J., (2009) \u201cNonlinear analysis of T-shaped concrete walls subjected to multi-directional displacements\u201d, PhD Thesis, Iowa State University, IA. Code Developed by: Jonathan Waugh, Iowa State University and Sri Sritharan, Iowa State University","title":"Concrete07"},{"location":"contrib/modeling/uniaxialMaterial/94-ConcreteCM%20-%20Complete%20Concrete%20Model%20by%20Chang%20and%20Mander%20%281994%29/","text":"ConcreteCM Developed and Implemented by: Kristijan Kolozvari , California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial ConcreteCM (Kolozvari et al., 2015), which is a uniaxial hysteretic constitutive model for concrete developed by Chang and Mander (1994). This model is a refined, rule-based, generalized, and non-dimensional constitutive model that allows calibration of the monotonic and hysteretic material modeling parameters, and can simulate the hysteretic behavior of confined and unconfined, ordinary and high-strength concrete, in both cyclic compression and tension (Figure 1). The model addresses important behavioral features, such as continuous hysteretic behavior under cyclic compression and tension, progressive stiffness degradation associated with smooth unloading and reloading curves at increasing strain values, and gradual crack closure effects. Details of the model are available in the report by Chang and Mander (1994). Figure 1. Hysteretic Constitutive Model for Concrete by Chang and Mander (1994) The Chang and Mander (1994) model successfully generates continuous hysteretic stress-strain relationships with slope continuity for confined and unconfined concrete in both compression and tension. The compression envelope curve of the model is defined by the initial tangent slope, (E<sub class=\u201csubscript\u201d>c</sub>), the peak coordinate (<math></math>\u2018<sub class=\u201csubscript\u201d>c</sub>, f\u2019<sub class=\u201csubscript\u201d>c</sub>), a parameter (r<sub class=\u201csubscript\u201d>c</sub>) from Tsai\u2019s (1988) equation defining the shape of the envelope curve, and a parameter (<math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub>) to define normalized (with respect to \\(\\epsilon\\) \u2018<sub class=\u201csubscript\u201d>c</sub>) strain where the envelope curve starts following a straight line, until zero compressive stress is reached at the spalling strain, \\(\\epsilon\\) <sub class=\u201csubscript\u201d>sp</sub>. These parameters can be controlled based on specific experimental results for a refined calibration of the compression envelope (Figure 2). Chang and Mander (1994) proposed empirical relationships for parameters E<sub class=\u201csubscript\u201d>c</sub>, <math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>, and r<sub class=\u201csubscript\u201d>c</sub> for unconfined concrete with compressive strength f\u2019<sub class=\u201csubscript\u201d>c</sub>, based on review of previous research. Parameters f\u2019<sub class=\u201csubscript\u201d>c</sub>, <math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>, E<sub class=\u201csubscript\u201d>c</sub>, r<sub class=\u201csubscript\u201d>c</sub>, and <math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub> can also be calibrated to represent the stress-strain behavior of confined concrete in compression, to follow the constitutive relationships for confined concrete proposed by Mander et al (1988) or similar. Figure 2. Compression and Tension Envelope Curves The shape of the tension envelope curve in the model is the same as that of the compression envelope; however, the tension envelope curve is shifted to a new origin that is based on the unloading strain from the compression envelope (Figure 2). As well, the strain ductility experienced previously on the compression envelope is also reflected on the tension envelope. The parameters associated with the tension envelope curve include the tensile strength of concrete (f<sub class=\u201csubscript\u201d>t</sub>), the monotonic strain at tensile strength (<math></math><sub class=\u201csubscript\u201d>t</sub>), a parameter (r<sub class=\u201csubscript\u201d>t</sub>) from Tsai\u2019s (1988) equation defining the shape of the tension envelope curve, and a parameter (<math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub>) to define normalized (with respect to \\(\\epsilon\\) <sub class=\u201csubscript\u201d>t</sub>) strain where the tension envelope curve starts following a straight line, until zero tensile stress is reached at a strain of \\(\\epsilon\\) <sub class=\u201csubscript\u201d>crk</sub>. These parameters can also be controlled and calibrated based on specific experimental results or empirical relations proposed by other researchers (e.g., Belarbi and Hsu, 1994) to model the behavior of concrete in tension and the tension stiffening phenomenon. Concrete experiencing tension stiffening can be considered not to crack completely; that is, a large value for parameter <math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub> (e.g., 10000) can be defined. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Input Format: uniaxialMaterial ConcreteCM $mattag $fpcc $epcc $Ec $rc $xcrn $ft $et $rt $xcrp &lt;-GapClose $gap &gt; mattag Unique uniaxialMaterial tag fpcc Compressive strength (f\u2019<sub class=\u201csubscript\u201d>c</sub>) epcc Strain at compressive strength (<math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>) Ec Initial tangent modulus (E<sub class=\u201csubscript\u201d>c</sub>) rc Shape parameter in Tsai\u2019s equation defined for compression (r<sub class=\u201csubscript\u201d>c</sub>) xcrn Non-dimensional critical strain on compression envelope (<math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub>, where the envelope curve starts following a straight line) ft Tensile strength (f<sub class=\u201csubscript\u201d>t</sub>) et Strain at tensile strength (<math></math><sub class=\u201csubscript\u201d>t</sub>) rt Shape parameter in Tsai\u2019s equation defined for tension (r<sub class=\u201csubscript\u201d>t</sub>) xcrp Non-dimensional critical strain on tension envelope (<math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub>, where the envelope curve starts following a straight line - large value [e.g., 10000] recommended when tension stiffening is considered) <-GapClose $gap> gap = 0, less gradual gap closure (default); gap = 1, more gradual gap closure Example: uniaxialMaterial ConcreteCM 1 -6.2 -0.0021 4500 7 1.035 0.30 0.00008 1.2 10000 Example of hysteretic stress-strain history generated by the model code is illustrated in Figure 3. Figure 3. Concrete Stress-Strain Behavior Discussion: An optional input parameter gap is introduced in the ConcreteCM model implemented in OpenSees for providing the users with the opportunity to control the intensity of gap closure in the stress-strain behavior of concrete, which in-turn influences the level of pinching in the lateral load-displacement behavior of a RC wall. The original Chang and Mander (1994) model adopts a non-zero tangent stiffness at zero stress level upon unloading from the tension envelope, which is represented by gap = 1 in ConcreteCM . Using gap = 0 (default) produces less gradual gap closure, since it assumes zero tangent stiffness at zero stress level upon unloading from the tension envelope, and is suitable for most analyses. Figure 4 illustrates the effect of plastic stiffness upon unloading from tension envelope (E<sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>pl</sub>) on crack closure, i.e. use of more gradual ( gap = 1) or less gradual ( gap = 0) gap closure. The effect of parameter gap on predictions of flexural behavior of a RC wall is illustrated in Example 1 of MVLEM element. Figure 4. Effect of Plastic Stiffness upon Unloading from Tension Envelope (Epl+) on Crack Closure Constitutive stress-strain concrete behavior is also implemented in OpenSees in uniaxialMaterial Cocnrete07 . However, ConcreteCM incorporates sophisticated unloading/reloading rules defined originally by Chang and Mander (1994), as opposed to Concrete07 that adopts simplified hysteretic rules. Comparison between stress-strain response predicted using ConcreteCM and Concrete07 is shown in Figure 5. Figure 5. Comparison of ConcreteCM and Concrete07 References: Belarbi H. and Hsu T.C.C. (1994), \u201cConstitutive Laws of Concrete in Tension and Reinforcing Bars Stiffened by Concrete\u201d, ACI Structural Journal, V. 91, No. 4, pp. 465-474. Chang, G.A. and Mander, J.B. (1994), \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I - Evaluation of Seismic Capacity\u201d, NCEER Technical Report No. NCEER-94-0006, State University of New York, Buffalo. Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, PEER Report No. 2015/12 Mander J.B., Priestley M.J.N., and Park R. (1988). \u201cTheoretical Stress-Strain Model for Confined Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 8, pp. 1804-1826. Orakcal K.(2004), \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. Tsai W.T. (1988), \u201cUniaxial Compressional Stress-Strain Relation of Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 9, pp. 2133-2136.","title":"ConcreteCM\n"},{"location":"contrib/modeling/uniaxialMaterial/95-ConcreteD/","text":"ConcreteD This command is used to construct a concrete material based on the Chinese design code. uniaxialMaterial ConcreteD $matTag $fc $epsc $ft $epst $Ec $alphac $alphat &lt; $cesp &gt; &lt; $etap &gt; matTag integer tag identifying material fc concrete compressive strength * epsc concrete strain at corresponding to compressive strength* ft concrete tensile strength * epst concrete strain at corresponding to tensile strength* Ec concrete initial Elastic modulus* alphac compressive descending parameter* alphat tensile descending parameter* cesp plastic parameter, recommended values: 0.2~0.3* etap plastic parameter, recommended values: 1.0~1.3* NOTES : Concrete compressive strength and the corresponding strain should be input as negative values. The value \\(fc/\\) epsc and \\(ft/\\) epst should be smaller than $Ec. The default value for $cesp and $etap are 0.25 and 1.15, respectively. EXAMPLE : Example 1: Simulation of compressive test in Karson and Jirsa (1969). uniaxialMaterial ConcreteD 1 -27.6 -0.002 3 0.0001 35000 1.0 0.1 0.25 1.15 REFERENCES : Karsan, I. D., and Jirsa, J. O. (1969). \u201cBehavior of concrete under compressive loadings.\u201d Journal of the Structural Division, 95(12), 2535-2563. Ministry of Housing and Urban-Rural Development of the People\u2019s Republic of China. (2010). \u201cCode for design of concrete structures.\u201d GB50010-2010, Beijing, China. Ren, X. D. (2010). Multi-scale based stochastic damage constitutive theory for concrete. Doctoral dissertation, Tongji University, Shanghai. (in Chinese) Wu, J. Y., Li, J., and Faria, R. (2006). \u201cAn energy release rate-based plastic-damage model for concrete.\u201d International Journal of Solids and Structures, 43(3), 583-612. Zeng, S. J. (2012). Dynamic Experimental Research and Stochastic Damage Constitutive Model for Concrete. Doctoral dissertation, Tongji University, Shanghai. (in Chinese) Code Developed By : Zengyong Wan, Decheng Feng, Xiaodan Ren, Jie Li, College of Civil Engineering, Tongji University,","title":"ConcreteD\n"},{"location":"contrib/modeling/uniaxialMaterial/96-ConcretewBeta%20Material/","text":"ConcretewBeta \u2003\u2003This command is used to construct a uniaxial concrete material object that explicitly considers for the effect of normal (to the axis where the material object is used) strain to the behavior of the concrete in compression. The compressive stress-strain envelope, up to the peak compressive strength(unconfined or confined) is based on the Fujii concrete model (Hoshikuma et al. 1997). The material has two options regarding the strength degradation in tension: (a) tri-linear or (b) nonlinear [based on the tension stiffening relation of Stevens et al (1991)]. The softening behavior in compression is tri-linear. \u2003\u2003The model accounts for the effect of normal tensile strains on the concrete compressive behavior when used with the Truss2 or CorotTruss2 elements. See the Truss2 Element for description of how the normal strain is computed. The instantaneous stress is &beta; * f where f is the computed stress and &beta; is the compressive stress reduction factor which depends on the normal tensile strain, &epsilon;<sub>n</sub>. The relation between &epsilon;<sub>n</sub> and &beta; (see the Biaxial Behavior Section ) is tri-linear. Default values result in &beta; = 1. See the Examples Section for the use of this material model in truss models for planar RC walls and a beam-truss model for a non-planar wall loaded biaxially. thumb|upright=2.0|alt=RC C-shaped wall |Reinforced concrete wall with a C-shaped section subject to multi-axial loading, described in the examples . uniaxialMaterial ConcretewBeta $matTag $fpc $ec0 $fcint $ecint $fcres $ecres $ft $ftint $etint $ftres $etres &lt;-lambda $lambda &gt; &lt;-alpha $alpha &gt; &lt;-beta $bint $ebint $bres $ebres &gt; &lt;-M $M &gt; &lt;-E $Ec &gt; &lt;-conf $fcc $ecc &gt; matTag integer tag identifying material fpc peak unconfined concrete compressive strength* ec0 compressive strain corresponding to unconfined concrete compressive strength* $fcint, \\(ecint</strong></p></td> <td><p>intermediate stress-strain point for compression post-peak envelope*</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) fcres, \\(ecres</strong></p></td> <td><p>residual stress-strain point for compression post-peak envelope*</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">ftint</code></td> <td><p>tensile strength of concrete</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) ftint, \\(etint</strong></p></td> <td><p>intermediate stress-strain point for tension softening envelope</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) ftres, \\(etres</strong></p></td> <td><p>residual stress-strain point for tension softening envelope</p></td> </tr> <tr class=\"odd\"> <td></td> <td></td> </tr> <tr class=\"even\"> <td><p>Optional:</p></td> <td></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">lambda</code></td> <td><p>controls the path of unloading from compression strain (default 0.5)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">alpha</code></td> <td><p>controls the path of unloading from tensile strain (default 1)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) bint \\(ebint</strong></p></td> <td><p>intermediate &amp;beta;-strain point for for biaxial effect (default 1 and 0, respectively)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) bres \\(ebres</strong></p></td> <td><p>residual &amp;beta;-strain point for for biaxial effect (default 1 and 0, respectively)</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">M</code></td> <td><p>factor for Stevens et al. (1991) tension stiffening (default 0; see Note 2)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Ec</code></td> <td><p>initial stiffness (default 2*<code class=\"tcl-variable\">fpc</code>/<code class=\"tcl-variable\">ec0</code>; see Note 3)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) fcc \\(ecc</strong></p></td> <td><p>confined concrete peak compressive stress and corresponding strain* (see Eq. 1)</p></td> </tr> </tbody> </table> <p>NOTES:</p> <p>(1) *Parameters of concrete in compression should be specified as negative values.</p> <p>(2) For non-zero <code class=\"tcl-variable\">M</code>, the tension stiffening behavior will govern the post-peak tension envelope. Tri-linear tension softening parameters <strong>\\) ftint, $etint, $ftres, \\(etres</strong> will have no effect, but dummy values must be specified.</p> <p>(3) Value of <code class=\"tcl-variable\">Ec</code> must be between <code class=\"tcl-variable\">fpc</code>/<code class=\"tcl-variable\">ec0</code> and 2*<code class=\"tcl-variable\">fpc</code>/<code class=\"tcl-variable\">ec0</code> otherwise the closest value will be assigned.</p> <h2 id=\"implementation\">Implementation</h2> <dl> <dt></dt> <dd> <dl> <dt></dt> <dd> <a href=\"File:ConcwBeta_Eq1a.png\" title=\"wikilink\">thumb|upright=2.5|Equation 1.</a> </dd> <dd> <a href=\"File:ConcwBeta_Eq2a.png\" title=\"wikilink\">thumb|upright=1.8|Equation 2.</a> </dd> <dd> <a href=\"File:ConcwBeta_Eq3.png\" title=\"wikilink\">thumb|upright=1.8|Equation 3.</a> </dd> </dl> </dd> </dl> <h3 id=\"uniaxial_behavior\">Uniaxial Behavior</h3> <p>&emsp;&emsp;Figure 1 shows the compression and tension envelopes and the input parameters. The confined concrete envelope is defined by Equation 1 up to strain <code class=\"tcl-variable\">ecc</code>. The default values of <code class=\"tcl-variable\">fcc</code> and <strong>\\) $ecc are equal to fpc and ec0 , respectively, for an an unconfined behavior. Following this region, the compression envelope is tri-linear and passes through the points ( ecint , fcint ) and ( ecres , fcres ) in that order. For compression strains larger than ecres , the residual stress is fcres . \u2003\u2003For compression strain, the slope of the unloading branch is defined by Equation 2. After reaching zero stress, the material reloads linearly to the point with the largest tensile strain that occurred before. \u2003\u2003The tension envelope is linear until it reaches ft . If the tension stiffening parameter M is not specified, the tension envelope after reaching ft is tri-linear and passes through the points ( etint , ftint ) and ( etres , ftres ) in that order. For tensile strains larger than etres , the residual stress is fcres . \u2003\u2003If M is specified, the nonlinear tension stiffening behavior defined by Equation 3. It is suggested that M = (75 mm)* &rho;<sub>l</sub> / d<sub>b</sub> where &rho;<sub>l</sub> is the steel ratio in the direction parallel to the material direction and d<sub>b</sub> is the bar diameter in mm. \u2003\u2003The material unloads from tension strain using a slope of Ec . After reaching zero stress, the material targets the point (0, - alpha ft ). Thereafter, the material loads linearly to the point where the peak compressive strain previously occurred. In the case where the slope leading to this target point is less than that for the point (0, - alpha ft ), the material reloads directly to the point where peak compressive strain occurred. thumb|center|upright=4.0|alt=ConcretewBeta Figure 1 |Figure 1. ConcretewBeta material model behavior based on specified input parameters thumb|upright=2.0|alt=ConcretewBeta Figure 2 |Figure 2. Relation between the concrete compressive stress reduction factor, &beta;, and normal tensile strain, &epsilon;<sub>n</sub> Biaxial Behavior \u2003\u2003The ConcretewBeta material model accounts for the biaxial strain field on the concrete compressive behavior when used in conjunction with the Truss2 element. The Truss2 element computes the strain normal to the direction of the element (see Truss2 Element ). \u2003\u2003Figure 2 shows the relationship between concrete compressive stress reduction factor, &beta; , and the normal tensile strain, &epsilon;<sub>n</sub>. For compressive stresses, the instantaneous stress value computed by the material is &beta; * f<sub>c</sub> where f<sub>c</sub> is the compressive stress given by the uniaxial behavior described above. For positive (tensile) stress, &beta; = 1. For compressive stress, the &beta; -&epsilon;<sub>n</sub> relationship is tri-linear and passes through the points (0,1), ( ebint , bint ), and ( ebres , bres ) in that order. For normal tensile strains larger than ebres , &beta; = bres . Examples 20-story RC core wall buildings: conventional fixed-base ( video ), rocking wall ( video ), and base isolation with rocking wall ( video ) 1200px |alt=20-story core walls 5-story coupled wall specimen with diagonal tension failure, see: Video of the simulation 5story_samplePic.png See: Truss Model - Mestyanek (1986) Squat RC Wall and Video of the simulation Mestyanek_resultsPlot2.png See: Beam-truss Model - Beyer et al. (2008) RC Wall and Video of the simulation BeyerWall_fig2.png See: Truss Model - Massone Sanchez (2005) Squat RC Wall and Video of the simulation MassoneWall_displ1a.jpg References Lu, Y., Panagiotou, M, and Koutromanos, I. (2014). \u201cThree-dimensional beam-truss model for reinforced concrete walls and slabs subjected to cyclic static or dynamic loading.\u201d Report PEER 2014/18, Pacific Earthquake Engineering Research Center, University of California, Berkeley, Berkeley, CA. Lu, Y. and Panagiotou, M. (2014). \u201cEarthquake Damage Resistant Multistory Buildings at Near Fault Regions using Base Isolation and Rocking Core Walls.\u201d 1st Huixian International Forum on Earthquake Engineering for Young Researchers, August 16-19, Harbin, China. Lu, Y., and Panagiotou, M. (2014). \u201cThree-Dimensional Nonlinear Cyclic Beam-Truss Model for Reinforced Concrete Non-Planar Walls.\u201d Journal of Structural Engineering, 140 (3), DOI: 10.1061/(ASCE)ST.1943-541X.0000852. Panagiotou, M., Restrepo, J.I., Schoettler, M., and Kim G. (2012). \u201cNonlinear cyclic truss model for reinforced concrete walls.\u201d ACI Structural Journal, 109(2), 205-214. Beyer, K., Dazio, A., and Priestley, M. J. N.(2008). \u201cQuasi-Static Cyclic Tests of Two U-Shaped Reinforced Concrete Walls.\u201d Journal of Earthquake Engineering, 12:7, 1023-1053. Hoshikuma, J., Kawashima, K., Nagaya, K., and Taylor, A. W. (1997). \u201cStress-strain model for confined reinforced concrete in bridge piers.\u201d Journal of Structural Engineering, 123(5), 624-633. Massone Sanchez, L. M. (2006). \u201cRC Wall Shear\u2014Flexure Interaction: Analytical and Experimental Responses.\u201d PhD thesis, University of California, Los Angeles, Los Angeles, CA, 398 pp. Mestyanek, J. M. (1986). \u201cThe earthquake resistance of reinforced concrete structural walls of limited ductility.\u201d ME thesis. University of Canterbury. Stevens, N. J., Uzumeri, S. M., Collins, M. P., and Will, T. G. (1991). \u201cConstitutive model for reinforced concrete finite element analysis.\u201d ACI Structural Journal, 88(1), 49-59. Code Developed by: Yuan Lu, UC Berkeley and Marios Panagiotou, UC Berkeley","title":"ConcretewBeta\n"},{"location":"contrib/modeling/uniaxialMaterial/97-ConfinedConcrete01%20Material/","text":"ConfinedConcrete01 This command is used to construct an uniaxial material object of confined concrete in according to the work of Braga, Gigliotti and Laterza (2006). The confined concrete model (BGLmodel) has not tensile strength and degraded linear unloading/reloading stiffness as proposed by Karsan and Jirsa (1969). The BGL model accounts for confinement effects due to different arrangements of transverse reinforcement and/or external strengthening such as steel jackets or FRP wraps. The confinement effect along the column is described as well. In order to obtain th ecompressive envelope curve a non linear approach is performed at each increment of column axial strain.The sougth curve is obtained crossing different stress\u2010strain relationships, each of which corresponding to a different level of confinement. Currently, the Attard and Setunge\u2019s model is implemented in calculating each active curve of the confined concrete. IMPORTANT: the units to be used are MPa, mm. uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec ( < -epscu $epscu > OR < -gamma $gamma > ) ( < -nu $nu > OR < -varub > OR < -varnoub > ) $L1 ( $L2 ) ( $L3 ) $phis $S $fyh $Es0 $haRatio $mu $phiLon < -internal $phisi $Si $fyhi $Es0i $haRatioi $mui > < -wrap $cover $Am $Sw $fuil $Es0w > < -gravel > < -silica > < -tol $tol > < -maxNumIter $maxNumIter > < -epscuLimit $epscuLimit > < -stRatio $stRatio > matTag ( int ) integer tag identifying material secType ( str ) tag for the transverse reinforcement configuration. see image below. \u2018S1\u2019 square section with S1 type of transverse reinforcement with or without external FRP wrapping \u2018S2\u2019 square section with S2 type of transverse reinforcement with or without external FRP wrapping \u2018S3\u2019 square section with S3 type of transverse reinforcement with or without external FRP wrapping \u2018S4a\u2019 square section with S4a type of transverse reinforcement with or without external FRP wrapping \u2018S4b\u2019 square section with S4b type of transverse reinforcement with or without external FRP wrapping \u2018S5\u2019 square section with S5 type of transverse reinforcement with or without external FRP wrapping \u2018C\u2019 circular section with or without external FRP wrapping \u2018R\u2019 rectangular section with or without external FRP wrapping. fpc ( float ) unconfined cylindrical strength of concrete specimen. Ec ( float ) initial elastic modulus of unconfined concrete. epscu_type ( str ) Method to define confined concrete ultimate strain - -epscu then value is confined concrete ultimate strain, - -gamma then value is the ratio of the strength corresponding to ultimate strain to the peak strength of the confined concrete stress-strain curve. If gamma cannot be achieved in the range [0, epscuLimit] then epscuLimit (optional, default: 0.05) will be assumed as ultimate strain. epscu_val ( float ) Value for the definition of the concrete ultimate strain nu ( str ) or ( list ) Definition for Poisson\u2019s Ratio. - [\u2018-nu\u2019, <value of Poisson\u2019s ratio>] - \u2018-varub\u2019 Poisson\u2019s ratio is defined as a function of axial strain by means of the expression proposed by Braga et al. (2006) with the upper bound equal to 0.5 - \u2018-varnoub\u2019 Poisson\u2019s ratio is defined as a function of axial strain by means of the expression proposed by Braga et al. (2006) without any upper bound. L1 ( float ) length/diameter of square/circular core section measured respect to the hoop center line. L2 ( float ) additional dimensions when multiple hoops are being used. L3 ( float ) additional dimensions when multiple hoops are being used. phis ( float ) hoop diameter. If section arrangement has multiple hoops it refers to the external hoop. S ( float ) hoop spacing. fyh ( float ) yielding strength of the hoop steel. Es0 ( float ) elastic modulus of the hoop steel. haRatio ( float ) hardening ratio of the hoop steel. mu ( float ) ductility factor of the hoop steel. phiLon ( float ) diameter of longitudinal bars. internalArgs ( list ( float )) internalArgs= [phisi, Si, fyhi, Es0i, haRatioi, mui] optional parameters for defining the internal transverse reinforcement. If they are not specified they will be assumed equal to the external ones (for S2 , S3 , S4a , S4b and S5 typed). wrapArgs ( list ( float )) wrapArgs=[cover, Am, Sw, ful, Es0w] optional parameters required when section is strengthened with FRP wraps. cover cover thickness measured from the outer line of hoop. Am total area of FRP wraps (number of layers x wrap thickness x wrap width). Sw spacing of FRP wraps (if continuous wraps are used the spacing is equal to the wrap width). ful ultimate strength of FRP wraps. Es0w elastic modulus of FRP wraps. \u2018-gravel\u2019 ( str ) Unknown \u2018-silica\u2019 ( str ) Unknown tol ( float ) Unknown maxNumIter ( int ) Unknown epscuLimit ( float ) Unknown stRatio Unknown tag integer tag identifying material. secType tag for the transverse reinforcement configuration. See NOTE 1. fpc unconfined cylindrical strength of concrete specimen. Ec initial elastic modulus of unconfined concrete. <-epscu $epscu> OR <-gamm $gamma> confined concrete ultimate strain. See NOTE 2. <-nu \\(nu&gt; OR &lt;-varub&gt; OR &lt;-varnoub&gt;</strong></p></td> <td><p>Poisson's Ratio. See NOTE 3.</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">L1</code></p></td> <td><p>length/diameter of square/circular core section measured respect to the hoop center line.</p></td> </tr> <tr class=\"even\"> <td><p><strong>(\\) L2), ($L3) additional dimensions when multiple hoops are being used. See NOTE 4. phis hoop diameter. If section arrangement has multiple hoops it refers to the external hoop. S hoop spacing. fyh yielding strength of the hoop steel. Es0 elastic modulus of the hoop steel. haRatio hardening ratio of the hoop steel. mu ductility factor of the hoop steel. phiLon diameter of longitudinal bars. <-internal $phisi $Si $fyhi $Es0i $haRatioi $mui> optional parameters for defining the internal transverse reinforcement. If they are not specified they will be assumed equal to the external ones (for S2, S3, S4a, S4b and S5 typed). <-wrap $cover $Am $Sw $ful $Es0w> optional parameters required when section is strengthened with FRP wraps. See NOTE 5. NOTES: The following section types are available: S1 square section with S1 type of transverse reinforcement with or without external FRP wrapping; S2 square section with S2 type of transverse reinforcement with or without external FRP wrapping; S3 square section with S3 type of transverse reinforcement with or without external FRP wrapping; S4a square section with S4a type of transverse reinforcement with or without external FRP wrapping; S4b square section with S4b type of transverse reinforcement with or without external FRP wrapping; S5 square section with S5 type of transverse reinforcement with or without external FRP wrapping; C circular section with or without external FRP wrapping; R rectangular section with or without external FRP wrapping. SectionTypes.png The confined concrete ultimate strain is defined using -epscu or -gamma . When -gamma option is specified, gamma is the ratio of the strength corresponding to ultimate strain to the peak strength of the confined concrete stress-strain curve. If gamma cannot be achieved in the range [0, epscuLimit ] then epscuLimit (optional, default: 0.05) will be assumed as ultimate strain. Poisson\u2019s Ratio is specified by one of these 3 methods: a) providing nu using the -nu option. b) using the -varUB option in which Poisson\u2019s ratio is defined as a function of axial strain by means of the expression proposed by Braga et al. (2006) with the upper bound equal to 0.5; or c) using the -varNoUB option in which case Poisson\u2019s ratio is defined as a function of axial strain by means of the expression proposed by Braga et al. (2006) without any upper bound. L1 (2l), L2 (a) and L3 (b) are required when either S4a or S4b section types is used. L1 (2d) and L2 (2c) must be used for rectangular section. When external stengthening is used must be specified the following parameters: cover cover thickness measured from the outer line of hoop. Am total area of FRP wraps (number of layers x wrap thickness x wrap width). Sw spacing of FRP wraps (if continuous wraps are used the spacing is equal to the wrap width). ful ultimate strength of FRP wraps. Es0w elastic modulus of FRP wraps. Stresses and strains can be defined either as positive or as negative values. All commands are not case sensitive. Examples Square section reinforced by simple transverse hoop and by additional FRP wraps (Section S1) S1.png Section S1 # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu # $epscu $nu $L1 $phis $S $fyh $Es0 $haRatio $mu $phiLon -stRatio # $stRatio</li> uniaxialMaterial ConfinedConcrete01 1 S1 -30 .0 26081.0 -epscu -0 .03 \\ -varub 300.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 -stRatio 0.85 Section S1 strengthened by additional FRP wraps # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu # $epscu $nu $L1 $phis $S $fyh $Es0 $haRatio $mu phiLon $cover $Am $Sw # $ful $Es0w -stRatio $stRatio</li> uniaxialMaterial ConfinedConcrete01 1 S1 -30 .0 26081.0 -epscu -0 .03 \\ -varub 300.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 \\ -wrap 30.0 51.0 100.0 3900.0 230000.0 -stRatio 0.85 Square section reinforced by multiple transverse hoop and by additional FRP wraps (Section S4a) S4a.png Section S4a # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu # $epscu $nu $L1 $L2 $L3 $phis $S $fyh $Es0 $haRatio $mu $phiLon -stRatio # $stRatio</li> uniaxialMaterial ConfinedConcrete01 1 S4a -30 .0 26081.0 -epscu -0 .03 \\ -varUB 300.0 200.0 100.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 \\ -stRatio 0.85 Section S4a strengthened by additional FRP wraps # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu # $epscu $nu $L1 $L2 $L3 $phis $S $fyh $Es0 $haRatio $mu $phiLon $cover # $Am $Sw $ful $Es0w -stRatio $stRatio uniaxialMaterial ConfinedConcrete01 1 S4a -30 .0 26081.0 -epscu -0 .03 \\ -varUB 300.0 200.0 100.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 \\ -wrap 30.0 51.0 100.0 3900.0 230000.0 -stRatio 0.85 Rectangular section reinforced by simple transverse hoop and by additional FRP wraps (Section R) R.png Section R # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu $epscu $nu $L1 $L2 $phis $S $fyh $Es0 $haRatio $mu $phiLon -stRatio $stRatio uniaxialMaterial ConfinedConcrete01 1 R -30 .0 26081.0 -epscu -0 .03 \\ -varUB 500.0 300.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 \\ -stRatio 0.85 Section R strengthened by additional FRP wraps # uniaxialMaterial ConfinedConcrete01 $tag $secType $fpc $Ec -epscu \\ # $epscu $nu $L1 $L2 $phis $S $fyh $Es0 $haRatio $mu $phiLon $cover $Am \\ # $Sw $ful $Es0w -stRatio $stRatio uniaxialMaterial ConfinedConcrete01 1 R -30 .0 26081.0 -epscu -0 .03 \\ -varUB 500.0 300.0 10.0 100.0 300.0 206000.0 0.0 1000.0 16.0 -wrap 30.0 \\ 51.0 100.0 3900.0 230000.0 -stRatio 0.85 REFEERENCES: Attard, M. M., Setunge, S., 1996. \u201cStress-strain relationship of confined and unconfined concrete\u201d. Material Journal ACI, 93(5), 432-444 Braga, F., Gigliotti, R., Laterza, M., 2006. \u201cAnalytical stress-strain relationship for concrete confined by steel stirrups and/or FRP jackets\u201d. Journal of Structural Engineering ASCE, 132(9), 1402-1416. D\u2019Amato M., February 2009. \u201cAnalytical models for non linear analysis of RC structures: confined concrete and bond-slips of longitudinal bars\u201d. Doctoral Thesis. University of Basilicata, Potenza, Italy. D\u2019Amato, M., Braga, F., Gigliotti, R., Kunnath S., Laterza, M., 2012. \u201cA numerical general-purpose confinement model for non-linear analysis of R/C members\u201d. Computers and Structures Journal, Elsevier, Vol. 102-103, 64-75. Karsan, I. D., Jirsa, J. O., 1969. \u201cBehavior of concrete under compressive loadings\u201d, Journal of Structural Division ASCE, 95(12), 2543-2563. Code Developed by: Michele D\u2019Amato, University of Basilicata, Italy","title":"ConfinedConcrete01\n"},{"location":"contrib/pattern/timeSeries/pattern/369-Linear%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor applied is linearly proportional to the time in the domain, i.e. <math> \\lambda = f(t) = cFactor*t</math> timeSeries Linear $tag <-factor $cFactor> $tag unique tag among TimeSeries objects. $cFactor the linear factor (optional, default=1.0) Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/495-Path%20TimeSeries/","text":"This command is used to construct a Path TimeSeries object. The relationship between load factor and time is input by the user as a series of discrete points in the 2d space (load factor, time). The input points can come from a file or from a list in the script. When the time specified does not match any of the input points, linear interpolation is used between points. There are many ways to specify the load path: For a load path where the factors are specified in a tcl list with a constant time interval between points: timeSeries Path $tag -dt $dt -values {list_of_values} <-factor $cFactor> <-useLast> <-prependZero> <-startTime $tStart> For a load path where the factors are specified in a file for a constant time interval between points: timeSeries Path $tag -dt $dt -filePath $filePath <-factor $cFactor> <-useLast> <-prependZero> <-startTime $tStart> For a load path where the values are specified at non-constant time intervals: timeSeries Path $tag -time {list_of_times} -values {list_of_values} <-factor $cFactor> <-useLast> For a load path where both time and values are specified in a list included in the command timeSeries Path $tag -fileTime $fileTime -filePath $filePath <-factor $cFactor> <-useLast> $tag unique tag among TimeSeries objects. $filePath file containing the load factors values $fileTime file containing the time values for corresponding load factors $dT time interval between specified points. { list_of_times} time values in a tcl list { list_of_values} load factor values in a tcl list $cFactor optional, a factor to multiply load factors by (default = 1.0) -useLast optional, to use last value after the end of the series (default = 0.0) -prependZero optional, to prepend a zero value to the series of load factors (default = false). See NOTES. $tStart optional, to provide a start time for provided load factors (default = 0.0) NOTES: Linear interpolation between points. If the specified time is beyond last point (AND WATCH FOR NUMERICAL ROUNDOFF), 0.0 is returned. Specify -useLast to use the last data point instead of 0.0. The transient integration methods in OpenSees assume zero initial conditions. So it is important that any timeSeries that is being used in a transient analysis starts from zero (first data point in the timeSeries = 0.0). To guarantee that this is the case the optional parameter -prependZero can be specified to prepend a zero value to the provided timeSeries. EXAMPLE: timeSeries Path 1 -dT 0.02 -filePath A-ELC270.AT2 -factor $G timeSeries Path 2 -time {0.0 0.2 0.4 1.0} -values {0.0 1.0 2.0 0.0} Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/547-Pulse%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor is some pulse function of the time in the domain. '''timeSeries Pulse $tag $tStart $tEnd $period <-width $pulseWidth> <-shift $shift> <-factor $cFactor> $tag unique tag among TimeSeries objects $tStart starting time of non-zero load factor $tEnd ending time of non-zero load factor $period characteristic period of pulse $pulseWidth pulse width as a fraction of the period (optional, default = 0.5) $shift phase shift in seconds (optional, default = 0.0) $cFactor the load amplification factor (optional, default = 1.0) Code Developed by: <span style=\"color:blue\"> Andreas Schellenberg, University of California, Berkeley. </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/580-Rectangular%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor is constant for a specified period and 0 otherwise, i.e. <math> \\lambda = f(t) = \\begin{cases} \\text{cFactor}, &\\text{tStart} <= t <= \\text{tEnd}\\\\ \\text{0.0}, &\\text{otherwise}\\\\ \\end{cases} </math> timeSeries Rectangular $tag $tStart $tEnd <-factor $cFactor> $tag unique tag among TimeSeries objects. $tStart starting time of non-zero load factor $tEnd ending time of non-zero load factor $cFactor the load factor applied (optional, default=1.0) Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/711-Triangular%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor is some triangular function of the time in the domain. '''timeSeries Triangle $tag $tStart $tEnd $period <-shift $shift> <-factor $cFactor> $tag unique tag among TimeSeries objects $tStart starting time of non-zero load factor $tEnd ending time of non-zero load factor $period characteristic period of triangular wave $shift phase shift in seconds (optional, default = 0.0) $cFactor the load amplification factor (optional, default = 1.0) Code Developed by: <span style=\"color:blue\"> Andreas Schellenberg, University of California, Berkeley. </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/712-Trigonometric%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor is some trigonemtric function of the time in the domain <math> \\lambda = f(t) = \\begin{cases} \\text{cFactor} * sin (\\frac{2.0 \\Pi (t-tStart)}{\\text{period}} + \\text{shift}), &\\text{tStart} <= t <= \\text{tEnd}\\\\ \\text{0.0}, &\\text{otherwise}\\\\ \\end{cases} </math> timeSeries Trig $tag $tStart $tEnd $period <-factor $cFactor> <-shift $shift> $tag unique tag among TimeSeries objects. $tStart starting time of non-zero load factor $tEnd ending time of non-zero load factor $period characteristic period of sine wave $shift phase shift in radians (optional, default=0.0) $cFactor the load factor amplification factor (optional, default=1.0) Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"contrib/pattern/timeSeries/pattern/98-Constant%20TimeSeries/","text":"This command is used to construct a TimeSeries object in which the load factor applied remains constant and is independent of the time in the domain, i.e. <math> \\lambda = f(t) = C </math> timeSeries Constant $tag <-factor $cFactor> $tag unique tag among TimeSeries objects. $cFactor the load factor applied (optional, default=1.0) Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"contrib/recorders/159-Drift%20Recorder/","text":"Drift Recorder The Drift type records the displacement drift between two nodes. The drift is taken as the ratio between the prescribed relative displacement and the specified distance between the nodes. The command to create a drift recorder is: recorder Drift <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-time> -iNode $inode1 $inode2 \u2026 -jNode $jnode1 $jnode2 \u2026 -dof $dof1 $dof2 \u2026 -perpDirn $perpDirn1 \\(perpDirn2 ...</em></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">fileName</code></p></td> <td><p>name of file to which output is sent. Each line of the file contains the result for a committed state of the domain file output is either in xml format (-xml option), textual (-file option) or binary (-binary option)</p></td> </tr> <tr class=\"even\"> <td><p><strong>inetAddr</strong></p></td> <td><p>ip address, \"xx.xx.xx.xx\", of remote machine to which data is sent</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">port</code></p></td> <td><p>port on remote machine awaiting tcp</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">nSD</code></p></td> <td><p>number of significant digits (optional, default is 6)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-time</code></p></td> <td><p>using this option places domain time in first entry of each data line (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) inode1 \\(inode2 ...</strong></p></td> <td><p>tags of set of i nodes for which drift is being recorded</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) jnode1 \\(jnode2 ...</strong></p></td> <td><p>tags of set of j nodes for which drift is being recorded</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dof1 dof2 \u2026 set of nodal degrees of freedom for which drift is being recorded. Valid range is from 1 through ndf (the number of nodal degrees of freedom). $perpDirn1 $perpDirn2 \u2026 set of perpendicular global directions (1=X, 2=Y, 3=Z). This input is needed to calculate the length between the nodes whose drift is calculated. NOTES Only one of -file, -xml, -binary, -tcp will be used. If multiple specified last option is used. -tcp option only available for version 2.2.1 and higher. Does not work in OpenSeesSP. EXAMPLE recorder Drift -file drift.out -time -iNode 1 2 -jNode 3 4 -dof 1 -perpDirn 2 Code Developed by: fmk","title":"Drift Recorder\n"},{"location":"contrib/recorders/205-ElementEnvelopeRecorder/","text":"ElementEnvelopeRecorder The Envelope Element recorder type records the response of a number of elements at every converged step. The response recorded is element-dependent and also depends on the arguments which are passed to the setResponse() element method. When the object is terminated, through the use of a wipe , exit , or remove the object will output the min, max and absolute max values on 3 seperate lines of the output file for each quantity. recorder EnvelopeElement <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision \\(nSD&gt; &lt;-time&gt; &lt;-closeOnWrite&gt; &lt;-ele (\\) ele1 $ele2 \u2026)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 \\(arg2 ...</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">fileName</code></p></td> <td><p>name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">nSD</code></p></td> <td><p>number of significant digits (optional, default is 6)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-time</code></p></td> <td><p>(optional using this option places domain time in first entry of each data line, default is to have time ommitted)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-flag\">-closeOnWrite</code></p></td> <td><p>optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) ele1 \\(ele2 ..</strong></p></td> <td><p>tags of elements whose response is being recorded -- selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) startEle \\(endEle ..</strong></p></td> <td><p>tag for start and end elements whose response is being recorded -- range of selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">regTag</code></p></td> <td><p>previously-defined tag of region of elements whose response is being recorded -- region of elements in domain (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) arg1 $arg2 \u2026 arguments which are passed to the setResponse() element method RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTE: The setResponse() element method is dependent on the element type, and is described with the Element Command . EXAMPLE Examples recorder Element -file Element1.out -time -ele 1 3 section 1 fiber 0.10 0.10 stressStrain Code Developed by: fmk","title":"ElementEnvelopeRecorder\n"},{"location":"contrib/recorders/208-Element%20Recorder/","text":"Element Recorder The Element recorder type records the response of a number of elements at every converged step. The response recorded is element-dependent and also depends on the arguments which are passed to the setResponse() element method. The command to create an element recorder is: recorder Element <-file $fileName> <-xml $fileName> <-binary $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-dT \\(deltaT&gt; &lt;-ele (\\) ele1 $ele2 \u2026)> <-eleRange $startEle $endEle> <-region $regTag> $arg1 $arg2 \u2026 fileName name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option) nSD number of significant digits (optional, default is 6) -time (optional using this option places domain time in first entry of each data line, default is to have time ommitted) -closeOnWrite optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis. deltaT time interval for recording. will record when next step is \\(deltaT greater than last recorder step. (optional, default: records at every time step)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) ele1 \\(ele2 ..</strong></p></td> <td><p>tags of elements whose response is being recorded -- selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) startEle \\(endEle ..</strong></p></td> <td><p>tag for start and end elements whose response is being recorded -- range of selected elements in domain (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">regTag</code></td> <td><p>previously-defined tag of region of elements whose response is being recorded -- region of elements in domain (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) arg1 $arg2 \u2026 arguments which are passed to the setResponse() element method RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTE: The setResponse() element method is dependent on the element type, and is described with the Element Command . EXAMPLE Examples recorder Element -file Element1.out -time -ele 1 3 section 1 fiber 0.10 0.10 stressStrain Code Developed by: fmk","title":"Element Recorder\n"},{"location":"contrib/recorders/430-Node%20Envelope%20Recorder/","text":"Node Envelope Recorder The EnvelopeNode recorder type records the min, max and absolute max of a number of nodal response quantaties. The command to create a node envelope recorder is: recorder EnvelopeNode <-file $fileName> <-xml $fileName> <-precision $nSD> <-time> <-closeOnWrite> <-timeSeries $tsTag> <-node $node1 $node2 \u2026> <-nodeRange $startNode $endNode> <-region \\(regionTag&gt; -dof (\\) dof1 $dof2 \u2026) \\(respType</em>'</p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">fileName</code></p></td> <td><p>name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">nSD</code></p></td> <td><p>number of significant digits (optional, default is 6)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-flag\">-time</code></p></td> <td><p>(optional using this option places domain time in first entry of each data line, default is to have time ommitted)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-flag\">-closeOnWrite</code></p></td> <td><p>optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis.</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">tsTag</code></p></td> <td><p>the tag of a previously constructed TimeSeries, results from node at each time step are added to load factor from series</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) node1 \\(node2 ..</strong></p></td> <td><p>tags of nodes whose response is being recorded (optional, default: omitted)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) startNode \\(endNode ..</strong></p></td> <td><p>tag for start and end nodes whose response is being recorded (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">regionTag</code></p></td> <td><p>a region tag; to specify all nodes in the previously defined region. (optional)</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) dof1 dof2 \u2026 the specified dof at the nodes whose response is requested. respType a string indicating response required. Response types are given in table below. disp displacement* vel velocity* accel acceleration* incrDisp incremental displacement \u201ceigen i\u201d eigenvector for mode i reaction nodal reaction RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. EXAMPLE recorder EnvelopeNode -file nodesD.out -time -node 1 2 3 4 -dof 1 2 disp recorder EnvelopeNode -file nodesA.out -time -timeSeries 1 -node 1 2 3 4 -dof 1 accel Code Developed by: fmk","title":"Node Envelope Recorder\n"},{"location":"contrib/recorders/431-Node%20Recorder/","text":"Node Recorder The Node recorder type records the response of a number of nodes at every converged step. The command to create a node recorder is: recorder Node <-file $fileName> <-xml $fileName> <-binary $fileName> <-tcp $inetAddress $port> <-precision $nSD> <-timeSeries $tsTag> <-time> <-dT $deltaT> <-closeOnWrite> <-node $node1 $node2 \u2026> <-nodeRange $startNode $endNode> <-region \\(regionTag&gt; -dof (\\) dof1 $dof2 \u2026) $respType \u2019 fileName name of file to which output is sent. file output is either in xml format (-xml option), textual (-file option) or binary (-binary option) inetAddr ip address, \u201cxx.xx.xx.xx\u201d, of remote machine to which data is sent port port on remote machine awaiting tcp nSD number of significant digits (optional, default is 6) -time optional, using this option places domain time in first entry of each data line, default is to have time ommitted -closeOnWrite optional. using this option will instruct the recorder to invoke a close on the data handler after every timestep. If this is a file it will close the file on every step and then re-open it for the next step. Note, this greatly slows the execution time, but is useful if you need to monitor the data during the analysis. deltaT time interval for recording. will record when next step is \\(deltaT greater than last recorder step. (optional, default: records at every time step)</p></td> </tr> <tr class=\"even\"> <td><p><code class=\"parameter-table-variable\">tsTag</code></p></td> <td><p>the tag of a previously constructed TimeSeries, results from node at each time step are added to load factor from series</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) node1 \\(node2 ..</strong></p></td> <td><p>tags of nodes whose response is being recorded (optional, default: omitted)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) startNode \\(endNode ..</strong></p></td> <td><p>tag for start and end nodes whose response is being recorded (optional, default: omitted)</p></td> </tr> <tr class=\"odd\"> <td><p><code class=\"parameter-table-variable\">regionTag</code></p></td> <td><p>a region tag; to specify all nodes in the previously defined region. (optional)</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) dof1 dof2 \u2026 the specified dof at the nodes whose response is requested. respType a string indicating response required. Response types are given in table below. disp displacement* vel velocity* accel acceleration* incrDisp incremental displacement \u201ceigen i\u201d eigenvector for mode i reaction nodal reaction rayleighForces damping forces RETURNS >0 an integer tag that can be used as a handle on the recorder for the remove recorder commmand. -1 recorder command failed if integer -1 returned. NOTES Only one of -file, -xml, -binary, -tcp will be used. If multiple specified last option is used. -tcp option only available for version 2.2.1 and higher. In case you want to remove a recorder you need to know the tag for that recorder. Here is an example on how to get the tag of a recorder: set tagRc [recorder Node -file nodesD.out -time -node 1 2 3 4 -dof 1 2 disp] EXAMPLES recorder Node -file nodesD.out -time -node 1 2 3 4 -dof 1 2 disp; Generates output file nodesD.out that contains relative displacements in x and y direction at nodes 1, 2, 3, and 4. The output file will contain 9 columns (time, disp. in x at node 1, disp. in y at node 1, \u2026 , disp. in y at node 4)) recorder Node -file nodesA.out -timeSeries 1 -time -node 1 2 3 4 -dof 1 accel; For a UniformExcitation analysis, this command generates output file nodesA.out that contains absolute accelerations (ground motion acceleration + relative acceleration) in x direction for nodes 1, 2, 3, and 4. NOTE that if no TimeSeries is provided and a uniform excitation analysis is performed, the relative accelerations are recorded. Code Developed by: fmk","title":"Node Recorder\n"},{"location":"contrib/recorders/517-Plot%20Recorder/","text":"Plot Recorder This recorder type opens a graphical window for the plotting of the contents of the prescribed file. The prescribed file can be the output of an other recorder. recorder plot $fileName $windowTitle $xLoc $yLoc $xPixels $yPixels -columns $xCol0 $yCol0 &lt;-columns $xCol1 $yCol1 &gt; ... fileName name of file from which data will be read windowTitle title of window to be opened $xLoc \\(yLoc</strong></p></td> <td><p>\\) xLoc, \\(yLoc specifies location on screen of top left corner of window</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) xPixels \\(yPixels</strong></p></td> <td><p>\\) xPixels, \\(yPixels specifies width and height in pixels of window to open</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) xCol $yCol \u2026 integers specifying which columns to plot for x and y axis. NOTES At least one set of columns must be specified, additional ones may be specified. the only way to save the image is a screen capture. EXAMPLE Examples recorder Plot node.out \u201cNodal Displacement\u201d 10 10 400 400 -columns 1 2 Code Developed by: fmk","title":"Plot Recorder\n"},{"location":"contrib/reliability/275-General%20Commands/","text":"General Commands :;<h2> reliability Command </h2> This command creates the reliability domain in which the sensitivity, reliability and optimization components are kept. This reliability domain is parallel to the finite element (FE) domain in OpenSees. Currently, the commands for stand-alone sensitivity :analysis (e.g., sensitivityIntegrator, sensitivityAlgorithm) are set in the reliability domain only and, thus, the \u2018reliability\u2019 reliability <h2> parameter Command </h2> In DDM-based FE response sensitivity analysis, the sensitivity parameters can be material, geometry or discrete loading parameters. Each parameter should be defined as: parameter $tag &lt;specific object arguments&gt; <h2> addToParameter Command </h2> In case that more objects (e.g., element, section) are mapped to an existing parameter, the following command can be used to relate these additional objects to the specific parameter: addToParameter $tag &lt;specific object arguments&gt; <h2> updateParameter Command </h2> Once the parameters in FE model are defined, their value can be updated: updateParameter $tag $newValue <h2> sensitivityIntegrator Command </h2> For static analysis, the only option currently available is the following, which must be defined before the \u2018analysis\u2019 command. sensitivityIntegrator -static For the dynamic case, currently only the Newmark algorithm is available. Two command need to be used together: integrator NewmarkWithSensitivity $gamma $beta sensitivityIntegrator -definedAbove Currently, \u2018-definedAbove\u2019 is the only option available in OpenSees. This means that the same integration scheme (i.e., \u2018NewmarkWithSensitivity\u2019) is used to perform both response and response sensitivity analysis. <h2> sensitivityAlgorithm Command </h2> The most general command is the following, which computes the response sensitivity at each time/load step, after the response has converged. sensitivityAlgorithm -computeAtEachStep In those cases in which the sensitivity computation does not need to be performed at each step (e.g., for linear elastic systems : subjected to static pushover analysis), the sensitivity computation may be performed only at the time/load steps required by user: sensitivityAlgorithm -computeByCommand However, before using the \u2018-computeByCommand\u2019 option, it is the user\u2019s responsibility to make sure that the response sensitivities computation is not needed at each time/load step. For example, in case of incremental nonlinear FE analysis or dynamic analysis, using the \u2018-computeByCommand\u2019 option will produce wrong sensitivity results. <h2> recorder Commands </h2> To record the nodal response and response sensitivity, the most commonly used format is: recorder Node -file disp29.out -time -node 29 -dof 1 &lt;-precision 16 &gt; disp recorder Node -file ddm29G1.out -time -node 29 -dof 1 \u201csensitivity 1\u201d recorder Node -file ddm29G1.out -time -node 29 -dof 1 \u201cvelSensitivity 1\u201d recorder Node -file ddm29G1.out -time -node 29 -dof 1 \"accSensitivity 1\" The above \u2018recorder\u2019 commands (extended for recording response sensitivities) save into files (with the file name defined after : the command \u2018-file\u2019) the responses and response sensitivities of the node 29 along the first degree of freedom (dof) direction. : Response quantities can be \u2018disp\u2019 (displacements), \u2018vel\u2019 (velocities) and \u2018acc\u2019 (accelerations). Response sensitivities are denoted by a string in double quotes and containing the response quantity identifier (i.e., \u201csensitivity\u201d for displacements, \u201cvelSensitivity\u201d for velocities and \u201caccSensitivity\u201d for accelerations) and the sensitivity parameter specified by the parameter : tag ( in this example the tag is 1). The command \u2018-precision\u2019 is optional, and allows users to change the number of digits used to record into file the response and/or response sensitivities. This command is particularly useful when the finite difference method is used to verify/validate : DDM-based FE response sensitivities, since high accuracy in the results may be needed. The user may also get responses and response sensitivities directly using the following Tcl commands: nodeDisp 29 1 nodeVel 29 1 nodeAccel 29 1 sensNodeDisp 29 1 2 sensNodeVel 29 1 2 sensNodeAccel 29 1 2 These commands return the responses of the node 29 along the first dof, and their response sensitivities with respect to the parameter with tag 2","title":"General Commands\n"},{"location":"contrib/studies/336-Infill%20Wall%20Model%20With%20In-Plane%2C%20Out-of-Plane%20Interaction%20and%20Element%20Removal%20During%20Simulation/","text":"Infill Wall Model With In-Plane, Out-of-Plane Interaction and Element Removal During Simulation This article is still under development. M. Selim Gunay and Khalid M. Mosalam, University of California, Berkeley This article describes the commands for modeling an infill wall element which considers in-plane and out-of-plane interaction and for removal of the element during nonlinear time history simulation in OpenSees. In addition, the infill wall model and element removal algorithm are briefly described. Interested readers can refer to the mentioned references for more information. Questions or comments can be directed to selimgunay [at] berkeley . edu or mosalam [at] ce . berkeley . edu Modeling of the Infill Wall The described infill wall model is a model which considers the interaction of in-plane (IP) and out-of-plane (OOP) effects. Modeling of the infill wall is performed by using the available OpenSees materials, sections, elements and tcl commands. The infill wall model is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass (Figure 1). The inelastic fiber section assigned to the ends of the elements connected to the midspan node is discretized as explained in the following paragraph. Elastic sections with very small moment of inertia (to simulate moment release) are assigned to the ends attached to the surrounding frame. The hinge length near the midspan node is selected as short as possible in order to produce a relatively sharp yield point for the element, while at the same time providing a numerically stable solution. 1/10 of the total length of the diagonal is a suitable value for the total hinge length (sum of the lengths of the hinges on both sides of the node). The hinge length on the other end can be selected as small as possible without losing numerical stability. Figure1.jpg Discretization of Inelastic Fiber Section and Calculation of OOP mass The inelastic fiber section of the beamWithhinges element is modeled by strategically locating a collection of nonlinear fiber elements[1,2]. The fibers are located along a line in the OOP direction (Z-direction in Figure 1). By this way, the beam-column element acts as a truss element and a flexural element in the IP and OOP directions, respectively. The discretization of the cross section is shown in Figure 2a. In this figure, the vector used to define the local-coordinate system in OpenSees, \u201cvecxz\u201d, is (0 0 -1) corresponding to the global axes shown in Figure 1. Each fiber is defined with the area <math>,</math>, z-coordinate \\(\\mathrm{z_i}\\,\\) and a bilinear stress-strain relationship. The strain hardening slope is chosen to be very small, hence the yield stress \\(\\mathrm{f_{yi}}\\,\\) and the yield strain \\(\\mathrm{{\\epsilon}_{yi}}\\,\\) define the stress-strain relationship of the \\(\\mathrm{i_{th}}\\,\\) fiber. Since only one diagonal is utilized in the model, it has both tension and compression strengths. Therefore, the fibers are considered to have the same absolute value for the tensile and compression yield strengths. Figure2-1.jpg The parameters defining a fiber section (<math>,</math>, <math>,</math>, <math>,</math>, and <math>,</math>) are set such that the intended strength interaction (Figure 2b) and the IP axial and OOP bending stiffness values of the diagonal infill wall element are properly simulated. In the current formulation, FEMA-356[3] or ASCE-41[4] equations are used for calculating the axial stiffness and unidirectional strength in the IP direction. However, any other relationships that the user considers as suitable can also be employed. The OOP mass, stiffness and unidirectional bending strength are calculated such that the model has the same natural frequency as the original infill wall, it should produce the same support reactions where it is attached to the surrounding frame for a given support motion (story acceleration), and it should exhibit initial yielding at the same level of support motion that causes the original infill wall to yield. Discretization of the inelastic fiber section is explained below. In the explanation, equations of FEMA-356 are referred to rather than ASCE-41 equations, since FEMA-356 document is accessible from FEMA website. However, Equations of FEMA-356 and ASCE-41 are very similar and ASCE-41 equations may be replaced with FEMA-356 equations. Calculate the IP axial force capacity of the equivalent diagonal element (<math>,</math>), Equation 1. Eq1.jpg In Equation 1, \\(\\mathrm{\\Theta}\\,\\) is the angle of the equivalent diagonal element with the horizontal. \\(\\mathrm{Q_{CE}}\\,\\) is the expected infill shear strength, \\(\\mathrm{A_{ni}}\\,\\) is the area of net mortared/grouted section across infill panel and \\(\\mathrm{f_{ive}}\\,\\) is the expected shear strength of masonry infill. Second part of Equation 1 corresponds to Equation 7-15 in FEMA-356. Calculate the OOP moment capacity under zero IP axial force (MOOP0) for the equivalent diagonal element, Equation 2. Eq2.jpg In Equation 2, \\(\\mathrm{L_{diag}}\\,\\) is the length of the equivalent diagonal element and <math>,</math>, \\(\\mathrm{L_{inf}}\\,\\) and \\(\\mathrm{t_{inf}}\\,\\) are the height, length and thickness of the infill wall panel, respectively. \\(\\mathrm{q_{in}}\\,\\) is the OOP strength of the infill wall panel, \\(\\mathrm{f_{m}}\\,\\) is the expected value of masonry compressive strength and \\(\\mathrm{{\\lambda}_2}\\,\\) is a slenderness parameter defined in Table 7-11 of FEMA-356. Equation 2c corresponds to Equation 7-21 in FEMA-356. Equation 2 is based on the assumption that the yield moment in the equivalent diagonal element is reached when the support spectral acceleration equals the yield spectral acceleration of the original infill wall. Derivation of Equation 2 can be found in Appendix D of reference [1]. Construct the IP axial and OOP bending strength interaction curve accepted as a 3/2-power curve[1, 2] represented with Equation 3. The 3/2 power curve is based on the OOP and IP capacity points obtained from the analyses of a nonlinear finite element (FE) model of an infill panel[3]. In Equation 3, \\(\\mathrm{P_{IP}}\\,\\) is the IP axial strength in the presence of OOP force, <math>,</math>, which is calculated in step 1, is the IP axial strength without OOP force, \\(\\mathrm{M_{OOP}}\\,\\) is the OOP bending strength in the presence of IP force, and <math>,</math>, which is calculated in step 2, is the OOP bending strength without IP force. Eq3.jpg It should be noted that steps 1, 2 and 3 consist of the construction of the IP axial and OOP bending strength interaction based on the explained methodology. The user is free to use any other interaction curve which might be based on experimental data or FE simulations, as long as the chosen interaction curve is not concave, since the equations used for calculation of the fiber locations are not suitable for concave diagrams. However, this limitation is not considered to be serious, since a concave interaction diagram is rarely encountered. The interaction diagram should be discretized at N pairs (N pairs including the (<math>,</math>, 0) and (0, <math>,</math>) pairs), where 2(N-1) is the total number of fibers in the section (N-1 fibers are placed at one side of the y-axis and N-1 fibers on the other side symmetrically as shown in Figure 2). Typically, 10 fibers along the section could be sufficient which corresponds to 6 data pairs on the interaction diagram. Calculate the equivalent strut width \u201ca\u201d using Equation 4, which corresponds to Equation 7-14 in FEMA-356. Then, cross-sectional area of the diagonal element becomes tinf\u00d7a. The user is free to use any other relationship to calculate the area of the equivalent diagonal element or the equivalent width. Eq4.jpg where \\(\\mathrm{h_{col}}\\,\\) is the height of the column of the surrounding frame, \\(\\mathrm{E_{m}}\\,\\) and \\(\\mathrm{E_{f}}\\,\\) are the elasticity moduli of the infill and frame materials, respectively. Equation 4 is unit dependent where force is in kips and displacement is in inches. Calculate the equivalent moment of inertia of the diagonal element in the OOP direction, \\(\\mathrm{I_{eq}}\\,\\) . Considering that the model has the same natural frequency as the original infill wall and it should produce the same support reactions where it is attached to the frame for a given story acceleration, \\(\\mathrm{I_{eq}}\\,\\) is calculated with Equation 5. Eq5.jpg where \\(\\mathrm{\\kappa}\\,\\) is a factor which represents the reduction in moment of inertia due to cracking. Calculate the distance of the \\(\\mathrm{i^{th}}\\,\\) fiber to the centroid (<math>,</math>), Equation 6. Eq6.jpg where M and P represent the OOP bending moment and IP axial force capacities in the interaction diagram (Figure 3). i=1 corresponds to the fiber farthest from the centroid and the point of pure compression on the P\u2212M diagram. The index i increases sequentially in the section as progressing inward to the y-axis and in the interaction diagram in the direction of decreasing P as shown in Figure 3. It should be noted that the coordinates of the points (<math>,</math>) on one side of the y axis (positive z) are calculated with Equation 6 but coordinates of the points on the other side are calculated as the negative of the values calculated with Equation 6. Equation 6 is obtained from the consideration of the changes in the plastic axial force and moment that occur as the plastic neutral axis is \u201cswept through\u201d the section. Derivation of this equation is explained in reference [2]. Figure3.jpg Area of each fiber is calculated such that the sum of the areas of the fibers is equal to the cross sectional area of the equivalent diagonal element (<math>,</math>\u00d7a) calculated in step 4 and sum of the second moment of the fibers is equal to the equivalent moment of inertia in OOP direction (<math>,</math>) calculated in step 5. Eq7a.jpg In order to have a unique solution of Equation 7a, the relationship between \\(\\mathrm{A_{i}}\\,\\) and \\(\\mathrm{z_{i}}\\,\\) is assumed to be represented with Equation 7b. Eq7b.jpg since \\(\\mathrm{z_{i}}\\,\\) values are known from Equation 6, \\(\\mathrm{\\gamma}\\,\\) and \\(\\mathrm{\\eta}\\,\\) can be determined from Equation Then, the area of each fiber is calculated using Equation 7b. Calculate yield stress and yield strain for each fiber, Equations 8 and 9. Eq89-2.jpg Equation 8b is obtained from the consideration of the change in the plastic axial force that occurs as the plastic neutral axis (PNA in Figure 2) is \u201cswept through\u201d the section. Derivation of this equation is explained in reference [2]. In addition to the fibers along z direction, a dummy fiber (a fiber with a very small area) should be located at an arbitrary point along the y-axis (Figure 2) to supply a very small IP moment of inertia. The inelastic fiber section is discretized following the above nine steps. Cross sectional area obtained in step 4 and moment of inertia in OOP direction obtained in step 5 are used as area and moment of inertia about the local axis corresponding to the OOP direction for the interior elastic part of the beamWithhinges element. A very small number is input for the moment of inertia about the other sectional local axis. Calculation of OOP Mass at the Midspan Node As stated previously, the described infill wall element is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass. This mass at the midspan node is calculated as 0.81M, where M is the total mass of the infill wall panel. This value is the first mode effective mass of the infill wall panel when it is defined as a beam spanning vertically with distributed mass and with simple supports at the ends. Theoretical derivation can be found in reference [1]. Implementation of Infill Wall Removal in OpenSees A progressive collapse algorithm is developed [4-6], the different applications of which can be found in references [7-10]. This algorithm is developed using element removal based on dynamic equilibrium and resulting transient change in system kinematics, the underlying theory of which can be found in the above references. The progressive collapse algorithm is implemented for automated removal of collapsed elements during an ongoing simulation (Figure 4). The implementation is carried out as a new OpenSees module, designed so that it is called by the main analysis module after each converged load step to check each element for possible violation of its respective removal criteria. A violation of any pre-defined removal criterion triggers the activation of the element removal algorithm on the violating element before returning to the main analysis module. Activation of the element removal algorithm includes updating nodal masses, checking if the removal of the collapsed element results in leaving behind dangling nodes or floating elements, which must be removed as well (Figure 5), and removing all associated element and nodal forces, imposed displacements, and constraints. Figure4.jpg Figure5.jpg Other than the aforementioned infill wall element, removal criteria are defined for force- and displacement-based distributed plasticity fiber elements and lumped plasticity beam-column elements with fiber-discretized plastic hinges. These criteria are based on material-level damage indices for a newly developed confined RC cross-section model [11-13]. The removal of the latter elements are not considered in the current version of OpenSees. However, they will be available in near future. Current version considers only the removal of the infill wall model described in the first section. Implementation of the removal of the elements representing the aforementioned infill wall analytical model in the progressive collapse algorithm is performed through defining a removal criterion for the beam-column elements of this model. This criterion is based on the interaction between the IP and OOP displacements. IP displacement is the relative horizontal displacement between the top and bottom nodes of the diagonal element. OOP displacement is that of the middle node (where the OOP mass is attached) with respect to the chord which connects the top and bottom nodes. The user is free to choose any interaction relationship between IP and OOP displacements. In the recent studies conducted with the introduced infill wall element [14, 15], same equation used for the strength interaction is considered for the displacement interaction, where IP and OOP displacement capacities in the presence of zero load in the other direction are obtained from FEMA-356 for collapse prevention level. During the nonlinear time history simulation, when the mentioned combination of displacements from the analysis exceeds the interaction curve (Figure 6), the two beam-column elements and the middle node, representing the unreinforced masonry infill wall, are removed. The procedure for the removal of an infill wall is presented in Figure 7. Figure6.jpg Figure7-1.jpg New Command in OpenSees Interpreter The only new tcl command in the OpenSees interpreter with respect to the infill wall removal is the collapse recorder. Three collapse recorders (the syntax of which are indicated below) are needed for the consideration of the removal of an infill wall. These collapse recorders should be defined individually for each infill wall that the user would like to be considered for removal. <pre style=\u201cbackground:yellow;color:black;width:1140px\u201d> recorder Collapse -ele \\(ele1 -time -crit INFILLWALL -\\) file $filename -file_infill $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele2 -time -crit INFILLWALL -file_infill $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele1 $ele2 -node \\(nodemid &lt;/pre&gt;</p> <p>\\) ele1, $ele2, $nodebot, $nodemid, and $nodetop are shown in Figure 8. Element objects store the identities of their associated Node objects in the data structures of OpenSees. Therefore, it might seem that node inputs are unnecessary. However, when there are shear springs in the model, $nodetop and $nodebot should be the nodes of the springs which connect to the beams, since the shear spring deformation contributes to the IP displacement of the infill wall. These nodes are not the nodes of the diagonal element. Therefore, it is necessary to input these nodes. $filename is the file name for element removal log. Only one log file is constructed for all collapse recorder commands (i.e. for all removals). The first file name input to a collapse recorder command is used and any subsequent file names are ignored. $filenameinf is the file used to input the displacement interaction curve. Two columns of data are input in this file where only positive values are input. First column is the OOP displacement in ascending order and second column is the corresponding IP displacement. Full interaction should be defined. In other words, first value of OOP displacement and last value of IP displacement should be zero. -crit INFILLWALL is used to state that the removal is for the infill wall, because there will be options for removal of other elements in the next versions of OpenSees as mentioned previously. $globgrav is the global axis of the model in the direction of gravity. 1, 2 and 3 should be input for X, Y and Z axes, respectively. For example, it is equal to 2 in Figure 1. Figure8.jpg References Kadysiewski, S. and Mosalam, K.M. (2009), \u201cModeling of Unreinforced Masonry Infill Walls Considering In-plane and Out-of-Plane Interaction\u201d, Pacific Earthquake Engineering Research Center , PEER 2008/102. Kadysiewski, S. and Mosalam, K.M. (2009), \u201cModelling of Unreinforced Masonry Infill Walls Considering In-Plane and Out-of-Plane Interaction\u201d, Proceedings of the 11th Canadian Masonry Symposium , Toronto, Ontario, May 31-June 6. Hashemi, S.A. and Mosalam, K.M. (2007), \u201cSeismic Evaluation of Reinforced Concrete Buildings Including Effects of Infill Masonry Walls\u201d, Pacific Earthquake Engineering Research Center , PEER 2007/100. Talaat, M. and Mosalam, K.M. (2008), \u201cComputational Modeling of Progressive Collapse in Reinforced Concrete Frame Structures\u201d, Pacific Earthquake Engineering Research Center , PEER 2007/10. Talaat, M. and Mosalam, K.M. (2009), \u201cModeling Progressive Collapse in Reinforced Concrete Buildings Using Direct Element Removal\u201d, Earthquake Engineering and Structural Dynamics , 38 (5): 609-634. Talaat, M. and K. M. Mosalam, K.M. (2009), Chapter20: How to Simulate Column Collapse and Removal in As-built and Retrofitted Building Structures?, in Seismic Risk Assessment and Retrofitting - with special emphasis on existing low-rise structures , Ilki, A, Karadogan, F, Pala, S & Yuksel, E (Eds), ISBN 978-90-481-2680-4, Springer. Talaat, M. and Mosalam, K.M. (2006), \u201cProgressive Collapse Modeling of Reinforced Concrete Framed Structures Containing Masonry Infill Walls\u201d, Proceedings of the 2nd NEES/E-Defense Workshop on Collapse Simulation of Reinforced Concrete Building Structures , Kobe, Japan. Talaat, M. and Mosalam, K.M. (2007), \u201cTowards Modeling Progressive Collapse in Reinforced Concrete Buildings\u201d, Proceedings of SEI-ASCE 2007 Structures Congress , Long Beach, California, USA. Mosalam, K.M., Talaat, M., and Park, S. (2008), \u201cModeling Progressive Collapse in Reinforced Concrete Framed Structures\u201d, Proceedings of the 14th World Conference on Earthquake Engineering , Beijing, China, October 12-17, Paper S15-018. Mosalam, K.M., Park, S., G\u00fcnay, M.S. (2009), \u201cEvaluation of an Element Removal Algorithm for Reinforced Concrete Structures Using Shake Table Experiments,\u201d Proceedings of the 2nd International Conference on Computational Methods in structural Dynamics and Earthquake Engineering (COMPDYN 2009), Island of Rhodes, Greece, June 22-24. Binici, B. and Mosalam, K.M. (2007), \u201cAnalysis of Reinforced Concrete Columns Retrofitted With Fiber Reinforced Polymer Lamina,\u201d Composites Part B: Engineering , 38 (2): 265-276. Mosalam, K.M., Talaat, M., and Binici, B. (2007), \u201cA Computational Model for Reinforced Concrete Members Confined with Fiber Reinforced Polymer Lamina: Implementation and Experimental Validation,\u201d Composites Part B: Engineering , 38 (5-6): 598-613. Mosalam, K.M., Talaat, M., and Binici, B. (2007), \u201cComputational Model for FRP-Confined RC Members\u201d, Proceedings of the 8th International Symposium on Fiber Reinforced Polymer Reinforcement for Concrete Structures (FRPRCS-8), University of Patras, Patras, Greece. Mosalam, K.M., and G\u00fcnay, S. (2010), Chapter 33: Seismic Retrofit of Non-Ductile Reinforced Concrete Frames Using Infill Walls as a Rocking Spine, in Advances in Performance-Based Earthquake Engineering, Geotechnical, Geological, and Earthquake Engineering , Fardis, M.N. (Ed.), Springer. G\u00fcnay, S., Korolyk, M., Mar D., Mosalam, K.M., and Rodgers, J. (2009), \u201cInfill Walls as a Spine to Enhance the Seismic Performance of Non-Ductile Reinforced Concrete Frames,\u201d Proceedings of the ATC&SEI Conference on Improving the Seismic Performance of Existing Buildings and Other Structures , December 9-11, San Francisco, California.","title":"Infill Wall Model With In-Plane, Out-of-Plane Interaction and Element\nRemoval During Simulation\n"},{"location":"contrib/studies/337-Infill%20Wall%20Model%20and%20Element%20Removal/","text":"Infill Wall Model and Element Removal M. Selim Gunay and Khalid M. Mosalam, University of California, Berkeley This article describes the commands for modeling an infill wall element which considers in-plane and out-of-plane interaction and for removal of the element during nonlinear time history simulation in OpenSees. In addition, the infill wall model and element removal algorithm are briefly described. Interested readers can refer to the mentioned references for more information. Questions or comments can be directed to selimgunay [at] berkeley . edu or mosalam [at] ce . berkeley . edu Note: This article is best viewed with Mozilla Firefox. Modeling of the Infill Wall The described infill wall model is a model which considers the interaction of in-plane (IP) and out-of-plane (OOP) effects. Modeling of the infill wall is performed by using the available OpenSees materials, sections, elements and tcl commands. The infill wall model is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass (Figure 1). The inelastic fiber section assigned to the ends of the elements connected to the midspan node is discretized as explained in the following paragraph. Elastic sections with very small moment of inertia (to simulate moment release) are assigned to the ends attached to the surrounding frame. The hinge length near the midspan node is selected as short as possible in order to produce a relatively sharp yield point for the element, while at the same time providing a numerically stable solution. 1/10 of the total length of the diagonal is a suitable value for the total hinge length (sum of the lengths of the hinges on both sides of the node). The hinge length on the other end can be selected as small as possible without losing numerical stability. Figure1.jpg Discretization of Inelastic Fiber Section and Calculation of OOP mass The inelastic fiber section of the beamWithhinges element is modeled by strategically locating a collection of nonlinear fiber elements[1,2]. The fibers are located along a line in the OOP direction (Z-direction in Figure 1). By this way, the beam-column element acts as a truss element and a flexural element in the IP and OOP directions, respectively. The discretization of the cross section is shown in Figure 2a. In this figure, the vector used to define the local-coordinate system in OpenSees, \u201cvecxz\u201d, is (0 0 -1) corresponding to the global axes shown in Figure 1. Each fiber is defined with the area <math>,</math>, z-coordinate \\(\\mathrm{z_i}\\,\\) and a bilinear stress-strain relationship. The strain hardening slope is chosen to be very small, hence the yield stress \\(\\mathrm{f_{yi}}\\,\\) and the yield strain \\(\\mathrm{{\\epsilon}_{yi}}\\,\\) define the stress-strain relationship of the \\(\\mathrm{i_{th}}\\,\\) fiber. Since only one diagonal is utilized in the model, it has both tension and compression strengths. Therefore, the fibers are considered to have the same absolute value for the tensile and compression yield strengths. Figure2-1.jpg The parameters defining a fiber section (<math>,</math>, <math>,</math>, <math>,</math>, and <math>,</math>) are set such that the intended strength interaction (Figure 2b) and the IP axial and OOP bending stiffness values of the diagonal infill wall element are properly simulated. In the current formulation, FEMA-356[3] or ASCE-41[4] equations are used for calculating the axial stiffness and unidirectional strength in the IP direction. However, any other relationships that the user considers as suitable can also be employed. The OOP mass, stiffness and unidirectional bending strength are calculated such that the model has the same natural frequency as the original infill wall, it should produce the same support reactions where it is attached to the surrounding frame for a given support motion (story acceleration), and it should exhibit initial yielding at the same level of support motion that causes the original infill wall to yield. Discretization of the inelastic fiber section is explained below. In the explanation, equations of FEMA-356 are referred to rather than ASCE-41 equations, since FEMA-356 document is accessible from FEMA website. However, Equations of FEMA-356 and ASCE-41 are very similar and ASCE-41 equations may be replaced with FEMA-356 equations. Calculate the IP axial force capacity of the equivalent diagonal element (<math>,</math>), Equation 1. Eq1.jpg In Equation 1, \\(\\mathrm{\\Theta}\\,\\) is the angle of the equivalent diagonal element with the horizontal. \\(\\mathrm{Q_{CE}}\\,\\) is the expected infill shear strength, \\(\\mathrm{A_{ni}}\\,\\) is the area of net mortared/grouted section across infill panel and \\(\\mathrm{f_{ive}}\\,\\) is the expected shear strength of masonry infill. Second part of Equation 1 corresponds to Equation 7-15 in FEMA-356. Calculate the OOP moment capacity under zero IP axial force (MOOP0) for the equivalent diagonal element, Equation 2. Eq2.jpg In Equation 2, \\(\\mathrm{L_{diag}}\\,\\) is the length of the equivalent diagonal element and <math>,</math>, \\(\\mathrm{L_{inf}}\\,\\) and \\(\\mathrm{t_{inf}}\\,\\) are the height, length and thickness of the infill wall panel, respectively. \\(\\mathrm{q_{in}}\\,\\) is the OOP strength of the infill wall panel, \\(\\mathrm{f_{m}}\\,\\) is the expected value of masonry compressive strength and \\(\\mathrm{{\\lambda}_2}\\,\\) is a slenderness parameter defined in Table 7-11 of FEMA-356. Equation 2c corresponds to Equation 7-21 in FEMA-356. Equation 2 is based on the assumption that the yield moment in the equivalent diagonal element is reached when the support spectral acceleration equals the yield spectral acceleration of the original infill wall. Derivation of Equation 2 can be found in Appendix D of reference [1]. Construct the IP axial and OOP bending strength interaction curve accepted as a 3/2-power curve[1, 2] represented with Equation 3. The 3/2 power curve is based on the OOP and IP capacity points obtained from the analyses of a nonlinear finite element (FE) model of an infill panel[3]. In Equation 3, \\(\\mathrm{P_{IP}}\\,\\) is the IP axial strength in the presence of OOP force, <math>,</math>, which is calculated in step 1, is the IP axial strength without OOP force, \\(\\mathrm{M_{OOP}}\\,\\) is the OOP bending strength in the presence of IP force, and <math>,</math>, which is calculated in step 2, is the OOP bending strength without IP force. Eq3.jpg It should be noted that steps 1, 2 and 3 consist of the construction of the IP axial and OOP bending strength interaction based on the explained methodology. The user is free to use any other interaction curve which might be based on experimental data or FE simulations, as long as the chosen interaction curve is not concave, since the equations used for calculation of the fiber locations are not suitable for concave diagrams. However, this limitation is not considered to be serious, since a concave interaction diagram is rarely encountered. The interaction diagram should be discretized at N pairs (N pairs including the (<math>,</math>, 0) and (0, <math>,</math>) pairs), where 2(N-1) is the total number of fibers in the section (N-1 fibers are placed at one side of the y-axis and N-1 fibers on the other side symmetrically as shown in Figure 2). Typically, 10 fibers along the section could be sufficient which corresponds to 6 data pairs on the interaction diagram. Calculate the equivalent strut width \u201ca\u201d using Equation 4, which corresponds to Equation 7-14 in FEMA-356. Then, cross-sectional area of the diagonal element becomes tinf\u00d7a. The user is free to use any other relationship to calculate the area of the equivalent diagonal element or the equivalent width. Eq4.jpg where \\(\\mathrm{h_{col}}\\,\\) is the height of the column of the surrounding frame, \\(\\mathrm{E_{m}}\\,\\) and \\(\\mathrm{E_{f}}\\,\\) are the elasticity moduli of the infill and frame materials, respectively. Equation 4 is unit dependent where force is in kips and displacement is in inches. Calculate the equivalent moment of inertia of the diagonal element in the OOP direction, \\(\\mathrm{I_{eq}}\\,\\) . Considering that the model has the same natural frequency as the original infill wall and it should produce the same support reactions where it is attached to the frame for a given story acceleration, \\(\\mathrm{I_{eq}}\\,\\) is calculated with Equation 5. Eq5.jpg where \\(\\mathrm{\\kappa}\\,\\) is a factor which represents the reduction in moment of inertia due to cracking. Calculate the distance of the \\(\\mathrm{i^{th}}\\,\\) fiber to the centroid (<math>,</math>), Equation 6. Eq6.jpg where M and P represent the OOP bending moment and IP axial force capacities in the interaction diagram (Figure 3). i=1 corresponds to the fiber farthest from the centroid and the point of pure compression on the P\u2212M diagram. The index i increases sequentially in the section as progressing inward to the y-axis and in the interaction diagram in the direction of decreasing P as shown in Figure 3. It should be noted that the coordinates of the points (<math>,</math>) on one side of the y axis (positive z) are calculated with Equation 6 but coordinates of the points on the other side are calculated as the negative of the values calculated with Equation 6. Equation 6 is obtained from the consideration of the changes in the plastic axial force and moment that occur as the plastic neutral axis is \u201cswept through\u201d the section. Derivation of this equation is explained in reference [2]. Figure3.jpg Area of each fiber is calculated such that the sum of the areas of the fibers is equal to the cross sectional area of the equivalent diagonal element (<math>,</math>\u00d7a) calculated in step 4 and sum of the second moment of the fibers is equal to the equivalent moment of inertia in OOP direction (<math>,</math>) calculated in step 5. Eq7a.jpg In order to have a unique solution of Equation 7a, the relationship between \\(\\mathrm{A_{i}}\\,\\) and \\(\\mathrm{z_{i}}\\,\\) is assumed to be represented with Equation 7b. Eq7b.jpg since \\(\\mathrm{z_{i}}\\,\\) values are known from Equation 6, \\(\\mathrm{\\gamma}\\,\\) and \\(\\mathrm{\\eta}\\,\\) can be determined from Equation Then, the area of each fiber is calculated using Equation 7b. Calculate yield stress and yield strain for each fiber, Equations 8 and 9. Eq89-2.jpg Equation 8b is obtained from the consideration of the change in the plastic axial force that occurs as the plastic neutral axis (PNA in Figure 2) is \u201cswept through\u201d the section. Derivation of this equation is explained in reference [2]. In addition to the fibers along z direction, a dummy fiber (a fiber with a very small area) should be located at an arbitrary point along the y-axis (Figure 2) to supply a very small IP moment of inertia. The inelastic fiber section is discretized following the above nine steps. Cross sectional area obtained in step 4 and moment of inertia in OOP direction obtained in step 5 are used as area and moment of inertia about the local axis corresponding to the OOP direction for the interior elastic part of the beamWithhinges element. A very small number is input for the moment of inertia about the other sectional local axis. Calculation of OOP Mass at the Midspan Node As stated previously, the described infill wall element is comprised of two equal size diagonal beamWithhinges elements and a midspan node with OOP mass. This mass at the midspan node is calculated as 0.81M, where M is the total mass of the infill wall panel. This value is the first mode effective mass of the infill wall panel when it is defined as a beam spanning vertically with distributed mass and with simple supports at the ends. Theoretical derivation can be found in reference [1]. Implementation of Infill Wall Removal in OpenSees A progressive collapse algorithm is developed [4-6], the different applications of which can be found in references [7-10]. This algorithm is developed using element removal based on dynamic equilibrium and resulting transient change in system kinematics, the underlying theory of which can be found in the above references. The progressive collapse algorithm is implemented for automated removal of collapsed elements during an ongoing simulation (Figure 4). The implementation is carried out as a new OpenSees module, designed so that it is called by the main analysis module after each converged load step to check each element for possible violation of its respective removal criteria. A violation of any pre-defined removal criterion triggers the activation of the element removal algorithm on the violating element before returning to the main analysis module. Activation of the element removal algorithm includes updating nodal masses, checking if the removal of the collapsed element results in leaving behind dangling nodes or floating elements, which must be removed as well (Figure 5), and removing all associated element and nodal forces, imposed displacements, and constraints. Figure4-2.jpg Figure5.jpg Other than the aforementioned infill wall element, removal criteria are defined for force- and displacement-based distributed plasticity fiber elements and lumped plasticity beam-column elements with fiber-discretized plastic hinges. These criteria are based on material-level damage indices for a newly developed confined RC cross-section model [11-13]. The removal of the latter elements are not considered in the current version of OpenSees. However, they will be available in near future. Current version considers only the removal of the infill wall model described in the first section. Implementation of the removal of the elements representing the aforementioned infill wall analytical model in the progressive collapse algorithm is performed through defining a removal criterion for the beam-column elements of this model. This criterion is based on the interaction between the IP and OOP displacements. IP displacement is the relative horizontal displacement between the top and bottom nodes of the diagonal element. OOP displacement is that of the middle node (where the OOP mass is attached) with respect to the chord which connects the top and bottom nodes. The user is free to choose any interaction relationship between IP and OOP displacements. In the recent studies conducted with the introduced infill wall element [14, 15], same equation used for the strength interaction is considered for the displacement interaction, where IP and OOP displacement capacities in the presence of zero load in the other direction are obtained from FEMA-356 for collapse prevention level. During the nonlinear time history simulation, when the mentioned combination of displacements from the analysis exceeds the interaction curve (Figure 6), the two beam-column elements and the middle node, representing the unreinforced masonry infill wall, are removed. The procedure for the removal of an infill wall is presented in Figure 7. Figure6.jpg Figure7-2.jpg New Command in OpenSees Interpreter The only new tcl command in the OpenSees interpreter with respect to the infill wall removal is the collapse recorder. Three collapse recorders (the syntax of which are indicated below) are needed for the consideration of the removal of an infill wall. These collapse recorders should be defined individually for each infill wall that the user would like to be considered for removal. <pre style=\u201cbackground:yellow;color:black;width:1140px\u201d> recorder Collapse -ele \\(ele1 -time -crit INFILLWALL -\\) file $filename -file_infill $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele2 -time -crit INFILLWALL -file_infill $filenameinf -global_gravaxis $globgrav -checknodes $nodebot $nodemid $nodetop recorder Collapse -ele $ele1 $ele2 -node \\(nodemid &lt;/pre&gt;</p> <p>\\) ele1, $ele2, $nodebot, $nodemid, and $nodetop are shown in Figure 8. Element objects store the identities of their associated Node objects in the data structures of OpenSees. Therefore, it might seem that node inputs are unnecessary. However, when there are shear springs in the model, $nodetop and $nodebot should be the nodes of the springs which connect to the beams, since the shear spring deformation contributes to the IP displacement of the infill wall. These nodes are not the nodes of the diagonal element. Therefore, it is necessary to input these nodes. $filename is the file name for element removal log. Only one log file is constructed for all collapse recorder commands (i.e. for all removals). The first file name input to a collapse recorder command is used and any subsequent file names are ignored. $filenameinf is the file used to input the displacement interaction curve. Two columns of data are input in this file where only positive values are input. First column is the OOP displacement in ascending order and second column is the corresponding IP displacement. Full interaction should be defined. In other words, first value of OOP displacement and last value of IP displacement should be zero. -crit INFILLWALL is used to state that the removal is for the infill wall, because there will be options for removal of other elements in the next versions of OpenSees as mentioned previously. $globgrav is the global axis of the model in the direction of gravity. 1, 2 and 3 should be input for X, Y and Z axes, respectively. For example, it is equal to 2 in Figure 1. Figure8.jpg Example Files related to the example can be downloaded from the links below. This example is based on \u201cExample 8. generic 3D Frame, NStory NBayX NBayZ, Reinforced-Concrete Section\u201d which is available in OpenSees Examples Manual. Main file is \u201cModel_IR.tcl\u201d. Lines 326-469 in this file are related to the infill wall model and element removal. File which conducts time history analysis is NRHA_IR.tcl. Ground motion files (PUL194.tcl, PUL104.tcl) should be located under a directory named \u201cGMFiles\u201d. Calculation of the infill wall parameters are summarized in the file Calculations.pdf. This file is created using Mathcad originally by Stephen Kadysiewski. Interested users can request the Mathcad file by sending email to selimgunay [at] berkeley . edu or mosalam [at] ce . berkeley . edu <strong>Files</strong> Model_IR.tcl NRHA_IR.tcl ReadSMDFile_IR.tcl LibAnalysisDynamicParameters_IR.tcl DisplayModel3D_IR.tcl DisplayPlane_IR.tcl BuildRCrectSection_IR.tcl LibMaterialsRC_IR.tcl LibUnits_IR.tcl Dispwall1-cg.tcl PUL194.tcl PUL104.tcl Calculations.pdf References Kadysiewski, S. and Mosalam, K.M. (2009), \u201cModeling of Unreinforced Masonry Infill Walls Considering In-plane and Out-of-Plane Interaction\u201d, Pacific Earthquake Engineering Research Center , PEER 2008/102. Kadysiewski, S. and Mosalam, K.M. (2009), \u201cModelling of Unreinforced Masonry Infill Walls Considering In-Plane and Out-of-Plane Interaction\u201d, Proceedings of the 11th Canadian Masonry Symposium , Toronto, Ontario, May 31-June 6. Hashemi, S.A. and Mosalam, K.M. (2007), \u201cSeismic Evaluation of Reinforced Concrete Buildings Including Effects of Infill Masonry Walls\u201d, Pacific Earthquake Engineering Research Center , PEER 2007/100. Talaat, M. and Mosalam, K.M. (2008), \u201cComputational Modeling of Progressive Collapse in Reinforced Concrete Frame Structures\u201d, Pacific Earthquake Engineering Research Center , PEER 2007/10. Talaat, M. and Mosalam, K.M. (2009), \u201cModeling Progressive Collapse in Reinforced Concrete Buildings Using Direct Element Removal\u201d, Earthquake Engineering and Structural Dynamics , 38 (5): 609-634. Talaat, M. and K. M. Mosalam, K.M. (2009), Chapter20: How to Simulate Column Collapse and Removal in As-built and Retrofitted Building Structures?, in Seismic Risk Assessment and Retrofitting - with special emphasis on existing low-rise structures , Ilki, A, Karadogan, F, Pala, S & Yuksel, E (Eds), ISBN 978-90-481-2680-4, Springer. Talaat, M. and Mosalam, K.M. (2006), \u201cProgressive Collapse Modeling of Reinforced Concrete Framed Structures Containing Masonry Infill Walls\u201d, Proceedings of the 2nd NEES/E-Defense Workshop on Collapse Simulation of Reinforced Concrete Building Structures , Kobe, Japan. Talaat, M. and Mosalam, K.M. (2007), \u201cTowards Modeling Progressive Collapse in Reinforced Concrete Buildings\u201d, Proceedings of SEI-ASCE 2007 Structures Congress , Long Beach, California, USA. Mosalam, K.M., Talaat, M., and Park, S. (2008), \u201cModeling Progressive Collapse in Reinforced Concrete Framed Structures\u201d, Proceedings of the 14th World Conference on Earthquake Engineering , Beijing, China, October 12-17, Paper S15-018. Mosalam, K.M., Park, S., G\u00fcnay, M.S. (2009), \u201cEvaluation of an Element Removal Algorithm for Reinforced Concrete Structures Using Shake Table Experiments,\u201d Proceedings of the 2nd International Conference on Computational Methods in structural Dynamics and Earthquake Engineering (COMPDYN 2009), Island of Rhodes, Greece, June 22-24. Binici, B. and Mosalam, K.M. (2007), \u201cAnalysis of Reinforced Concrete Columns Retrofitted With Fiber Reinforced Polymer Lamina,\u201d Composites Part B: Engineering , 38 (2): 265-276. Mosalam, K.M., Talaat, M., and Binici, B. (2007), \u201cA Computational Model for Reinforced Concrete Members Confined with Fiber Reinforced Polymer Lamina: Implementation and Experimental Validation,\u201d Composites Part B: Engineering , 38 (5-6): 598-613. Mosalam, K.M., Talaat, M., and Binici, B. (2007), \u201cComputational Model for FRP-Confined RC Members\u201d, Proceedings of the 8th International Symposium on Fiber Reinforced Polymer Reinforcement for Concrete Structures (FRPRCS-8), University of Patras, Patras, Greece. Mosalam, K.M., and G\u00fcnay, S. (2010), Chapter 33: Seismic Retrofit of Non-Ductile Reinforced Concrete Frames Using Infill Walls as a Rocking Spine, in Advances in Performance-Based Earthquake Engineering, Geotechnical, Geological, and Earthquake Engineering , Fardis, M.N. (Ed.), Springer. G\u00fcnay, S., Korolyk, M., Mar D., Mosalam, K.M., and Rodgers, J. (2009), \u201cInfill Walls as a Spine to Enhance the Seismic Performance of Non-Ductile Reinforced Concrete Frames,\u201d Proceedings of the ATC&SEI Conference on Improving the Seismic Performance of Existing Buildings and Other Structures , December 9-11, San Francisco, California.","title":"Infill Wall Model and Element Removal\n"},{"location":"contrib/studies/793-User%20talk%3AKkolozvari/","text":"User talk:Kkolozvari Element MVLEM - Multiple-Vertical-Line-Element-Model for RC Walls Developed and Implemented by: Kristijan Kolozvari<span style=\u201ccolor:black\u201d>, California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles The MVLEM element command is used to generate a two-dimensional Multiple-Vertical-Line-Element-Model (MVLEM; Vulcano et al., 1988; Orakcal et al., 2004) for simulation of flexure-dominated RC wall behavior. A single model element incorporates six global degrees of freedom, three of each located at the center of rigid top and bottom beams, as illustrated in Figure 1a. The axial/flexural response of the MVLEM is simulated by a series of uniaxial elements (or macro-fibers) connected to the rigid beams at the top and bottom (e.g., floor) levels, whereas the shear response is described by a shear spring located at height ch from the bottom of the wall element (Figure 1a). Shear and flexural responses of the model element are uncoupled. The relative rotation between top and bottom faces of the wall element occurs about the point located on the central axis of the element at height ch (Figure 1b). Rotations and resulting transverse displacements are calculated based on the wall curvature, derived from section and material properties, corresponding to the bending moment at height ch of each element (Figure 1b). A value of c =0.4 was recommended by Vulcano et al. (1988) based on comparison of the model response with experimental results. Source: /usr/local/cvs/OpenSees/SRC/element/MVLEM/ Figure 1. a) MVLEM Element, b) MVLEM Rotations and Displacements Input Format: Element MVLEM $eleTag $Dens $iNode $jNode $m \\(c -thick {Thicknesses} -width {Widths} -rho {Reinforcing_ratios} -matConcrete {Concrete_tags} -matSteel {Steel_tags} -matShear {Shear_tag}</strong></p></td> </tr> </tbody> </table> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">eleTag</code></td> <td><p>Unique element object tag</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">Dens</code></td> <td><p>Wall density</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) iNode $jNode End node tags m Number of element macro-fibers c Location of center of rotation from the iNode, c = 0.4 (recommended) {Thicknesses} Array of m macro-fiber thicknesses {Widths} Array of m macro-fiber widths {Reinforcing_ratios} Array of m reinforcing ratios corresponding to macro-fibers; for each fiber: rho<sub class=\u201csubscript\u201d>i</sub> = A<sub class=\u201csubscript\u201d>s,i</sub>/A<sub class=\u201csubscript\u201d>gross,i</sub> (1 < i < m) {Concrete _tags} Array of m uniaxialMaterial tags for concrete {Steel_tags} Array of m uniaxialMaterial tags for steel {Shear_tag} Tag of uniaxialMaterial for shear material Element Recorders: The following recorders are available with the MVLEM element: globalForce Element global forces Curvature Element curvature Shear_Force_Deformation Element shear force-deformation relationship Fiber_Strain Vertical strains in m fibers along the cross-section Fiber_Stress_Concrete Vertical concrete stresses in m fibers along the cross-section Fiber_Stress_Steel Vertical steel stresses in m fibers along the cross-section Examples: Element MVLEM 1 0.0 1 2 8 0.4 -thick 4 4 4 4 4 4 4 4 -width 7.5 1.5 7.5 7.5 7.5 7.5 1.5 7.5 -rho 0.0293 0.0 0.0033 0.0033 0.0033 0.0033 0.0 0.0293 -matConcrete 3 4 4 4 4 4 4 3 -matSteel 1 2 2 2 2 2 2 1 -matShear 5 Recorder Element -file MVLEM_Fgl.out -time -ele 1 globalForce Recorder Element -file MVLEM_FiberStrain.out -time -ele 1 Fiber_Strain References: Orakcal K., Conte J.P., and Wallace J.W. (2004). \u201cFlexural Modeling of Reinforced Concrete Structural Walls - Model Attributes\u201d, ACI Structural Journal, V. 101, No. 5, pp 688-698. Orakcal K. and Wallace J.W. (2006). \u201cFlexural Modeling of Reinforced Concrete Structural Walls - Experimental Verification\u201d, ACI Structural Journal, V. 103, No. 2, pp. 196-206. Vulcano A., Bertero V.V., and Colotti V. (1988). \u201cAnalytical Modeling of RC Structural Walls\u201d, Proceedings, 9th World Conference on Earthquake Engineering, V. 6, Tokyo-Kyoto, Japan, pp. 41-46. Orakcal K. (2004). \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. Example 1. Simulation of Flexural Behavior of a Slender RC Wall Specimen under Cyclic Loading using MVLEM Model Application of the MVLEM element for simulation of flexural response of RC walls is illustrated using the RC wall specimen RW2 tested by Thomsen and Wallace (1995). The specimen was tested under constant axial load and cyclic lateral displacement history applied at the top of the wall. Input parameters and selected output results are presented in the following sections. E1.1. Model Calibration Specimen RW2 was 144 in tall, 48 in wide and 4 in thick, resulting in aspect ratio of 3.0 (slender wall). Figure E1.1 displays model discretization of the RW2 cross-section, with eight uniaxial elements defined along the length of the wall. The analytical model was discretized along wall height with 16 MVLEM elements with element heights in agreement with instrumentation provided on the specimen to allow consistent strain comparisons between model and experimental results. The material models were calibrated to match as tested material properties. Details about model calibration and experimental validation are provided by Orakcal (2004), and Orakcal and Wallace (2004). Figure E1.1. Geometry and Discretization of Wall Specimen RW2 E1.2. Input Files Input files (. tcl ) used to build the wall model and perform displacement-controlled analysis can be found in Example 1. MVLEM.zip : MVLEM_RW2.tcl - model generation and definition of analysis parameters gravity.tcl - application of gravity load dispControl.tcl - application of lateral displacement history (run this file) LibAnalysisStaticParameters.tcl - definition of static analysis parameters LibGeneratePeaks.tcl - generation of displacement history E1.3. Analysis Results Flexural load-deformation responses predicted by the MVLEM model and measured during the experiment are shown on Figure E1.2. Figure E1.2. Experimental and Analytical Load versus Flexural Deformation Relationships Figure E1.3 illustrates the sensitivity of analytical predictions obtained using the MVLEM to the optional gap closure parameter of the ConcreteCM model ( -GapClose $gap , LINK ), which allows consideration of different intensities of gradual gap closure in concrete (Figure E1.3a), as well as selection of the steel material model SteelMPF versus Steel02 (Figure E1.3b). It can be observed from Figure E1.3a that pinching characteristics of the response are slightly more pronounced when less gradual gap closure versus more gradual gap closure (i.e., gap =0 versus gap =1) is adopted. Figure E1.3b illustrates that the wall yield capacity as well as pinching characteristics of the behavior predicted by the MVLEM vary slightly when SteelMPF versus Steel02 is used. Figure E1.3. Sensitivity of Analytical Results to Material Modeling Parameters of: a) Concrete, and b) Steel For illustration purposes, additional response predictions obtained using the MVLEM model are presented in Figure E1.4 and Figure E1.5, where analytically-predicted strain histories at the outermost and central wall fibers, and concrete and steel strain-stress relationships at the outermost fiber are presented, respectively. Responses are obtained using MVLEM recorders Fiber_Strain , Fiber_Stress_Concrete , and Fiber_Stress_Steel . Figure E1.4. Analytical Strain Histories at Outermost and Central Wall Fibers Figure E1.5. Analytically Predicted Stress-Strain Relationships at Wall Outermost Fiber: a) Concrete, b) Steel Element SFI_MVLEM - Cyclic Shear-Flexure Interaction Model for RC Walls Developed and Implemented by: Kristijan Kolozvari<span style=\u201ccolor:black\u201d>, California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles The SFI_MVLEM command is used to construct a Shear-Flexure Interaction Multiple-Vertical-Line-Element Model (SFI-MVLEM, Kolozvari et al., 2014a, b), which captures interaction between axial/flexural and shear behavior of RC structural walls and columns under cyclic loading. The SFI_MVLEM element (Figure 1) incorporates 2-D RC panel behavior described by the Fixed-Strut-Angle-Model (nDMaterial FSAM; Ulugtekin, 2010; Orakcal et al., 2012), into a 2-D macroscopic fiber-based model (MVLEM). The interaction between axial and shear behavior is captured at each RC panel (macro-fiber) level, which further incorporates interaction between shear and flexural behavior at the SFI_MVLEM element level. Source: /usr/local/cvs/OpenSees/SRC/element/SFI_MVLEM/ Figure 1. a) SFI_MVLEM Element, b) RC Panel Element (nDMaterial FSAM) Input Format: Element SFI_MVLEM $eleTag $iNode $jNode $m $c -thick { Thicknesses } -width { Widths } -mat { Material_tags } eleTag Unique element object tag $iNode $jNode End node tags m Number of element macro-fibers c Location of center of rotation with from the iNode, c = 0.4 (recommended) {Thicknesses} Array of m macro-fiber thicknesses {Widths} Array of m macro-fiber widths {Material_tags} Array of m macro-fiber nDMaterial <sup class=\u201csuperscript\u201d>1</sup> tags <sup class=\u201csuperscript\u201d>1</sup> SFI_MVLEM element shall be used with nDMaterial FSAM , which is a 2-D plane-stress constitutive relationship representing reinforced concrete panel behavior. Element Recorders: The following recorders are available with the SFI_MVLEM element: globalForce Element global forces Curvature Element curvature ShearDef Element shear deformation RCPanel $fibTag \\(Response</strong></p></td> <td><p>Returns RC panel (macro-fiber) <em>\\) Response for a \\(fibTag</em>-th panel (1 \u2264 <em>fibTag</em> \u2264 m). For available <em>\\) Response -s refer to nDMaterial FSAM ( LINK ). Examples: Element SFI_MVLEM 1 1 2 5 0.4 -thick 6 6 6 6 6 -width 9 10 10 10 9 -mat 7 6 6 6 7 Recorder Element -file SFI_MVLEM_Fgl.out -time -ele 1 2 3 globalForce Recorder Element -file SFI_MVLEM_panel_strain.out -time -ele 1 RCPanel 1 panel_strain References: Kolozvari K., Orakcal K., and Wallace J. W. (2015a). \u201dModeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls. I: Theory\u201d, ASCE Journal of Structural Engineering, 141(5), 04014135 doi Kolozvari K., Tran T., Orakcal K., and Wallace, J.W. (2015b). \u201dModeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls. II: Experimental Validation\u201d, ASCE Journal of Structural Engineering, 141(5), 04014136 doi Kolozvari K. (2013). \u201cAnalytical Modeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls\u201d, PhD Dissertation, University of California, Los Angeles. Example 1. Simulation of Shear-Flexural Behavior of a Medium-Rise RC Wall Specimen under Cyclic Loading using the SFI-MVLEM Model The behavior of RC wall specimen RW-A15-P10-S78 (Tran and Wallace, tested under constant axial load and cyclic lateral displacement history applied at the top of the wall is predicted using the SFI_MVLEM model. The input parameters and output results are presented in the following sections. E1.1. Model Calibration Basic properties of the specimen with model discretization are shown on Figure E1.1. Detailed information about the test specimen can be found in paper by Tran and Wallace (2012), whereas details of model calibration are provided by Kolozvari (2013) and Kolozvari et al. (2015b). Figure E1.1. Model discretization: a) Plan view, b) Cross-section E1.2. Input Files Input files (. tcl ) used to build the wall model and perform displacement-controlled analysis can be found in Example 1. SFI_MVLEM.zip : SFI_MVLEM_SP4.tcl - model generation and definition of analysis parameters gravity.tcl - application of gravity load dispControl.tcl - application of lateral displacement history (run this file) LibAnalysisStaticParameters.tcl - definition of static analysis parameters LibGeneratePeaks.tcl - generation of displacement history E1.3. Analysis Results The following sub-section presents analytical results obtained for the test specimen described above, using the input files provided. The results include global wall responses (compared against experimental results), model element responses, and individual RC panel (macro-fiber) responses. E1.3.1. Global Wall Responses Analytical and experimental lateral load versus top total displacement responses and wall cracking patterns are presented on Figure E1.2, whereas lateral load versus flexural and shear deformations are shown on Figure E1.3. Total top displacement is obtained from the top node, shear force is recorded using globalForce element recorder, total shear displacement is obtained using shearDef element recorder and crack orientations are obtained using RCPanel and cracking_angles element recorders. Figure E1.2. Wall responses: a) Load versus Top Displacement Behavior, b) Cracking Patterns Figure E1.3. Load versus Deformation Behavior for: a) Flexure, b) Shear E1.3.2. Model Element Responses Figure E1.4 plots lateral load versus total, flexural and shear displacement responses, as well as moment versus curvature relationship, obtained from the analysis for the bottom wall model element. Responses are recorded using globalForce , ShearDef , and Curvature element recorders. Figure E1.4. Model Element Responses: a) Shear Force vs. Total Deformation, b) Shear force vs. Flexural Deformation, c) Shear Force vs. Shear Deformation, d) Moment vs. Curvature E1.3.3. Reinforced Concrete Panel Responses Various stress-strain responses for an individual boundary panel element (outermost macro-fiber) within the bottommost wall element are presented, including total (resultant) stress vs. strain relationships in the xy plane (Figure E1.5; element RCPanel recorders: panel_strain and panel_stress ), stress-strain relationships along the two concrete struts (Figure E1.6; element RCPanel recorders: strain_stress_concrete1 and strain_stress_concrete2 ), and stress-strain relationship along horizontal and vertical steel reinforcement (Figure E1.7; element RCPanel recorders: strain_stress_steelX and strain_stress_steelY ). Figure E1.5. Panel Total Stress vs. Strain Responses: a) Axial-Horizontal, b) Axial-Vertical, c) Shear Figure E1.6. Predicted Stress-Strain Behavior for Concrete: a) Strut 1, b) Strut 2 Figure E1.7. Predicted Stress-Strain Behavior for Steel: a) Horizontal (X), b) Vertical (Y) Example 2. Dynamic Analysis of a Coupled Wall-Frame System This example illustrates application of the SFI_MVLEM wall model for nonlinear dynamic analysis. Analytical model of a coupled wall-frame building system was generated and analyzed under a single ground motion time-history. Brief description of the building characteristics and the analytical model are provided in the following sections. E2.1. Building Description Plan and elevation/section views of the considered building are shown in Figure E2.1. The building footprint is 140 ft \u00d7 60 ft , with 20 ft long spans. Analysis is conducted for shaking in the transverse direction only, where the lateral-force-resisting elements include two identical one-bay frames located at the building perimeter (axis 1 and 8, Figure E2.1a) and two identical walls located near the center of the building (axis 4 and 5, Figure E2.1a). Structural design is performed for a residential building (I=1.0, risk category I, design category D; ASCE 7-10 S11.5 and S11.6) for uniformly distributed dead load of 150 psf and live load of 40 psf (ASCE 7-10, Table 4-1), as well as the earthquake lateral loading obtained using Equivalent Lateral Force Procedure of ASCE 7-10 (S12.8). The frame was designed to resist 25% of the earthquake lateral load (Dual System, ASCE 7-10). Concrete compressive strength of f\u2019<sub class=\u201csubscript\u201d>c</sub> = 5,000 psi and reinforcing steel (both longitudinal and transversal reinforcement) with yield strength f<sub class=\u201csubscript\u201d>y</sub> = 60,000 psi were used. Based on the structural design, cross-section dimensions of 12 in \u00d7 240 in (walls), 18 in \u00d7 32 in (beams; width \u00d7 depth), and 28 in \u00d7 28 in (columns) were adopted. Cross-sections of structural elements with the reinforcement detailing are provided in Figure E2.2. Figure E2.1. Building Views: a) Plan View, b) Frame Elevation, c) Wall Elevation Figure E2.2. Member Cross-Sections: a) Walls, b) Columns, c) Beams E2.2. Analytical Model Description Due to building symmetry and applied direction of the ground motion, a two-dimensional model consisting of one frame and one wall (Figure E2.3) is used to simulate the building behavior. The gravity system is not included in the model (ASCE 7-10) and the assumption of a rigid diaphragm is implemented within each story level. Tributary mass is assigned at the element nodes at each story level at locations of axes of the vertical elements (i.e., wall and columns), whereas gravity load (dead and live) was assigned according to corresponding tributary areas as either nodal load at wall-element nodes of each story or uniformly distributed load along the beams of the frame. As show on Figure E2.3, the RC wall is modeled using ten equal-length SFI_MVLEM elements along the wall height (i.e., two elements per story height). Wall discretization in horizontal direction was performed using six macro-fibers to represent the wall cross section, where two outer macro-fibers were used to represent the confined wall boundaries and the remaining four represent the unconfined wall web. Material models for steel and concrete are calibrated based on adopted material strengths to represent the behavior of confined and unconfined concrete and reinforcing steel. RC frame elements (i.e., beams and columns) are modeled using elastic beam-column elements by assuming the location of plastic hinges at the faces of beam-column joints (Figure E2.3a), the behavior of which was simulated using zero-length elements at locations of hinges and the elasto-plastic moment-rotation hysteretic model (Modified Ibarra Krawinkler Deterioration Model; Lignos and Krawinkler, 2011), with modeling parameters adopted according to beam and column flexural capacities and the ASCE 41 backbone relationships (Figure E2.3b). The reduction of flexural stiffness after cracking was considered using stiffness modifiers for elastic portions of beam and column elements according to ASCE 41 (Table 6.5). E2.3. Input Files Input files (. tcl ) used to build the model of a 5-story wall-frame system and perform gravity and dynamic analysis can be found in Example 2. SFI_MVLEM.zip : 5storyWF_SFI.tcl - model generation, definition of analysis parameters, gravity analysis Modal.tcl - modal analysis Dynamic.tcl - application of earthquake acceleration time-history (run this file) MCEScaledEQ1X.acc - earthquake acceleration time history file DisplayModel2D.tcl - display 2D model DisplayPlane.tcl - display plane Figure E2.3. Analytical Model of Building System: a) Modeling Approach, b) Plastic Hinge Model E2.4. Dynamic Analysis Results Results obtained using analytical model of the building described in the previous section are presented, including modal properties of the structure, wall global (i.e., lateral deformations, drifts, shear force, moments) and local (i.e., vertical strains and rotations) responses. Responses of the structural elements comprising the RC frame are not considered. E2.4.1. Dynamic Properties First two building fundamental periods and mode shapes are presented in Figure E2.4. Figure E2.4. Mode Shapes: a) 1st Mode, b) 2nd Mode E2.4.2. Time-history Responses Time histories of ground motion acceleration, wall top nodal displacement, and wall base shear force (bottom wall node reaction) are presented in Figure 2.5; the responses are obtained using globalForce and Reactions node recorders. Figure E2.5. Global Building Responses E2.4.3. Maximum Global Responses over the Wall Height Maximum envelopes of wall lateral displacements and interstory drifts, and shear force and bending moment are presented in Figure E2.6 and Figure E2.7, respectively. Wall lateral displacements and drifts are obtained using corresponding node recorders, disp and drift , whereas shear force and bending moments over the wall height are recorded using element recorders globalForce . Figure E2.6. Maximum Deformation Responses: a) Lateral Displacements, b) Interstory Drifts Figure E2.7. Maximum Shear Force and Bending Moment over Wall Height E2.4.4. Bottom Wall Element Responses Figure E2.8 plots the responses of the bottom wall element, including lateral load versus total, flexural and shear displacement, and moment versus curvature relationship obtained from the dynamic analysis. Note that wall element shear displacement and curvature time-histories are obtained using SFI_MVLEM element recorders ShearDef and Curvature , respectively, whereas shear force and bending moment are recorded using element recorder globalForce . Figure E2.8. Model Element Responses: a) Lateral Load vs. Displacement, b) Lateral Load vs. Flexural Deformation, Lateral Load vs. Shear Deformation, d) Moment vs. Curvature E2.4.5. Single RC Panel Responses Analytically-predicted strain-stress responses of a single RC panel (macro-fiber) located at the left wall boundary of the bottom wall element are presented. Global panel stress-strain relationships presented on Figure E2.9 are obtained using element recorder RCPanel with commands panel_strain and panel_stress ; the uniaxial behavior of concrete along the two concrete struts presented on Figure E2.10 are recorded using strain_stress_concrete1 and strain_stress_concrete2 commands; uniaxial stress-strain behavior of horizontal and vertical reinforcing steel presented on Figure E2.11 are obtained using strain_stress_steelX and strain_stress_steelY commands. Other panel responses described in Section 3 could be plotted in a similar manner. Figure E2.9. Panel Total Stress vs. Strain Responses: a) Axial-Horizontal, b) Axial-Vertical, c) Shear Figure E2.10. Predicted Stress-Strain Behavior for Concrete: a) Strut 1, b) Strut 2 Figure E2.11. Predicted Stress-Strain Behavior for Steel: a) Horizontal (X), b) Vertical (Y) Finally, vertical profiles of maximum vertical strains (Figure E2.12a) are obtained using element recorder with RCPanel and panel_strain recorder commands, whereas maximum wall rotations over the wall height (Figure E2.12b) are derived from element Curvature recorder. Similarly, the distribution of other wall responses could be plotted over the wall height (e.g., shear deformations, etc.). Figure E2.12. Local Responses - Vertical Profiles of Maximum: a) Vertical Strains, b) Rotations uniaxialMaterial SteelMPF - Steel Material Model by Menegotto and Pinto (1973) extended by Filippou et al. (1983) Developed and Implemented by: Kristijan Kolozvari<span style=\u201ccolor:black\u201d>, California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial SteelMPF , which represents the well-known uniaxial constitutive nonlinear hysteretic material model for steel proposed by Menegotto and Pinto (1973), and extended by Filippou et al. (1983) to include isotropic strain hardening effects. The relationship is in the form of curved transitions (Figure 1), each from a straight-line asymptote with slope E<sub class=\u201csubscript\u201d>0</sub> (modulus of elasticity) to another straight-line asymptote with slope E<sub class=\u201csubscript\u201d>1</sub> = bE<sub class=\u201csubscript\u201d>0</sub> (yield modulus) where b is the strain hardening ratio. The curvature of the transition curve between the two asymptotes is governed by a cyclic curvature parameter R , which permits the Bauschinger effect to be represented, and is dependent on the absolute strain difference between the current asymptote intersection point and the previous maximum or minimum strain reversal point depending on whether the current strain is increasing or decreasing, respectively. The strain and stress pairs (\u03b5<sub class=\u201csubscript\u201d>r</sub>,\u03c3<sub class=\u201csubscript\u201d>r</sub>) and (\u03b5<sub class=\u201csubscript\u201d>0</sub>,\u03c3<sub class=\u201csubscript\u201d>0</sub>) shown on Figure 1 are updated after each strain reversal. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Figure 1. Constitutive Model for Steel (Menegotto and Pinto, 1973) Input Format: uniaxialMaterial SteelMPF $mattag $fyp $fyn $E0 $bp $bn $R0 $a1 $a2 &lt; $a3 $a4 &gt; mattag Unique uniaxialMaterial tag fyp Yield strength in tension (positive loading direction) fyn Yield strength in compression (negative loading direction) E0 Initial tangent modulus bp Strain hardening ratio in tension (positive loading direction) bn Strain hardening ratio in compression (negative loading direction) R0 Initial value of the curvature parameter R (R0 = 20 recommended) a1 Curvature degradation parameter (a1 = 18.5 recommended) a2 Curvature degradation parameter (a2 = 0.15 or 0.0015 recommended) a3 Isotropic hardening parameter (optional, default = 0.01) a4 Isotropic hardening parameter (optional, default = 7.0) Example: uniaxialMaterial SteelMPF 1 60 60 29000 0.02 0.02 20.0 18.5 0.15 Discussion: Although the Menegotto-Pinto model is already available in OpenSees (e.g., Steel02 ), the formulation of SteelMPF introduces several distinctive features compared to existing models. For example, the model allows definition of different yield stress values and strain hardening ratios for tension and compression, and it considers degradation of cyclic curvature parameter R for strain reversals in both pre- and post- yielding regions, which could produce more accurate predictions of yield capacity for some RC wall specimens (see LINK Example 1), whereas Steel02 considers the degradation in post-yielding region only. Strain-stress relationships obtained using SteelMPF and Steel02 are compared in Figure 2 for a strain history that includes strain reversals at strain values equal to one-half of the yield strain (e.i., <math></math><sub class=\u201csubscript\u201d>r</sub> = \u00b10.001 = <math></math><sub class=\u201csubscript\u201d>y/2</sub>). The model also allows calibration of isotropic hardening parameters through optional input variables a<sub class=\u201csubscript\u201d>3</sub> and a<sub class=\u201csubscript\u201d>4</sub> , and uses default values of a<sub class=\u201csubscript\u201d>3</sub> = 0.01 and a<sub class=\u201csubscript\u201d>4</sub> = 7.0 as calibrated by Filippou et al. (1983) based on test results. To disregard isotropic strain hardening behavior in SteelMPF , parameter a<sub class=\u201csubscript\u201d>3</sub> needs to be assigned a zero value ( a<sub class=\u201csubscript\u201d>3</sub> = 0.0). Figure 2. Comparison of Steel02 and SteelMPF References: Filippou F.C., Popov, E.P., and Bertero, V.V. (1983). \u201cEffects of Bond Deterioration on Hysteretic Behavior of Reinforced Concrete Joints\u201d. Report EERC 83-19, Earthquake Engineering Research Center, University of California, Berkeley. Menegotto, M., and Pinto, P.E. (1973). Method of analysis of cyclically loaded RC plane frames including changes in geometry and non-elastic behavior of elements under normal force and bending. Preliminary Report IABSE, vol 13. uniaxialMaterial ConcreteCM - Complete Concrete Model by Chang and Mander (1994) Developed and Implemented by: Kristijan Kolozvari<span style=\u201ccolor:black\u201d>, California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial ConcreteCM , which is a uniaxial hysteretic constitutive model for concrete developed by Chang and Mander (1994). This model is a refined, rule-based, generalized, and non-dimensional constitutive model that allows calibration of the monotonic and hysteretic material modeling parameters, and can simulate the hysteretic behavior of confined and unconfined, ordinary and high-strength concrete, in both cyclic compression and tension (Figure 1). The model addresses important behavioral features, such as continuous hysteretic behavior under cyclic compression and tension, progressive stiffness degradation associated with smooth unloading and reloading curves at increasing strain values, and gradual crack closure effects. Details of the model are available in the report by Chang and Mander (1994). Figure 1. Hysteretic Constitutive Model for Concrete by Chang and Mander (1994) The Chang and Mander (1994) model successfully generates continuous hysteretic stress-strain relationships with slope continuity for confined and unconfined concrete in both compression and tension. The compression envelope curve of the model is defined by the initial tangent slope, (E<sub class=\u201csubscript\u201d>c</sub>), the peak coordinate (<math></math>\u2018<sub class=\u201csubscript\u201d>c</sub>, f\u2019<sub class=\u201csubscript\u201d>c</sub>), a parameter (r<sub class=\u201csubscript\u201d>c</sub>) from Tsai\u2019s (1988) equation defining the shape of the envelope curve, and a parameter (<math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub>) to define normalized (with respect to \\(\\epsilon\\) \u2018<sub class=\u201csubscript\u201d>c</sub>) strain where the envelope curve starts following a straight line, until zero compressive stress is reached at the spalling strain, \\(\\epsilon\\) <sub class=\u201csubscript\u201d>sp</sub>. These parameters can be controlled based on specific experimental results for a refined calibration of the compression envelope (Figure 2). Chang and Mander (1994) proposed empirical relationships for parameters E<sub class=\u201csubscript\u201d>c</sub>, <math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>, and r<sub class=\u201csubscript\u201d>c</sub> for unconfined concrete with compressive strength f\u2019<sub class=\u201csubscript\u201d>c</sub>, based on review of previous research. Parameters f\u2019<sub class=\u201csubscript\u201d>c</sub>, <math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>, E<sub class=\u201csubscript\u201d>c</sub>, r<sub class=\u201csubscript\u201d>c</sub>, and <math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub> can also be calibrated to represent the stress-strain behavior of confined concrete in compression, to follow the constitutive relationships for confined concrete proposed by Mander et al (1988) or similar. Figure 2. Compression and Tension Envelope Curves The shape of the tension envelope curve in the model is the same as that of the compression envelope; however, the tension envelope curve is shifted to a new origin that is based on the unloading strain from the compression envelope (Figure 2). As well, the strain ductility experienced previously on the compression envelope is also reflected on the tension envelope. The parameters associated with the tension envelope curve include the tensile strength of concrete (f<sub class=\u201csubscript\u201d>t</sub>), the monotonic strain at tensile strength (<math></math><sub class=\u201csubscript\u201d>t</sub>), a parameter (r<sub class=\u201csubscript\u201d>t</sub>) from Tsai\u2019s (1988) equation defining the shape of the tension envelope curve, and a parameter (<math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub>) to define normalized (with respect to \\(\\epsilon\\) <sub class=\u201csubscript\u201d>t</sub>) strain where the tension envelope curve starts following a straight line, until zero tensile stress is reached at a strain of \\(\\epsilon\\) <sub class=\u201csubscript\u201d>crk</sub>. These parameters can also be controlled and calibrated based on specific experimental results or empirical relations proposed by other researchers (e.g., Belarbi and Hsu, 1994) to model the behavior of concrete in tension and the tension stiffening phenomenon. Concrete experiencing tension stiffening can be considered not to crack completely; that is, a large value for parameter <math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub> (e.g., 10000) can be defined. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Input Format: uniaxialMaterial ConcreteCM $mattag $fpcc $epcc $Ec $rc $xcrn $ft $et $rt $xcrp &lt;-GapClose $gap &gt; mattag Unique uniaxialMaterial tag fpcc Compressive strength (f\u2019<sub class=\u201csubscript\u201d>c</sub>) epcc Strain at compressive strength (<math></math>\u2019<sub class=\u201csubscript\u201d>c</sub>) Ec Initial tangent modulus (E<sub class=\u201csubscript\u201d>c</sub>) rc Shape parameter in Tsai\u2019s equation defined for compression (r<sub class=\u201csubscript\u201d>c</sub>) xcrn Non-dimensional critical strain on compression envelope (<math></math><sup class=\u201csuperscript\u201d>-</sup><sub class=\u201csubscript\u201d>cr</sub>, where the envelope curve starts following a straight line) ft Tensile strength (f<sub class=\u201csubscript\u201d>t</sub>) rt Shape parameter in Tsai\u2019s equation defined for tension (r<sub class=\u201csubscript\u201d>t</sub>) xcrp Non-dimensional critical strain on tension envelope (<math></math><sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>cr</sub>, where the envelope curve starts following a straight line - large value [e.g., 10000] recommended when tension stiffening is considered) <-GapClose $gap> gap = 0, less gradual gap closure (default); gap = 1, more gradual gap closure Example: uniaxialMaterial ConcreteCM 1 -6.2 -0.0021 4500 7 1.035 0.30 0.00008 1.2 10000 Example of hysteretic stress-strain history generated by the model code is illustrated in Figure 3. Figure 3. Concrete Stress-Strain Behavior Discussion: An optional input parameter gap is introduced in the ConcreteCM model implemented in OpenSees for providing the users with the opportunity to control the intensity of gap closure in the stress-strain behavior of concrete, which in-turn influences the level of pinching in the lateral load-displacement behavior of a RC wall. The original Chang and Mander (1994) model adopts a non-zero tangent stiffness at zero stress level upon unloading from the tension envelope, which is represented by gap = 1 in ConcreteCM . Using gap = 0 (default) produces less gradual gap closure, since it assumes zero tangent stiffness at zero stress level upon unloading from the tension envelope, and is suitable for most analyses. Figure 4 illustrates the effect of plastic stiffness upon unloading from tension envelope (E<sup class=\u201csuperscript\u201d>+</sup><sub class=\u201csubscript\u201d>pl</sub>) on crack closure, i.e. use of more gradual ( gap = 1) or less gradual ( gap = 0) gap closure. Figure 4. Effect of Plastic Stiffness upon Unloading from Tension Envelope (Epl+) on Crack Closure Constitutive stress-strain concrete behavior is also implemented in OpenSees in uniaxialMaterial Cocnrete07 . However, ConcreteCM incorporates sophisticated unloading/reloading rules defined originally by Chang and Mander (1994), as opposed to Concrete07 that adopts simplified hysteretic rules. Comparison between stress-strain response predicted using ConcreteCM and Concrete07 is shown in Figure 5. Figure 5. Comparison of ConcreteCM and Concrete07 References: Belarbi H. and Hsu T.C.C. (1994). \u201cConstitutive Laws of Concrete in Tension and Reinforcing Bars Stiffened by Concrete\u201d, ACI Structural Journal, V. 91, No. 4, pp. 465-474. Chang, G.A. and Mander, J.B. (1994), \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I - Evaluation of Seismic Capacity\u201d, NCEER Technical Report No. NCEER-94-0006, State University of New York, Buffalo. Mander J.B., Priestley M.J.N., and Park R. (1988). \u201cTheoretical Stress-Strain Model for Confined Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 8, pp. 1804-1826. Orakcal K.(2004), \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. NDMaterial FSAM - 2D RC Panel Constitutive Behavior Developed and Implemented by: Kristijan Kolozvari<span style=\u201ccolor:black\u201d>, California State University, Fullerton Kutay Orakcal<span style=\u201ccolor:black\u201d>, Bogazici University, Istanbul, Turkey Leonardo Massone<span style=\u201ccolor:black\u201d>, University of Chile, Santiago John Wallace<span style=\u201ccolor:black\u201d>, Univeristy of California, Los Angeles This command is used to construct a nDMaterial FSAM (Fixed-Strut-Angle-Model, Figure 1), which is a plane-stress constitutive model for simulating the behavior of RC panel elements under generalized, in-plane, reversed-cyclic loading conditions (Ulugtekin, 2010; Orakcal et al., 2012). In the FSAM constitutive model, the strain fields acting on concrete and reinforcing steel components of a RC panel are assumed to be equal to each other, implying perfect bond assumption between concrete and reinforcing steel bars. While the reinforcing steel bars develop uniaxial stresses under strains in their longitudinal direction, the behavior of concrete is defined using stress-strain relationships in biaxial directions, the orientation of which is governed by the state of cracking in concrete. Although the concrete stress-strain relationship used in the FSAM is fundamentally uniaxial in nature, it also incorporates biaxial softening effects including compression softening and biaxial damage. For transfer of shear stresses across the cracks, a friction-based elasto-plastic shear aggregate interlock model is adopted, together with a linear elastic model for representing dowel action on the reinforcing steel bars (Kolozvari, 2013). Source: /usr/local/cvs/OpenSees/SRC/material/nD/reinforcedConcretePlaneStress/ Figure 1. FSAM for Converting In-Plane Strains to In-Plane Smeared Stresses on a RC Panel Element Input Format: nDMaterial FSAM $mattag $rho $sX $sY $conc $rouX $rouY $nu $alfadow mattag Unique nDMaterial tag rho Material density sX Tag of uniaxialMaterial simulating horizontal (x) reinforcement sY Tag of uniaxialMaterial simulating vertical (y) reinforcement conc Tag of uniaxialMaterial<sup class=\u201csuperscript\u201d>1</sup> simulating concrete rouX Reinforcing ratio in horizontal (x) direction (rouX = A<sub class=\u201csubscript\u201d>s,x</sub>/A<sub class=\u201csubscript\u201d>gross,x</sub>) rouY Reinforcing ratio in vertical (y) direction (rouY = A<sub class=\u201csubscript\u201d>s,y</sub>/A<sub class=\u201csubscript\u201d>gross,y</sub>) nu Concrete friction coefficient (0.0 < nu < 1.5) alfadow Stiffness coefficient of reinforcement dowel action (0.0 < alfadow < 0.05) <sup class=\u201csuperscript\u201d>1</sup>nDMaterial FSAM shall be used with uniaxialMaterial ConcreteCM Recommended values for parameter of a shear resisting mechanism ( nu and alfadow , Figure 2) are provided above. Details about the sensitivity of analytical predictions using SFI_MVLEM to changes in these parameters are presented by Kolozvari (2013). Material Recorders: The following output is available from the FSAM RC panel model: panel_strain Strains \u03b5<sub class=\u201csubscript\u201d>x</sub>, \u03b5<sub class=\u201csubscript\u201d>y</sub>, &gamma;<sub class=\u201csubscript\u201d>xy</sub> (Figure 4) panel_stress Resulting panel stresses \u03c3<sub class=\u201csubscript\u201d>x</sub>, \u03c3<sub class=\u201csubscript\u201d>y</sub>, &tau;<sub class=\u201csubscript\u201d>xy</sub> (concrete and steel, Figure 1) panel_stress_concrete Resulting panel concrete stresses \u03c3<sub class=\u201csubscript\u201d>xc</sub>, \u03c3<sub class=\u201csubscript\u201d>yc</sub>, &tau;<sub class=\u201csubscript\u201d>xyc</sub> (Figure 2b) panel_stress_steel Resulting panel steel stresses \u03c3<sub class=\u201csubscript\u201d>xs</sub>, \u03c3<sub class=\u201csubscript\u201d>ys</sub>, &tau;<sub class=\u201csubscript\u201d>xys</sub> (Figure 2d) strain_stress_steelX Uniaxial strain and stress of horizontal reinforcement \u03b5<sub class=\u201csubscript\u201d>x</sub>, \u03c3<sub class=\u201csubscript\u201d>xxs</sub> strain_stress_steelY Uniaxial strain and stress of vertical reinforcement \u03b5<sub class=\u201csubscript\u201d>y</sub>, \u03c3<sub class=\u201csubscript\u201d>yys</sub> strain_stress_concrete1 Uniaxial strain and stress of concrete strut 1 \u03b5<sub class=\u201csubscript\u201d>c1</sub>, \u03c3<sub class=\u201csubscript\u201d>c1</sub> strain_stress_concrete2 Uniaxial strain and stress of concrete strut 2 \u03b5<sub class=\u201csubscript\u201d>c2</sub>, \u03c3<sub class=\u201csubscript\u201d>c2</sub> strain_stress_interlock1 Shear strain and stress in concrete along crack 1 \u03b5<sub class=\u201csubscript\u201d>cr1</sub>, &tau;<sub class=\u201csubscript\u201d>cr1</sub> (Figure 2c) strain_stress_interlock2 Shear strain and stress in concrete along crack 2 \u03b5<sub class=\u201csubscript\u201d>cr2</sub>, &tau;<sub class=\u201csubscript\u201d>cr2</sub> (Figure 2c) cracking_angles Orientation of concrete cracks Note that recorders for a RC panel (marco-fiber) are invoked as SFI_MVLEM element recorders using command RCPanel and one of the desired commands listed above. Currently, it is possible to output values only for one macro-fiber within one or multiple elements. Example: nDMaterial FSAM 1 0.0 1 2 4 0.0073 0.0606 0.1 0.01 Recorder Element -file MVLEM_panel_strain.out -time -ele 1 RCPanel 1 panel_strain Figure 2. Behavior and Input/Output Parameters of the FSAM Constitutive Model References: Kolozvari K. (2013). \u201cAnalytical Modeling of Cyclic Shear-Flexure Interaction in Reinforced Concrete Structural Walls\u201d, PhD Dissertation, University of California, Los Angeles. Orakcal K., Massone L.M., and Ulugtekin D. (2012). \u201cConstitutive Modeling of Reinforced Concrete Panel Behavior under Cyclic Loading\u201d, Proceedings, 15th World Conference on Earthquake Engineering, Lisbon, Portugal. Ulugtekin D. (2010). \u201cAnalytical Modeling of Reinforced Concrete Panel Elements under Reversed Cyclic Loadings\u201d, M.S. Thesis, Bogazici University, Istanbul, Turkey.","title":"User talk:Kkolozvari\n"},{"location":"developer/","text":"Developer Documentation Welcome to the OpenSeesRT developer documentation. Architecture Compiling Extending Contributing","title":"Developer Documentation\n"},{"location":"developer/architecture/","text":"Architecture An OpenSees application can be decomposed into the following parts: The core framework, as originally presented in @mckenna1997 ( link ). This defines the core components and interfaces. Component libraries and community-contributions; these are concrete objects such as elements, materials and solvers. These implement the interfaces described in class_interface . Most of the documentation for these is in the user-space side of things. Runtime ( OpenSeesRT , OpenSees.exe , OpenSeesPy ). A runtime is responsible for providing a mechanism to users for conducting an analysis. Runtimes have been implemented using various communication mechanisms. The classic OpenSees Tcl interpreters generally invoke class methods directly to perform analysis procedures, meanwhile OpenSeesPy leverages the interpreter framework introduced in @mckenna2010 The OpenSeesRT distribution implements a new runtime and aims to achieve the following goals: Idempotence Reliability In order to prevent the exensability of the framework from impacting its reliability , modularity must be separated from the core framework. Architecture: libG3 - Core OpenSees framework libOpenSeesRT - Tcl package linking libG3 with OpenSees component libraries. libOpenSeesPyRT - Python bindings. Exposes direct interface to model objects like Element , UniaxialMaterial , etc.","title":"Architecture\n"},{"location":"developer/architecture/api/","text":"G3 API Model Building Domain * G3_getDomain ( G3_Runtime *); Materials UniaxialMaterial * G3_getUniaxialMaterialInstance ( G3_Runtime *, int ); int G3_addUniaxialMaterial ( G3_Runtime *, UniaxialMaterial *); Loading int G3_addTimeSeries ( G3_Runtime *, TimeSeries *); TimeSeries * G3_getTimeSeries ( G3_Runtime *, int ); StaticAnalysis * G3_getStaticAnalysis ( G3_Runtime *); int G3_setStaticAnalysis ( G3_Runtime *, StaticAnalysis *); StaticIntegrator * G3_getStaticIntegrator ( G3_Runtime *); int G3_setStaticIntegrator ( G3_Runtime *, StaticIntegrator *); TclSafeBuilder * G3_getSafeBuilder ( G3_Runtime *);","title":"G3 API\n"},{"location":"developer/architecture/api/analysis/","text":"Analysis API Static Analysis G3_setStaticAnalysis ( G3_Runtime * rt , StaticAnalysis * analysios ) Transient Analysis G3_setTransientAnalysis ( G3_Runtime * rt , DirectIntegrationAnalysis * analysis ); Systems of Equations G3_setLinearSoe ( G3_Runtime * rt , LinearSOE * soe ); Point the runtime, rt , to the LinearSOE pointer, soe . If the runtime is aware of a StaticAnalysis or [ DirectIntegrationAnalysis ], their respective setLinearSOE() methods will be called. LinearSOE ** G3_getLinearSoePtr ( G3_Runtime * rt ); Get the current system of equations. LinearSOE * G3_getDefaultLinearSoe ( G3_Runtime * rt , int flags ); flags is unused right now but could be useful for ensuring properties about the SOE, like forcing fullGen.","title":"Analysis API\n"},{"location":"developer/architecture/api/element_api/","text":"C API 2 Model Building Domain * OPS_GetDomain ( void ); eleObj* OPS_GetElement(int* eleTag); matObj* OPS_GetMaterialType(char* type, int sizeType); eleObj* OPS_GetElementType(char* type, int sizeType); int OPS_AllocateElement(eleObject * theEle, int* matTags, int* matType); int OPS_AllocateMaterial(matObject * theMat); limCrvObj* OPS_GetLimitCurveType(char* type, int sizeType); int OPS_AllocateLimitCurve(limCrvObject * theLimCrv); Coordinate Transformations CrdTransf * OPS_GetCrdTransf ( int crdTag ); Materials UniaxialMaterial * OPS_GetUniaxialMaterial ( int matTag ); NDMaterial * OPS_GetNDMaterial ( int matTag ); matObj * OPS_GetMaterial ( int * matTag , int * matType ); int addPlasticMaterial ( PlasticHardeningMaterial & theMaterial )= 0 ; PlasticHardeningMaterial * getPlasticMaterial ( int tag )= 0 ; Sections SectionForceDeformation * OPS_GetSectionForceDeformation ( int secTag ); FrictionModel * OPS_GetFrictionModel ( int frnTag ); LimitCurve * OPS_GetLimitCurve ( int LimCrvTag ); int addSection ( SectionForceDeformation & theSection )= 0 ; SectionForceDeformation * getSection ( int tag )= 0 ; int addSectionRepres ( SectionRepres & theSectionRepres )= 0 ; SectionRepres * getSectionRepres ( int tag )= 0 ; Other Yield Surface int addYieldSurface_BC ( YieldSurface_BC & theYS )= 0 YieldSurface_BC * getYieldSurface_BC ( int tag )= 0 ; int addYS_EvolutionModel ( YS_Evolution & theModel )= 0 ; YS_Evolution * getYS_EvolutionModel ( int tag )= 0 ; Cyclic Models int addCyclicModel ( CyclicModel & theModel ); CyclicModel * getCyclicModel ( int tag ); Damage models int addDamageModel ( DamageModel & theModel ); DamageModel * getDamageModel ( int tag ); Friction models int addFrictionModel ( FrictionModel & theFrnMdl ); FrictionModel * getFrictionModel ( int tag ); Runtime int OPS_GetNDF (); int OPS_GetNDM (); extern FE_Datastore * OPS_GetFEDatastore (); extern \"C\" const char * OPS_GetInterpPWD (); AnalysisModel ** OPS_GetAnalysisModel ( void ); EquiSolnAlgo ** OPS_GetAlgorithm ( void ); ConstraintHandler ** OPS_GetHandler ( void ); DOF_Numberer ** OPS_GetNumberer ( void ); LinearSOE ** OPS_GetSOE ( G3_Runtime *); EigenSOE ** OPS_GetEigenSOE ( void ); StaticAnalysis ** OPS_GetStaticAnalysis ( void ); DirectIntegrationAnalysis ** OPS_GetTransientAnalysis ( void ); VTDI_Analysis ** OPS_GetVTDI_Analysis ( void ); // VTDI_Analysis** OPS_GetVariableTimeStepTransientAnalysis(void); StaticIntegrator ** OPS_GetStaticIntegrator ( void ); TransientIntegrator ** OPS_GetTransientIntegrator ( void ); ConvergenceTest ** OPS_GetTest ( void ); bool * OPS_builtModel ( void ); Conducting Analysis int * OPS_GetNumEigen ( void ); int OPS_InvokeMaterial ( eleObject *, int *, modelState *, double *, double *, double *, int *); int OPS_InvokeMaterialDirectly ( matObject **, modelState *, double *, double *, double *, int *); int OPS_InvokeMaterialDirectly2 ( matObject *, modelState *, double *, double *, double *, int *); int OPS_GetNodeDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeVel ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeAccel ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeIncrDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeIncrDeltaDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeCrd ( int * nodeTag , int * sizeData , double * data ); int OPS_numIter ( void ); IO int OPS_GetNumRemainingInputArgs (); int OPS_ResetCurrentInputArg ( int cArg ); int OPS_GetIntInput ( int * numData , int * data ); int OPS_SetIntOutput ( int * numData , int * data , bool scalar ); int OPS_GetDoubleInput ( int * numData , double * data ); int OPS_SetDoubleOutput ( int * numData , double * data , bool scalar ); const char * OPS_GetString (); // does a strcpy const char * OPS_GetStringFromAll ( char * buffer , int len ); // does a strcpy int OPS_SetString ( const char * str ); int OPS_GetStringCopy ( char ** cArray ); // returns a new copy int OPS_ResetInput ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , TCL_Char * * argv , Domain * domain , TclModelBuilder * builder ); int OPS_ResetInputNoBuilder ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , TCL_Char * * argv , Domain * domain ); int OPS_GetString ( char * cArray , int sizeArray ); // does a strcpy void OPS_GetMaterialPtr ( int * matTag , matObj * theRes );","title":"C API 2\n"},{"location":"developer/architecture/api/element_api_c/","text":"C API IO API int OPS_GetIntInput(int* numData, int* data); int OPS_GetDoubleInput(int* numData, double* data); int OPS_GetString(char* cArray, int sizeArray); int OPS_Error(char*, int length); Model Building API matObj* OPS_GetMaterial(int* matTag, int* matType); void OPS_GetMaterialPtr(int*, matObj*); eleObj* OPS_GetElement(int*); matObj* OPS_GetMaterialType(char* type, int sizeType); eleObj* OPS_GetElementType(char*, int); int OPS_AllocateElement(eleObj*, int* matTags, int* maType); int OPS_AllocateMaterial(matObj*); limCrv* OPS_GetLimitCurveType(char* type, int sizeType);//**MRL int OPS_AllocateLimitCurve(limCrvObj*);//**MRL int OPS_InvokeMaterial(struct eleObj*, int*, modelState*, double*, double*, double*, int*); int OPS_InvokeMaterialDirectly(matObj**, modelState*, double*, double*, double*, int*); int OPS_InvokeMaterialDirectly2(matObj*, modelState*, double*, double*, double*, int*); int OPS_GetNodeCrd(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeDisp(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeVel(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeAcc(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeIncrDisp(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeIncrDeltaDisp(int* nodeTag, int* sizeData, double* data); Runtime API int OPS_GetNDF (); int OPS_GetNDM (); AnalysisModel ** OPS_GetAnalysisModel ( void ); EquiSolnAlgo ** OPS_GetAlgorithm ( void ); ConstraintHandler ** OPS_GetHandler ( void ); DOF_Numberer ** OPS_GetNumberer ( void ); LinearSOE ** OPS_GetSOE ( void ); EigenSOE ** OPS_GetEigenSOE ( void ); StaticAnalysis ** OPS_GetStaticAnalysis ( void ); DirectIntegrationAnalysis ** OPS_GetTransientAnalysis ( void ); VariableTimeStepDirectIntegrationAnalysis ** OPS_GetVariableTimeStepTransientAnalysis ( void ); int * OPS_GetNumEigen ( void ); StaticIntegrator ** OPS_GetStaticIntegrator ( void ); TransientIntegrator ** OPS_GetTransientIntegrator ( void ); ConvergenceTest ** OPS_GetTest ( void ); bool * OPS_builtModel ( void ); #define ISW_INIT 0 #define ISW_COMMIT 1 #define ISW_REVERT 2 #define ISW_FORM_TANG_AND_RESID 3 #define ISW_FORM_MASS 4 #define ISW_REVERT_TO_START 5 #define ISW_DELETE 6 #define ISW_SET_RESPONSE 7 #define ISW_GET_RESPONSE 8 #define OPS_UNIAXIAL_MATERIAL_TYPE 1 #define OPS_SECTION2D_TYPE 2 #define OPS_SECTION3D_TYPE 3 #define OPS_PLANESTRESS_TYPE 4 #define OPS_PLANESTRAIN_TYPE 5 #define OPS_THREEDIMENSIONAL_TYPE 6 #define OPS_SECTION_TYPE 7 typedef struct modState modelState ; typedef void (* matFunct )( struct matObject *, modelState *, double * strain , double * tang , double * stress , int * isw , int * error ); typedef struct limCrvObject limCrvObj ; typedef void (* eleFunct )( struct eleObject *, modelState *, double * tang , double * resid , int * isw , int * error ); typedef struct eleObject eleObj ; typedef struct matObject matObj ; typedef void (* limCrvFunct )( struct limCrvObject *, modelState *, double * strain , double * tang , double * stress , int * isw , int * error ); struct modState { double time ; double dt ; }; struct matObject { int tag ; int matType ; int nParam ; int nState ; double * theParam ; double * cState ; double * tState ; matFunct matFunctPtr ; void * matObjectPtr ; }; struct limCrvObject { int tag ; int nParam ; int nState ; double * theParam ; double * cState ; double * tState ; limCrvFunct limCrvFunctPtr ; void * limCrvObjectPtr ; }; struct eleObject { int tag ; int nNode ; int nDOF ; int nParam ; int nState ; int nMat ; int * node ; double * param ; double * cState ; double * tState ; matObj ** mats ; eleFunct eleFunctPtr ; };","title":"C API\n"},{"location":"developer/architecture/api/ops_api/","text":"Runtime API OPS_GetNDF(void) OPS_GetNDM(void) OPS_InvokeMaterialObject(struct matObject theMat, modelState theModel, OPS_Error(char errorMessage, int length) OPS_GetMaterial(int matTag, int matType) OPS_GetElement(int eleTag) OPS_GetElementType(char type, int sizeType) OPS_GetMaterialType(char type, int sizeType) OPS_GetLimitCurveType(char type, int sizeType) OPS_AllocateLimitCurve(limCrvObject theLimCrv) OPS_AllocateMaterial(matObject theMat) OPS_AllocateElement(eleObject theEle, int matTags, int matType) OPS_GetNodeCrd(int nodeTag, int sizeCrd, double data) OPS_GetNodeDisp(int nodeTag, int sizeData, double data) OPS_GetNodeVel(int nodeTag, int sizeData, double data) OPS_GetNodeAccel(int nodeTag, int sizeData, double data) OPS_GetNodeIncrDisp(int nodeTag, int sizeData, double data) OPS_GetNodeIncrDeltaDisp(int nodeTag, int sizeData, double data) OPS_InvokeMaterial(eleObject theEle, int mat, modelState *model, OPS_InvokeMaterialDirectly(matObject **theMat, modelState model, OPS_InvokeMaterialDirectly2(matObject theMat, modelState *model, OPS_GetUniaxialMaterial(int matTag) OPS_GetNDMaterial(int matTag) OPS_GetSectionForceDeformation(int secTag) OPS_GetCrdTransf(int crdTag) OPS_GetFrictionModel(int frnTag) OPS_GetFEDatastore() OPS_GetInterpPWD() OPS_GetDomain(void) OPS_GetLimitCurve(int LimCrvTag) OPS_GetAnalysisModel(void) OPS_GetAlgorithm(void) OPS_GetHandler(void) OPS_GetNumberer(void) OPS_GetSOE(void) OPS_GetEigenSOE(void) OPS_GetStaticAnalysis(void) OPS_GetTransientAnalysis(void) OPS_GetVariableTimeStepTransientAnalysis(void) OPS_GetNumEigen(void) OPS_GetStaticIntegrator(void) OPS_GetTransientIntegrator(void) OPS_GetTest(void) OPS_builtModel(void) OPS_numIter() Parsing API OPS_GetString ( void ) OPS_GetStringFromAll ( char * buffer , int len ) OPS_SetString ( const char * str ) OPS_GetStringCopy ( char ** arrayData ) OPS_GetNumRemainingInputArgs () OPS_ResetCurrentInputArg ( int cArg ) OPS_ResetInput ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , OPS_ResetInputNoBuilder ( ClientData clientData , Tcl_Interp * interp , int cArg , OPS_GetIntInput ( int * numData , int * data ) OPS_SetIntOutput ( int * numData , int * data , bool scalar ) OPS_GetDoubleInput ( int * numData , double * data ) OPS_SetDoubleOutput ( int * numData , double * data , bool scalar )","title":""},{"location":"developer/architecture/class_interface/","text":"Class Interface Specification Classes may be categorized as follows: Domain : These classes describe the finite element model and store the results of an analysis on the model. The classes include Domain , Element , Node , Load, SP_Constraint , MP_Constraint , and their subclasses. Analysis : These classes perform the analysis of the finite element model. The classes include the Analysis , ConstraintHandler , DOF_Numberer , SolutionAlgorithm , Integrator , FE_Element , DOF_Group and AnalysisModel classes, and their subclasses. Computational Classes : These classes allow for composing efficient computational strategies that take advantage of prolem features such as sparsity , symmetry , and parallelism . More specifically these include: System of Equation These include the abstract SystemOfEquation and Solver classes, and subclasses of these classes. These classes are provided for the solving of large scale systems of linear and eigenvalue equations. Graph These are classes used to provide information about nodal and elemental connectivity and sparsity of systems of equations. The classes include Graph , Vertex , GraphNumberer , GraphPartitioner , and their subclasses. There is no Edge class provided at present. In current design each Vertex stores in an ID the tag of all it\u2019s adjacent Vertices. For graph numbering and partitioning this has proved sufficient. Parallel Classes These facilitate the development of parallel object-oriented finite element programs, classes are provided for parallel programming. The classes in the framework support the aggregate programming model. The classes include Actor , Shadow , Message , MachineBroker , FEM_ObjectBroker , Channel , and their subclasses. Runtime Classes: These include the ModelNamespace and G3_Runtime classes. An analyst will interact with a ModelBuilder object, to create the Element, Node, Load and Constraint objects that define the model. Other/Utility Classes Matrix Classes: These include the classes Matrix, Vector and ID (integer array). These classes are used in the framework for passing information between objects in a safe manner, and for small scale numerical calculations in element formulation. Data Storage These are classes used to store data. There are two abstract classes TaggedObjectStorage and FE_Datastore . Objects of type TaggedObjectStorage are used as containers to store and provide access to the TaggedObjects in memory during program execution. FE_Datastore objects are used to store/retrieve information from databases, containers which can permanently hold program data. Visualization Classes These are classes used to generate images of the model for the analyst. These classes include Renderer , ColorMap , and their subclasses. This design allows for contributions in the fields of: Element and material modeling. Solution algorithms, integration procedures and constraint handling techniques. Model generation. Numerical analysis for solution of linear and eigenvalue problems. Graph theory for numbering and partitioning graphs. Data structures for container classes and database. Graphics. Message passing systems and load balancing in parallel environments. Frank McKenna and Gregory L. Fenves December 20, 1999","title":"Class Interface Specification\n"},{"location":"developer/architecture/class_interface/Parallel/","text":"Parallel Classes To facilitate the development of parallel object-oriented finite element programs, a new framework is presented in this section. The classes in the framework support the aggregate programming model. The new classes are: Shadow - A Shadow object represents a remote actor object in the local actor process. Actor - An Actor object is a local object in the remote actor process. It performs the operations requested of it by the Shadow object. The actor objects in an aggregation collectively perform the analysis operations by communicating between themselves. Channel - The Shadow and Actor objects communicate with each other through Channel objects. A Channel object represents a point in a local actor process through which a local object can send and receive information. Address - An Address object represents the location of a Channel object in the machine space. Channel objects send information to other Channel objects, whose locations are given by an Address object. Channel objects also receive information from other Channel objects, whose locations are given by an Address object. MovableObject - A MovableObject is an object which can send its state from one actor process to another. ObjectBroker - An ObjectBroker is an object in a local actor process for creating new objects. MachineBroker - A MachineBroker is an object in a local actor process that is responsible for creating remote actor processes at the request of Shadow objects in the same local process. Frank McKenna and Gregory L. Fenves Version 0.1 - Preliminary Draft December 20, 1999 PEER, University of California at Berkeley","title":"Parallel Classes\n"},{"location":"developer/architecture/class_interface/Parallel/actor/","text":"Actor Shadow Channel TCP_Socket MPI_Channel MovableObject Message FEM_ObjectBroker MachineBroker","title":""},{"location":"developer/architecture/class_interface/Parallel/actor/actor/Actor/","text":"Actor #include <actor/actor/Actor.h> class Actor Actor is meant as an abstract class, i.e. no instances of Actor should exist. An actor is associated with a shadow object. The shadow acts like a normal object in the users address space, data and processing that is done by the shadow may be stored and processed in a remote process, the actor resides in this remote address space. The actor and the shadow both have a channel, a communication port. This allows the two to communicate with each other. Constructor ### Destructor // Public Methods for Processing Functions // Public Methods for Sending/Receiving Objects This is called by the remote process upon initialization to construct the local actor object. It is used to create an Actor object in that remote address space which will communicate with objects in other processes through a channel object, theChannel and which uses theBroker to receive movable objects sent from other processes. The subclass will be able to add numMethods actor methods using addMethod() call. The base classes constructor invokes setUpActor() on theChannel object. It then sets the Address of the remote shadow object which created the actor process by invoking getLastSendersAddress() on theChannel . Provided so subclass destructor will be called. A method to add as a function to the actor object the function fp , this function is identified by the tag value. This function will be invoked by the actor on invocation of processMethod() with tag as the argument. The object checks to see that the tag has not been used previously. If it has not and the number of functions so far added is less than numActorMethods the function is added and \\(0\\) is returned, otherwise a \\(-1\\) (if tag was already used) or \\(-2\\) (if numActorMethods already added) or a \\(-3\\) (if running out of space) is returned to indicate the function was not added. virtual int getMethod (); A method which returns the next integer value sitting in the actors channel. This int value corresponds to the tag of the next method that the shadow object wants the actor to perform. If an error occurs \\(-1\\) will be returned. virtual int processMethod ( int tag ); This causes the actor object to invoke the function that was added to the actor with the tag identifier. If no method with tag exists a \\(-1\\) is returned. virtual int sendObject(MovableObject &theObject, ChannelAddress *theAddress =0); A method which will send theObject through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendObj(0, theObject,theBroker,theAddress) on the actors channel object if an address is specified, otherwise the result of invoking sendObj(theMessage,theBroker,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvObject(MovableObject &theObject, ChannelAddress *theAddress =0); A method which will receive theObject from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvObj(0, theObject,theBroker,theAddress) on the actors channel object if an address is specified, otherwise the result of invoking recvObj(theMessage,theBroker,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendMessage(Message &theMessage, ChannelAddress *theAddress =0); A method which will send the data in the message theMessage through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendMsg ( 0 , 0 , theMessage , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendMsg ( theMessage , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. virtual int recvMessage ( Message & theMessage ); A method which will receive the data in the message theMessage from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvMsg ( 0 , 0 , theMessage , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvMsg(0,0,theMessage,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendMatrix(Matrix &theMatrix, ChannelAddress *theAddress =0); A method which will send theMatrix through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendMatrix ( 0 , 0 , theMatrix , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendMatrix(0,0,theMatrix,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvMatrix ( Matrix & theMatrix ); A method which will receive theMatrix from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvMatrix ( 0 , 0 , theMatrix , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvMatrix(0,0,theMatrix,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendVector(Vector &theVector, ChannelAddress *theAddress =0); A method which will send theVector through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendVector ( 0 , 0 , theVector , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendVector(0,0,theVector,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvVector ( Vector & theVector ); A method which will receive theVector from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvVector ( 0 , 0 , theVector , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvVector(0,0,theVector,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendID ( ID & theID , ChannelAddress \\ * theAddress = 0 ); A method which will send theID through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendID ( 0 , 0 , theID , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendID ( 0 , 0 , theID , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. virtual int recvID ( ID & theID ); A method which will receive theID from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvID ( 0 , 0 , theID , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvID ( 0 , 0 , theID , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. void Channel \\ * getChannelPtr ( void ) const ; A method which returns a pointer to the channel passed in the constructor. void FEM_ObjectBroker \\ * getObjectBrokerPtr ( void ) const ; A method which returns a pointer to the FEM_ObjectBroker passed in the constructor. void ChannelAddress \\ * getChannelAddressPtr ( void ) const ; A method which returns a pointer to the channel address for the shadow object that created the actor.","title":"Actor\n"},{"location":"developer/architecture/class_interface/Parallel/actor/actor/MovableObject/","text":"MovableObject #include </actor/actor/MovableObject.h> class MovableObject MovableObject is an abstract class, i.e. no instances of MovableObject should exist. MovableObjects are objects which are able to send/receive themselves to/from Channel objects. With each movable object is associated a unique class identifier, it is this id which will allow object brokers in remote processes to create an object of the correct type. In addition when databases are being used, each MovableObject will have a unique database tag, it is this integer which will allow the objects to retrieve their own data from the database. Constructor Destructor // Public Methods The constructor sets the objects class identifier to classTag : this is a unique id for each class of instantiable movable objects. The identifier will allow an object broker to recognize the object type to be instantiated. Sets the objects database tag to dbTag : this is a unique id for identifying the object in a database. The constructor sets the objects class identifier to classTag and sets the objects database tag to 0 . A method which returns the class id, classTag , provided in the constructor. int getDbTag ( void ) const ; A method which returns the database tag, dbTag , provided in the constructor or last set in setDbTag() . void setDbTag ( int dbTag ); A method to set the database tag to be equal to dbTag . virtual int sendSelf ( int commitTag , Channel & theChannel ) = 0 ; This is a pure virtual method, one must be written for each instantiable subclass of MovableObject. Each object has to send the data needed to be able to reproduce that object in a remote process. The object uses the methods provided by theChannel object to send the data to another channel at the remote actor, the address of the channel is set before this method is called. An object of similar type at the remote actor is invoked with a receiveSelf() to receive the data. Returns \\(0\\) if successful (successful in that the data got to the channel), or a \\(-1\\) if no data was sent. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) =0; This is a pure virtual method, one must be written for each instantiable subclass of MovableObject. Each object has to receive the data needed to be able to recreate itself in the new process after it has been sent through theChannel . If the object is an aggregation containing other objects, new objects of the correct type can be constructed using theBroker . To return \\(0\\) if successful or a \\(-1\\) if not.","title":"MovableObject\n"},{"location":"developer/architecture/class_interface/Parallel/actor/message/Message/","text":"Message #include <actor/message/Message.h> class Message Messages are objects that can be sent between Channels. They are provided to allow data of arbitrary length and type, e.g. structs, to be sent between processes running on similar machine architectures. WARNING Sending Messages between machines with different architectures can result in erroniuos data being received. Each Message object keeps a pointer to the data it represents and an integer outlining the data size. There is no copy of the data kept by the Message. Constructors Destructor // Public Member Functions ; To construct an empty message. To construct a message for sending/receiving an array containing num doubles. To construct a message for sending/receiving an array containing num ints. To construct a message for sending/receiving a string of num characters or a struct. Does nothing. ; A method which will put the data given by the character pointer theData of size endLoc -startLoc into the data array pointed to by the Message starting at location \\(startLoc\\) in this array. Returns \\(0\\) if successful; an error message is printed and a \\(-1\\) is returned if not. The routine bcopy() is used to copy the data. virtual const char \\ * getData ( void ); A method which returns a const char * pointer to the messages data. virtual int getSize ( void ); A method to get the size of the array. The unit of size is that of a character.","title":"Message\n"},{"location":"developer/architecture/class_interface/Parallel/actor/objectBroker/FEM_ObjectBroker/","text":"FEM_ObjectBroker #include <actor/objectBroker/FEM_ObjectBroker.h> class FEM_ObjectBroker FEM_ObjectBrokers is an object used to create a new blank of a certain type in a process. The explicit type of object created depends on the method invoked and the integer classTag passed as an argument to the method. Once the object has been created, recvSelf() can be invoked on the object to instantiate the object with it\u2019s data. Constructor ### Destructor // Public Methods to get new Domain objects // Public Methods to get New Matrix,Vector and ID objects - NOT USED // Public Methods to get new Analysis objects - NOT NEEDED SEQUENTIAL // Public Methods for Parallel Model Generation Does nothing. Does nothing.","title":"FEM_ObjectBroker\n"},{"location":"developer/architecture/class_interface/Parallel/actor/objectBroker/ObjectBroker/","text":"ObjectBroker #include <ObjectBroker.h> class ObjectBroker ObjectBroker is an abstract class, i.e. no instances of ObjectBroker should exist. ObjectBrokers are objects in remote processes which create new objects in the remote process. It has one method virtual MovableObject \\ * getNewObject ( Channel & channel ) = 0 ; This method returns a pointer to an object of the type whose class type is given by the integer class ID value that is waiting at the Channel. The method must first instantiate the correct type of object, it then can invoke recv(channel) on this object. To get from a pointer of MovableObject to one of its descendents type casting must be used.","title":"ObjectBroker\n"},{"location":"developer/architecture/class_interface/Parallel/channel/Channel/","text":"Channel #include <actor/channel/Channel.h> class Channel Channel is an abstract class, i.e. no instances of Channel should exist. A Channel is a point of communication in a program, a mailbox to/from which data enters/leaves a program. Channels are objects through which the objects in the current processes address space can interact with objects in another processes address space. A channel in one process space is associated with a channel in the address space of another process space. The interaction is in the form of data sent between the two processes along the connection line. ### Constructor ### Destructor // Public Methods Does nothing. Does nothing. Provided so that a subclasses destructor will be invoked. When creating remote actors the channels created in the actor space need to know how to contact the shadows channels. This information is provided in the string returned from this method. It is used by the machine broker when starting the remote process. It places this information as the last arguments to the program. A method invoked in the local address space by a shadow object. The method is to be invoked concurrently with a setUpShadow() invocation on a channel object in all the remote actor processes. virtual int setUpActor ( void ) = 0 ; A method invoked in the remote address space by the actor. The method is invoked concurrently with a corresponding setUpShadow() invocation on a channel in a local actor process by the shadow object that created the running actor process. If the method fails returns a negative number. For actors with only one Channel this should cause the termination of the actor. virtual int setNextAddress ( ChannelAddress & theNextAddress ) = 0 ; A method invoked to set specify the next address that the next messages to be sent if sendMessage() or received if recvMessage() is invoked with a null pointer. To return the next available database tag, must be an integer value greater than \\(0\\) , \\(0\\) is used my the objects to check if they have yet been assigned a database tag. The method defined for the Channel base class always returns \\(0\\) , only database channel objects need worry about assigning unique integer values. To send the object theObject and the commit tag commitTag to a remote Channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. To receive the object theObject with the commit tag commitTag from a remote Channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel receives from the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method which is invoked to send the data in the Message object theMessage to another Channel object. The object will obtain the data and size of the data to be sent by invoking getData() and getSize() on theMessage . The channel object is then responsible for sending that data to the remote channel address given by theAddress . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method which is invoked to send the data in the Message object theMessage to another Channel object. The object will obtain the the size of the data that is being received by invoking getSize() on theMessage . The channel object is then responsible for receiving that amount of data from the channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel receives from the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a Matrix theMatrix to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a Matrix theMatrix from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a Vector theVector to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a Vector theVector from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a ID theID to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a ID theID from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not.","title":"Channel\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/LoadBalancer/","text":"LoadBalancer #include <domain/loadBalancer/LoadBalancer.h> class LoadBalancer A LoadBalancer is an object used to balance a PartitionedDomain. The LoadBalancer does this by invoking methods in the DomainPartitioner object with which it is associated. Constructor ### Destructor // Public Methods // Public Methods Sets the pointer to the associated PartitionedDomain to be \\(0\\) . Does nothing. Provided so the subclasses destructor will be called. Sets the pointer to the DomainPartitioner object associated with the LoadBalancer to point to thePartitioner . virtual int balance ( Graph & theWeightedGraph ) = 0 ; Each subclass must provide an implementation of this method. This method is invoked to balance the PartitionedDomain. The Graph theWeightedGraph is a weighted graph in which the vertices represent the Subdomains, the edges Subdomains sharing common boundary nodes and the weight the cost of the previous Subdomain calculations (determined by invoking getCost() on the Subdomains). Returns a pointer to the DomainPartitioner. If no DomainPartitioner has been set, a warning message is printed and \\(0\\) returned.","title":"LoadBalancer\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/ReleaseHeavierToLighterNeighbours/","text":"#include <domain/loadBalancer/ReleaseHeavierToLighterNeighbours.h> clas ReleaseHeavierToLighterNeighbours: public LoadBalancer LoadBalancer A ReleaseHeavierToLighterNeighbours is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. For numRelease times the Vertices of theWeightedGraph are iterated through. For each Vertex, \\(i\\) , releaseBoundary(i, theWeightedGraph, true, factorGreater) is invoked on the DomainPartitioner. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or releaseBoundary() returns a negative number.","title":""},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/ShedHeaviest/","text":"ShedHeaviest #include <domain/loadBalancer/ShedHeaviest.h> class ShedHeaviest: public LoadBalancer LoadBalancer A ShedHeaviest is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. The heaviest loaded partition, max , is first determined by iterating through the Graph theWeightedGraph looking at the vertex weights. Then releaseBoundary(max, theWieightedGraph, true, factorGreater) is invoked on the DomainPartitioner numRelease times. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or releaseBoundary() returns a negative number.","title":"ShedHeaviest\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/SwapHeavierToLighterNeighbours/","text":"SwapHeavierToLighterNeighbours #include <domain/loadBalancer/SwapHeavierToLighterNeighbours.h> class SwapHeavierToLighterNeighbours : public LoadBalancer LoadBalancer A SwapHeavierToLighterNeighbours is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. For numRelease times the Vertices of theWeightedGraph are iterated through. For each Vertex, \\(i\\) , the weight of the Vertex is compared to those of it\u2019s adjacent Vertices, \\(other\\) , (this is done by looping through the adjacency ID of the Vertex), if the vertex weight is factorGreater times greater than the other Vertices load then swapBoundary(i, other) is invoked on the DomainPartitioner. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or swapBoundary() returns a negative number.","title":"SwapHeavierToLighterNeighbours\n"},{"location":"developer/architecture/class_interface/Parallel/machineBroker/MachineBroker/","text":"MachineBroker #include <actor/machineBroker/MachineBroker.h> class MachineBroker MachineBrokers are objects that are used to start remote processes running on the parallel machine. Constructor ### Destructor // Public Member Functions Does nothing. Invoked to start the program, actorProgram , on the parallel machine. The remote actor process uses information supplied by theChannel to allow the remote process to connect to the local process. The integer compDemand provides an indication of the computational demands of the remote process in a heterogeneous environment.","title":"MachineBroker\n"},{"location":"developer/architecture/class_interface/Parallel/shadow/Shadow/","text":"Shadow #include <actor/shadow/Shadow.h> class Shadow Shadow is meant as an abstract class, i.e. no instances of Shadow should exist. A Shadow object is associated with an Actor object which may exist in another process. The Shadow acts like a normal object in the users address space, data and processing that is done by the Shadow may be stored and processed in a remote process, the Actor object resides in this remote address space. The Actor and the Shadow both have a Channel, a communication port. This allows the two to communicate with each other. Constructors Destructor // Protected Methods for Sending Objects to Remote Actor This constructor is used when the actor process is already up and running. The constructor sets its channel to be theChannel , its associated object broker to be theBroker , and the address to which it will send data to be thaActorsAddress . This constructor is used to get an actor process up and running. If startShadow is true , the constructor invokes startActor(program,theChannel,compDemand) on theMachineBroker object. It then invokes setUpShadow() on theChannel and getLastSendersAddress() on theChannel to set up store the address of the actors channel, theActorsAddress ; this is done in case multiple shadow objects use a single channel. If an error occurs an error message is printed and the program terminated. Does nothing. A method which will send the MovableObject theObject to the actor object through the shadows channel. It returns the result of invoking sendObj(0,0,theObject, theBroker, theActorsAddress) on the shadow\u2019s associated channel theChannel . virtual void recvObject ( MovableObject & theObject ); A method which will cause the object to read the MovableObject theObject from the channel. It will return the result of invoking recvObj(0,0,theObject, theBroker, theActorsAddress) on the shadows associated channel theChannel . A method which will send the message theMessage to the actor object through the shadows channel. It will return the result of invoking sendMsg(0,0,theMessage, theActorsAddress) on the shadows associated channel theChannel . virtual void recvMessage ( Message & theMessage ); A method which will cause the object to read the message theMessage from the channel. It will return the result of invoking recvMsg(0,0,theMessage, theActorsAddress) on the shadows associated channel theChannel . A method which will send the Matrix theMatrix to the actor object through the shadows channel. It will return the result of invoking sendMatrix(0,0,theMatrix, theActorsAddress) on the shadows associated channel theChannel . virtual void recvMatrix ( Matrix & theMatrix ); A method which will cause the object to read the Matrix theMatrix from the channel. It will return the result of invoking recvMatrix(0,0,theMatrix, theActorsAddress) on the shadows associated channel theChannel . A method which will send the Vector theVector to the actor object through the shadows channel. It will return the result of invoking sendVector(0,0,theVector, theActorsAddress) on the shadows associated channel theChannel . virtual void recvVector ( Vector & theVector ); A method which will cause the object to read the Vector theVector from the channel. It will return the result of invoking recvVector(0,0,theVector, theActorsAddress) on the shadows associated channel theChannel . A method which will send the ID theID to the actor object through the shadows channel. It will return the result of invoking sendID(0,0,theID, theActorsAddress) on the shadows associated channel theChannel . virtual void recvID ( ID & theID ); A method which will cause the object to read the ID theID from the channel. It will return the result of invoking recvID(0,0,theID, theActorsAddress) on the shadows associated channel theChannel . void Channel \\ * getChannelPtr ( void ) const ; A method which returns a pointer to the channel currently set. void FEM_ObjectBroker \\ * getObjectBrokerPtr ( void ) const ; A method which returns a pointer to the FEM_ObjectBroker passed in the constructor. void ObjectBroker \\ * getActorAddressPtr ( void ) const ; A method which returns a pointer to the channel in the actors address space.","title":"Shadow\n"},{"location":"developer/architecture/class_interface/analysis/","text":"Analysis Classes The Analysis object is an aggregation of objects of the following types: SolnAlgorithm : The solution algorithm object is responsible for orchestrating the steps performed in the analysis. AnalysisModel : The AnalysisModel object is a container class for storing and providing access to the following types of objects: DOF_Group : The DOF_Group objects represent the degrees-of-freedom at the Node s or new degrees-of-freedom introduced into the analysis to enforce the constraints. FE_Element : The FE_Element objects represent the Elements in the Domain or they are introduced to add stiffness and/or load to the system of equations in order to enforce the constraints. Integrator : The Integrator object is responsible for defining the contributions of the FE_Element s and DOF_Group s to the system of equations and for updating the response quantities at the DOF_Group s with the appropriate values given the solution to the system of equations. ConstraintHandler : The ConstraintHandler object is responsible for handling the constraints. It does this by creating FE_Element s and DOF_Group s of the correct type. DOF_Numberer : The DOF_Numberer object is responsible for mapping equation numbers in the system of equations to the degrees-of-freedom in the DOF_Group s.","title":"Analysis Classes\n"},{"location":"developer/architecture/class_interface/analysis/ConstraintHandler/","text":"ConstraintHandler #include <analysis/handler/ConstraintHandler.h> class ConstraintHandler : public MovableObject The ConstraintHandler class is an abstract base class. Its purpose is to define the interface common among all subclasses. A constraint handler is responsible for: creating the FE_Element and DOF_Group objects and adding them to the AnalysisModel. setting the initial dof equation numbers to \\(-1\\) , \\(-2\\) or \\(-3\\) . A \\(-1\\) indicates to the DOF_Numberer object that no equation number is to be allocated for this dof, a \\(-3\\) that this dof is to be among the last group of dof to be numbered. deleting the DOF_Group and FE_Element objects that it created. Constructor Destructor // Public Methods // Protected Methods The integer classTag is passed to the MovableObject constructor. Does nothing. Invoked to set the links that the ConstraintHandler will need. These include links to the Domain, theDomain , for which the ConstraintHandler object will apply the constraints and the AnalysisModel, theModel , to which the ConstraintHandler will add the FE_Element and DOF_Group objects. Invoked to handle the constraints imposed on the domain by the SP_Constraints and MP_Constraints. The ConstraintHandler object does this by instantiating the appropriate FE_Element and DOF_Group objects and adding them to the AnalysisModel. For all the dofs in each DOF_Group the ConstraintHandler sets initial equation numbers as either \\(-1\\) , \\(-2\\) or \\(-3\\) : A \\(-1\\) indicates to the DOF_Numberer object that no equation number is to be allocated for this dof, a \\(-2\\) that an equation number is to be given for the dof, and a \\(-3\\) that an equation number is to be allocated and that this dof is to be among the last group of dof to be numbered,i.e. all dof initially assigned a \\(-3\\) are to be given a higher equation number than those given a \\(-2\\) . Those dof with a \\(-3\\) should include all those dof associated with the nodes whose tags are in nodesToBeNumberedLast . Returns a positive number if successfully, a negative integer if not; the positive number is to be set at the number of dof assigned a value \\(-3\\) (this will be the number of external dof for a subdomain), the negative value of which depends on the type of ConstraintHandler. For subdomains the constraint handler is responsible for setting the FE_Element by calling setFE_elementPtr . virtual void clearAll ( void ) = 0 ; Invoked to inform the ConstraintHandler object that the FE_Elements and DOF_Groups it constructed are no longer part of the AnalysisModel. The ConstraintHandler can delete these objects if necessary; or the ConstraintHandler can store them and use them in subsequent calls to handle() . A const member function to return the Domain object associated with the ConstraintHandler, theDomain . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function to return the AnalysisModel object associated with the ConstraintHandler, theModel . Integrator \\ * getIntegratorPtr ( void ) const ; A const member function to return the Integrator object associated with the ConstraintHandler, theIntegrator .","title":"ConstraintHandler\n"},{"location":"developer/architecture/class_interface/analysis/DOF_Numberer/","text":"DOF_Numberer #include <analysis/numberer/DOF_Numberer.h> class DOF_Numberer : public MovableObject The DOF_Numberer class is a base class. Its purpose is to define the interface common among all subclasses. A DOF_Numberer object is responsible for assigning the equation numbers to the individual dofs in each of the DOF_Groups in the AnalysisModel. The base DOF_Numberer uses a GraphNumberer object to first number the DOF_Groups, based on the ordering of the DOF_Group objects, it assigns the equation numbers to the individual degrees-of-freedom. Subtypes may wish to implement the numbering in a more efficient manner by using the FE_Element and DOF_Group objects directly. Constructors ### Destructor // Public Methods // Protected Methods The integer NUMBERER_TAG_DOF_Numberer (defined in <classtags.h> ) is passed to the MovableObject classes constructor. Sets the GraphNumberer to be used in the numbering to theGraphNumberer() . Provided for subclasses. The integer classTag is passed to the MovableObject classes constructor. Provided for FEM_ObjectBroker. The integer NUMBERER_TAG_DOF_Numberer (defined in <classtags.h> ) is passed to the MovableObject classes constructor. Sets the GraphNumberer to be used in the numbering to be \\(0\\) , the GraphNumberer object is created and linked in a recvSelf() method invocation. Does nothing. Invoked to set a link to the AnalysisModel from which the DOF_Numberer will number (provide the equation number in the SystemOfEqn object) the degrees-of-freedoms in each DOF_Group objects. Invoked to assign the equation numbers to the dofs in the DOF_Groups and the FE_Elements, ensuring that the dof\u2019s in the DOF_Group whose tag is given by lastDOF_Group are numbered last in a \\(-2\\) or \\(-3\\) group. The initial values of these equation numbers have been set by the ConstraintHandler object to be \\(-1\\) , \\(-2\\) or \\(-3\\) , all dofs with a \\(-3\\) are to be assigned higher equation numbers than those assigned a \\(-2\\) . To set the numEqn in the AnalysisModel and to return the number of equations numEqn if successful, a negative number if not. This base class performs the ordering by getting an ID containing the ordered DOF_Group tags, obtained by invoking number(theModel- \\(>\\) getDOFGroupGraph(), lastDOF_Group) on the GraphNumberer, theGraphNumberer , passed in the constructor. The base class then makes two passes through the DOF_Group objects in the AnalysisModel by looping through this ID; in the first pass assigning the equation numbers incrementally to any degree-of-freedom marked with a \\(-2\\) and in the second pass assigning the equation numbers incrementally to any degree-of-freedom marked with a \\(-3\\) . It then iterates through the FE_Elements in the AnalsisModel invoking setID() on each object. Finally setNumEqn(numEqn) is invoked on the AnalysisModel. Return numEqn if successful, a warning message and a negative number is returned if an error occurs; \\(-1\\) is returned if setLinks() has not yet been invoked, \\(-2\\) if no GraphNumberer was passed in the constructor, \\(-3\\) if the number of DOF_Groups in AnalysisModel and size of ID returned are not the same, and a \\(-4\\) if there is no DOF_Group corresponding to one of the tags given in the ID. Invoked to assign the equation numbers to the dofs in the DOF_Groups and the FE_Elements, ensuring that the dof\u2019s in the DOF_Groups whose tag is given in lastDOF_Groups are numbered last in a \\(-2\\) or \\(-3\\) group. The initial values of these equation numbers have been set by the ConstraintHandler object to be \\(-1\\) , \\(-2\\) or \\(-3\\) , all dofs with a \\(-3\\) are to be assigned higher equation numbers than those assigned a \\(-2\\) . To set the numEqn in the AnalysisModel and to return the number of equations numEqn if successful, a negative number if not. This method in the base class is almost identical to the one just described. The only difference is that the ID identifying the order of the DOF_Groups is obtained by invoking number(theModel- \\(>\\) getDOFGroupGraph(), lastDOF_Groups) on the GraphNumberer. The DOF_Numberer sends the class identifier and database tag of the GraphNumberer in a ID to the channel, if no GraphNumberer is associated a \\(-1\\) is sent as the class tag. The object then invokes sendSelf() on the GraphNumberer. The DOF_Numberer receives the class identifier and database tag of the GraphNumberer in an ID from the channel, if no GraphNumberer is associated a \\(-1\\) is received. The DOF_Numberer will then ask theBroker for a GraphNumberer with that class identifier, it sets the database tag for the GraphNumberer and it then invokes recvSelf() on that GraphNumberer. A const member function to return the AnalysisModel object associated with the DOF_Numberer, theModel . A const member function to return the GraphNumberer object associated with the DOF_Numberer, theGraphNumberer .","title":"DOF_Numberer\n"},{"location":"developer/architecture/class_interface/analysis/algorithm/EquiSolnAlgo/","text":"EquiSolnAlgo #include <analysis/algorithm/equiSolnAlgo/EquiSolnAlgo.h> class EquiSolnAlg : public SolutionAlgo MovableObject SolutionAlgorithm The EquiSolnAlgo class is an abstract base class. Its purpose is to define the interface common among all subtypes. An EquiSolnAlgo object defines the sequence of operations performed by the the Integrator and the LinearSOE objects in solving the equilibrium equation \\(R(U) = 0\\) given the current state of the domain at each time step in a direct integration analysis or load increment in a static analysis. Constructor Destructor // Public Methods // Public Methods for Output // Public Methods for Pointers - not Protected for ConvergenceTest The integer classTag is passed to the SolutionAlgorithm classes constructor. Does nothing. Sets up the links needed by an object of this class, or a derived class, to an AnalysisMode, IncrementalIntegrator and LinearSOE object. Pointers to these objects can be obtained by subtypes using the protected methods defined below. A method implemented by each subclass which specifies the steps taken in order to get the system into an equilibrium state. It is a pure virtual function, i.e. all subclasses or their descendents must implement this routine. To return \\(0\\) if algorithm succeeds, a negative value otherwise. The Integrator is to send information to the stream based on the integer flag . A const member function which returns a pointer to the AnalysisModel associated with the EquiSolnAlgo object, theModel passed in setLinks() . \\(0\\) returned if one not yet associated. IncrementalIntegrator \\ * getIncrementalIntegratorPtr ( void ) const ; A const member function which returns a pointer to the StaticMethod associated with the StaticSolnAlgo object, theIntegrator passed in setLinks() . \\(0\\) returned if one not yet associated. LinSysOfEqn \\ * getLinearSOEptr ( void ) const ; A const member function which returns a pointer to the LinearSOE associated with the EquiSolnAlgo object, theLinearSOE passed in setLinks() . \\(0\\) returned if one not yet associated.","title":"EquiSolnAlgo\n"},{"location":"developer/architecture/class_interface/analysis/algorithm/SolutionAlgorithm/","text":"SolutionAlgorithm #include <analysis/algorithm/SolutionAlgorithm.h> class SolutionAlgorithm : public MovableObject The SolutionAlgorithm class is an abstract base class. Its purpose is to define the interface common among all its subclasses. A SolutionAlgorithm object performs the steps in the analysis by specifying the sequence of operations to be performed by members in the analysis aggregation. Constructor Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. Invokes the destructor on any recorder object added to the SolutionAlgorithm and releases memory used to hold pointers to the recorder objects. Is called by the Analysis if the domain changes. It is called after domainChange() has been called on the ConstraintHandler , DOF_Numberer and the Integrator and after setSize() has been called on the SystemOfEqn object. For base class nothing is done and \\(0\\) is returned. The subclasses can provide their own implementation of this method if anything needs to be done, e.g. memory allocation, To return \\(0\\) if successful, a negative number if not. To add a recorder object theRecorder to the SolutionAlgorithm. returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if not enough memory is available. To invoke record(track) on any Recorder objects which have been added to the SolutionAlgorithm . To invoke playback(track) on any Recorder objects which have been added to the SolutionAlgorithm .","title":"SolutionAlgorithm\n"},{"location":"developer/architecture/class_interface/analysis/analysis/Analysis/","text":"Analysis #include <analysis/analysis/Analysis.h> class Analysis ; The Analysis class is an abstract base class. Each Analysis object will be associated with a single Domain, the Domain upon which it will perform the analysis operations. The base Analysis class holds a pointer to this Domain and will return this pointer to subclasses. Constructors and Destructor Analysis(theDomain &theDomain); All analysis are associated with a single domain, this constructor sets up the link between the analysis and the domain. virtual ~ Analysis (); Does nothing. Provided so that the subclasses destructor will be invoked. Pure Virtual Public Member Functions virtual int domainChanged ( void ) = 0 ; Invoked to inform the analysis that the finite element model has changed, for example when new elements have been added. It is also a virtual function. To return \\(0\\) if successful, a negative number if not. Protected Method Domain * getDomainPtr ( void ); Returns a pointer to the domain that was passed in the constructor.","title":"Analysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DirectIntegrationAnalysis/","text":"DirectIntegrationAnalysis #include <analysis/analysis/DirectIntegrationAnalysis.h> class DirectIntegrationAnalysis : public TransientAnalysis ; Analysis TransientAnalysis DirectIntegrationAnalysis is a subclass of TransientAnalysis. It is used to perform a transient analysis using an incremental approach on the Domain. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors. TransientIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. EquiSolnAlgo - an algorithmic class specifying the sequence of operations to be performed in setting up and solving the finite element equation which can be represented by the equation K(U) U = P(U). Constructor ### Destructor // Public Methods // Public Methods to vary the type of Analysis tStart , tFinish and thDomain are passed to the TransientAnalysis class constructor. The constructor is responsible for setting up all links needed by the objects in the aggregation. It invokes setLinks(theDomain) on theModel , setLinks(theDomain,theModel,theIntegrator) on theHandler , setLinks(theModel) on theNumberer , setLinks ( theModel , theSOE ) on theIntegrator and setLinks(theModel,theAnalysis, theIntegrator, theSOE) on theSolnAlgo . Does nothing. clearAll() must be invoked if the destructor on the objects in the aggregation need to be invoked. Invoked to perform a transient analysis on the FE_Model. The method checks to see if the domain has changed before it performs the analysis. The DirectIntegrationAnalysis object performs the following: while \u0304 while w\u0304hile \u0304 double time = tStart; while (theDomain- \\(>\\) getCurrntTime() \\(<\\) tFinish) { if (theDomain- \\(>\\) hasDomainChanged() == true) this- \\(>\\) domainChanged(); theIntegrator- \\(>\\) newStep( \\(\\delta t\\) ); theAlgorithm- \\(>\\) solveCurrentStep(); theIntegrator- \\(>\\) commit(); } The type of analysis performed, depends on the type of the objects in the analysis aggregation. If any of the methods invoked returns a negative number, an error message is printed, revertToLastCommit() is invoked on the Domain, and a negative number is immediately returned. Returns a \\(0\\) if the algorithm is successful. void clearAll ( void ); Will invoke the destructor on all the objects in the aggregation. NOTE this means they must have been constructed using new() , otherwise a segmentation fault can occur. void domainChange ( void ); This is a method invoked by a domain which indicates to the analysis that the domain has changed. The method invokes the following: It invokes clearAll() on theModel which causes the AnalysisModel to clear out its list of FE_Elements and DOF_Groups, and clearAll() on theHandler . It then invokes handle() on theHandler . This causes the constraint handler to recreate the appropriate FE_Element and DOF_Groups to perform the analysis subject to the boundary conditions in the modified domain. It then invokes number() on theNumberer . This causes the DOF numberer to assign equation numbers to the individual dof\u2019s. Once the equation numbers have been set the numberer then invokes setID() on all the FE_Elements in the model. Finally the numberer invokes setNumEqn() on the model. It then invokes domainChanged() on theIntegrator and theAlgorithm to inform these objects that changes have occurred in the model. It invokes setSize ( theModel . getDOFGraph ()) on theSOE which causes the system of equation to determine its size based on the connectivity of the dofs in the analysis model. Finally it invokes domainChanged() on theIntegrator and theAlgorithm . Returns \\(0\\) if successful. At any stage above, if an error occurs the method is stopped, a warning message is printed and a negative number is returned. int setDeltaT ( double $ \\delta t $ ); Sets the time increment used in the analyze() method to \\(\\delta t\\) . Returns \\(0\\) . To change the algorithm between analysis. It first invokes the destructor on the old SolutionAlgorithm object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new SolutionAlgorithm. Returns \\(0\\) if successful, a warning message and a negative number if not. To change the integration scheme between analysis. It first invokes the destructor on the old Integrator object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . It also invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new Integrator. Returns \\(0\\) if successful, a warning message and a negative number if not. To change the linear system of equation object between analysis. It first invokes the destructor on the old LinearSOE object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newSOE . links for this object by invoking setLinks() . It then invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes setSize() on the new LinearSOE. Returns \\(0\\) if successful, a warning message and a negative number if not.","title":"DirectIntegrationAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DomainDecompositionAnalysis/","text":"DomainDecompositionAnalysis UNDER CONSTRUCTION #include <analysis/analysis/DomainDecompositionAnalysis.h> class DomainDecompositionAnalysis : public Analysis , public MovableObject ; \\ Analysis\\ MovableObject\\ DomainDecompositionAnalysis is a subclass of Analysis, it is used when performing an analysis using the domain decomposition method to solve the equations. Its public member functions are all virtual to allow for the generalization of the class. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where A is a matrix, and x and b are vectors. IncrementalIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. DomainDecompositionAlgo - an algorithmic class specifying the sequence of operations to be performed in determining the response for the external dof and placing these in the system of equations. DomainSolver - an algorithmic class specifying the sequence of operations to be performed in performing the numerical operations. ### Destructor // Public Methods // Protected Member Functions The constructor sets all the links required by the objects in the aggregation. To do this it invokes setLinks(theDomain) on theModel , setLinks(theSubdomain,theModel,theIntegrator) on theHandler , setLinks(theModel) on theNumberer , it invokes setLinks(theModel, theSOE) on theIntegrator , and it invokes setLinks(theModel,theIntegrator, theSOE,theSolver,theSubdomain) on theSolnAlgo . Finally it invokes setAnalysis ( \\ * this ) on theSubdomain . A constructor that is used when creating a DomainDecompositionObject which is to receive itself afterwards. Sets the links to the Subdomain. It is essential that this object recvSelf() before DomainDecompositionAnalysis methods are invoked as their invocation will cause segmentation faults. Invokes setAnalysis(this) on the Subdomain. DomainDecompositionAnalysis ( int classTag , Subdomain & theDomain ); Provided for subclasses to use. Invokes setAnalysis(this) on the Subdomain. Causes an error message to be output and returns \\(-1\\) . virtual void domainChanged ( void ); Method used to inform the object that the domain has changed. The DomainDecompositionAnalysis object then performs the following: theAnalysisModel- \\(>\\) clearAll(), theConstraintHandler- \\(>\\) clearAll(); numExtEqn = theConstraintHandler- \\(>\\) handle(theSubdomain- \\(>\\) getExternalNodes()); theDOFnumberer- \\(>\\) number(theExternalDOFsDOFGrps); theLinSysOfEqn- \\(>\\) setSize(theAnalysisModel- \\(>\\) getDOFGraph); theIntegrator- \\(>\\) domainChanged(); theAlgorithm- \\(>\\) domainChanged(); Finally tangFormed is marked as false . int getNumExternalEqn ( void ); A method to return the number of external degrees-of-freedom on the Subdomain interface, this information is returned when handle() is invoked on theConstraintHandler . virtual int computeInternalResponse ( void ); A method which invokes solveCurrentStep() on theAlgorithm . virtual int formTangent ( void ); A method to form the condensed tangent matrix, given the current number of internal dof. It first checks to see if the Subdomain has changed, by invoking hasDomainChanged() on the Subdomain; if it has invokeChangeOnAnalysis() is invoked on the Subdomain . It then checks to see if counter is equal to \\(-1\\) or not; a \\(-1\\) indicating the tangent has already been formed in order that the residual could be determined. If this is not the case formTangent() is invoked on theIntegrator , condenseA() is invoked on theSolver object, a flag is set to indicate that the tangent has been formed, and the counter is incremented. Returns a \\(0\\) if successful, if either the formTangent() or condenseA() method returns a negative number this number is returned. virtual int formResidual ( void ); A method to form the condensed residual vector, given the current number of internal dof. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed it invokes formTangent() on itself and sets the counter to \\(-1\\) . To form the residual formUnbalance() is invoked on theIntegrator and condenseRHS(numInt) is invoked on theSolver . Returns \\(0\\) or the negative number that was returned if either formUnbalance() or condenseRHS() failed. int formTangVectProduct ( Vector & u ); A method to form the product of the condensed tangent matrix times the vector \\(u\\) . A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed it invokes formTangent() on itself and sets the counter to \\(-1\\) . Finally the result of invoking computeCondensedMatVect ( numInt , u ) on theSolver is returned. virtual Matrix & getTangent (); A method which returns the portion of A corresponding to internal equation numbers. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed formTangent() is invoked. The method returns the result of invoking getCondensedA() on theSolver() . virtual Vector & getResidual (); A method which returns the portion of the \\(b\\) corresponding to the external equation numbers. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain and formResidual() is called. The object returns the Vector obtained from invoking getCondensedRHS() on the solver. const Vector & getTangVectProduct (); Returns the result of invoking getCondensedMatVect() on the solver. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . The object returns the Vector obtained from invoking getCondensedMatVect() on theSolver . int sendSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID and populates the ID with the class tags of the aggregates in the aggregation. This ID is sent and then sendSelf(theChannel,theBroker) is invoked on each of the aggregates. Returns 0. int recvSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID and receives data into it from theChannel . Based on the class tags in the ID theBroker is then asked to return pointers to new objects required in the aggregation. sendSelf ( theChannel , theBroker ) is invoked on each of these new aggregate objects. Finally setLinks is invoked on each of these objects with the correct arguments and setAnalysis(this) is invoked on the Subdomain . Returns 0. A const member function which returns a pointer to theSubdomain . ConstraintHandler \\ * getConstraintHandlerPtr ( void ) const ; A const member function which returns a pointer to theSubdomain . DOF_Numberer \\ * getDOF_NumbererPtr ( void ) const ; A const member function which returns a pointer to theNumberer . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function which returns a pointer to theModel . DomainDecompAlgo \\ * getDomainDecompAlgoPtr ( void ) const ; A const member function which returns a pointer to theAlgorithm . IncrementalIntegrator \\ * getIncrementalIntegratorPtr ( void ) const ; A const member function which returns a pointer to theIntegrator . LinearSOE \\ * getLinSOEPtr ( void ) const ; A const member function which returns a pointer to theSOE . A const member function which returns a pointer to theSolver . associated with the DomainDecompositionAnalysis object.","title":"DomainDecompositionAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DomainUser/","text":"DomainUser #include <DomainUser.h> class DomainUser ; Analysis Design DomainDisplay The DomainUser class is an abstract base class. Its purpose is to define the interface common among all subclasses. A DomainUser is a user of the domain, example subtypes being Analysis and Design. The class defines the pure virtual function domainChange() : it is this method that is invoked by the domain on all domain users once the domain has changed, i.e. the connectivity has changed. All DomainUser are associated with a single domain, this constructor sets up the link between the DomainUser and the domain, setting its link with theDomain. The constructor invokes addDomainUser ( \\ * this ) on the domain. All DomainUser are associated with a single domain, the destructor removes the link in the domain by invoking removeDomainUser ( \\ * this ) on the domain. Invoked by the associated domain to inform the domainUser that the connectivity of the domain has changed. A const method which returns a pointer to the Domain object on which the DomainUser performs its DomainUser.","title":"DomainUser\n"},{"location":"developer/architecture/class_interface/analysis/analysis/StaticAnalysis/","text":"StaticAnalysis #include <analysis/analysis/StaticAnalysis.h> class StaticAnalysis : public Analysis ; Description StaticAnalysis is a subclass of Analysis , it is used to perform a static analysis on the Domain. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors. StaticIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. EquiSolnAlgo - an algorithmic class specifying the sequence of operations to be performed in setting up and solving the finite element equation which can be represented by the equation K(U) U = P(U). Class Interface Constructors StaticAnalysis ( Domain & theDomain , ConstraintHandler & theHandler , DOF_Numberer & theNumberer , AnalysisModel & theModel , EquiSolnAlgo & theSolnAlgo , LinearSOE & theSOE , StaticIntegrator & theIntegrator , int numIncrements = 1 ); The constructor is responsible for setting the links between the objects in the aggregation. To do this it invokes setLinks(theDomain) on theModel , setLinks ( theDomain , theModel , theIntegrator ) on theHandler , setLinks(theModel) on theNumberer , setLinks(theModel, theSOE) on theIntegrator , and setLinks(theModel,theAnalysis, theIntegrator, theSOE) on theSolnAlgo . The constructor also sets the number of analysis steps that will be performed to be numIncrements . Destructor Does nothing. clearAll() must be invoked if the destructor on the objects in the aggregation need to be invoked. Public Methods int analyze ( int numSteps ); Invoked to perform a static analysis on the FE_Model. The analysis The StaticAnalysis object performs the following: // while \u0304 while w\u0304hile \u0304 for ( int i = 0 ; i < numSteps ; i ++) { if ( theDomain -> hasDomainChanged () == true ) this -> domainChanged (); theIntegrator . newStep (); theSolnAlgo . solveCurrentStep (); theIntegrator . commit (); } The type of analysis performed, depends on the type of the objects in the analysis aggregation. If any of the methods invoked returns a negative number, an error message is printed, revertToLastCommit() is invoked on the Domain, and a negative number is immediately returned. Returns a \\(0\\) if the algorithm is successful. void clearAll ( void ); Will invoke the destructor on all the objects in the aggregation. NOTE this means they must have been constructed using new() , otherwise a segmentation fault can occur. int domainChange ( void ); This is a method invoked by the analysis during the analysis method if the Domain has changed. The method invokes the following: It invokes clearAll() on theModel which causes the AnalysisModel to clear out its list of FE_Elements and DOF_Groups , and clearAll() on theHandler . It then invokes handle() on theHandler . This causes the constraint handler to recreate the appropriate FE_Element and DOF_Groups to perform the analysis subject to the boundary conditions in the modified domain. It then invokes number() on theNumberer . This causes the DOF numberer to assign equation numbers to the individual dof\u2019s. Once the equation numbers have been set the numberer then invokes setID() on all the FE_Elements in the model. Finally the numberer invokes setNumEqn() on the model. It invokes setSize ( theModel . getDOFGraph ()) on theSOE which causes the system of equation to determine its size based on the connectivity of the dofs in the analysis model. Finally domainChanged() is invoked on both theIntegrator and theAlgorithm . Returns 0 if successful. At any stage above, if an error occurs the method is stopped, a warning message is printed and a negative number is returned. Public Methods to vary the type of Analysis int setNumIncrements ( int numIncrements ); To set the number of incremental steps in the analysis to be numIncrements . Returns \\(0\\) . int setAlgorithm ( EquiSolnAlgo & theAlgorithm ); To change the algorithm between analysis. It first invokes the destructor on the old SolutionAlgorithm object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new SolutionAlgorithm. Returns \\(0\\) if successful, a warning message and a negative number if not. int setIntegrator ( StaticIntegrator & theIntegrator ); To change the integration scheme between analysis. It first invokes the destructor on the old Integrator object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . It also invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new Integrator. Returns \\(0\\) if successful, a warning message and a negative number if not. int setLinearSOE ( LinearSOE & theSOE ); To change the linear system of equation object between analysis. It first invokes the destructor on the old LinearSOE object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newSOE . links for this object by invoking setLinks() . It then invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes setSize() on the new LinearSOE. Returns \\(0\\) if successful, a warning message and a negative number if not.","title":"StaticAnalysis"},{"location":"developer/architecture/class_interface/analysis/analysis/SubstructuringAnalysis/","text":"SubstructuringAnalysis #include </analysis/analysis/SubstructuringAnalysis.h> class SubstructuringAnalysis : public DomainDecompositionAnalysis ; MovableObject Analysis DomainDecompositionAnalysis SubstructuringAnalysis is a subclass of DomainDecompositionAnalysis. It is used when performing an analysis using the substructuring method. It differs from the DomainDecompositionAnalysis class only in that the constructor ensures that a SubstructuringSolver is given for the Solver. The constructor is responsible for ensuring a Substructuring solver is passed in as an argument. The base class does the rest. For this reason WE WILL FORGET THIS CLASS. Invokes removeDomainUser(this) on the domain object.","title":"SubstructuringAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/TransientAnalysis/","text":"TransientAnalysis #include <analysis/analysis/TransientAnalysis.h> class TransientAnalysis : public Analysis ; The TransientAnalysis class is an abstract class. Its purpose is to define the interface common among all subclasses. A TransientAnalysis object is responsible for performing a transient analysis on the domain. Constructor Destructor // Public Methods // Protected Data The Domain theDomain is passed to the Analysis classes constructor. Sets the starting time and finishing time for the transient analysis to tStart and tFinish . Does nothing. Invoked to perform a dynamic analysis on the model. The type of analysis performed, depends on the type of the objects in the analysis aggregation. Returns a \\(0\\) if successful, otherwise a negative number is returned; the value of which depends on the type of the analysis. virtual void setTimeStart ( double tStart ); To set the starting time of the TransientAnalysis to tStart . It invokes setCurrntTime(tStart) on the associated domain object. virtual void setTimeFinish ( double tFinish ); To set the finishing time of the TransientAnalysis to tFinish .","title":"TransientAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/convergenceTest/ConvergenceTest/","text":"#include \\(<\\tilde{}\\) /convergenceTest/ConvergenceTest.h \\(>\\) class ConvergenceTest: public MovableObject MovableObject A ConvergenceTest object is an object which can be used in an algorithmic class to test if convergence has been achieved for an iteration. The ConvergenceTest class is an abstract class, defining the interface that all subclasses must provide. The integer classTag is passed to the MovableObject constructor. Does nothing. To set the corresponding EquiSolnAlgo class. To return a postive number if the convergence criteria defined for the object has been satisfied, the positibe number equal to the number of times since start that test() has been invoked. Otherwise a negative number is to be returned. A -2 is returned if the test fails to meet the criteria and no more tests are to be performed due to limits set, i.e. the maximum number of iterations, otherwise a -1 is to be returned. This is invoked at the start of each iteration. To return 0 if sucessfull, i.e that testing can proceed, a negative number if not.","title":""},{"location":"developer/architecture/class_interface/analysis/integrator/CentralDifference/","text":"CentralDifference #include <analysis/integrator/CentralDifference.h> class CentralDifference : public TransientIntegrator MovableObject Integrator IncrementalIntegrator CentralDifference is a subclass of TransientIntegrator which implements the CentralDifference method. In the CentralDifference method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , the equilibrium equation (expressed for the TransientIntegrator) is typically solved at time \\(t\\) for \\({\\bf U}_{t+\\Delta t}\\) , i.e. solve: \\[{\\bf R} ({\\bf U}_{t+ \\Delta t}) = {\\bf P}(t) - {\\bf F}_I(\\ddot{\\bf U}_{t}) - {\\bf F}_R(\\dot{\\bf U}_{t},{\\bf U}_{t})\\] where we use following to relate \\(\\dot{\\bf U}_{t}\\) and \\(\\ddot{\\bf U}_{t}\\) to \\({\\bf U}_{t}\\) and the displacement quantities at times \\(t\\) and \\(t - \\Delta t\\) : \\[\\dot {\\bf U}_{t} = \\frac{1}{2 \\Delta t} \\left( {\\bf U}_{t + \\Delta t} - {\\bf U}_{t - \\Delta t} \\right)\\] \\[\\ddot {\\bf U}_{t} = \\frac{1}{\\Delta t^2} \\left( {\\bf U}_{t + \\Delta t} - 2 {\\bf U}_t + {\\bf U}_{t - \\Delta t}\\right)\\] which results in the following \\[\\left[ \\frac{1}{\\Delta t^2} {\\bf M} + \\frac{1}{2 \\Delta t} {\\bf C} \\right] {\\bf U}_{t + \\Delta t} = {\\bf P}(t) - F_I \\left(\\ddot{\\bf U}_t^{(i-1)} \\right) -F_R\\left( \\dot{\\bf U}_t^{(i-1)}, {\\bf U}_t)\\right)\\] Constructors Destructor // Public Methods // Public Methods for Output Sets \\(\\gamma\\) to \\(1/2\\) and \\(\\beta\\) to \\(1/4\\) . Sets a flag indicating whether the incremental solution is done in terms of displacement, \\(\\Delta \\U\\) , if dispFlag is true , or acceleration, \\(\\Delta \\ddot \\U\\) , if dispFlag is false . Sets \\(\\gamma\\) to gamma and \\(\\beta\\) to beta . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag . Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 {\\bf K} + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1) theEle- \\(>\\) addCtoTang(c2) theEle- \\(>\\) addMtoTang(c3) int formNodTangent ( DOF_Group \\ * theDof ); The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() theDof- \\(>\\) addMtoTang(c3) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE- \\(>\\) getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\Delta t $ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 depending on the flag indicating whether incremental displacements or accelerations are being solved for at each iteration. If dispFlag was true , c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta * deltaT)\\) and c3 to \\(1/ (\\beta * deltaT^2)\\) . If the flag is false c1 is set to \\(\\beta * deltaT^2\\) , c2 to \\(\\gamma * deltaT\\) and c3 to \\(1.0\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . Then the velocity and accelerations approximations at time \\(t + \\delta t\\) are set using the difference approximations if dispFlag was true . (displacement and velocity if false ). The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with new quantities for time \\(t + \\Delta t\\) . current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\Delta U $ ); Invoked this causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response at the DOF_Group objects are then updated by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\delta U\\) are of different sizes. int sendSelf(int commitTag, Channel &theChannel); Places the \\(\\beta\\) and \\(\\gamma\\) and dispFlag into a vector if size 3 and invokes sendVector on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 3 the values of \\(\\beta\\) , \\(\\gamma\\) and dispFlag . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\gamma\\) and \\(\\beta\\) .","title":"CentralDifference\n"},{"location":"developer/architecture/class_interface/analysis/integrator/DisplacementControl/","text":"DisplacementControl UNDER CONSTRUCTION. #include <analysis/integrator/DisplacementControl.h> class DisplacementControl : public StaticIntegrator MovableObject Integrator IncrementalIntegrator DisplacementControl is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the displacement control method. In the displacement control method the displacement at a specified degree-of-freedom Uc is specified for each iteration. The following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[Uc_n^{(i)} - Uc_{n-1} = \\delta Uc_n\\] where \\(\\delta Uc_n\\) depends on \\(\\delta Uc_{n-1}\\) , the displacement increment at the previous time step, \\(J_{n-1}\\) , the number of iterations required to achieve convergence in the previous load step, and \\(Jd\\) , the desired number of iteraions. \\(\\delta Uc_n\\) is bounded by \\(\\delta Uc_{min}\\) and \\(\\delta Uc_{max}\\) . \\[\\delta Ucn = max \\left( \\delta Uc{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta Uc{n-1}, \\delta Uc{max} \\right) \\right)\\] SOME THEORY. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_DisplacementControl (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. \\(\\delta Uc_1\\) is the load factor used in the first step. The arguments \\(Jd\\) , \\(\\delta Uc_{min}\\) , and \\(\\delta Uc_{max}\\) are used in the determination of the increment in the load factor at each step. Does nothing. int newStep ( void ); WHAT DO I DO? int update ( const Vector & $ \\Delta U $ ); WHAT DO I DO? int sendSelf(int commitTag, Channel &theChannel); WHAT DO I DO? int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); WHAT DO I DO? int Print ( OPS_Stream & s , int flag = 0 ); WHAT DO I DO?","title":"DisplacementControl\n"},{"location":"developer/architecture/class_interface/analysis/integrator/IncrementalIntegrator/","text":"IncrementalIntegrator #include <analysis/integrator/IncrementalIntegrator.h> class IncrementalIntegrator: public Integrator MovableObject Integrator IncrementalIntegrator is an abstract class. A subclass of it is used when performing a static or transient analysis using an incremental displacement approach. Subclasses of IncrementalIntegrators provide methods informing the FE_Element and DOF_Group objects how to build the tangent and residual matrices and vectors. They also provide the method for updating the response quantities at the DOFs with appropriate values; these values being some function of the solution to the linear system of equations. Constructor ### Destructor // Public Methods // Public Method added for Domain Decomposition // Protected Methods The integer classTag is passed to the Integrator classes constructor. Pointers to the AnalysisModel and LinearSOE are set to \\(0\\) . Does nothing. Invoked by the Analysis object to set up the links the IncrementalIntegrator objects needs to perform its operations. Sets the pointers to the AnalysisModel and LinearSOE objects to point to theAnalaysisModel and theSOE . virtual int formTangent ( void ); Invoked to form the structure tangent matrix. The method first loops over all the FE_Elements in the AnalysisModel telling them to form their tangent and then it loops over the FE_Elements again adding the tangent to the LinearSOE objects A matrix. It performs the following: while \u0304 while w\u0304hile \u0304 FE_EleIter &theEles = theAnalysisModel.getFEs(); theSOE.zeroA(); while((elePtr = theEles1()) \\(\\neq\\) 0) if (theSOE.addA(elePtr- \\(>\\) getTangent(this), elePtr- \\(>\\) getID(), \\(1.0\\) ) \\(<\\) 0) return \\(-1\\) ; Returns \\(0\\) if successful, otherwise an error message is printed an a \\(-1\\) is returned if setLinks() has not been called, or \\(-2\\) if failure to add an FE_Elements tangent to the LinearSOE. The two loops are introduced to allow for efficient parallel programming. THIS MAY CHANGE TO REDUCE MEMORY DEMANDS. virtual int formUnbalance ( void ); Invoked to form the unbalance. The method fist zeros out the \\(B\\) vector of the LinearSOE object and then invokes formElementResidual() and formNodalUnbalance() on itself. while \u0304 while w\u0304hile \u0304 theSOE.zeroB(); this- \\(>\\) fromElementResidual(); this- \\(>\\) formNodalUnbalance() If an error occurs in either of these two methods or if setLinks() has not been called, an error message is printed and a negative number is returned. Returns \\(0\\) if successful. To inform the FE_Element how to build its tangent matrix for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int formEleResidual ( FE_Element \\ * theEle ) = 0 ; To inform the FE_Element how to build its residual vector for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int formNodTangent ( DOF_Group \\ * theDof ) = 0 ; To inform the DOF_Group how to build its tangent matrix for addition to the system of equations. The subclasses must provide the implementation of this method. This is required in transient analysis as th Node objects have mass. THIS MAY CHANGE. virtual int formNodUnbalance ( DOF_Group \\ * theDof ) = 0 ; To inform the DOF_Group how to build its residual vector for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int update ( const Vector & $ \\Delta U $ ) = 0 ; When invoked causes the integrator object to update the DOF_Group responses with the appropriate values based on the computed solution to the system of equation object. The subclasses must provide an implementation of this method. virtual int commit ( void ) = 0 ; Invoked by the SolutionAlgorithm to inform the Integrator that current state of domain is on solution path. Returns the result of invoking commitDomain() on the AnalysisModel object associated with the Integrator. Returns in result values for the last solution to the system of equation object whose location in the solution vector is given by id . For a location specified by a negative integer in id 0.0 will be returned in result . Returns a \\(0\\) if successful, a warning message and a negative number is returned if an error occurs. \\(-1\\) if setSize() has not been called and a \\(-2\\) if location in id is greater than \\(order-1\\) of \\(b\\) vector. A const member function which returns a pointer to the LinearSOE associated with the IncrementalIntegrator object, i.e. theSOE passed in setLinks() . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function which returns a pointer to the AnalysisModel associated with the IncrementalIntegrator object, i.e. theModel passed in setLinks() . virtual int formNodalUnbalance ( void ); The method first loops over all the DOF_Group objects telling them to form their unbalance and then adds this Vector to the \\(b\\) vector of the LinearSOE object, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 DOF_EleIter &theDofs = theAnalysisModel.getDOFs(); theSOE.zeroB(); while((dofPtr = theDofs()) \\(\\neq\\) 0) theSOE.addB(dofPtr- \\(>\\) getUnbalance(theIntegrator), dofPtr- \\(>\\) getID()) Returns \\(0\\) if successful, otherwise a negative number is returned and a warning message is printed if an error occurred. Note, no test is made to ensure setLinks() has been invoked. virtual int formElementResidual ( void ); Invoked to form residual vector (the C vector in theSOE). The method iterates twice over the FE_elements in the AnalysisModel, the first time telling the FE_Elements top form their residual and the second time to add this residual to the LinearSOE objects \\(b\\) vector, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 FE_EleIter &theEles = theAnalysisModel.getFEs(); while((elePtr = theEles()) \\(\\neq\\) 0) { theSOE.addA(elePtr- \\(>\\) getResidual(this), elePtr- \\(>\\) getID()) Returns \\(0\\) if successful, otherwise a warning message is printed and a negative number is returned if an error occurs. Note, no test is made to ensure setLinks() has been invoked.","title":"IncrementalIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/Integrator/","text":"Integrator #include <analysis/integrator/Integrator.h> class Integrator : public MovableObject ; MovableObject The Integrator class is an abstract base class. Its purpose is to define the interface common among all subclasses. An integrator method is responsible for defining how the system of equations are set up (this it does by specifying how the FE_Element and DOF_Group objects of the analysis model construct the vectors and matrices asked of them by the Analysis). It is also responsible for updating the response quantities at the DOFs with the appropriate values; the values are determined from the solution to the system of equations. Constructor Destructor // Public Methods // Public Method added for Domain Decomposition // Public Method added for Output classTag is passed to the MovableObject classes constructor. Does nothing. Provided so the subclass destructors will be invoked. Is called by the Analysis object. Refer to the Analysis classes to see when it is invoked. To return \\(0\\) if successful, a negative number if not. This base class returns \\(0\\) . Called upon to determine the FE_Element theEle s matrix contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the DOF_Group theDof s matrix contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the FE_Element theEle s vector contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the DOF_Group theDof s vector contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. virtual int getLastResponse ( Vector & result , const ID & id ) = 0 ; Called upon to get the result quantities for the components specified in the ID id and to place them in the Vector result . This is provided for domain decomposition methods. To return \\(0\\) if successful, a negative number otherwise. The Integrator is to send information to the stream based on the integer flag .","title":"Integrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/LoadControl/","text":"LoadControl #include <analysis/integrator/LoadControl.h> class LoadControl: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadControl is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the load control method. In the load control method, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = \\delta \\lambda_n\\] where \\(\\delta \\lambda_n\\) depends on \\(\\delta \\lambda_{n-1}\\) , the load increment at the previous time step, \\(J_{n-1}\\) , the number of iterations required to achieve convergence in the previous load step, and \\(Jd\\) , the desired number of iteraions. \\(\\delta \\lambda_n\\) is bounded by \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] Knowing \\(\\lambda_n^{(i)}\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor] , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadControl}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadControl (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. \\(\\delta \\lambda_1\\) is the load factor used in the first step. The arguments \\(Jd\\) , \\(\\delta \\lambda_{min}\\) , and \\(\\delta \\lambda_{max}\\) are used in the determination of the increment in the load factor at each step. Does nothing. int newStep ( void ); The object obtains the current value of \\(\\lambda\\) from the AnalysisModel object. It increments this by \\(\\delta \\lambda_n\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] It will then invoke applyLoadDomain ( 0.0 , $ \\lambda $ ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\Delta U $ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. Sets the value of the load increment in newStep() to be \\(\\delta \\lambda\\) . Returns \\(0\\) . int sendSelf(int commitTag, Channel &theChannel); Places in a vector if size 5 the value of \\(\\delta \\lambda_{n-1}\\) , \\(Jd\\) , \\(J_{n-1}\\) , \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) ) and then sends the Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 5 the data that was sent in sendSelf() . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"LoadControl\n"},{"location":"developer/architecture/class_interface/analysis/integrator/LoadPath/","text":"LoadPath #include <analysis/integrator/LoadPath.h> class LoadPath: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadPath is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a user specified load path. The load path is specified in a Vector, path , to the objects constructor and at each step in the analysis: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = path(n) - path(n-1)\\] Knowing \\(\\lambda_n^{(i)} = path(n)\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor] , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadPath}\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. A vector object path is created which is a copy of loadPath and an index into this vector is set to \\(0\\) . The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. No vector object is created. Provided for the FEM_ObjectBroker to create a blank object, recvSelf() should be invoked on this object. Invokes the destructor on the vector path . The object obtains the current value of \\(\\lambda\\) from the path vector using the current index. The index is then incremented by \\(1\\) . If the index is greater than the size of path , \\(\\lambda\\) is set to \\(0\\) and an error message is printed. It will then invoke applyLoadDomain(0.0, \\(\\lambda\\) ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\Delta U $ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int sendSelf(int commitTag, Channel &theChannel); Places the size if path and the index in an ID of size 2 and send this ID. Then sends the Vector path . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the ID or the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a ID of size 2 the size of the vector and current index. Creates a new Vector and receives the Vector from the Channel. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to receive the Vector or the ID. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) .","title":"LoadPath\n"},{"location":"developer/architecture/class_interface/analysis/integrator/MinUnbalDispNorm/","text":"MinUnbalDispNorm #include <analysis/integrator/MinUnbalDispNorm.h> UNDER CONSTRUCTION. class MinUnbalDispNorm: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator MinUnbalDispNorm is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the minimum unbalanced displacement norm method. In this method WHAT SOME THEORY. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_MinUnbalDispNorm (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. Does nothing. int newStep ( void ); WHAT DO I DO? int update ( const Vector & $ \\Delta U $ ); WHAT DO I DO? int sendSelf(int commitTag, Channel &theChannel); WHAT DO I DO? int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); WHAT DO I DO? int Print ( OPS_Stream & s , int flag = 0 ); WHAT DO I DO?","title":"MinUnbalDispNorm\n"},{"location":"developer/architecture/class_interface/analysis/integrator/StaticIntegrator/","text":"StaticIntegrator #include <analysis/integrator/StaticIntegrator.h> class StaticIntegrator: public Integrator MovableObject Integrator IncrementalIntegrator LoadControl ArcLength DisplacementControl StaticIntegrator is an abstract class. It is a subclass of IncrementalIntegrator provided to implement the common methods among integrator classes used in performing a static analysis on the FE_Model. The StaticIntegrator class provides an implementation of the methods to form the FE_Element and DOF_Group contributions to the tangent and residual. A pure virtual method newStep() is also defined in the interface, this is the method first called at each iteration in a static analysis, see the StaticAnalysis class. In static nonlinear finite element problems we seek a solution ( \\(\\U\\) , \\(\\lambda\\) ) to the nonlinear vector function \\[\\R(\\U, \\lambda) = \\lambda {\\bf P} - {\\bf F}_R(\\U) = \\zero \\label{staticGenForm}\\] The most widely used technique for solving the non-linear finite element equation, equation [femGenForm] , is to use an incremental scheme. In the incremental formulation, a solution to the equation is sought at successive incremental steps. \\[\\R({\\bf U}_{n}, \\lambda_n) = \\lambda_n {\\bf P} - {\\bf F}_R({\\bf U}_{n}) \\label{staticIncForm}\\] The solution of this equation is typically obtained using an iterative procedure, in which a sequence of approximations ( \\({\\bf U}_{n}^{(i)}\\) , \\(\\lambda_n^{(i)}\\) ), \\(i=1,2, ..\\) is obtained which converges to the solution ( \\({\\bf U}_n\\) , \\(\\lambda_n)\\) . The most frequently used iterative schemes, such as Newton-Raphson, modified Newton, and quasi Newton schemes, are based on a Taylor expansion of equation [staticIncForm] about ( \\({\\bf U}_{n}\\) , \\(\\lambda_n\\) ): \\[\\R({\\bf U}_{n},\\lambda_n) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - \\left[ \\begin{array}{cc} {\\bf K}_n^{(i)} & -{\\bf P} \\\\ \\end{array} \\right] \\left\\{ \\begin{array}{c} {\\bf U}_{n} - {\\bf U}_{n}^{(i)} \\\\ \\lambda_n - \\lambda_n^{(i)} \\end{array} \\right\\} \\label{staticFormTaylor}\\] which a system of of \\(N\\) equations with ( \\(N+1\\) ) unknowns. Two solve this, an additional equation is required, the constraint equation. The constraint equation used depends on the static integration scheme, of which there are a number, for example load control, arc length, and displacement control. Constructors ### Destructor // Public Methods The integer classTag is passed to the IncrementalIntegrator classes constructor. Does nothing. Provided so that the subclasses destructors will be called. To form the tangent matrix of the FE_Element, theEle , is instructed to zero this matrix and then add it\u2019s \\(K\\) matrix to the tangent, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang() The method returns \\(0\\) . virtual int formEleResidual ( FE_Element \\ * theEle ); To form the residual vector of the FE_Element, theEle , is instructed to zero the vector and then add it\u2019s \\(R\\) vector to the residual, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroResidual() theEle- \\(>\\) addRtoResid() The method returns \\(0\\) . virtual int formNodTangent ( DOF_Group \\ * theDof ); This should never be called in a static analysis. An error message is printed if it is. Returns -1. virtual int formNodUnbalance ( DOF_Group \\ * theDof ); To form the unbalance vector of the DOF_Group, theDof , is instructed to zero the vector and then add it\u2019s \\(P\\) vector to the unbalance, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() theDof- \\(>\\) addPtoUnbal() The method returns \\(0\\) .","title":"StaticIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/TransientIntegrator/","text":"TransientIntegrator #include <analysis/integrator/TransientIntegrator.h> class TransientIntegrator : public Integrator MovableObject Integrator IncrementalIntegrator Newmark HHT Wilson- \\(\\Theta\\) Generalized Alpha TransientIntegrator is an abstract subclass of IncrementalIntegrator . A subclass of it is used when performing a nonlinear transient analysis of the problem using a direct integration method. The TransientIntegrator class redefines the formTangent() method of the IncrementalIntegrator class and it defines a new method newStep() which is invoked by the DirectIntegrationAnalysis class at each new time step. In nonlinear transient finite element problems we seek a solution ( \\(\\U\\) , \\(\\dot \\U\\) , \\(\\ddot \\U\\) ) to the nonlinear vector function \\[{\\bf R}({\\bf U},\\Ud, \\Udd) = {\\bf P}(t) - {\\bf F}_I(\\Udd) - {\\bf F}_R(\\U, \\Ud) = \\zero \\] {#femGenForm} The most widely used technique for solving the transient non-linear finite element equation, equation [femGenForm] , is to use an incremental direct integration scheme. In the incremental formulation, a solution to the equation is sought at successive time steps \\(\\Delta t\\) apart. \\[\\R({\\bf U}_{n \\Delta t},\\dot{\\bf U}_{n \\Delta t}, \\ddot{\\bf U}_{n \\Delta t}) = {\\bf P}(n \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{n \\Delta t}) - {\\bf F}_R({\\bf U}_{n \\Delta t}, \\dot{\\bf U}_{n \\Delta t}) \\] {#fullTimeForm} For each time step, \\(t\\) , the integration schemes provide two operators, \\(\\operatorname{I}_1\\) and \\(\\operatorname{I}_2\\) , to relate the velocity and accelerations at the time step as a function of the displacement at the time step and the response at previous time steps: \\[\\dot {\\bf U}_{t} = {\\I}_1 ({\\bf U}_t, {\\bf U}_{t-\\Delta t}, \\dot {\\bf U}_{t-\\Delta t}, \\ddot {\\bf U}_{t - \\Delta t}, {\\bf U}_{t - 2\\Delta t}, \\dot {\\bf U}_{t - 2 \\Delta t}. ..., ) \\label{I1}\\] \\[\\ddot {\\bf U}_{t} = {\\I}_2 ({\\bf U}_t, {\\bf U}_{t-\\Delta t}, \\dot {\\bf U}_{t-\\Delta t}, \\ddot {\\bf U}_{t - \\Delta t}, {\\bf U}_{t - 2\\Delta t}, \\dot {\\bf U}_{t - 2 \\Delta t}. ..., ) \\label{I2}\\] These allow us to rewrite equation [fullTimeForm] , in terms of a single response quantity, typically the displacement: \\[\\R({\\bf U}_t) = {\\bf P}(t) - {\\bf F}_I(\\ddot{\\bf U}_t) - {\\bf F}_R({\\bf U}_t, \\dot{\\bf U}_t) \\label{genForm}\\] The solution of this equation is typically obtained using an iterative procedure, i.e. making an initial prediction for \\({\\bf U}_{t}\\) , denoted \\({\\bf U}_{t}^{(0)}\\) a sequence of approximations \\({\\bf U}_{t}^{(i)}\\) , \\(i=1,2, ..\\) is obtained which converges (we hope) to the solution \\({\\bf U}_{t}\\) . The most frequently used iterative schemes, such as Newton-Raphson, modified Newton, and quasi Newton schemes, are based on a Taylor expansion of equation [genForm] about \\({\\bf U}_{t}\\) : \\[\\R({\\bf U}_{t}) = \\R({\\bf U}_{t}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial {\\bf U}_t} \\vert}_{{\\bf U}_{t}^{(i)}}\\right] \\left( {\\bf U}_{t} - {\\bf U}_{t}^{(i)} \\right)\\] \\[ \\R({\\bf U}_{t}) = {\\bf P} (t) - {\\bf F}_{I} \\left( \\ddot {\\bf U}_{t}^{(i)} \\right) - {\\bf F}_{R} \\left( \\dot {\\bf U}_{t}^{(i)}, {\\bf U}_{t}^{(i)} \\right)- \\left[ {\\bf M}^{(i)} {\\I}_2' + {\\bf C}^{(i)} {\\I}_1' + {\\bf K}^{(i)} \\right] \\left( {\\bf U}_{t} - {\\bf U}_{t}^{(i)} \\right) \\label{femGenFormTaylor}\\] To start the iteration scheme, trial values for \\({\\bf U}_{t}\\) , \\(\\dot {\\bf U}_{t}\\) and \\(\\ddot {\\bf U}_{t}\\) are required. These are obtained by assuming \\({\\bf U}_{t}^{(0)} = {\\bf U}_{t-\\Delta t}\\) . The \\(\\dot {\\bf U}_{t}^{(0)}\\) and \\(\\ddot {\\bf U}_{t}^{(0)}\\) can then be obtained from the operators for the integration scheme. Subclasses of TransientIntegrators provide methods informing the FE_Element and DOF_Group objects how to build the tangent and residual matrices and vectors. They also provide the method for updating the response quantities at the DOFs with appropriate values; these values being some function of the solution to the linear system of equations. Constructor Destructor // Public Methods The integer classTag is passed to the IncrementalIntegrator classes constructor. Does nothing. Invoked to form the structure tangent matrix. The method is rewritten for this class to include inertia effects from the nodes. The method iterates over both the FE_Elements and DOF_Groups invoking methods to form their contributions to the \\(A\\) matrix of the LinearSOE and then adding these contributions to the \\(A\\) matrix. The method performs the following: // while \u0304 while w\u0304hile \u0304 theSysOfEqn . zeroA (); DOF_EleIter & theDofs = theAnalysisModel . getDOFs (); while (( dofPtr = theDofs ()) \\neq 0 ) dofPtr -> formTangent ( theIntegrator ); theSOE . addA ( dofPtr -> getTangent ( this ), dofPtr -> getID ()) FE_EleIter & theEles = theAnalysisModel . getFEs (); while (( elePtr = theEles ()) \\neq 0 ) theSOE . addA ( elePtr -> getTangent ( this ), elePtr -> getID (), 1.0 ) Returns \\(0\\) if successful, otherwise a \\(-1\\) if an error occurred while trying to add the stiffness. The two loops are introduced for the FE_Elements, to allow for efficient parallel programming when the FE_Elements are associated with a ShadowSubdomain. virtual int formEleResidual ( FE_Element * theEle ); Called upon by the FE_Element theEle to determine it\u2019s contribution to the rhs of the equation. The following are invoked before \\(0\\) is returned. // while \u0304 while w\u0304hile \u0304 theEle - $ > $ zeroResidual () theEle - $ > $ addRIncInertiaToResid () virtual int formNodUnbalance ( DOF_Group * theDof ); Called upon by the DOF_Group theDof to determine it\u2019s contribution to the rhs of the equation. The following are invoked before \\(0\\) is returned. // while \u0304 while w\u0304hile \u0304 theDof -> zeroUnbalance () theDof -> addPIncInertiaToUnbalance () virtual int newStep ( double deltaT ) = 0 ; Invoked to inform the integrator that the transient analysis is proceeding to the next time step. To return \\(0\\) if successful, a negative number if not.","title":"TransientIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/model/","text":"Analysis Model The AnalysisModel object is a container class for storing and providing access to the following types of objects: 1. **DOF_Group**: The **DOF_Group** objects represent the degrees-of-freedom at the **Node**s or new degrees-of-freedom introduced into the analysis to enforce the constraints. 2. [`FE_Element`](model/fe_ele): The `FE_Element` objects represent the `Elements` in the `Domain` or they are introduced to add stiffness and/or load to the system of equations in order to enforce the constraints. The `FE_Element`s and `DOF_Group`s are important to the design because: 1. They remove from the `Node` and `Element` objects the need to worry about the mapping between degrees-of-freedoms and equation numbers. 2. They also remove from the `Node` and `Element` class interfaces methods for forming tangent and residual vectors, that are used to form the system of equations. 3. The subclasses of `FE_Element` and `DOF_Group` are responsible for handling the constraints. This removes from the rest of the objects the analysis aggregation the need to deal with the constraints.","title":"Analysis Model\n"},{"location":"developer/architecture/class_interface/analysis/model/AnalysisModel/","text":"AnalysisModel MODIFY INTERFACE TO OFFER USER DEFINED STORAGE TYPE. #include \"analysis/model/AnalysisModel.h\" class AnalysisModel : public MovableObject AnalysisModel is a container class. This class is responsible for holding and providing access to the FE_Element and DOF_Group objects that the ConstraintHandler creates. It is also responsible for updating the response quantities at the DOF_Groups and for triggering methods in the associated Domain. It provides operations for the following: Population : methods so that the ConstraintHandler can add the FE_Element and DOF_Group objects to the analysis model. Access : methods so that other classes in the analysis aggregation can access the components of the AnalysisModel. Connectivity : methods such that the SysOfEqn can determine the connectivity of the DOF, which is needed for storage, sparsity, etc. Update : methods for updating the individual DOFs with the response quantities given by the AnalysisMethod. Trigger : methods which trigger events in the domain. Each subclass of AnalysisModel must have its own subclasses of FE_ELEIter and DOF_GrpIter . NOTE at the moment FE_Element and DOF_Group objects are not TaggedObjects and for this reason TaggedObjectStorage classes cannot be used for storage. This may change to allow efficient storage classes to be used. Constructors Destructor // Public Methods - Population/Depopulation // Public Member Functions - Access // Public Member Functions - Connectivity // Public Member Functions - Update // Public Member Functions - Trigger // Public Methods for Output // Protected Member Functions Constructs an empty AnalysisModel. The constructor allocates space for two arrays of 256 pointers to FE_Elements and DOF_Groups. If not enough memory is available for these arrays, an error message is printed and the program is terminated. Note these arrays grow automatically if the problem needs it. Provided for subclasses to be used. The storage of the FE_Elements and DOF_Groups and iters to access them must be provided by the subclass. Is responsible for returning to memory the arrays used for storing pointers to the FE_Element and DOF_Groups which have been added to the AnalysisModel. It is not responsible for deleting the individual DOF_Group and FE_Element objects, that is the responsibility of the ConstraintHandler. If the Graphs have been requested their destructor is invoked. Adds the FE_Element pointed to by theElement to the domain and invokes setAnalysisModel(*this) on the FE_Element. If the array for the FE_Elements is large enough, it adds this pointer to the array and increments the number of FE_Elements in the array. If the array is not large enough, a new one double in size is constructed, all the old pointers are copied to this new array and the new pointer is then added. If not enough room is available for this array, an error message is printed and the program is terminated. Returns true , otherwise false if theElement is \\(0\\) or derived class used which does not implement the method. virtual bool addDOF_Group ( DOF_Group \\ * theGroup ); Adds the DOF_Group pointed to by theGroup to the domain. If the array for the DOF_Groups is large enough, it adds this pointer to the array and increments the number of DOF_Groups in the array. If the array is not large enough, a new one double in size is constructed, all the old pointers are copied to this new array and the new pointer is then added. If not enough room is available for this array, an error message is printed and the program is terminated. Returns true , otherwise false if theGroup is \\(0\\) or derived class used which does not implement the method. virtual void clearAll ( void ); Clears from the model all FE_Element and DOF_Group objects that have been added to the analysis model using the above two methods. It does this by setting the components in the two arrays of pointers equal to \\(0\\) and setting the number of components to \\(0\\) . If the Graphs have been created their destructor is invoked. Also sets numEqn to \\(0\\) . Returns the number of DOF_Group objects that have been added to the model. Returns a pointer to the DOF_Group object whose tag is given by tag . It first checks to see if the DOF_Group object is at the location in the array given by tag ; if not it searches through the array to find the DOF_Group object. Returns a pointer to the object if found, otherwise \\(0\\) is returned. Returns an FE_EleIter for the FE_Elements of the model. virtual ` DOF_Group ` getDOFs ( void )= 0 ; Returns a DOF_GrpIter for the DOF_Groups of the model. Sets the value of the number of equations in the model. Invoked by the DOF_Numberer when it is numbering the dofs. Returns the number of DOFs in the model which have been assigned an equation number. Returns the value passed in setNumEqn() , if setNumEqn() was not invoked \\(0\\) is returned. virtual const Graph & getDOFGraph ( void ); Returns the DOF connectivity graph for the individual dofs in the model. This graph is used by the system of equation object to determine its size. If no graph has yet been constructed it creates a new DOF_Graph object using itself as the argument, otherwise it returns a pointer to this graph. THIS WILL CHANGE WHEN I REMOVE DOF_Graph CLASS - will go through and construct the Graph. virtual const Graph & getDOFGroupGraph ( void ); Returns the connectivity of the DOF_Group objects in the model. This graph is used by the DOF_Numberer to assign equation numbers to the dofs. If no graph has yet been constructed it creates a new DOF_GroupGraph object using itself as the argument, otherwise it returns a pointer to this graph. AGAIN WILL CHANGE. The model is responsible for invoking setDisp(disp) , setVel(vel) and setAccel(accel) on each DOF_Group in the model. It does this by iterating over the DOF_Group objects using the iter. virtual void setDisp ( const const Vector & disp ); The model is responsible for invoking setDisp(disp) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeDisp(disp) on each DOF_Group. virtual void setVel ( const const Vector & vel ); The model is responsible for invoking setVel(vel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeVel(vel) on each DOF_Group. virtual void setAccel ( const const Vector & accel ); The model is responsible for invoking setAccel(accel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeAccel(accel) on each DOF_Group. virtual void incrDisp ( const const Vector & disp ); The model is responsible for invoking incrNodeDisp(disp) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeDisp(disp) on each DOF_Group. virtual void incrVel ( const const Vector & vel ); The model is responsible for invoking incrNodeVel(vel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeVel(vel) on each DOF_Group. virtual void incrAccel ( const const Vector & accel ); The model is responsible for invoking incrNodeAccel(accel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeAccel(accel) on each DOF_Group. Method to set the link to the associated Domain. Invoked by during the construction of the Analysis object. virtual void applyLoadDomain(double timeStep = 0.0, double loadFactor = 1.0); Method which invokes applyLoad ( timeStep , loadFactor ) on the domain. This method causes the domain ask the loads in the currently set to apply themselves. If no Domain has been set nothing is done and an error message is printed. virtual int commitDomain ( void ); Method which invokes commit() on the domain: this is an operation which causes all nodes in the domain to take the current values of response quantities and copy them into the accepted values. Returns \\(0\\) if successful , a negative number if not: \\(-1\\) if no Domain has been set and \\(-2\\) if commit() fails on the Domain. virtual int revertDomainToLastCommit ( void ); Method which invokes revertToLastCommit() on the domain: this is an operation which causes all nodes in the domain to set the trial response quantities equal to the last committed response quantities. Returns \\(0\\) if successful , a negative number if not: \\(-1\\) if no Domain has been set and \\(-2\\) if revertToLastCommit () fails on the Domain. virtual void updateDomain ( void ); Method which invokes update() on the domain. If no Domain has been set nothing is done and an error message is printed. To get the current time in the Domain. If no Domain has been set a warning message is printed and \\(0.0\\) is returned, otherwise the result of invoking getCurrentTime() on the Domain is returned. To set the current time in the Domain to be newTime . If no Domain has been set a warning message is printed, otherwise setCurrentTime(newTime) is invoked on the Domain. To get the current load factor in the Domain. If no Domain has been set a warning message is printed and \\(0.0\\) is returned, otherwise the result of invoking getCurrentLoadFactor() on the Domain is returned. ; To set the current load factor in the Domain to be newFactor . If no Domain has been set a warning message is printed, otherwise setCurrentLoadFactor(newFactor) is invoked on the Domain. Returns \\(0\\) . Note the FE_Elements and DOF_Group objects are not sent as they are not MovableObjects. AnalysisModel objects are only sent when setting up a DomainDecompAnalysis on a remote process; only type info and whatever subclasses might need need to be sent. ; Returns \\(0\\) . Returns a pointer to the associated Domain, that is the Domain set when setLinks() was last invoked.","title":"AnalysisModel\n"},{"location":"developer/architecture/class_interface/analysis/model/dof_grp/DOF_Group/","text":"NEED A GETTANGFORCE() LIKE FE_Element FOR ELE_BY_ELE SOLVERS. KEEP A POINTER TO LAST INTEGRATOR. DOF_Group #include <analysis/dof_grp/DOF_Group.h> class DOF_Group; DOF_Group is a base class. An object of type DOF_Group represents an unconstrained node of the domain in the model. Each node in the domain is associated with one DOF_Group. DOF_Groups are called upon in the analysis to provide their contributions of unbalanced load to the system of equations. Subclasses are used by the constraint handler to to introduce new dofs into the analysis. The DOF_Group is responsible for providing operations to set and access the mapping betwwen equation numbers and DOFs, allowing the Integrator to from the tangent (if nodal masses in transient problem) and unbalanced load information, and for setting and obtaining the nodal trial response quantities. Constructors Destructor // Public Methods - Mapping // Public Methods - Tangent & Residual // Public Methods - Node Response Constructs a DOF_Group with an associated node given by theNode and a tag given by tag . During construction it determines the number of unknown dofs from the node, numDOF , and creates an Vector object to hold the unbalance information and an ID object to hold mapping between degrees-of-freedom and equation numbers. All values of the ID are set to \\(-2\\) initially. It creates a Vector to hold the unbalance loads and an ID to hold the mapping information, both of size equal to the number of unknowns. If the size of the Vector or the ID is \\(0\\) , i.e. ran out of memory, a warning message is orinted and numDOF set to \\(0\\) . DOF_Group ( int tag , int numDOF ); Provided for subclasses. Constructs a DOF_Group with the number of unknown dofs given by numDOF and a tag given by tag . No Node is associated with this DOF_Group. Creates a Vector of size numDOF to hold the unbalance information and an ID object to hold mapping between degrees-of-freedom and equation numbers. All values of the ID are set to \\(-2\\) initially. If the size of the Vector or the ID is \\(0\\) , i.e. ran out of memory, a warning message is orinted and numDOF set to \\(0\\) . Invokes the destructor on the Vector created to hold the unbalance. Operation to set the equation number of the dof\u2019th DOF in the DOF_Group to value . In this base class, if index is a valid location, \\(0 < index < numDOF-1\\) the operator (index) = value is invoked on the ID object created for the mapping, otherwise an error message is printed. virtual void setID ( const ID & values ); An operation to set the equation numbers of all the DOFs in the DOF_Group to be those given in the ID values . In this base class, the operator = values is invoked on the ID object created for the mapping. virtual const ID & getID ( void ) const ; A const member function which returns in an ID object the equation numbers associated with the degrees-of-freedom in the DOF_Group. The size of the ID object is equal to the number of degrees-of-freedom represented by the DOF_Group. This base class returns the ID created for the mapping. virtual int getTag ( void ) const ; A const member function which returns the integer identifier tag passed in the constructor. virtual int getNumDOF ( void ) const ; Returns the total number of DOFs in the DOF_Group. This base class returns numDOF . virtual int getNumFreeDOF ( void ) const ; Returns the total number of free DOFs in the DOF_Group, i.e. number of dof in the group who have not been assigned a negative equation number. Determines this by looping through the ID containing the mapping information. virtual int getNumConstrainedDOF ( void ) const ; Returns the total number of constrained DOFs in the DOF_Group, i.e. number of dof in the group who have been assigned a negative equation number. Determines this by looping through the ID containing the mapping information. Returns the current tangent matrix for the DOF_Group. If no tangent matrix has been created, one of size(numDOF,numDOF) is constructed. If not enough space is available for a new tangent matrix, an error message is printed and an error Matrix is returned.. To form the DOF_Groups tangent. Invokes formNodTangent(this) on The Integrator object theIntegrator . To zero the tangent. If a tangent matrix has been allocated, will invoke Zero() on the tangent matrix. To add fact times the nodal mass matrix to the tangent matrix. In this base class, if a Matrix to store the tangent has not yet been created, one of size (numDOF,numDOF) is now created; if construction of this matrix fails an error is printed and an error Matrix is returned. Invokes addMatrix ( theNode - $ > $ getMass , fact ) on the Matrix, printing a warining message if this method returns a \\(negative\\) value. If no Node is associated with the DOF_Group an error message is printed and nothing is done. To zero the unbalance vector. Invokes Zero() on the vector object used to store the unbalance information. virtual void formUnbalance(Integrator *theIntegrator); Causes the DOF_Group to form its contribution to the residual. Invokes formNodUnbalance(this) on theIntegrator . virtual const Vector &getUnbalance() const; Returns the vector holding the unbalance. virtual void addPtoUnbalance ( double fact = 1.0 ); Adds the product of the unbalanced load at the node and fact to the unbalance vector. A warning message is printed and nothing is done if no node is associated with the DOF_Group, otherwise addVector(theNode- \\(>\\) getUnbalancedLoad(),fact) is invoked on the unbalance vector and a warning message is printed if this method returns a negative value. virtual void addMtoTang ( const Vector & $ \\ddot u $ , double fact ); Adds fact times the product of the associated nodes mass matrix and the Vector \\(\\ddot u\\) to the unbalance vector. A warning message is printed and nothing is done if no node is associated with the DOF_Group. To return the committed displacement at the node. Returns the result of invoking getDisp() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. To return the committed velocity at the node. Returns the result of invoking getVel() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. To return the committed velocity at the node. Returns result of invoking getAccel() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. This operation sets the value of the nodal trial displacement at the associated node. The vector u is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector u using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal displacement for the node. Creates a Vector to store the correct components of u , then invokes setTrialDisp() on the node object; if no node object an error message is printed. CURRENTLY THERE IS NO CHECK TO SEE IF myID(i) DOES NOT OVERFLOW ADMISSIBLE VALUES IN U - THIS NEEDS TO CHANGE virtual int setNodeVel ( const Vector & $ u ^{.} $ ); This operation sets the value of the nodal trial velocity at the associated node. The vector \\(u^{.}\\) is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector \\(u^{.}\\) using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal velocity for the node. Creates a Vector to store the correct components of u , then invokes setTrialVel() on the node object; if no node object an error message is printed. MUST CHANGE AS setNodeDisp virtual int setNodeAccel ( const Vector & $ u ^{..} $ ); This operation sets the value of the nodal trial acceleration at the associated node. The vector \\(u^{..}\\) is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector \\(u^{..}\\) using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal acceleration for the node. The return value is as outlined above for setNodeAccel(). Creates a Vector to store the correct components of u , then invokes setTrialAccel() on the node object; if no node object an error message is printed. MUST CHANGE AS setNodeDisp These methods are similar to those three just outlined, the only difference being that the trial response quantities at the nodes are incremented, not set, with the values now given; this is done by invoking incrTrialDisp() , incrTrialVel() , and incrTrialAccel() respectively on the nodes. MUST ALL CHANGE AS setNodeDisp","title":"`DOF_Group`\n"},{"location":"developer/architecture/class_interface/analysis/model/dof_grp/TransformationDOF_Group/","text":"TransformationDOF_Group #include <analysis/dof_grp/TransformationDOF_Group.h> UNDER CONSTRUCTION. class TransformationDOF_Group: public DOF_Group; DOF_Group TransformationDOF_Group is a subclass of DOF_Group. This object stores the transformation matrix \\(\\T\\) used by the TransformationFE objects when a node has been constrained with an MP or SP_Constraint. Constructors Destructor // Public Methods - dealing with the ID and Transformation matrix // Public Methods - Tangent & Residual // Public Methods - update trial response quantities","title":"TransformationDOF_Group\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/FE_Element/","text":"FE_Element #include <analysis/fe_ele/FE_Element.h> class FE_Element ; FE_Element is a base class, subtypes of which are used to enforce the constraints on the domain. An object of type FE_Element represents an element of the domain in the analysis. It enforces no constraints other than single point homogeneous boundary conditions, imposed on any of the elements nodes. It provides a similar interface to that of an Element but modified to provide features useful to an Analysis class. The FE_Element is responsible for: Holding information about the mapping between equation numbers and the degrees-of-freedom at the element ends, this mapping is determined from the DOF_Group objects associated with the elements Node objects. Providing methods to allow the integrator to combine the elements stiffness, mass and damping matrices into the elements contribution to the structure tangent matrix and the elements resisting force to the structure unbalance. Obtaining the stiffness, damping and mass matrices from the elements. Providing methods so other forces can be determined. While the FE_Element class is associated with an element in the domain, subclasses do not have to be. It is the subclasses that are used to implement the constraints imposed on the nodal displacements in the domain. // Constructors // Destructor // Public Methods - Mapping // Public Methods to form and obtain Tangent & Residual // Public Methods to allow Integrator to Build Tangent // Public Methods to allow Integrator to Build Residual // Public Methods to allow Element-by-Element strategies // Public Methods added for Domain Decomposition Constructs an empty FE_Element with an associated element given by theElement . During construction it determines the number of unknown dofs from the element. Constructs an ID for the mapping between dof\u2019s of the element and equation numbers in the system of equation and an ID to hold the tag of the DOF_Group objects associated with each Node of the element. If the result of invoking theElementPtr->isSubdomain() is true invokes setFE_Element(this) on the Subdomain; if false creates a Matrix for the tangent and a Vector for the residual to be stored. An error message is printed and the program is terminated if no Domain object is associated with the Element, a Node of the Element does not exist in the Domain, each Node has not yet been associated with a DOF_Group object, or there is not enough memory for the Vectors and Matrices required. FE_Element ( int numDOFGroup , int numDOF ); Provided for subclasses. Constructs an empty FE_Element with the number of unknown dofs given by numDOF and the number of associated DOF_Group objects given by numDOFGroup , two empty IDs are constructed to hold the mapping and the tags of the DOF_Groups. The subclass must fill in the ID for the tags of the DOF_Groups in order that setID() will work. No element is associated with this FE_Element. No space is allocated for the tangent and residual matrix and vector, this is the responsibility of the subclass. ~ FE_Element (); Deletes the IDs, Vectors and Matrices created by the constructor. Returns a const ID containing the unique tag number of the DOF_Group objects associated with that FE_Element. For this base class, these are obtained from the DOF_Groups associated with the Node objects that are associated with the Element object passed in the constructor. This ID is computed only once, during the creation of the object. virtual const ID & getID ( void ) const ; Returns a const ID containing the equation numbers associated with its matrices and vectors. This ID will contain \\(0\\) \u2019s unless the setID() method has been called. void setAnalysisModel ( AnalysisModel & theModel ); To set a link to the AnalysisModel in which the FE_Element resides; this link is needed in setID() . Is invoked by the AnalysisModel when the FE_element is added to the AnalysisModel. virtual void setID ( void ); Causes the FE_Element to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. The \\(i-1\\) component of the ID contains the equation number that is associated with \\(i\\) \u2019th degree-of-freedom (a consequence of C indexing for IDs). The method is to be invoked by the DOF_Numberer after the DOF_Groups have been assigned their equation numbers. The base class uses the ID containing the tags of the DOF_Group objects to determine this by looping over the DOF_Group objects (identified in the DOF_Group ID and obtained from the AnalysisModel) and getting their mapping by invoking getID() . Returns \\(0\\) if successful, a warning message and a negative number is returned if an error occurs: \\(-1\\) returned if no AnalysisModel link has been set, \\(-2\\) if a DOF_Group object does not exist in the AnalysisModel and a \\(-3\\) if there are more dof\u2019s in the DOF_Groups than dof\u2019s identified for the FE_Element. Causes the FE_Element to determine it\u2019s contribution to the tangent matrix and to return this matrix. If the Element is a Subdomain it invokes computeTangent() and getTang() on the Subdomain. Otherwise formEleTangent(this) is invoked on theIntegrator and the new tangent matrix is returned. Subclasses must provide their own implementation. If no Element is passed in the constructor, a warning message is printed and an error Matrix of size 1X1 is returned. Causes the FE_Element to determine it\u2019s contribution to the residual vector and to return this vector. If the Element is a Subdomain it invokes computeResidual() and getResistingForce() on the Subdomain. Otherwise formEleResidual(this) is invoked on theIntegrator and the resuting residual vector is returned. Subclasses must provide their own implementation. If no Element is passed in the constructor, a warning message and an error vector is returned. Zeros the tangent matrix. If the Element is not a Subdomain invokes Zero() on the tangent matrix. Subclasses must provide their own implementation. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKtToTang(double fact = 1.0); Adds the product of fact times the element\u2019s tangent stiffness matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getTangentStiff(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKsToTang(double fact = 1.0); Adds the product of fact times the element\u2019s secant stiffness matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getSecantStiff(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addCtoTang(double fact = 1.0); Adds the product of fact times the element\u2019s damping matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getDamp(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addMtoTang(double fact = 1.0); Adds the product of fact times the element\u2019s mass matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getMass(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. Zeros the residual vector. If the Element is not a Subdomain invokes Zero() on the residual vector. Subclasses must provide their own implementation. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addRtoResidual(double fact = 1.0); Adds to the residual vector the product of the elements residual load vector and fact . If no element is associated with the FE_Element nothing is added, if the associated element is not a Subdomain addVector(myEle- \\(>\\) getResistingForce(),fact) is invoked on the residual. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addRIncInertiaToResidual(double fact = 1.0); Adds to the residual vector the product of the elements residual load vector with inertia forces included and fact . If no element is associated with the FE_Element nothing is added, if the associated element is not a Subdomain addVector(myEle- \\(>\\) getResistingForceIncInertia(),fact) is invoked on the residual. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKtForce(const Vector &disp, double fact = 1.0); Adds to the residual the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addKsForce(const Vector &disp, double fact = 1.0); Adds to the residual the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addD_Force(const Vector &vel, double fcat = 1.0); Adds to the residual the product of elements current damping matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector vel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addM_Force(const Vector &accel, double fact = 1.0); Adds to the residual the product of elements current mass matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector accel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual const Vector &getTangForce(const Vector &disp, double fact=1.0); Returns the product of FE_Elements current tangent matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If the element associated with the FE_Element is a subdomain, the tangent is obtained by invoking getTang() on the subdomain, otherwise the tangent is formed by invoking formEleTang(this) on the integrator object last used in a getTangent() or getResidual() . If no element is associated with the FE_Element a zero vector is returned and an error message is printed. An error message is also printed if invoking addMatrixVector() on the force vector returns \\(< 0\\) . virtual const Vector &getKtForce(const Vector &disp, double fact=1.0); Returns the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain an error vector is returned and a warning message printed. virtual const Vector &getKsForce(const Vector &disp, double fact = 1.0); Returns the product of elements current secant stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain an error vector is returned and a warning message printed. virtual const Vector & getD_Force ( const Vector & vel , double fact = 1.0 ); Returns the product of elements current damping matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector vel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain a warning message is printed and an error Vector is returned. virtual const Vector & getM_Force ( const Vector & accel , double fcat = 1.0 ); Returns the product of elements current mass matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector accel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain a warning message is printed and an error Vector is returned. Integrator * getLastIntegrator ( void ); Method which returns the last integrator supplied in a formTangent() or a formResidual() invocation. const Vector & getLastResponse ( void ); A method which invokes getLastResponse() on the Integrator object that was last passed as an argument to any of the routines. The FE_Element s ID and the force Vector object is passed as arguments. Returns the force Vector object if successful. If no element is associated with the FE_Element or no integrator has yet to be passed, a warning message is printed and an error Vector is returned.","title":"FE_Element\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/lagrange/LagrangeMP_FE/","text":"LagrangeMP_FE #include <analysis/fe_ele/lagrange/LagrangeMP_FE.h> class LagrangeMP_FE : public ` FE_Element ` ; LagrangeMP_FE is a subclass of FE_Element used to enforce a multi point constraint, of the form \\({\\bf U}_c = {\\bf C}_{cr} {\\bf U}_r\\) , where \\({\\bf U}_c\\) are the constrained degrees-of-freedom at the constrained node, \\({\\bf U}_r\\) are the retained degrees-of-freedom at the retained node and \\({\\bf C}_{cr}\\) a matrix defining the relationship between these degrees-of-freedom. To enforce the constraint the following are added to the tangent and the residual: \\[\\left[ \\begin{array}{cc} 0 & \\alpha{\\bf C}^t \\\\ \\alpha{\\bf C} & 0 \\end{array} \\right] , \\left\\{ \\begin{array}{c} 0 \\\\ 0 \\end{array} \\right\\}\\] at the locations corresponding to the constrained degree-of-freedoms specified by the MP_Constraint, i.e. \\([{\\bf U}_c\\) \\({\\bf U}_r]\\) , and the lagrange multiplier degrees-of-freedom introduced by the LagrangeConstraintHandler for this constraint, \\({\\bf C} = [-\\I\\) \\({\\bf C}_{cr}]\\) . Nothing is added to the residual. Constructor Destructor // Public Methods To construct a LagrangeMP_FE element to enforce the constraint specified by the MP_Constraint theMP using a default value for \\(\\alpha\\) of \\(alpha\\) . The FE_Element class constructor is called with the integers \\(3\\) and the two times the size of the retainedID plus the size of the constrainedID at the MP_Constraint theMP plus . A Matrix and a Vector object are created for adding the contributions to the tangent and the residual. The residual is zeroed. If the MP_Constraint is not time varying, then the contribution to the tangent is determined. Links are set to the retained and constrained nodes. The DOF_Group tag ID is set using the tag of the constrained Nodes DOF_Group, the tag of the retained Node DOF_Group and the tag of the LagrangeDOF_Group, theGroup . A warning message is printed and the program is terminated if either not enough memory is available for the Matrices and Vector or the constrained and retained Nodes of their DOF_Groups do not exist. Invokes delete on any Matrix or Vector objects created in the constructor that have not yet been destroyed. Causes the LagrangeMP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. This information is obtained by using the mapping information at the DOF_Group objects associated with the constrained and retained nodes and the LagrangeDOF_Group, theGroup . Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node (sets corresponding ID component to \\(-1\\) so nothing is added to the tangent) and \\(-4\\) if the ID in the DOF_Group is too small for the Node (again setting corresponding ID component to \\(-1\\) ). If the MP_Constraint is time-varying, from the MP_Constraint theMP it obtains the current \\(C_{cr}\\) matrix; it then adds the contribution to the tangent matrix. Returns this tangent Matrix. Returns the residual, a \\(\\zero\\) Vector. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); CURRENTLY just returns the \\(0\\) residual. THIS WILL NEED TO CHANGE FOR ELE-BY-ELE SOLVERS.","title":"LagrangeMP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/lagrange/LagrangeSP_FE/","text":"LagrangeSP_FE #include <analysis/fe_ele/lagrange/LagrangeSP_FE.h> class LagrangeSP_FE : public FE_Element LagrangeSP_FE is a subclass of FE_Element used to enforce a single point constraint. It does this by adding to the tangent and the residual: \\[\\left[ \\begin{array}{cc} 0 & \\alpha \\\\ \\alpha & 0 \\end{array} \\right] , \\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] at the locations corresponding to the constrained degree-of-freedom specified by the SP_Constraint and the lagrange multiplier degree-of-freedom introduced by the LagrangeConstraintHandler for this constraint, where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to the constraint. Constructor ### Destructor // Public Methods To construct a LagrangeSP_FE element to enforce the constraint specified by the SP_Constraint theSP using a value for \\(\\alpha\\) of alpha (which, if none is specified, defaults to \\(1.0\\) ). The FE_Element class constructor is called with the integers \\(2\\) and \\(2\\) . A Matrix and a Vector object of order \\(2\\) are created to return the tangent and residual contributions, with the tangent entries (0,1) and (1,0) set at \\(\\alpha\\) . A link to the Node in the Domain corresponding to the SP_Constraint is also set. A warning message is printed and program terminates if there is not enough memory or no Node associated with the SP_Constraint exists in the Domain, or DOF_Group is associated with the Node. Invokes the destructor on the Matrix and Vector objects created in the constructor. Causes the LagrangeSP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. From the Node object link, created in the constructor, the DOF_Group corresponding to the Node associated with the constraint is determined. From this DOF_Group object the mapping for the constrained degree of freedom is determined and the myID(0) in the base class is set. The myID(1) is determined from the Lagrange DOF_Group theGroup passed in the constructor. Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node and \\(-4\\) if the ID in the DOF_Group is too small for the Node. Returns the tangent Matrix created in the constructor. Sets the FE_Elements contribution to the residual: \\[\\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid. Returns this residual Vector. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); Sets the FE_Elements contribution to the residual: \\[\\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement in disp corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid.","title":"LagrangeSP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/penalty/PenaltyMP_FE/","text":"PenaltyMP_FE #include <analysis/fe_ele/penalty/PenaltyMP_FE.h> class PenaltyMP_FE : public ` FE_Element ` ; PenaltyMP_FE is a subclass of FE_Element used to enforce a multi point constraint, of the form \\({\\bf U}_c = {\\bf C}_{cr} {\\bf U}_r\\) , where \\({\\bf U}_c\\) are the constrained degrees-of-freedom at the constrained node, \\({\\bf U}_r\\) are the retained degrees-of-freedom at the retained node and \\({\\bf C}_{cr}\\) a matrix defining the relationship between these degrees-of-freedom. To enforce the constraint a matrix \\(\\alpha {\\bf C}^T \\C\\) is added to the tangent for the degrees-of-freedom \\([{\\bf U}_c\\) \\({\\bf U}_r]\\) , where \\({\\bf C} = [-\\I\\) \\({\\bf C}_{cr}]\\) . Nothing is added to the residual. Constructor ### Destructor // Public Methods To construct a PenaltyMP_FE element to enforce the constraint specified by the MP_Constraint theMP using a default value for \\(\\alpha\\) of \\(alpha\\) . The FE_Element class constructor is called with the integers \\(2\\) and the size of the retainedID plus the size of the constrainedID at the MP_Constraint theMP . A Matrix and a Vector object are created for adding the contributions to the tangent and the residual. The residual is zeroed. A Matrix is created to store the \\(C\\) Matrix. If the MP_Constraint is not time varying, the components of this Matrix are determined, then the contribution to the tangent \\(\\alpha C^TC\\) is determined and finally the \\(C\\) matrix is destroyed. Links are set to the retained and constrained nodes. A warning message is printed and the program is terminated if either not enough memory is available for the Matrices and Vector or the constrained and retained Nodes do not exist in the Domain. Invokes delete on any Matrix or Vector objects created in the constructor that have not yet been destroyed. Causes the PenaltyMP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. This information is obtained by using the mapping information at the DOF_Group objects associated with the constrained and retained nodes to determine the mappings between the degrees-of-freedom identified in the constrainedID and the retainedID at the MP_Constraint theMP . Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node (sets corresponding ID component to \\(-1\\) so nothing is added to the tangent) and \\(-4\\) if the ID in the DOF_Group is too small for the Node (again setting corresponding ID component to \\(-1\\) ). If the MP_Constraint is time-varying, from the MP_Constraint theMP it obtains the current \\(C_{cr}\\) matrix; it then forms the \\(C\\) matrix and finally it sets the tangent matrix to be \\(\\alpha C^TC\\) . Returns the tangent matrix. Returns the residual, a \\(\\zero\\) Vector. virtual const Vector &getTangForce(const Vector &disp, double fact = 1.0); CURRENTLY just returns the \\(0\\) residual. THIS WILL NEED TO CHANGE FOR ELE-BY-ELE SOLVERS.","title":"PenaltyMP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/penalty/PenaltySP_FE/","text":"PenaltySP_FE #include <analysis/fe_ele/penalty/PenaltySP_FE.h> class PenaltySP_FE : public FE_Element ; PenaltySP_FE is a subclass of FE_Element used to enforce a single point constraint. It does this by adding \\(\\alpha\\) to the tangent and \\(\\alpha * (U\\_s - U\\_t)\\) to the residual at the locations corresponding to the constrained degree-of-freedom specified by the SP_Constraint , where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to the constraint. Constructor Destructor // Public Methods To construct a PenaltySP_FE element to enforce the constraint specified by the SP_Constraint theSP using a value for \\(\\alpha\\) of alpha (which, if none is specified, defaults to \\(1.0e8\\) ). The FE_Element class constructor is called with the integers \\(1\\) and \\(1\\) . A Matrix and a Vector object of order \\(1\\) are created to return the tangent and residual contributions, with the tangent entry being set at \\(\\alpha\\) . A link to the Node in the Domain corresponding to the SP_Constraint is also set. A warning message is printed and program terminates if there is not enough memory or no Node associated with the SP_Constraint exists in the Domain. Invokes the destructor on the Matrix and Vector objects created in the constructor. Causes the PenaltySP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. From the Node object link, created in the constructor, the DOF_group corresponding to the Node associated with the constraint is determined. From this DOF_Group object the mapping for the constrained degree of freedom is determined and the ID in the base class is set. Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group , \\(-3\\) if the constrained DOF specified is invalid for this Node and \\(-4\\) if the ID in the DOF_Group is too small for the Node. Returns the tangent Matrix created in the constructor. Sets the FE_Elements contribution to the residual to be \\(\\alpha * (U_s - U_t)\\) , where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid. Returns this residual Vector set. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); Sets the FE_Elements contribution to the residual to be \\(\\alpha * (U\\_s - disp\\_t)\\) , where \\(U\\_s\\) is the specified value of the constraint and \\(disp\\_t\\) the value in disp corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the mapping, determined in setID() , for the the specified constrained degree-of-freedom lies outside disp .","title":"PenaltySP_FE\n"},{"location":"developer/architecture/class_interface/database/","text":"Data Storage In this work there are two general types of data storage classes provided: Classes which can be used to store and provide access to the TaggedObjects during program execution. The abstract base class for these classes is TaggedObjectStorage . The concrete subclasses can implement the interface using the traditional CS data storage techniques, such as arrays, linked lists, hash tables, etc.. Classes which can be used to store and retrieve information from permanent data archives, i.e. databases. The abstract base class defining the interface for these classes is FE_Datastore .","title":"Data Storage\n"},{"location":"developer/architecture/class_interface/database/FE_Datastore/","text":"FE_Datastore #include <database/FE_Datastore.h> class FE_Datastore: public ModelBuilder, public Channel ModelBuilder Channel FE_Datastore is an abstract class. An FE_Datastore object is used in the program to store/restore the geometry and state information in the domain at particular instances. How, where and how the data is stored depends on the implementation provided by the concrete subclasses. // Constructor // Destructor // Public Methods // Protected Methods The Domain object theDomain is passed to the ModelBuilder constructor. A pointer is kept to theBroker object. Does nothing. To return a unique integer identifier at each call. This identifier will be used by the objects to store/retrieve their information to/from the database. Invoked to store the current state of the domain in the database. The integer commitTag is used to identify the state for subsequent calls to restore the information from the database. To return \\(0\\) if successful, a negative number if not. In the implementation for the FE_Datastore class, the object first invokes validateBaseRelationsWrite() on itself. If this method returns \\(0\\) , the object then loops over all the components of the Domain object invoking sendSelf ( commitTag , this ) on each of these objects. Returns \\(0\\) if successful, a negative number if not. For each domain component that could not send itself a warning message is printed. Invoked to restore the state of the domain from a database. The state of the domain at the end of this call is to be the same as the state of the domain when commitState(commitTag) was invoked. To return \\(0\\) if successful, a negative number if not. In the implementation for the FE_Datastore class, the object first invokes validateBaseRelationsRead() on itself. If this method returns \\(0\\) , the object then loops over all the components of the Domain object invoking recvSelf ( commitTag , this ) on each of these objects. Returns \\(0\\) if successful, a negative number if not. For each domain component that could not send itself a warning message is printed. This method is invoked before the information can be sent to the database. It is required to ensure that: Each Node, Element, SP_Constraint , MP_Constraint , NodalLoad and ElementalLoad which is to save information in the database has a database tag. That the information in the base tables is up to date so that a later call to validateBaseRelationsRead(commitTag) will be successful. To return \\(0\\) if the base relations are up to date, to return \\(1\\) if they are up to date and the component data has been sent to the database, and a negative number if the method fails. This method is invoked before the information can be extracted from the database. It is required to ensure that the Domain has the same type of DomainComponent objects and that each of these has the same database tag as when validateBaseRealationsWrie(commitTag) was invoked. To return \\(0\\) if the base relations are up to date, to return \\(1\\) if they are up to date and the component data has been received from the database, and a negative number if the method fails. Returns a pointer to theBroker object passed in the constructor.","title":"FE_Datastore\n"},{"location":"developer/architecture/class_interface/database/FileDatastore/","text":"FileDatastore #include <database/FileDatastore.h> class FileDatastore: public FE_Datastore ModelBuilder Channel FE_Datastore FileDatastore is a concrete class. An FileDatastore object is used in the program to store/restore the geometry and state information in the domain at particular instances. This information is stored in binary form in files. As no standard format is used for the storage of integers and double values, files used to store the data on one type of machine, may not be read by a FileDatastore object on another type of machine where the storage of integers and doubles is different. For each of the base relations, i.e. Domain, Nodes, Elements, SP_Constraints, MP_Constraints, NodalLoads and ElementalLoads, a separate file is used to store the information. Files are also used for each size of ID, Vector and Matrix stored. At present, Messages are not stored, only ID and Vector objects of size \\(<= 200\\) can be stored, the max \\(noRows * noCols\\) of Matrices that can be stored is \\(<= 2000\\) , and only a single relation is created for Matrices which have similar sizes but differing dimensions. The data is stored in the files following the schema outlined previously. // Constructor // Destructor // Public Methods inherited from the ModelBuilder Class // Public Methods inherited from the FE_Datastore Class // Public Methods inherited from the Channel Class Opens the files for the domain and base component relations, files have names name.relation , and stores the end of file locations. Creates three arrays of file pointers for the ID, Vector and Matrix files and then zeros these arrays. If the files could not be opened, or there is not enough memory for the arrays an error message is printed and the program is terminated. Each file that is opened is closed and the arrays of file pointers obtained from the heap in the constructor are returned to the heap. To build the finite element model from data in the database. It does this by invoking restor ( 0 ) on itself. Increments the integer containing the current dbTag and returns this integer. The object first checks to see if the Domain has already been committed to the database with a similar commitTag . If it has, a check is made to ensure that the current domain stamp and the one at the time of this last commit are the same. If they are different, an error message is printed and \\(-1\\) is returned. A check is then made to see if the component base relations have been updated for this current domain stamp. If they have not been the base relations are updated, and each domain component is asked to send its data to the database. Finally the Domain relation is updated with the current time, load factor and domain stamp. Returns \\(1\\) if the component base relations needed to be updated and the component information sent, \\(0\\) if just the Domain relation needed to be updated. A warning message and a negative number is printed if an error occurs. The object first obtains from the Domain relation the information for commitTag . If no information exists, an error message is printed and a \\(-1\\) is returned. A check is then made to see if the domain stamp for this entity and the Domain objects current stamp are the same. If different, clearAll() is invoked on the Domain, and from the component base relations new domain components are created, are asked to recvSelf() from this and these new components are added to the Domain. Finally the current time, domain stamp and load factor are set using the information in the entity. Returns \\(1\\) if the domain needed to be cleared and new component objects created, \\(0\\) if just the Domain object needed to be updated with current time and load factor. A warning message and a negative number is printed if an error occurs. Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns the result of invoking sendSelf ( commitTag , \\ * this ) on theObject . Returns the result of invoking recvSelf(commitTag, *this, theBroker) on theObject . Prints an error message and returns \\(-1\\) as not yet implemented. Prints an error message and returns \\(-1\\) as not yet implemented. First determines the size of the matrix, \\(noRows * noCols\\) . If a files for matrices of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a Matrix with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for Matrices of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if Matrix size is too large. First determines the size of the matrix, \\(noRows * noCols\\) . If a files for matrices of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a Matrix with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the Matrix is set. returns \\(0\\) if successful. If a file for Vectors of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a Vector with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for Vectors of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if Vector size is too large. If a file for Vectors of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a Vector with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the Vector is set. Returns \\(0\\) if successful. If a file for IDs of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a ID with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for IDss of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if ID size is too large. If a file for IDs of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a ID with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the ID is set. Returns \\(0\\) if successful.","title":"FileDatastore\n"},{"location":"developer/architecture/class_interface/database/database/","text":"TaggedObject TaggedObjectStorage ArrayOfTaggedObjects MapOfTaggedObjects FE_Datastore FileDatastore Recorder MaxNodeDispRecorder FileNodeDispRecorder DatastoreRecorder","title":""},{"location":"developer/architecture/class_interface/domain/","text":"Domain Classes These are the classes that are used to describe the finite element model and to store the results of an analysis on this model. The classes provide include Domain , Element , Node , Load , Constraint and their subclasses. Typically, a Domain object is used as a container object to store and provide access to the Node , Element , Load and Constraint objects created by the ModelBuilder object. Component Constraint Domain Load loadBalancer Node Partitioner Pattern","title":"Domain Classes\n"},{"location":"developer/architecture/class_interface/domain/domain/","text":"DomainComponent Element Node Load NodalLoad ElementalLoad SP_Constraint MP_Constraint TimeSeries LinearSeries RectangularSeries PathSeries PathTimeSeries LoadPattern EarthquakePattern UniformExcitation Domain","title":""},{"location":"developer/architecture/class_interface/domain/component/DomainComponent/","text":"DomainComponent #include <domain/component/DomainComponent.h> class DomainComponent TaggedObject MovableObject Element Node NodalLoad ElementalLoad SP_Constraint MP_Constraint The DomainComponent class is an abstract class, example subclasses include Element, Node, SP_Constraint , MP_Constraint , NodalLoad, ElementalLoad. Each object of these types is a component of an enclosing Domain object. The DomainComponent class provides methods to set and retrieve a pointer to the enclosing Domain object. Constructor ### Destructor // Public Methods Constructs a DomainComponent with a tag given by tag , whose class tag is given by classTag . The tag of a component is some unique means of identifying the component among like components, i.e. the tag of a node would be its unique node number. The classTag is a means of identifying the class of the object. No domain is associated with the object. The integer tag is passed to the TaggedObject constructor and the integer classTag is passed to the MovableObject constructor. Does nothing. Provided so subclasses destructor\u2019s will always be called. Sets the encompassing domain of the component to that given by theDomain . This method is invoked by theDomain when the component is being added to the domain, in an addDomain.. invocation (see interface for Domain). Returns a pointer to the Domain to which the component was added, or \\(0\\) if the setDomain() command was never called on the object. To cause the object to display itself using theRenderer . The integer displayMode is used to indicate what is to be displayed and the float fact is used to factor the nodal displacements. To return \\(0\\) if successful, a negative number if not. This base class simply returns \\(0\\) . Its up to the subclasses to override this method if the objects are to be rendered.","title":"DomainComponent\n"},{"location":"developer/architecture/class_interface/domain/constraints/MP_Constraint/","text":"MP_Constraint #include <domain/constraints/MP_Constraint.h> class MP_Constraint : public DomainComponent TaggedObject MovableObject An MP_Constraint represents a multiple point constraint in the domain. A multiple point constraint imposes a relationship between the displacement for certain dof at two nodes in the model, typically called the retained node and the constrained node: \\(U_c = C_{cr} U_r\\) An MP_Constraint is responsible for providing information on the relationship between the dof, this is in the form of a constraint Matrix, \\(C_{cr}\\) , and two ID objects, retainedID and constrainedID indicating the dof\u2019s at the nodes represented by \\(C_{cr}\\) . For example, for the following constraint imposing a relationship between the displacements at node \\(1\\) , the constrained node, with the displacements at node \\(2\\) , the retained node in a problem where the x,y,z components are identified as the 0,1,2 degrees-of-freedom: \\[u_{1,x} = 2 u_{2,x} + u_{2,z}\\] \\[u_{1,y} = 3 u_{2,z}\\] the constraint matrix is: \\[C_{cr} = \\left[ \\begin{array}{cc} 2 & 1 \\\\ 0 & 3 \\\\ \\end{array} \\right]\\] constrainedID = \\([0\\) \\(1]\\) and retainedID \\(= [0\\) \\(2]\\) . Constructors ### Destructor // Public Methods // Public Methods for Output To construct a multiple point constraint where the constrained node is given by nodeConstr , the retained node by nodeRetain , the constrainedID by constrainedDOF , the retainedID by retainedDOF and \\(C_{cr}\\) by constraint . The integers tag and CNSTRNT_TAG_MP_Constraint are passed to the DomainComponent classes constructor. New Matrix and ID objects are created to hold the information. For the subclasses to use. The subclasses can vary the contents of the Matrix returned when getConstraint() is invoked. The integers tag classTag are passed to the DomainComponent classes constructor. New ID objects are created to hold the information. Provided for the FEM_ObjectBroker to construct a blank object. The data for the object is filled in when recvSelf() is invoked on the object. \\(0\\) and classTag are passed to the DomainComponent constructor. Invokes the destructor on both the ID and the Matrix object, if a Matrix object is passed in the constructor. Returns the value of nodeRetain passed in the constructor, i.e. the tag of the retained node. virtual int getNodeConstrained(void) const; Returns the value of nodeConstr passed in the constructor, i.e. the tag of the constrained node. virtual const ID &getConstrainedDOFs(void) const; Returns, as a const, the constrainedID formed in the constructor. virtual const ID &getRetainedDOFs(void) const; Returns, as a const, the retainedID formed in the constructor. virtual int applyConstraint(double timeStamp) A method to invoked to inform the MP_Constraint to determine \\(C_{cr}\\) , for the time timeStamp . The base class will do nothing, as Matrix is assumed to be constant. virtual const Matrix & getConstraint ( void ) const ; Returns the current constraint Matrix, that determined in the last call to applyConstraint() . For the MP_Constraint class, \\(C_{cr}\\) determined in the constructor is returned. virtual int sendSelf ( int commitTag , Channel & theChannel ); Creates a Vector, stores the MP_Constraints tag, nodeRetain, nodeConstrained and value in the Vector, and sends the Vector to the Channel using the objects own database tag and commitTag . It then sends the participatingDOF ID and the constraint Matrix, again using the objects database tag and commitTag . Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to send the data. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates a Vector, receives the Vector from the Channel using commitTag and the objects database tag, and sets theMP_Constraints tag, nodeRetain, nodeConstrained from the the Vector. Creates a Vector and a Matrix, and then receives the participatingDOF ID and the constraint Matrix into these objects. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to receive the data. virtual void Print ( OPS_Stream & s , int flag = 0 ); Prints out the MP_Constraints tag, then the tags of the constrained and retained nodes, then the two ID\u2019s and finally the constraint Matrix.","title":"MP_Constraint\n"},{"location":"developer/architecture/class_interface/domain/constraints/SP_Constraint/","text":"SP_Constraint #include <domain/constraints/SP_Constraint.h> class SP_Constraint : public DomainComponent TaggedObject MovableObject DomainComponent An SP_Constraint represents a single point constraint in the domain. A single point constraint specifies the response of a particular degree-of-freedom at a node. The declaration that all methods are virtual allows for time varying constraints to be introduced. Constructors SP_Constraint ( int classTag ); SP_Constraint ( int nodeTag , int ndof , int classTag ); SP_Constraint ( int nodeTag , int ndof , double value , bool isConstant ); Destructor Public Methods virtual int getNodeTag ( void ) const ; virtual int getDOF_Number ( void ) const ; virtual int applyConstraint ( double loadFactor ); virtual double getValue ( void ); virtual bool isHomogeneous ( void ) const ; virtual void setLoadPatternTag ( int loadPaternTag ); virtual int getLoadPatternTag ( void ) const ; Public Methods for Output virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag = 0 ); To construct a single point constraint to constrain the trial displacement of the ndof \u2019th dof at node node to the value given by value . The integer value tag is used to identify the SP_Constraint among all other SP_Constraints. If value is equal to \\(0.0\\) the method isHomogeneous() will always return true , otherwise false . Provided for subclasses to use. The subclasses can vary the value of the imposed displacement when getValue() is invoked. If this constructor is used the isHomogeneous() method will always return false . The integer value tag is used to identify the SP_Constraint among all other SP_Constraints. Provided for the FEM_ObjectBroker to be able to instantiate an object; the data for this object will be read from a Channel object when recvSelf() is invoked. \\(0\\) and classTag are passed to the DomainComponent constructor. Does nothing. Provided so that a subclasses destructor can be invoked. Returns the value of node passed in the constructor, this should be the tag of the node that is being constrained. virtual int getDOF_Number ( void ) const ; Returns the value of ndof that was passed in the constructor, this identifies the dof number corresponding to the constraint. To set the value of the constraint for the load factor given by loadFactor . The constraint is set equal to loadFactor * value if the constraint is not constant, or value if the constraint was identified as constant in the constructor. To return a boolean indicating whether or not the constraint is a homogeneous constraint. A homogeneous constraint is one where the value of the constraint, value , is always \\(0\\) . This information can be used by the ConstraintHandler to reduce the number of equations in the system. virtual double getValue ( void ) const ; To return the value of the constraint determined in the last call to applyConstraint() . This base class returns value passed in the constructor. To set the LoadPattern tag associated with the object to be loadPatternTag . To return the load pattern tag associated with the load. virtual int sendSelf ( int commitTag , Channel & theChannel ); Creates a Vector, and stores the SP_Constraints tag, nodeTag, ndof and value in the Vector. It then passes the Vector as an argument to theChannel objects sendVector() method, along with the objects database tag and commitTag . Subclasses must invoke this method in their implementation of sendSelf() , so that the node and ndof values in remote object can be set. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to send the data. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates a Vector, and receives the Vector from the channel object using the recvVector() method call and the objects own database tag and commitTag . Using the information contained in the Vector, the SP_Constraints tag, nodeTag, ndof and value are set. Subclasses must invoke this method in their implementation of recvSelf() , so that the node and ndof values can be set. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to receive the data. virtual void Print ( OPS_Stream & s , int flag = 0 ) const ; Prints out the SP_Constraints tag, then node , ndof and value .","title":"SP_Constraint\n"},{"location":"developer/architecture/class_interface/domain/domain/Domain/","text":"Domain #include <domain/domain/Domain.h> class Domain Domain is container class for storing and providing access to the components of a domain, i.e. nodes, elements, boundary conditions, and load patterns. A Domain is a container class which contains the all elements, nodes, load cases, single point constraints and multiple point constraints that the model builder uses to create the model of the structure. It provides operations for the following: Population: Methods so that the DomainComponents can be addled to the Domain. Depopulation: Methods so that the DomainComponents can be removed from the Domain. Access: Methods so that other classes, i.e. analysis and design, can access the DomainComponents. Query: Methods for determining the state of the domain. Update: Methods for updating the state of the Domain Analysis: Methods added for the Analysis class. Output: Methods added for outputting information. The Domain class stores each type of object, i.e. Nodes, Elements, SP_Constraints, MP_Constraints, NodalLoads and ElementalLoads, in a container object. Currently these container objects are a subtype of TaggedObjectStorage (templates are not used as yet due to present difficulties in porting code which uses templates). Constructors Destructor // Public Methods to Populate the Domain // Public Methods to Populate the LoadPatterns // Public Methods to Depopulate the Domain // Public Methods to Access the Components of the Domain // Public Methods to Query the State of the Domain // Public Methods to Update the Domain // Public Methods for Output // Protected Member Functions Constructs an empty domain. The storage for the DomainComponents uses ArrayOfTaggedObjects objects for each type of object to be stored. The initial sizes specified for these objects are 4096 for the Elements and Nodes, 256 SP_Constraints and MP_Constraints, and 32 for the container for the LoadPatterns. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Constructs an empty Domain. The storage for the DomainComponents uses ArrayOfTaggedObjects objects for each type of object to be stored. The initial sizes specified for these objects are as given in the arguments for this constructor, i.e. numElements for the Elements and numNodes for the Nodes. A size of 32 is used for the LoadPatterns. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Constructs a Domain where the Nodes, Elements, MP_Constraints, SP_Constraint and LoadPattern objects will be stored in the storage objects provided. A check is made to ensure these container objects are empty is made; if not empty the warning() method of the global ErrorHandler is invoked and the objects are cleared. Constructs a Domain where the Nodes, Elements, MP_Constraints, SP_Constraint and LoadPattern objects will be stored in the storage objects obtained by invoking getEmptyCopy() on the theStorageType object. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Invokes delete on all the storage objects. This means that, if the two latter constructors have been called, the container objects must have been created using new and that at no other point in the program is the destructor invoked on these objects. It should be noted, that the objects in the Domain, i.e. the DomainComponents, are not destroyed. To clean up these objects clearAll() should be invoked before the destructor is called. To add the element pointed to by theElementPtr to the domain. If _DEBUG is defined the domain checks to see that: 1) that all external nodes for the element exists in the domain. and 2) that the sum of the dof at all the nodes equals the num of dof at the element. In addition the domain always checks to ensure that no other element with a similar tag exists in the domain. If the checks are successful, the element is added to the domain by the domain invoking addComponent(theElePtr) on the container for the elements. The domain then invokes setDomain(this) on the element and domainChange() on itself if the element is successfully added. The call returns true if the element is added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addNode ( Node \\ * theNodePtr = false ); To add the node pointed to by theNodePtr to the domain. The domain first checks that no other node with a similar tag, node number, has been previously added to the domain. The domain will then add the node to it\u2019s node container object, by invoking addComponent(theNodePtr) . If successful, the Domain invokes setDomain(this) on the node, domainChange() on itself, and checks the coordinates of the domain to see if they effect the box encompassing the Domain. The call returns true if the node was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addSP ( SP_Constraint \\ * theSPptr = false ); To add the single point constraint pointed to by theSPptr to the domain. If _DEBUG is defined the domain is responsible for checking to see that 1) the constrained node exists in the domain and 2) that the node has the dof that is to be constrained. In addition the domain always checks to ensure that no other constraint with a similar tag exists in the domain. If the checks are successful, the constraint is added to domain by the domain invoking addComponent(theSPptr) on the container for the SP_Constraints. The domain then invokes setDomain(this) on the constraint and domainChange() on itself. The call returns true if the constraint was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addMP ( MP_Constraint \\ * theMPptr = false ); To add the multiple point constraint pointed to by theMPptr, to the domain. If _DEBUG is defined the domain first checks to see that the retained and the constrained node both exist in the model and that the matrix is of proper dimensions (THIS LAST PART NOT YET IMPLEMENTED). In addition the domain always checks to ensure that no other MP_Constraint with a similar tag exists in the domain. If the checks are successful, the constraint is added to domain by the domain invoking addComponent(theMPptr) on the container for the MP_Constraints. The domain then invokes setDomain(this) on the constraint and domainChange() on itself. The call returns true if the constraint was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addLoadPattern ( LoadPattern \\ * thePattern ); To add the LoadPattern thePattern to the domain. The load is added to domain by the domain invoking addComponent(theLd) on the container for the LoadPatterns. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addNodalLoad ( NodalLoad \\ * theLd , int loadPatternTag ); To add the nodal load theld to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding node exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addNodalLoad(theLd) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. virtual bool addElementalLoad(ElementalLoad *theLd, int loadPatternTag); To add the elemental load theld to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding element exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addElementalLoad(theLd) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. virtual bool addSP_Constraint(SP_Constraint *theConstraint, int loadPatternTag); To add the elemental load theConstraint to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding node exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addSP_Constraint(theConstraint) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the constraint. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. To remove all the components from the model and invoke the destructor on these objects. First clearAll() is invoked on all the LoadPattern objects. Then the domain object invokes clearAll() on its container objects. In addition the destructor for each Recorder object that has been added to the domain is invoked. In addition the current time and load factor are set to \\(0\\) , and the box bounding the domain is set to the box enclosing the origin. To remove the element whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the elements. Returns \\(0\\) if no such element exists in the domain. Otherwise the domain invokes setDomain ( 0 ) on the element (using a cast to go from a TaggedObject to an Element, which is safe as only an Element objects are added to this container) and domainChange() on itself before a pointer to the element is returned. virtual Node \\ * removeNode ( int tag ); To remove the node whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the nodes. Returns \\(0\\) if no such node exists in the domain. If the node is to be removed the domain invokes setDomain ( 0 ) on the node and domainChange() on itself before a pointer to the Node is returned. virtual SP_Constraint \\ * removeSP_Constraint ( int tag ); To remove the SP_Constraint whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the single point constraints. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain(0) on the constraint and domainChange() on itself before a pointer to the constraint is returned. Note this will only remove SP_Constraints which have been added to the domain and not directly to LoadPatterns. virtual ` MP_Constraint ` \\ * removeMP_Constraint ( int tag ); To remove the MP_Constraint whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the multi point constraints. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and domainChange() on itself before a pointer to the constraint is returned. virtual LoadPattern \\ * removeLoadPattern ( int tag ); To remove the LoadPattern whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the load patterns. If the LoadPattern exists, the domain then iterates through the loads and constraints of the LoadPattern invoking setDomain ( 0 ) on these objects. Returns \\(0\\) if the load was not in the domain, otherwise returns a pointer to the load that was removed. Invokes setDomain ( 0 ) on the load case before it is returned. To return an iter for the Elements in the domain. It returns an ElementIter for the elements of the domain that were added using addElement() . virtual NodeIter & getNodes ( void ); It returns a NodeIter for the nodes which have been added to the domain. virtual SP_ConstraintIter & getSPs ( void ); To return an SP_ConstraintIter for the single point constraints which have been added to the domain. virtual MP_ConstraintIter & getMPs ( void ); To return an MP_ConstraintIter for the multiple point constraints which have been added to the domain. virtual LoadPatternIter & getLoadPatterns ( void ); To return an LoadPatternIter for the LoadPattern objects which have been added to the domain. virtual Element \\ * getElement ( int tag ); To return a pointer to the element tag . If no such element exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the element container and performing a cast to an element if the object exists. virtual Node \\ * getNode ( int tag ); To return a pointer to the node whose tag is given by tag . If no such node exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the node container and performing a cast to a node if the object exists. virtual SP_Constraint \\ * getSP_ConstraintPtr ( int tag ); To return a pointer to the SP_Constraint whose tag is given by tag . If no such SP_Constraint exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the single-point constraint container and performing a cast to an SP_Constraint if the object exists. virtual ` MP_Constraint ` \\ * getMP_ConstraintPtr ( int tag ); To return a pointer to the MP_Constraint whose tag is given by tag . If no such MP_Constraint exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the multi-point constraint container and performing a cast to an MP_Constraint if the object exists. virtual ElementalLoad \\ * getLoadPattern ( int tag ); To return a pointer to the LoadPattern whose tag is given by tag . If no such LoadPattern exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the elemental load container and performing a cast to a LoadPattern if the object exists. To return the number of elements in the domain. It does this by invoking getNumComponents() on the container for the elements. virtual int getNumNodes ( void ) const ; To return the number of nodes in the domain. It does this by invoking getNumComponents() on the container for the nodes. virtual int getNumSPs ( void ) const ; To return the number of single point constraints in the domain. It does this by invoking getNumComponents() on the container for the single point constraints. virtual int getNumMPs ( void ) const ; To return the number of multi point constraints in the domain. It does this by invoking getNumComponents() on the container for the multi point constraints. virtual int getNumLoadPatterns ( void ) const ; To return the number of load patterns in the domain. It does this by invoking getNumComponents() on the container for the load patterns. virtual const Vector & getPhysicalBounds ( void ); To return the bounding rectangle for the Domain. The information is contained in a Vector of size 6 containing in the following order {xmin, ymin, zmin, xmax, ymax, zmax}. This information is built up as nodes are added to the domain, initially all are set to \\(0\\) in the constructor. virtual Graph & getElementGraph ( void ); Returns the current element graph (the connectivity of the elements in the domain). If the eleChangeFlag has been set to true the method will invoke buildEleGraph(theEleGraph) on itself before returning the graph. The vertices in the element graph are to be labeled \\(0\\) through \\(numEle-1\\) . The Vertices references contain the elemental tags. virtual Graph & getNodeGraph ( void ); Returns the current node graph (the connectivity of the nodes in the domain). If the nodeChangeFlag has been set to true the will invoke buildNodeGraph(theNodeGraph) on itself before returning the graph. The vertices in the node graph are to be labeled \\(0\\) through \\(numNode-1\\) . The Vertices references contain the nodal tags. To set the current commitTag to newTag . To set the current time to newTime . To set the committed time to newTime . To apply the loads for the given time pseudoTime . The domain first clears the current load at all nodes and elements, done by invoking zeroUnbalancedLoad() on each node and zeroLoad() on each element. The domain then invokes applyLoad(pseudoTime) on all LoadPatterns which have been added to the domain. The domain will then invoke applyConstraint(pseudoTime) on all the constraints in the single and multi point constraint containers. Finally the domain sets its current time to be pseudoTime . To set the loads in the LoadPatterns to be constant. The domain achieves this by invoking setLoadConstant() on all the LoadPatterns which have been added to the domain. Note that LoadPatterns added after this method has been invoked will not be constant until this method is invoked again. virtual void commit ( void ); To commit the state of the domain , that is to accept the current state as being ion the solution path. The domain invokes commit() on all nodes in the domain and then commit() on all elements of the domain. These are calls for the nodes and elements to set there committed state as given by their current state. The domain will then set its committed time variable to be equal to the current time and lastly increments its commit tag by \\(1\\) . virtual int revertToLastCommit ( void ); To return the domain to the state it was in at the last commit. The domain invokes revertToLastCommit() on all nodes and elements in the domain. The domain sets its current loadFactor and time stamp to be equal to the last committed values. The domain decrements the current commitTag by \\(1\\) . Finally it invokes applyLoad() on itself with the current time. virtual void update ( void ); Called by the AnalysisModel to update the state of the domain. Iterates over all the elements of the Domain and invokes update() . To set the domain stamp to be newStamp . Domain stamp is the integer returned by hasDomainChanged() . virtual int hasDomainChanged ( void ); To return an integer stamp indicating the state of the domain. Initially \\(0\\) , this integer is incremented by \\(1\\) if domainChange() has been invoked since the last invocation of the method. If the domain has changed it marks the element and node graph flags as not having been built. To add a recorder object theRecorder to the domain. record(commitTag) is invoked on each commit() . The pointers to the recorders are stored in an array which is resized on each invocation of this method. The domain will invoke playback(commitTag) on all recorder objects which have been added to the domain. To print the state of the domain. The domain invokes Print ( s , flag ) on all it\u2019s container objects. This function allows domain objects to be printed to streams. The function invokes \\(M.Print(s)\\) before returning \\(s\\) . Sets a flag indicating that the integer returned in the next call to hasDomainChanged() must be incremented by \\(1\\) . This method is invoked whenever a Node, Element or Constraint object is added to the domain. virtual int buildEleGraph(Graph &theEleGraph) A method which will cause the domain to discard the current element graph and build a new one based on the element connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr. virtual int buildNodeGraph(Graph &theNodeGraph) A method which will cause the domain to discard the current node graph and build a new one based on the node connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr.","title":"Domain\n"},{"location":"developer/architecture/class_interface/domain/domain/partitioned/PartitionedDomain/","text":"UNDER CONSTRUCTION #include </domain/domain/partitioned/PartitionedDomain.h> class PartitionedDomain: public Domain Domain PartitionedDomain is an extension of Domain. A partitioned domain is an aggregation of subdomains. All elements, nodes, loadcases are added to the PartitionedDomain. The components can be moved among subdomains (keeping in mind that subdomains are themselves subclasses of domain and therefore must obey the requirements for adding and removing elements specified in the interface for Domain) by invoking the remove..() and add...() methods on the subdomain. Constructors Destructor // Public Member Functions - which extend the Domain class // Public Member Functions - inherited from Domain but rewritten // Protected Methods virtual int buildEleGraph(Graph &theEleGraph) Constructs an empty PartitionedDomain. A link with the domain partitioner thePartitioner is set up. The thePartitioner is used by the domain to partition and load balance the partitioned domain. Constructs an empty PartitionedDomain, storage is allocated for the components that are to be added using the estimated number of components passed as arguments. A link with the domain partitioner thePartitioner is set up. The thePartitioner is used by the domain to partition and load balance the partitioned domain. Deletes the storage components. Method which first checks that subdomains with tags 1 through numPartitions exist in the PartitionedDomain. Then it invokes setPartitionedDomain(*this) on the DomainPartitioner and finally it returns the result of invoking partition(numPartitions on the DomainPartitioner, which will return 0 if successful, a negative number if not. virtual bool addSubdomain ( Subdomain \\ * theSubdomainPtr ); Adds the subdomain pointed to by theSubdomainPtr to the domain. The domain is responsible for checking that no other subdomain with a similar tag, has been previously added to the domain. If successful the domain is responsible for invoking setDomain(this) on the Subdomain. The domain is also responsible for invoking domainChange() . The call returns false if the subdomain was not added, otherwise true is returned. virtual int getNumSubdomains ( void ); Method which returns the number of Subdomains (partitions). virtual Subdomain \\ * getSubdomainPtr ( int tag ); Returns the Subdomain whose tag is given by tag . virtual SubdomainIter & getSubdomains ( void ); Returns an iter for the Subdomains of the PartitionedDomain. Node *removeExternalNode(int tag); A method to remove a Node whose tag is given by tag from the PartitionedDomain, but will not remove the Node from any Subdomains. Graph &getSubdomainGraph(void); This will create a new graph each time it is invoked; deleting the old graph. THIS WILL BE CHANGED. A vertex is created for each Subdomain, with an edge to each Subdomain the Subdomain is connected to, a tag equal to the Subdomain tag, and a weight equal to the result of invoking getCost() on the Subdomain. To add the element pointed to by theElementPtr to the domain. If check is true the domain is responsible for checking to see that: 1) no other element with a similar tag, element number, exists in any of the subdomains. If check is successful the partitioned domain attempts to add the element to the storage arrey. The call returns false if the element was not added, otherwise true is returned. virtual bool addNode ( Node \\ * theNodePtr , bool check = false ); Adds the node pointed to by theNodePtr to the domain. If check is true the domain is responsible for checking that no other node with a similar tag, node number, exists in any of the subdomains. If successful the partition domain attempts to add the node by invoking Domain::addNode . The call returns false if the node was not added, otherwise true is returned. virtual bool addSP_Constraint(SP_Constraint *theSPptr, bool check = false); Adds the single point constraint pointed to by theSPptr to the domain. The domain performs some checks is check is true. If successful the domain adds the constraint using Domain::addSP_Constraint() . The call returns false if the constraint was not added, otherwise true is returned. virtual bool addMP ( MP_Constraint \\ * theMPptr , bool check = false ); Adds the multiple point constraint pointed to by theMPptr, to the domain. The domain performs some checks is check is true. If successful the domain adds the constraint using Domain::addMP_Constraint() . The call returns false if the constraint was not added, otherwise true is returned. virtual bool addLoadCase ( LoadCase \\ * theLCptr ); It returns an PartionedDomEleIter for the elements of the domain. This is an iter which goes through all the subdomains, invoking getElements() on the subdomain to get an ElementIter. The PartitionedDomEleIter uses this iter to go through the elements of the subdomain until it begins returning \\(0\\) ; at which point it goes on to the next subdomain. virtual Element \\ * getElement ( int tag ) const ; Returns a pointer to the element whose tag is given by tag . If no such element exists \\(0\\) is returned. This is done by invoking getElement(tag) on the subdomains until the element is found or no more subdomains exist; in which case a \\(0\\) is returned. virtual Node \\ * getNode ( int tag ) const ; Returns a pointer to the node whose tag is given by tag . If no such node exists \\(0\\) is returned. This is done by invoking getNode(tag) on the subdomains until the element is found or no more subdomains exist; in which case a \\(0\\) is returned. virtual LoadCase \\ * getLoadCasePtr ( int tag ) const ; Returns a pointer to the element whose tag is given by tag . If no such load case exists \\(0\\) is returned. Sets the current load case of the domain to be that whose tag is given by LCtag. It iterates through all the subdomains invoking the same operation on them. Returns false if no such load case exists, otherwise returns true . Sets the current load case of the domain to be that whose tag is given by newTime . It iterates through all the subdomains invoking the same operation on them. virtual void applyLoad ( double time = 0.0 , double loadFactor = 1.0 ); The partitioned domain iterates through all the subdomains invoking applyLoad(double timeStamp) on them. virtual void linearize ( void ); The partitioned domain iterates through all the subdomains invoking linearize() on them. virtual void commit ( void ); The partitioned domain iterates through all the subdomains invoking commit() on them. Returns the tag of the current load case set for the domain. If no load case is set \\(-1\\) is returned. Returns the currentTime set for the domain. If no load case is set \\(0\\) is returned. Returns the number of elements in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumNodes ( void ) const = 0 ; Returns the number of nodes in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumSPs ( void ) const ; Returns the number of SP_Constraints in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumMPs ( void ) const ; Returns the number of MP_Constraints in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumLCs ( void ) const ; Returns the number of LoadCases in the domain. This number is obtained by summing the contributions from each subdomain. virtual Domain \\ * getEmptyDomainCopy ( void ); Returns an empty copy of the actual domain. virtual Element \\ * removeElement ( int tag ); To remove the element whose tag is given by tag from the domain. The method Returns \\(0\\) if no such element exists in the domain. Otherwise the domain invokes setDomain ( 0 ) on the element and setDomainChange(true,true,false) on itself before a pointer to the element is returned. virtual Node \\ * removeNode ( int tag , bool checkNeeded = true ); To remove the node whose tag is given by tag from the domain. Returns \\(0\\) if no such node exists in the domain. Otherwise if the checkNeeded is true before the node is removed a check is made to see that the node is not referenced by any element, constraint or load. If it is referenced the Node will not be removed and \\(0\\) is returned. If the node is to be removed the domain invokes setDomain ( 0 ) on the node and setDomainChange(true,false,true) on itself before a pointer to the Node is returned. virtual LoadCase \\ * removeLoadCase ( int tag ); To remove the load case whose tag is given by tag from the domain. Returns \\(0\\) if the load case was not in the domain, otherwise returns a pointer to the load case that was removed. Invokes setDomain ( 0 ) on the load case before it is returned. virtual SP_Constraint \\ * removeSP_Constraint ( int tag ); To remove the SP_Constraint whose tag is given by tag from the domain. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and setDomainChange(true,false,false) on itself before a pointer to the constraint is returned. virtual ` MP_Constraint ` \\ * removeMP_Constraint ( int tag ); To remove the MP_Constraint whose tag is given by tag from the domain. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and setDomainChange(true,false,false) on itself before a pointer to the constraint is returned. Will return a pointer to the DomainPartitioner object associated with the PartitionedDomain. virtual int buildEleGraph(Graph &theEleGraph) A method which will cause the domain to discard the current element graph and build a new one based on the element connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr.","title":""},{"location":"developer/architecture/class_interface/domain/load/Load/","text":"Load #include <domain/load/Load.h> class Load: public DomainComponent TaggedObject MovableObject DomainComponent Load is an abstract base class. A Load object is used to add load to the domain. The Load class defines one method in its interface applyLoad() , a method all subclasses must implement. Constructor ### Destructor // Public Methods Constructs a load with a tag given by tag and a class tag is given by classTag . These are passed to the DomainComponent constructor. The load object is to add loadFactor times the load to the corresponding residual value at its associated element(s) or node(s). To set the tag of the enclosing load pattern for the load to be loadPatternTag . To return the current load pattern tag associated with the load. If no load pattern tag has been set \\(-1\\) is returned.","title":"Load\n"},{"location":"developer/architecture/class_interface/domain/node/DummyNode/","text":"DummyNode #include <DummyNode.h> class DummyNode : public DomainComponent DomainComponent DummyNodes are a type of node created and used by Subdomains for their exterior nodes. They reference a real node and most methods invoked on them are in turn invoked by the dummy node on the real node. The calls asking the real node to change its current state are ignored. The calls involving DOF_Group are handled by the dummy node. To construct a dummy node which is associated with the node pointed to by theRealNode . Each DummyNode, when involved with a StaticCondensationAnalysis analysis, will be associated with a DOF_Group object. It is the DOF_Group that contains the ID of equation numbers. When invoked this method sets that link for the DummyNode object. virtual ` DOF_Group ` \\ * getDOF_GroupPtr ( void ); Method which returns a pointer to the DOF_Group object that was set using setDOF_GroupPtr . If no pointer has been set a \\(0\\) is returned. virtual int getNumberDOF ( void ) const ; Returns the result of invoking getNumberDOF() on its associated Node object. virtual Vector & getMass ( void ) const ; Returns the result of invoking getMass() on its associated Node object. virtual void setMass ( Vector & mass ); Invokes getNumberDOF() on its associated Node object. virtual const Vector & getCrds ( void ) const ; Returns the result of invoking getCrds() on its associated Node object. virtual const Vector & getDisp ( void ) const ; Returns the result of invoking getDisp() on its associated Node object. virtual const Vector & getVel ( void ) const ; Returns the result of invoking getVel() on its associated Node object. virtual const Vector & getAccel ( void ) const ; Returns the result of invoking getAccel() on its associated Node object. virtual const Vector & getTrialDisp ( void ) const ; Returns the result of invoking getTrialDisp() on its associated Node object. virtual const Vector & getTrialVel ( void ) const ; Returns the result of invoking getTrialVel() on its associated Node object. virtual const Vector & getTrialAccel ( void ) const ; Returns the result of invoking getTrialAccel() on its associated Node object. void addUnbalancedLoad ( const Vector & additionalLoad ); Returns the result of invoking addUnbalancedLoad() on its associated Node object. virtual const Vector & getUnbalancedLoad ( void ) const ; Returns the result of invoking getUnbalancedLoad() on its associated Node object. The following commands do nothing, they just return.","title":"DummyNode\n"},{"location":"developer/architecture/class_interface/domain/node/NodalLoad/","text":"NodalLoad #include <domain/node/NodalLoad.h> class NodalLoad: public Load TaggedObject MovableObject DomainComponent Load NodalLoads are loads acting on Nodes. The public methods are all declared as virtual to allow subclasses to be introduced for the provision of time varying loads. Each NodalLoad object is associated with a single Node object and has a Vector object corresponding to the load acting on this Node object as a result of the NodalLoad. Constructors ### Destructor // Public Methods // Public Methods for Output To create a NodalLoad object with tag tag acting on Node node with a reference load given by load . tag and LOAD_TAG_NodalLoad (defined in <classTags.h> )are passed to the Load constructor. A new vector object is created using the vector load as the argument. (THIS MAY CHANGE - may associate the load Vector with load , allowing identical loads on diff nodes to be created without the need for each to have its own vector) If no enough memory is available an error message is printed and the program terminates. The boolean isLoadConstant is used to indicate whether the value of the load applies to the Node is independent of the load factor. Provided for subclasses, which may which to provide the abstraction of time varying nodal loads. The integers tag and classTag are passed to the Load constructor. Provided so that a FEM_ObjectBroker can construct an object. \\(0\\) and classTag are passed to the Load classes constructor. The data for the object is filled in when recvSelf() is invoked on the object. If a Vector for the load was constructed, the destructor invokes delete on this Vector object. To set the associated Domain object. First checks to ensure that a Node object with the tag exists in the Domain. It sets the pointer for it\u2019s associated Node object to point to this object, and then invokes the DomainComponent classes setDomain() method. If the Node does not exist in the Domain a warning message and setDomain() is not invoked. Returns the integer node passed in the constructor. To it\u2019s associated Node it invokes addUnbalancedLoad() with it\u2019s copy of the Vector object load and a factor of loadFactor if isLoadConstant was specified as false in the constructor or \\(1\\) if it was specified as true . Warning messages are printed, if no Domain has been associated with the NodalLoad object or no Node with a tag node exists in the Domain. For efficiency reasons, the NodalLoad object keeps a pointer to it\u2019s associated Node object. The time timeStep has no influence on the load added. Determines its database tag. The object then sends it\u2019s tag, node and size of load Vector to the Channel in an ID object. Then, if load is not NULL, it sends it\u2019s copy of the load Vector. Returns \\(0\\) if successful, a negative number if the Channel failed to send the data. The object first determines its database tag. It then invokes receives an ID object from the Channel containing it\u2019s tag, node and size of load Vector. If size of load is not \\(0\\) it then receives it\u2019s copy of the load Vector. Returns \\(0\\) if successful, a negative number if the Channel failed to receive the data. Prints it\u2019s node and then prints the load Vector.","title":"NodalLoad\n"},{"location":"developer/architecture/class_interface/domain/node/Node/","text":"Node NEW METHOD POSSIBLY NEEDED TO SPECIFY THE NUMBER OF PREVIOUSLY COMMITTED RESPONSES TO KEEP .. NEEDED FOR EXPLICIT DYNAMIC INTEGRATORS #include </domain/node/Node.h> class Node : public DomainComponent TaggedObject MovableObject Nodes are points in space connected by the elements. Nodes have original position, trial displacement, velocity and acceleration, and committed displacement, velocity and acceleration (the last committed trial quantities). Nodes also store information about any load acting on the node, nodal mass and the nodal participation matrix. In addition, each Node object keeps track of it\u2019s associated DOF_Group object. The Node interface provides methods to set and retrieve these quantities. Constructors Destructor // Public Methods dealing with DOF at the Node // Public Method for obtaining nodal coordinates // Public Method for obtaining committed and trial responses // Public Method for updating trial responses // Public Method for setting and obtaining unbalanced load // Public Method for setting state // Public Method for dynamic and modal analysis // Public Method for Output To construct a node which has no data, other than the classTag identifier; \\(0\\) and classTag are passed to the DomainComponent constructor. This is the constructor called by an FEM_ObjectBroker. The data must be filled in subsequently by a call to recvSelf() . To construct a node whose unique integer among nodes in the domain is given by tag and whose classTag is given by classTag . This constructor can be used by subclasses who wish to handle their own data management. To construct a node for 1d problems whose unique integer among nodes in the domain is given by tag and whose original position in 1d space is given by (Crd1). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node (defined in classTags.h). A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node for 2d problems whose unique integer among nodes in the domain is given by tag and whose original position in 2d space is given by (Crd1,Crd2). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node. A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node for 3d problems whose unique integer among nodes in the domain is given by tag and whose original position in 3d space is given by (Crd1,Crd2,Crd3). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node. A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node which is an exact copy of theCopy . Invokes the destructor on all the storage objects created to hold the coordinates, response quantities, mass and load quantities. Returns the number of degrees-of-freedom, ndof , associated with the node. Each node, when involved with an analysis, will be associated with a DOF_Group object. It is the DOF_Group that contains the ID of equation numbers. When invoked this method sets the pointer to that DOF_Group object. virtual ` DOF_Group ` \\ * getDOF_GroupPtr ( void ); Method which returns a pointer to the DOF_Group object that was set using setDOF_GroupPtr . If no pointer has been set a \\(0\\) is returned. virtual const Vector & getCrds ( void ) const ; Returns the original coordinates in a Vector. The size of the vector is 2 if node object was created for a 2d problem and the size is 3 if created for a 3d problem. virtual const Vector & getDisp ( void ) ; Returns the last committed displacement as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getVel ( void ) ; Returns the last committed velocity as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getAccel ( void ) ; Returns the last committed acceleration as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getTrialDisp ( void ) ; Returns the current trial displacements as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getTrialVel ( void ) ; Returns the current trial velocities as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getTrialAccel ( void ) ; Returns the current trial accelerations as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getIncrDisp ( void ) ; Returns the incremental displacement as a Vector. The incremental displacement is equal to the difference between the current trial displacement and committed displacement (trial - committed). If no Vector has yet been allocated, three Vector objects are created to store the committed, trial and incremental response quantities; if not enough space is available an error message is printed and program terminated. virtual int setTrialDisp ( const Vector & newTrialDisp ); Sets the current trial displacement to be that given by newTrialDisp . Sets th incremental displacement to be trial \\(-\\) committtd. If no space has yet been allocated for the trial displacements, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialDisp is not of size ndof . virtual int setTrialVel ( const Vector & newTrialVel ); Sets the current trial velocity to be that given by newTrialVel . If no space has yet been allocated for the trial velocities, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialVel is not of size ndof . virtual int setTrialAccel ( const Vector & newTrialAccel ); Sets the current trial acceleration to be that given by newTrialAccel . If no space has yet been allocated for the trial accelerations, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialAccel is not of size ndof . virtual int incrTrialDisp ( const Vector & trialIncrDisp ); Sets the current trial displacement to be that given by the addition of the last trial displacement, assumed \\(0\\) if not yet set, and trialIncrDisp . Increments the incremental displacement by trialIncrDisp . If no space has yet been allocated for the displacements, three Vector objects are now created to store the trial, committed and incremental response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrDisp is not of size ndof . virtual int incrTrialVel ( const Vector & trialIncrVel ); Sets the current trial velocity to be that given by the addition of the last trial velocity, assumed \\(0\\) if not yet set, and trialIncrVel . If no space has yet been allocated for the trial velocities, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrVel is not of size ndof . virtual int incrTrialAccel ( const Vector & trialIncrAccel ); Sets the current trial Acceleration to be that given by the addition of the last trial Acceleration, assumed \\(0\\) if not yet set, and trialIncrAccel . If no space has yet been allocated for the trial accelerations, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrAccel is not of size ndof . virtual void zeroUnbalancedLoad ( void ); Causes the node to zero out its unbalanced load vector. virtual int addUnbalancedLoad(const Vector &additionalLoad, double fact); The Node is responsible for adding fact times additionalLoad to the current unbalanced load at the Node. If additionalLoad is not of size ndof no load is added, an error message is printed and a \\(-1\\) is returned. If no space has yet been allocated for the unbalanced load a new Vector is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. Returns \\(0\\) if successful. To add minus fact times the product \\(M * R * accel\\) to the current unbalanced load. Nothing is done if no mass or R matrix have been set. Prints a warning and returns a \\(-1\\) if the size of accel and the number of columns in \\(R\\) are not the same. If no space has yet been allocated for the unbalanced load a new Vector is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. Returns \\(0\\) if successful. virtual const Vector & getUnbalancedLoad ( void ); Returns the current unbalanced load. If no space has yet been allocated for the unbalanced load a new Vector of size numDOF is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. virtual const Vector & getUnbalancedLoadIncInertia ( void ); Returns the current unbalanced load Vector, as defined above, MINUS the product of the nodes mass matrix and the trial nodal accelerations. The result is saved in another vector which is returned. If no space has yet been allocated for this new Vector, a Vector of size numDOF is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. virtual int commitState ( void ); Causes the node to set the committed model displacements, velocities and accelerations to be equal to the current trial displacements, velocities and accelerations. The incremental displacement is set to \\(0\\) . No assignment is done for any of the quantities for which no memory has been allocated. Returns \\(0\\) . virtual int revertToLastCommit ( void ); Causes the node to set the trial nodal displacements, velocities and accelerations to be equal to the current committed displacements, velocities and accelerations. The incremental displacement is set to \\(0\\) . No assignment is done for any of the trial quantities for which no memory has been allocated. Returns \\(0\\) . virtual int revertToStart ( void ); Causes the node to set the trial and committed nodal displacements, velocities and accelerations to zero. No assignment is done for any of the trial quantities for which no memory has been allocated. Returns \\(0\\) . virtual const Matrix & getMass ( void ) ; Returns the mass matrix set for the node, which is a matrix of size ndof,ndof . This matrix is equal to that set in setMass() or zero if setMass() has not been called. If no storage space has been allocated for the mass, a matrix is now created. An error message is printed and the program terminated if no space is available on the heap for this matrix. virtual int setMass ( const Matrix & mass ); Sets the value of the mass at the node. A check is made to ensure that the mass has the same dimensions of the mass matrix associated with the Node; if incompatible size an error message is printed and -1 returned. If no mass matrix yet allocated, one is created; if no space is available an error message is printed and the program terminated. Returns 0 if successful. Creates a Matrix to store the R matrix. The matrix is of dimension ndof and numCol . If not enough space is available for this matrix an error message is printed and the program is terminated. Zeros the matrix R and returns \\(0\\) if successful. Sets the \\(row,col\\) entry of R to be equal to Value . If no matrix R has been specified or the position in R is out of range a warning message is printed and a \\(-1\\) is returned. Returns \\(0\\) if successful. This is a method provided for Element objects, the Node object returns the product of the matrix \\(R\\) and the vector \\(V\\) . If the matrix and vector are of inappropriate size a warning message is printed and a zero vector is returned. virtual int sendSelf ( int commitTag , Channel & theChannel ); Causes the Node object to send the data needed to init itself on a remote machine to the Channel object theChannel . The data sent includes the tag, number of dof, coordinates, committed response quantities, unbalanced load, mass and participation matrix. To do this the Node creates an ID object into which it stores its tag, the ndof and a flag indicating whether any additional information, i.e. mass, response quantities also need to be sent. In addition four database tags are also included in this ID object. The database tags, if not already obtained, are requested from the Channel object (these are needed as each object can only store a single object of a particular size using it\u2019s own database tags \u2013 additional tags are needed when multiple objects of the same size are needed. The objects that have been created are then sent. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Invoked on a remote machine to read its data that was sent by a node object in another actor when sendSelf() was invoked. As in sendSelf() , the Node object creates an ID object. It asks the Channel object to fill this object with data. Based on the data it creates Matrix and Vector objects to store the Nodes data and asks the Channel object to fill these with data. The data placed here by the Channel object correspond to the data put there by the sending Node object. void Print ( OPS_Stream & s , int flag = 0 ); Causes the Node to print out its tag, mass matrix, and committed response quantities. Causes the Node to display itself. If flag is \\(1\\) the Node will cause its tag to be printed to the display.","title":"Node\n"},{"location":"developer/architecture/class_interface/domain/partitioner/DomainPartitioner/","text":"UNDER CONSTRUCTION DomainPartitioner #include <domain/partitioner/DomainPartitioner.h> class DomainPartitioner A DomainPartitioner is an object used to partition and load balance a PartitionedDomain. The DomainPartitioner uses the element graph of the domain to partition and load balance. Derived types can use the node graph of the domain. The partitioner uses a GraphPartitioner and a LoadBalancingAlgo to partition and load balance the domain. Constructors Destructor // Public Methods // Public Methods Used by the LoadBalancer Constructs a DomainPartitioner which will use theGraphPartitioner to initially partition the PartitionedDomain using the element graph and the theLoadBalancer to load balance the PartitionedDomain. The max number of subdomains that the Domain can be partitioned is currently set at 8. Constructs a DomainPartitioner which will use theGraphPartitioner to initially partition the PartitionedDomain. The max number of subdomains that the Domain can be partitioned is currently set at 8. Sets the link with the PartitionedDomain that is to be partitioned. virtual int partition ( int numParts ); Method invoked to partition the Domain. It first checks to see that the PartitionedDomain has at least numParts Subdomains, with tags 1 through numParts ; if not prints an error message and returns -1. It then asks the domain for the element graph. This graph is then partitioned using the GraphPartitioner into numParts ; if partitioning fails an error message is printed and \\(-10 +\\) number returned from GraphPartitioner is returned. If successful the domain is partitioned according to the following rules: All nodes which are internal to a partition are added using the addNode() method of the Subdomain. These nodes are removed from the PartionedDomain using removeNode() . External nodes (these are nodes shared across partitions as a result of element connectivity or MP_Constraints are added to those Subdomains whose elements reference them. They are added using the addExternalNode() command. SP_Constraints whose node is interior to a Subdomain are removed from the PartitionedDomain and added to the Subdomain. MP_Constraints whose two nodes are interior to a Subdomain are removed from the PartitionedDomain and added to the Subdomain. The elements are sent to the partition whose tag is given by the color of the vertex in the partitioned (colored) element graph. The elements are removed from the PartitionedDomain using removeElement() and added to the Subdomain using addElement() . For the loads, a check is made to ensure that each Subdomain has a LoadCase with a tag equal to the tags in the LoadCases that have been added to the PartitionedDomain; if not new LoadCases are created and added to the Subdomain. It then iterates through all the NodalLoads in the LoadCases in the PartionedDomain, if the corresponding node is external the NodalLoad is removed and added to the corresponding LoadCase in the Subdomain. ELEMENTAL LOADS are not yet dealt with. The DomainPartitioner invokes hasDomainChanged() on each Subdomain; if the Subdomain has changed invokeChangeOnAnalysis() . Finally hasDomainChanged() is invoked on the PartitionedDomain; if it has changed invokeChangeOnAnalysis() . partitionFlag is set to true. virtual void balance(Graph &theWeightedGraph) Checks first to see that the partitionFlag has been set; if it hasn\u2019nt an error message is printed and a \\(-1\\) is returned. If a LoadBalancer was passed in the constructor balance() is invoked on this object; if no LoadBalancer was passed nothing is done and method returns \\(0\\) . If balancing is performed, the DomainPartitioner invokes hasDomainChanged() on each Subdomain; if the Subdomain has changed invokeChangeOnAnalysis() . Finally hasDomainChanged() is invoked on the PartitionedDomain; if it has changed invokeChangeOnAnalysis() . partitionFlag is set to true. Method which invokes setPartitioner(this) on the LoadBalancingAlgo. It then invokes balance(load) on this object, where load is vector of size numParts containing the load of each subdomain. Returns the number of partitions in the PartitionedDomain. Method which returns the partition graph. This is a graph with a vertex for every partition and an edge between partitions if there exists an element in one partition which is connected to an element in the other partition. virtual Graph &getColoredGraph(void); A method which returns the current colored graph representing the partitioning of the elements in the subdomains. Does this by invoking getElementGraph() on the PartitionedDomain. Note that this is the same graph that was colored by the DomainPartitioner in partitioning the PartitionedDomain. virtual void swapVertex(int from, int to, int vertexTag, bool notAdjacentOther = true); Method which will take the element given by vertex reference of the vertex whose tag is given by vertexTag from subdomain from and place it in subdomain to . If notAdjacentOther is true a check is made to ensure that the vertex to be swapped is not adjacent to a vertex in any other partition. Returns \\(0\\) if successful, returns an error message and \\(-1\\) if PartitionedDomain has not been partitioned, \\(-2\\) if from Subdomain does not exist, \\(-3\\) if to Subdomain does not exist, \\(-4\\) if a vertex given by tag does not exist, returns \\(-5\\) if notAdjacentOther was true and the vertex was adjacent to a vertex in another partition, and returns \\(-6\\) if no Element with a tag similar to tag exists (this should not happen if element graph is built correctly). The Element, Nodes, NodalLoads, SP_Constraints and MP_Constraints that need to be moved between the two Subdomains, or between the PartitionedDomain and Subdomains are also moved. NO ELEMENTAL LOADS are moved yet. virtual void swapBoundary(int from, int to, bool notAdjacentOther = true); Method which when invoked will take all the boundary elements in subdomain from that are connected to elements in subdomain to and place them in subdomain to . If adjacentVertexOther is true no Elements which are connected to elements in subdomains other than to and from are moved. Returns \\(0\\) if successful, returns an error message and \\(-1\\) if PartitionedDomain has not been partitioned, \\(-2\\) if from Subdomain does not exist, \\(-3\\) if to Subdomain does not exist. The Elements, Nodes, NodalLoads, SP_Constraints and MP_Constraints that need to be moved between the two Subdomains, or between the PartitionedDomain and Subdomains are also moved. NO ELEMENTAL LOADS are moved yet. It performs the operation by creating an ID of vertices and then using code similar to that used in swapVertex() ; swapVErtex() is not called repeatedly as this was found to be too slow. virtual int releaseVertex(int from, int vertexTag, Graph &theWeightedPartitionGraph, double factorGreater, bool adjacentVertexOonly); Method which when invoked will take the element given by vertex reference of the vertex whose tag is given by vertexTag from subdomain from and place it in the subdomain to which it is most attracted (to which it is most connected). If it is equally attracted to two subdomains it is sent to the one with the lightest load (the loads on the subdomains are given in the theWeightedPartitionGraph . If the mustReleaseToLighter is true a check is first made to see if the load on the intended subdomain is lighter than the load in from and that the ratio in load between from and the new domain is greater than factorGreater ; if this is the case the element is swapped, if not the element is not swapped. An additional requirement that the vertex that is to be swapped is not adjacent to any other partition can also be set. The method determines which partition the vertex is to be sent to and then returns the result of invoking swapVertex() on itself, with this partition used as the to argument in the arguments. virtual int releaseBoundary(int from, Graph &theWeightedPartitionGraph, double factorGreater, bool adjacentVertexOonly); Method which when invoked will release all the elements on the boundary of subdomain from . It performs the operation by creating an ID of all the vertices on the boundary of the from Subdomain. Then releaseBoundary() is invoked on all these vertices.","title":"DomainPartitioner\n"},{"location":"developer/architecture/class_interface/domain/pattern/EarthquakePattern/","text":"EarthquakePattern #include <domain/pattern/EarthquakePattern.h> NEEDS MODIFICATION TO ALLOW MULTIPLE EARTHQUAKE PATTERNS, SO DON\u201dT HAVE TO SET R IN NODES EACH APPLYLOAD. class EarthquakePattern: public LoadPattern TaggedObject MovableObject DomainComponent LoadPattern The EarthquakePattern class is an abstract class. An EarthquakePattern is an object which adds earthquake loads to models. This abstract class keeps track of the GroundMotion objects and implements the applyLoad() method. It is up to the concrete subclasses to set the appropriate values of R at each node in the model. Constructor ### Destructor // Public Methods // Protected Methods The integers tag and classTag are passed to the LoadPattern classes constructor. Invokes the destructor on all GroundMotions added to the Earthquakepattern. It then invokes the destructor on the array holding pointers to the GroundMotion objects. Obtains from each GroundMotion, the velocity and acceleration for the time specified. These values are placed in two Vectors of size equal to the number of GroundMotion objects. For each node in the Domain addInertiaLoadToUnbalance() is invoked with the acceleration Vector objects. SIMILAR OPERATION WITH VEL and ACCEL NEEDS TO BE INVOKED ON ELEMENTS .. NEED TO MODIFY ELEMENT INTERFACE Adds the GroundMotion, theMotion to the list of GroundMotion objects.","title":"EarthquakePattern\n"},{"location":"developer/architecture/class_interface/domain/pattern/LoadPattern/","text":"LoadPattern #include <domain/pattern/LoadPattern.h> class LoadPattern : public DomainComponent TaggedObject MovableObject DomainComponent The LoadPattern class is a concrete base class. A LoadPattern is a container class for Load and SP_Constraint objects. Each LoadPattern object is associated with a TimeSeries object which, for a given pseudo time, will return the appropriate load factor to be applied to the load in the LoadPattern. // Constructors // Destructor // Public Methods The integer tag is passed to the DomainComponent classes constructor. Creates three ArrayOftaggedObjects objects to store pointers to the NodalLoad, ElementalLoad and SP_Constraints and three iters. If not enough memory is available for these objects an error message is printed and the program is terminated. This is the constructor provided for subclasses to use. The integers tag and classTag are passed to the DomainComponent classes constructor. Invokes the destructor on the TimeSeries object. Also invokes the destructor on any objects created in the constructor for storage of the pointers and for iters. It does not invoke the destructor on these objects, the Domain object is responsible for doing this. If a TimeSeries object is associated with the pattern, the destructor is invoked on that TimeSeries object. It then sets the TimeSeries object associated with the LoadPattern to theSeries . If any loads or constraint objects exist in the LoadPattern, the LoadPattern will invoke setDomain() on those objects. Finally invokes the DomainComponent classes setDomain() method. Adds the NodalLoad object pointed to by theLoad to the LoadPattern. If the LoadPattern could add the pointer to its storage object for nodal loads, it will invoke setDomain() and setLoadPattern() on the load object if a Domain has been set. Adds the ElementalLoad pointed to by theLoad to the LoadPattern. If the LoadPattern could add the pointer to its storage object for elemental loads, it will invoke setDomain() and setLoadPattern() on the load object if a Domain has been set. Adds the SP_Constraint pointed to by theSp to the LoadPattern. If the LoadPattern could add the pointer to its storage object for single-point constraints, it will invoke setDomain() and setLoadPattern() on the constraint object if a Domain has been set. Returns an iter to the nodal loads in the LoadPattern. Returns an iter to the elemental loads in the LoadPattern. Returns an iter to the single-point constraints in the LoadPattern. To remove the nodal load whose identifier is given by tag from the LoadPattern and sets the loads associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To remove the elemental load whose identifier is given by tag from the LoadPattern and set the loads associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To remove the single-point constraint whose identifier is given by tag from the LoadPattern and st its associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To apply the load for the pseudo time pseudoTime . From the associated TimeSeries object the LoadPattern will obtain a current load factor for the pseudo time. It will then invoke applyLoad ( load factor ) on the loads and applyConstraint ( load factor ) on the single-point constraints in the LoadPattern. If setLoadConstant() has been invoked, the saved load factor is used and no call is made to the TimeSeries object. If no TimeSeries is associated with the object a load factor of 0.0 is used. Marks the LoadPattern as being constant. Subsequent calls to applyLoad() will use the current load factor. Creates a vector of size 4 into which it places the current load factor, the mark indicating whether LoadPattern is constant, and the database tag and class tag of the TimeSeris object. Invokes sendVector() on the Channel object and sendSelf() on the TimeSeries object. Does the mirror image of sendSelf() . Invokes Print ( s , flag ) on the TimeSeries, NodalLoads, ElementalLoads and SP_Constraints.","title":"LoadPattern\n"},{"location":"developer/architecture/class_interface/domain/pattern/TimeSeries/","text":"TimeSeries #include <domain/pattern/TimeSeries.h> class TimeSeries : public DomainComponent MovableObject The TimeSeries class is an abstract base class. A TimeSeries object is used in a LoadPattern to determine the current load factor to be applied to the loads and constraints for the time specified. Constructor ### Destructor // Pure Virtual Public Methods The integer classTag is passed to the MovableObject classes constructor. Does nothing. To return the current load factor for the given value of pseudoTime to be applied to the loads and single-point constraints in a LoadPattern based on the value of pseudoTime . To print to the stream s output based on the value of flag .","title":"TimeSeries\n"},{"location":"developer/architecture/class_interface/element/Element/","text":"Element NEED TO ADD ADD_INERTIA_LOAD TO INTERFACE .. SEE EARTHQUAKE_PATTERN CLASS. #include <element/Element.h> class Element : public DomainComponent TaggedObject MovableObject Element is an abstract class, i.e. no instances of Element will exist. The element class provides the interface that all element writers must provide when introducing new element classes. Constructor & Destructor To construct an element whose unique integer among elements in the domain is given by tag , and whose class identifier is given by classTag . Both of these integers are passed to the DomainComponent constructor. The destructor. Declared as virtual to allow subclass destructors to be invoked. Public Methods dealing with Nodes and dof Public Methods dealing with State Public Methods for obtaining Linearized Stiffness, Mass and Damping Matrices Public Methods for obtaining Resisting Forces methods for obtaining information specific to an element To return the number of external nodes associated with the element. To return an ID containing the tags of the external nodes for the element. To return the number of dof associated with the element. This should equal the sum of the dofs at each of the external nodes. To ensure this, each subclass can overwrite the DomainComponent classes setDomain() method. virtual int commitState ( void ) = 0 ; The element is to commit its current state. To return \\(0\\) if successful, a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; The element is to set it\u2019s current state to the last committed state. To return \\(0\\) if successful, a negative number if not. virtual int revertToStart ( void ) = 0 ; The element is to set it\u2019s current state to the state it was at before the analysis started. To return \\(0\\) if successful, a negative number if not. virtual int update ( void ); This method is invoked after the response quantities have been updated in the Domain, but not necessarily committed, e.g. during a non-linear Newton-Raphson solution algorithm. To return \\(0\\) if successful, a negative number if not. This base class implementation returns \\(0\\) . virtual bool isSubdomain ( void ); The element is to return true if the element is of type (or subtype) Subdomain, else the element should return false. This base class implementation returns \\(false\\) . virtual Matrix & getTangentStiff ( void ) = 0 ; To return the tangent stiffness matrix. The element is to compute its stiffness matrix based on the original location of the nodes and the current trial displacement at the nodes. \\[{\\bf K}_e = {\\frac{\\partial {\\bf F}_{R_i}}{\\partial \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual Matrix & getSecantStiff ( void ) = 0 ; To return the elements secant stiffness matrix. The element is to compute its stiffness matrix based on the original location of the nodes and the current trial displacement at the nodes. THIS SECANT MAY BE REMOVED. virtual Matrix & getDamp ( void ) = 0 ; To return the damping matrix. The element is to compute its damping matrix based on the original location of the nodes and the current trial response quantities at the nodes. \\[{\\bf C}_e = {\\frac{\\partial {\\bf F}_{R_i}}{\\partial \\dot \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual Matrix & getMass ( void ) = 0 ; To return the mass matrix. The element is to compute its mass matrix based on the original location of the nodes and the current trial response quantities at the nodes. \\[{\\bf M}_e = {\\frac{\\partial {\\bf F}_{I_i}}{\\partial \\ddot \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual void zeroLoad ( void ) = 0 ; This is a method invoked to zero the element load contributions to the residual, i.e. \\({\\bf P}_e = \\zero\\) virtual Vector & getResistingForce ( void ) = 0 ; Returns the resisting force vector for the element. This is equal to the applied load due to element loads minus the loads at the nodes due to internal stresses in the element due to the current trial displacement, i.e. \\[{\\bf R}_e = {\\bf P}_{e} - {\\bf F}_{R_e}({\\bf U}_{trial})\\] virtual Vector & getResistingForceIncInertia ( void ) = 0 ; Returns the resisting force vector for the element with inertia forces included. This is equal to the applied load due to element loads (loads set using addLoad() , minus the loads at the nodes due to internal stresses in the element due to the current trial response quantities, i.e. \\[{\\bf R}_e = {\\bf P}_e - {\\bf F}_{I_e} (\\ddot {\\bf U}_{trial}) - {\\bf F}_{R_e}(\\dot {\\bf U}_{trial}, {\\bf U}_{trial})\\] setResponse() is a method invoked to determine if the element will respond to a request for a certain of information. The information requested of the element is passed in the array of char pointers argv of length em argc. If the element does not respond to the request a \\(-1\\) is returned. If it does respond, an integer value greater than or equal to \\(0\\) is returned. This is the responseID passed in the getResponse() method. In addition the Element object is responsible for setting the Information object eleInformation with the type of the return, i.e. IntType, DoubleType, MatrixType, VectorType, IDType , and for creating a Matrix, Vector or ID object for the Information object, if the information to be returned is of any of these types. The information object is responsible for invoking the destructor on these objects. The base class responds to no requests and will always return \\(-1\\) . getResponse is a method invoked to obtain information from an analysis. The method is invoked with the integer argument returned and the Information object that was prepared in a successful setResponse() method invocation. To return \\(0\\) if successful, a negative number if not. The base class implementation will always return \\(-1\\) .","title":"Element\n"},{"location":"developer/architecture/class_interface/element/ElementalLoad/","text":"ElementalLoad #include <element/ElementalLoad.h> class ElementalLoad: public Load TaggedObject MovableObject DomainComponent Load ElementalLoad is an abstract class, i.e. no instances of ElementalLoad will exist. The ElementalLoad class provides the interface that all ElementalLoad writers must provide when introducing new ElementalLoad classes. // Constructors // Destructor // Public Methods Provided to allow subclasses to construct an ElementalLoad object associated with the Element whose unique identifier in the Domain will be elementTag . The integers tag and and classTags are passed to the Load constructor. Provided so that a FEM_ObjectBroker can construct an object. \\(0\\) and classTag are passed to the Load classes constructor. The data for the object is filled in when recvSelf() is invoked on the object. Does nothing. Provided so that the ElementalLoad subclasses destructor will be called. Returns the integer elementTag passed in the constructor.","title":"ElementalLoad\n"},{"location":"developer/architecture/class_interface/element/beamWithHinges/BeamWithHinges2D/","text":"NEED TO ADD ADD_INERTIA_LOAD TO INTERFACE .. SEE EARTHQUAKE_PATTERN CLASS. BeamWithHinges2D #include <element/BeamWithHinges2D.h> class BeamWithHinges2D : public DomainComponent\\ TaggedObject\\ MovableObject\\ DomainComponent\\ Element\\ BeamWithHinges2D is a beam-column element which uses the force based formulation for its state determination. This element has material non-linear hinges at both ends and exhibits linear elastic behavior through its interior region, including linear elastic shear effects. Constructors ### Destructor // Public Methods dealing with Nodes and dof // Public Methods dealing with State // Public Methods for obtaining Linearized Stiffness, Mass and Damping Matrices // Public Methods for obtaining Resisting Forces Constructs a BeamWithHinges2D object with tag tag , unique among all elements in the domain. The end nodes of the element are set to be those with tags nodeI and nodeJ . The elastic properties of the interior beam region are set to be E , the modulus of elasticity; I , the second moment of area of the beam cross-section; A , the beam cross-sectional area; G , the shear modulus; and alpha , the cross-section shape factor for elastic shear effects. Element hinges are created by obtaining copies of sectionI and sectionJ . The hinge lengths are specified as ratios of the total element length, ratioI and ratioJ . The element distributed load (reference value) is set to be distrLoad , and the element mass density per unit length is massDens . Constructs a BeamWithHinges2D object with tag tag , unique among all elements in the domain. The end nodes of the element are set to be those with tags nodeI and nodeJ . The elastic properties of the interior beam region are set to be E , the modulus of elasticity; I , the second moment of area of the beam cross-section; A , the beam cross-sectional area; G , the shear modulus; and alpha , the cross-section shape factor for elastic shear effects. Element hinges are created by obtaining copies of sectionI and sectionJ . The hinge lengths are specified as ratios of the total element length, ratioI and ratioJ . The element mass density per unit length is massDens . Constructs a blank BeamWithHinges2D object. Invokes the section destructors. Returns 2, the number of external nodes for this element. Returns an ID containing the tags of the two external nodes for this element. Returns 6, the number of degrees of freedom for this element. int commitState ( void ); Invokes commitState() on each section and returns the sum of the result of these invocations. int revertToLastCommit ( void ); Invokes revertToLastCommit() on each section and returns the sum of the result of these invocations. int revertToStart ( void ); Invokes revertToStart() on each section and returns the sum of the result of these invocations. const Matrix & getTangentStiff ( void ); Computes the element flexibility matrix, then returns its inverse, the element stiffness matrix. The element flexibility is the sum of the hinge flexibilities, \\(\\mathbf{f}_I\\) and \\(\\mathbf{f}_J\\) , and the elastic flexibility of the beam interior, \\(\\mathbf{f}_{mid}\\) . \\[\\label{eq:fele} \\fbas := \\int_{0}^{L}{\\bint^T \\fsec \\bint \\: dx} = \\mathbf{f}_I + \\mathbf{f}_{mid} + \\mathbf{f}_J\\] The flexibility of the beam interior is obtained in closed form, \\[\\mathbf{f}_{mid} = \\int_{l_I}^{L-l_J}{\\bint^T \\fsec_{mid} \\bint \\: dx}\\] where \\(\\bint\\) is the force interpolation matrix, \\[\\bint := \\left[ \\begin{array}{c c c} 1 & 0 & 0 \\\\ 0 & \\frac{x}{L} & \\frac{x}{L} - 1 \\\\ 0 & \\frac{1}{L} & \\frac{1}{L} \\end{array} \\right]\\] and \\(\\fsec\\) is the elastic section flexibility of the beam interior. \\[\\fsec_{mid} = \\left[ \\begin{array}{c c c} \\frac{1}{EA} & 0 & 0 \\\\ 0 & \\frac{1}{EI} & 0 \\\\ 0 & 0 & \\frac{1}{\\alpha GA} \\end{array} \\right]\\] The hinge flexibilities, \\(\\mathbf{f}_I\\) and \\(\\mathbf{f}_J\\) , are obtained by the midpoint integration rule, \\[{\\mathbf{f}}_i = \\bint(x_i)^T \\fsec_i \\bint(x_i) * l_i, \\:\\: i=I,J\\] where \\(x_i\\) is the midpoint of hinge \\(i\\) , measured along the length of the beam, and is the point at which the force interpolation matrix, \\(\\bint\\) is evaluated. The flexiblity, \\(\\fsec_i\\) , is obtained from the constitutive relation for section \\(i\\) . The element stiffness is then obtained by inversion of the element flexibility, given by Equation [eq:fele] . \\[\\label{eq:kele} \\kbas = \\fbas^{-1}\\] The element then obtains the matrix, \\(\\mathbf{A}\\) , which transforms the element basic stiffness from its corotating frame to the global frame of reference. The transformed stiffness matrix, \\(\\kele\\) , is then assembled into the structural system of equations. \\[\\kele = \\mathbf{A}^T \\kbas \\mathbf{A}\\] const Matrix & getSecantStiff ( void ); To return the elements secant stiffness matrix. THIS SECANT MAY BE REMOVED. const Matrix & getDamp ( void ); To return the damping matrix. const Matrix & getMass ( void ); Returns the element lumped mass matrix, \\(\\mele\\) . It is assumed that the mass density per unit length, \\(\\rho\\) , is constant along the entire element, including the hinge regions. \\[\\label{eq:mele} \\mele = \\left[ \\begin{array}{c c c c c c} \\frac{\\rho L}{2} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{\\rho L}{2} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{\\rho L}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{\\rho L}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\end{array} \\right]\\] void zeroLoad ( void ); This is a method invoked to zero the element load contributions to the residual. const Vector & getResistingForce ( void ); Returns the element resisting force vector. The basic element force vector is obtained as the product of the basic element stiffness, \\(\\kbas\\) , given by Equation [eq:kele] , and the basic element deformations, \\(\\vbas\\) . \\[\\qbas = \\kbas \\vbas\\] The basic element force vector is then transformed from the corotating frame to the global frame of reference. The transformed force vector is then assembled into the structural system of equations. \\[\\label{eq:qele} \\qele = \\mathbf{A}^T \\qbas\\] const Vector & getResistingForceIncInertia ( void ); Returns the element resisting force vector, \\(\\tilde{\\qele}\\) with inertia forces included, \\[\\tilde{\\qele} = \\qele - \\mele \\ddot{\\mathbf u}\\] where \\(\\qele\\) and \\(\\mele\\) are obtained from Equations [eq:qele] and [eq:mele] , respectively, and \\(\\ddot{\\mathbf u}\\) is the vector of trial nodal accelerations for the element.","title":"BeamWithHinges2D\n"},{"location":"developer/architecture/class_interface/element/zeroLength/ZeroLength/","text":"ZeroLength #include <element/ZeroLength.h> class ZeroLength: public Element TaggedObject MovableObject DomainComponent Element The ZeroLength class represents an element defined by two nodes at the same geometric location, hence it has zero length. The nodes are connected by of uniaxial materials to represent the force-deformation relationship for the element. ZeroLength elements are constructed with a tag in a domain of dimension 1, 2, or 3, connected by nodes Nd1 and Nd2 . The vector x defines the local x-axis for the element and the vector yprime lies in the local x-y plane for the element. The local z-axis is the cross product between x and yprime , and the local y-axis is the cross product between the local z-axis and x . Constructors ### Destructor // public methods to obtain information about dof & connectivity // public methods to set the state of the element // public methods to obtain stiffness, mass, damping and residual information // public methods for element output Construct a ZeroLength element with tag . The force-deformation relationship for the element is given by a pointer theMaterial to a UniaxialMaterial model acting in local direction . The local direction is 1, 2, 3, for translation in the local x, y, z axes or 4, 5, 6 for rotation about the local x, y, z axes. Construct a ZeroLength element with tag . The force-deformation relationship is given by the n1dMat pointers theMaterial to UniaxialMaterial models. direction is an ID of length n1dMat that gives the local direction for each corresponding entry in the array theMaterial The local direction is 1, 2, 3, for translation in the local x, y, z axes or 4, 5, 6 for rotation about the local x, y, z axes. This is the constructor invoked by an FEM_ObjectBroker object. It constructs an empty ZeroLength element with two nodes. The recvSelf() method is invoked on the object for it to set the internal data. Element destructor deletes memory for storing material model pointers. Returns 2. Return ID of size \\(2\\) with the node tags defining the element. Return the number of DOF for the element, which depends on the dimension of the problem and the number of DOF associated with each node. Initialize element and define data structures. Commit state of element by committing state of materials. Return 0 if successful, !0 otherwise. Revert state of element to last commit by reverting to last committed state of materials. Return 0 if successful, !0 otherwise. Revert state of element to initial state by reverting to initial state of materials. Return 0 if successful, !0 otherwise. Return tangent stiffness matrix for element. Return secant stiffness matrix of element. The secant stiffness is defined by the secant for the materials. Return a zero damping matrix. Return a zero mass matrix. The element has no loads, so this operation has no effect. The element has no loads, so this operation has no effect and returns 0. The element has no mass, so this operation has no effect and returns 0. Return resisting force vector. Return resisting force vector with inertia included. Send information about element over a channel. Receive information about element over a channel. Display element. Print information about element. Set response quantities as \"force\", \"deformation\", \"material\", or \"stiff\". Return response ID or -1 if error. Currently, only the one uniaxial material can be set. Get response information for responseID . Return 0 if successful, -1 otherwise.","title":"ZeroLength\n"},{"location":"developer/architecture/class_interface/element/zeroLength/ZeroLengthSection/","text":"ZeroLengthSection #include <element/zeroLength/ZeroLengthSection.h> class ZeroLengthSection : public Element TaggedObject MovableObject DomainComponent Element The ZeroLengthSection class represents an element defined by two nodes at the same geometric location, hence it has zero length. The nodes are connected by a SectionForceDeformation object which represents the force-deformation relationship for the element. ZeroLengthSection elements are constructed with a tag in a domain of dimension 2 or 3, connected by nodes Nd1 and Nd2 . The vector x defines the local x-axis for the element and the vector yprime lies in the local x-y plane for the element. The local z-axis is the cross product between x and yprime , and the local y-axis is the cross product between the local z-axis and x . Constructors Destructor // public methods to obtain information about dof & connectivity // public methods to set the state of the element // public methods to obtain stiffness, mass, damping and residual information // public methods for element output Construct a ZeroLengthSection element with tag . The force-deformation relationship for the element is obtained by invoking getCopy() on the SectionForceDeformation pointer theSection . The section model acts in the local space defined by the x and yprime vectors. The section axial force-deformation acts along the element local x-axis and the section y-z axes directly corresponsd to the local element y-z axes. This is the constructor invoked by an FEM_ObjectBroker object. It constructs an empty ZeroLengthSection element with two nodes. The recvSelf() method is invoked on the object for it to set the internal data. Element destructor deletes memory for storing the section model pointer. Returns 2. Return ID of size \\(2\\) with the node tags defining the element. Return the number of DOF for the element, which depends on the dimension of the problem and the number of DOF associated with each node. Initialize element and define data structures. Sets up the element transformation matrix, \\(A\\) , which defines the kinematic relationship between nodal displacements and section deformations. Commit state of element by committing state of the section. Return 0 if successful, !0 otherwise. Revert state of element to last commit by reverting to last committed state of the section. Return 0 if successful, !0 otherwise. Revert state of element to initial state by reverting to initial state of the section. Return 0 if successful, !0 otherwise. Return tangent stiffness matrix for element. The element tangent is computed from the section tangent matrix, \\(k_b\\) , as \\(K_e = A^T k_b A\\) . The section tangent is obtained by calling getSectionTangent() . Returns the tangent stiffness matrix for the element as the secant stiffness is not defined for SectionForceDeformation objects. Return a zero damping matrix. Return a zero mass matrix. The element has no loads, so this operation has no effect. The element has no loads, so this operation has no effect and returns 0. The element has no mass, so this operation has no effect and returns 0. Return resisting force vector for element. The element resisting force is computed from the section stress resultants, \\(s\\) , as \\(P_e = A^T s\\) . The section stress resulant is obtained by calling getStressResultant() . Returns the result of getResistingForce() as there is no element mass. Send information about element and the section over a channel. Receive information about element and section from a channel. Display element. Prints the element node tags and section model to the stream em s. Currently returns -1. Currently returns -1.","title":"ZeroLengthSection\n"},{"location":"developer/architecture/class_interface/graph/","text":"Graph Classes In this work Graphs are used for three purposes: to provide information on the sparsity of the system of equation to the SystemofEqn object, to provide the connectivity of the DOF_Group objects for determining a good mapping between degrees-of-freedom and equation numbers. to provide information on the connectivity both the Elements and Nodes in the Domain, which can be useful for example in partitioning. The classes provided include Graph, Vertex, GraphNumberer and GraphPartitioner. There is no Edge class provided at present. In current design each Vertex stores in an ID the tag of all it\u2019s adjacent Vertices, this may change. For graph numbering and partitioning this has to date proved sufficient. Graph Vertex GraphNumberer RCM GraphPartitioner Metis","title":"Graph Classes\n"},{"location":"developer/architecture/class_interface/graph/graph/ArrayGraph/","text":"UNDER CONSTRUCTION - removeVertex & printSpecial NEED TO BE ADDED. ArrayGraph #include <graph/graph/ArrayGraph.h> class ArrayGraph: public Graph Graph ArrayGraph is a subtype of Graph. The vertices for this type of graph are held in a simple array data structure whose initial size is specified at construction. This size can increase if needed. The array storage scheme is more efficient than a List storage scheme in terms of accessing the vertices; in very large problems where memory is limited this type of scheme may have problems getting enough contiguous meory in which case a List might be a better choice. There is a question as to whether or not the public methods should be declared as virtual. Good OOP programming would have all methods declared as virtual, however as subclasses cannot gain access to the private member data there does not seem to be much point in declaring them, except for the destructor, virtual in this instance. Constructors ### Destructor // Public Methods // Protected Methods To construct an empty ArrayGraph. Creates a Vertex ** array, theVertices of size arraySize and sets the number of vertices, numVertex , and number of edges numEdge to \\(0\\) . If it fails to get an array of appropriate size it sets its arraySize to \\(0\\) ; subclasses can check if successfull construction by invoking the protected member function getArraySize() . Goes through theVertices and anywhere it finds a non-zero pointer, invokes the vertex destructor on that pointer. It then invokes the destructor on theVertices array. Method to add a vertex to the graph. If the adjacency list of the vertex is not empty the graph will first check to see all vertices in the the the vertices adjacency list exist in the graph before the vertex is added. It then checks if it neeeds a new array and if so creates one, i.e. if the arraySize \\(=\\) numVertex it creates a new array, whose size is double the original and copies the pointers to the vertices, before invoking delete() on the old array. It now tries to add the vertex in the array at location vertexTag . If this fails it adds at the first empty location it comes to. Returns a 0 if successfull addition, a \\(-1\\) otherwise and a message to opserr explaining the problem. virtual int addEdge(int vertexTag, int otherVertexTag); Causes the Graph to add an edge ( vertexTag , otherVertexTag ) to the Graph. A check is first made to see if vertices with tags given by vertexTag and otherVertexTag exist in the graph. If they do not exist a \\(-1\\) is returned, otherwise the method invokes addEdge() on each of the corresponding vertices in the graph. Returns \\(0\\) or a positive integer if sucessfull (positive if edge has already been added), a negative number if not. virtual Vertex \\ * getVertexPtr ( int vertexTag ); A method which returns a pointer to the vertex whose tag is given by vertexTag . The method first looks at location vertexTag for the vertex, otherwise it must search through the array until it finds the vertex it is looking for. If no such vertex exists in the graph \\(0\\) is returned. virtual VertexIter & getVertices ( void ); A method which first invokes reset() on the graphs ArrayVertexIter and then returns a reference to this iter. virtual int getNumVertex ( void ) const ; A method to return the number of vertices in the graph, returns numVertex. virtual int getNumEdge ( void ) const ; A method to return the number of edges in the graph, returns numEdge. virtual void Print ( OPS_Stream & s ) const = 0 ; A method to print the graph. It first prints out numVertex and numEdge and then on each newline prints the vertexTag and the edges for that vertex. It does this by going through theVertices array and invoking Print() on each non-zero pointer. A method to return the size of the graphs array.","title":"ArrayGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/DOFGraph/","text":"DOFGraph #include <DOFGraph.h> class DOFGraph : public ArrayGraph Graph ArrayGraph DOFGraph is a type of Graph. It is a graph of the DOF connectivity of the analysis model. It is utilised by a SystemOfEqn object to determine the sparsity of the system. It is a subtype of ArrayGraph, though it could just as easily be a subtype of any other type of Graph subclass that fully implements the graph interface. The constructor is responsible for constructing the graph given theModel . It creates the vertices of the graph, one for every DOF in the model and adds all edges based on the FE_Element connectivity. For this reason the model must be fully populated with the DOF_Group and FE_Element objects before the constructor is called. The superclass ArrayGraph is responsible for destroying the vertices.","title":"DOFGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/DOF_GroupGraph/","text":"DOF_GroupGraph #include <DOF_GroupGraph.h> class DOF_GroupGraph : public ArrayGraph Graph ArrayGraph DOF_GroupGraph is a type of Graph. It is a graph of the DOF_Group connectivity of the analysis model. It is utilised by the DOF_Numberer to assign equation numbers to the individual DOFs in the DOF_Groups of the model. It is a subtype of ArrayGraph, though it could just as easily be a subtype of any other type of Graph subclass that fully implements the graph interface. The constructor is responsible for constructing the graph given theModel . It creates the vertices of the graph, one for every equation (each DOF that has not been constrained out by the constraint handler) in the model and adds all edges based on the FE_Element connectivity. For this reason the model must be fully populated with the DOF_Group_Group and FE_Element objects before the constructor is called. The superclass ArrayGraph is responsible for destroying the vertices.","title":"DOF_GroupGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/Graph/","text":"Graph #include <graph/graph/Graph.h> class Graph: Graph is a base class. A Graph is a container class responsible for holding the vertex set and edge set. The class is responsible for: providing methods to add vertices and edges. accessing the vertices and edges. All the methods for the class are declared as virtual to allow subclasses to be introduced. Constructors ### Destructor // Public Methods To create an empty Graph. Creates an ArrayOfTagged object of initial size \\(32\\) in which to store the Vertices. The ArrayOfTagged object is used to store the Vertices. To create an empty Graph. Creates an ArrayOfTagged object of initial size numVertices in which to store the Vertices. The ArrayOfTagged object is used to store the Vertices. To create an empty Graph. The theVerticesStorage object is used to store the Vertices. clearAll() is invoked on this object to ensure it is empty. Invokes clearAll() on the storage object used to store the Vertices. It then invokes delete on the storage object used, which was either passed or created in the constructor. Causes the graph to add a vertex to the graph. If checkAdjacency is true , a check is made to ensure that all the Vertices in the adjacency list of the Vertex are in the Graph. If a vertex in the adjacency is not in the Graph the vertex is not added, a warning message is printed and false is returned. If successful, returns the result of invoking addComponent() on the TaggedStorage object used to store the Vertices. virtual int addEdge(int vertexTag, int otherVertexTag); Causes the Graph to add an edge ( vertexTag , otherVertexTag ) to the Graph. A check is first made to see if vertices with tags given by vertexTag and otherVertexTag exist in the graph. If they do not exist a \\(-1\\) is returned, otherwise the method invokes addEdge() on each of the corresponding vertices in the graph. Increments numEdge by \\(1\\) and returns \\(0\\) if sucessfull, a \\(1\\) if the edge already existed, and a \\(-2\\) if one addEdge() was successful, but the other was not. virtual Vertex \\ * getVertexPtr ( int vertexTag ); A method which returns a pointer to the vertex whose tag is given by vertexTag . If no such vertex exists in the graph \\(0\\) is returned. Invokes getComponentPtr(vertexTag) on the vertex storage object and casts this to a Vertex * if not null. virtual VertexIter & getVertices ( void ); A method which returns a reference to the graphs VertexIter. This iter can be used for iterating through the vertices of the graph. virtual int getNumVertex ( void ) const ; A method to return the number of vertices in the graph. Invokes getNumComponents() on the Vertex storage object. virtual int getNumEdge ( void ) const ; A method to return the number of edges in the graph, returns numEdge . To remove the Vertex from the Graph whose tag is equal to vertexTag . If removeEdgeFlag is true will also remove the Vertex from the remaining Vertices adjacency lists. returns a pointer to the removed Vertex if successful, \\(0\\) if the Vertex was not in the Graph. Invokes removeComponent(vertexTag) on the vertex storage object and casts this to a Vertex * if not null. DOES NOT YET DEAL WITH removeEdgeFlag . virtual void Print ( OPS_Stream & s , int flag = 0 ); A method to print the graph. Invokes Print ( s , flag ) on the vertex storage object. Invokes Print() on the Graph G .","title":"Graph\n"},{"location":"developer/architecture/class_interface/graph/graph/Vertex/","text":"Vertex #include <graph/graph/Vertex.h> class Vertex : public TaggedObject ; Vertex is the abstraction of a vertex in a graph. It has a color, weight and a temporary integer value associated with it. Also associated with it is an integer reference, which can be used to identify an object of some type the vertex is representing and in integer temporary variable for algorithms which work with graphs. // Constructor // Destructor // Public Methods . Construct a Vertex whose tag, reference, weight and color are as given by the arguments. The degree of the vertex is set to \\(0\\) . The integer *tag* is passed to the TaggedObject classes constructor. Does nothing. To set the weight of the vertex to *newWeight* virtual void setColor ( int newColor ); To set the color of the vertex to *newColor* virtual void setTmp ( int newTmp ); To set the temporary variable of the vertex to *newTmp* virtual int getTag ( void ) const ; . Returns the vertices tag. virtual int getRef ( void ) const ; Returns the vertices integer reference. virtual double getWeight ( void ) const ; Returns the vertices weight. virtual int getColor ( void ) const ; Returns the vertices color. virtual int getTmp ( void ) const ; Returns the vertices temporary variable. virtual int addEdge ( int otherTag ); If the adjacency list for that vertex does not already contain otherTag , otherTag is added to the adjacency list and the degree of the vertex is incremented by \\(1\\) . Returns a \\(0\\) if sucessfull, a \\(1\\) if edge already existed and a negative number if not. Note that no check is done by the vertex to see that a vertex with otherTag exists in the graph. The adjacency list for a Vertex is stored in an ID object containing the adjacent Vertices tags. A check is made to see if otherTag is in this ID using getLocation() , if it needs to be added the * \\[degree\\] * operator is invoked on the ID. virtual int getDegree ( void ) const ; Returns the vertices degree. virtual const ID & getAdjacency ( void ) const ; Returns the vertices adjacency list, this is returned as an ID whose components are tags for vertices which have been successfully added. virtual void Print ( OPS_Stream & s , int flag = 0 ); Prints the vertex. If the flag = 0 only the vertex tag and adjacency list is printed. If the flag =1 the vertex tag, weight and adjacency are printed. If the flag =2 the vertex tag, color and adjacency are printed. If the flag =3 the vertex tag, weight, color and adjacency are printed.","title":"Vertex\n"},{"location":"developer/architecture/class_interface/graph/numberer/GraphNumberer/","text":"GraphNumberer #include <graph/numberer/GraphNumberer.h> class GraphNumberer : public MovableObject ; RCM MinDegree GraphNumberer is an abstract class. The GraphNumberer class defines the interface that all programmers must provide when introducing new GraphNumberer subclasses. A GraphNumberer is an algorithmic class for numbering the Vertices of a Graph; that is assigning a unique integer value ( \\(0\\) through numVertex \\(-1\\) ) to each Vertex (uses tmp variable of Vertex) of the Graph. Constructor Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. Does nothing. This is the method invoked to perform the graph numbering, that is to assign a unique integer \\(1\\) through numVertex , to each Vertex in the Graph. Returns an ordered ID containing the vertex references in the order of the numbering, i.e. \\(ID(0)\\) contains the integer reference for the vertex assigned the number 1, \\(ID(1)\\) contains the integer reference for the vertex assigned the number 2 and so on. A side effect of the numbering is that the Tmp variable of each vertex is set to the number assigned to that vertex. If lastVertex is not \\(-1\\) the Vertex whose tag is given by lastVertex should be numbered last (it does not have to be though THIS MAY CHANGE). This is the method invoked to perform the graph numbering, that is to assign a unique integer \\(1\\) through numVertex , to each Vertex in the Graph. Returns an ordered ID containing the vertex references in the order of the numbering, i.e. \\(ID(0)\\) contains the integer reference for the vertex assigned the number 1, \\(ID(1)\\) contains the integer reference for the vertex assigned the number 2 and so on. A side effect of the numbering is that the Tmp variable of each vertex is set to the number assigned to that vertex. lastVertices is used as a hint to indicate that these Vertices should be numbered last (they do not have to be though THIS MAY CHANGE).","title":"GraphNumberer\n"},{"location":"developer/architecture/class_interface/graph/partitioner/GraphPartitioner/","text":"GraphPartitioner #include <graph/partitioner/GraphPartitioner.h> class GraphPartitioner ; Metis GraphPartitioner is an abstract class. The GraphPartitioner class defines the interface that all programmers must provide when introducing new GraphPartitioner subclasses. A GraphPartitioner is an algorithm for partitioning (coloring) the vertices of a graph; that is assigning a color (1 through the number of partitions) to each vertex of the graph. Constructor Destructor // Public Methods To construct a GraphPartitioner. This is the method invoked to partition the graph into numPart partitions. On completion of the routine each vertex will be assigned a color \\(1\\) through numPart , the color assigned indicating the partition to which the vertex belongs. Returns a \\(0\\) if successful, a negative number if not; the value depending on the subclass.","title":"GraphPartitioner\n"},{"location":"developer/architecture/class_interface/material/","text":"Material Classes Material classes are used to provide information to the Elements about the material. There is one main class MaterialModel. The Element objects query the MaterialModel objects to obtain the current value of stress and the tangent defining the stress-strain relationship for the current value of strain at the point in the domain represented by the MaterialModel object.","title":"Material Classes\n"},{"location":"developer/architecture/class_interface/material/ElasticIsotropicMaterial/","text":"ElasticIsotropicMaterial #include <material/nD/ElasticIsotropicMaterial.h> class ElasticIsotropicMaterial : public NDMaterial\\ TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial is an abstract class. It provides the interface to which all elastic isotropic material implementations must conform. It also serves as a prototype for all elastic isotropic material implementations, as described by the Prototype pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods To construct an ElasticIsotropicMaterial whose unique integer tag among NDMaterials in the domain is given by tag , and whose class tag is given by classTag . These tags are passed to the NDMaterial class constructor. Does nothing. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Returns a specific implementation of an ElasticIsotropicMaterial by switching on type . Outputs an error if type is not valid. This is the prototype method.","title":"ElasticIsotropicMaterial\n"},{"location":"developer/architecture/class_interface/material/HystereticBackbone/","text":"HystereticBackbone // Description: This file contains the interface for HystereticBackbone, // which represents a backbone curve for hysteretic models. // // Written: MHS // Created: Aug 2000 // extern bool OPS_addHystereticBackbone ( HystereticBackbone * newComponent ); extern HystereticBackbone * OPS_getHystereticBackbone ( int tag ); extern void OPS_clearAllHystereticBackbone ( void ); class HystereticBackbone : public TaggedObject , public MovableObject { public : HystereticBackbone ( int tag , int classTag ); virtual ~ HystereticBackbone (); virtual double getStress ( double strain ) = 0 ; virtual double getTangent ( double strain ) = 0 ; virtual double getEnergy ( double strain ) = 0 ; virtual double getYieldStrain ( void ) = 0 ; virtual HystereticBackbone * getCopy ( void ) = 0 ; virtual int setVariable ( char * argv ); virtual int getVariable ( int varID , double & theValue ); virtual int setParameter ( char ** argv , int argc , Information & eleInformation ); virtual int updateParameter ( int responseID , Information & eleInformation ); protected : private : };","title":"HystereticBackbone\n"},{"location":"developer/architecture/class_interface/material/Material/","text":"PRESENTLY LITTLE IN THE INTERFACE .. THIS MAY CHANGE IF MAKE GENERAL i.e 1D, 2D and 3d PROBLEMS RETURN MATRICES AND VECTORS .. IF CHANGE, INTERFACE FOR UniaxialMaterial MAY THEN CHANGE. Material #include <material/Material.h> class Material: public TaggedObject, public MovableObject TaggedObject MovableObject Material is an abstract class. The Material class provides the interface that all Material writers must provide when introducing new Material subclasses. A Material object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. // Constructor // Destructor To construct a Material whose unique integer among Materials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the TaggedObject and MovableObject class constructors.","title":"Material\n"},{"location":"developer/architecture/class_interface/material/NDMaterial/","text":"INTERFACE MAY CHANGE IF MAKE MATERIAL MORE GENERAL. NDMaterial #include <material/nD/NDMaterial.h> class NDMaterial : public Material TaggedObject MovableObject Material NDMaterial is an abstract class. The NDMaterial class provides the interface that all NDMaterial writers must provide when introducing new NDMaterial subclasses. An NDMaterial object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. Constructor ### Destructor // Public Methods To construct a NDMaterial whose unique integer among NDMaterials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. Does nothing. Sets the value of the trial strain vector, that value used by getStress() and getTangent() , to be strain . To return \\(0\\) if successful and a negative number if not. To return the material stress vector at the current trial strain. To return the material tangent stiffness matrix at the current trial strain. To accept the current value of the trial strain vector as being on the solution path. To return \\(0\\) if successful, a negative number if not. To cause the material to revert to its last committed state. To return \\(0\\) if successful, a negative number if not. Invoked to cause the material to revert to its original state in its undeformed configuration. To return \\(0\\) if successful, a negative number if not. Returns a pointer to a new NDMaterial, which is an exact copy of this instance. It is up to the caller to ensure that the destructor is invoked.","title":"NDMaterial\n"},{"location":"developer/architecture/class_interface/material/UniaxialMaterial/","text":"UniaxialMaterial #include <material/UniaxialMaterial.h> class UniaxialMaterial : public Material TaggedObject MovableObject Material UniaxialMaterial is an abstract class. The UniaxialMaterial class provides the interface that all UniaxialMaterial writers must provide when introducing new UniaxialMaterial subclasses. A UniaxialMaterial object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. Constructor and Destructor UniaxialMaterial ( int tag , int classTag ); To construct a UniaxialMaterial whose unique integer among UniaxialMaterials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. ~ UniaxialMaterial () Does nothing. Public Methods virtual int setTrialStrain ( double strain ) = 0 ; virtual int setTrialStrain ( double strain , double strainRate = 0 ) = 0 ; virtual int setTrialStrain ( double strain , double temperature , double strainRate ); virtual int setTrial ( double strain , double & stress , double & tangent , double strainRate = 0.0 ); virtual int setTrial ( double strain , double temperature , double & stress , double & tangent , double & thermalElongation , double strainRate = 0.0 ); Sets the value of the trial strain, that value used by getStress() and getTangent() , to be strain . Return \\(0\\) if successful, a negative number if not. virtual double getStress ( void ) = 0 ; To return the current value of stress for the trial strain. virtual double getTangent ( void ) = 0 ; To return the current value of the tangent for the trial strain. virtual double getInitialTangent ( void ) = 0 ; Return the initial tangent. virtual int commitState ( void ) = 0 ; To accept the current value of the trial strain as being on the solution path. To return \\(0\\) if successful, a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; To cause the material to revert to the state at the last commit. To return \\(0\\) if successful, a negative number if not. virtual int revertToStart ( void ) = 0 ; Invoked to cause the material to revert to its original state in its undeformed configuration. To return \\(0\\) if successful, a negative number if not. virtual UniaxialMaterial * getCopy ( void ) = 0 ; To return an exact copy of the material.","title":"UniaxialMaterial\n"},{"location":"developer/architecture/class_interface/material/mdMaterial/","text":"MaterialModel UniaxialMaterial ElasticMaterial ElasticPPMaterial ParallelMaterial Concrete01 Steel01 NDMaterial SectionForceDeformation GenericSection1D GenericSectionND ElasticSection2D ElasticSection3D FiberSection2D FiberSection3D","title":""},{"location":"developer/architecture/class_interface/material/section/ElasticSection3D/","text":"ElasticSection3D #include <material/section/ElasticSection3D.h> class ElasticSection3D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation ElasticSection3D provides the implementation of a section which exhibits uncoupled elastic behavior in axial, moment, shear, and torsion response. Constructor Destructor // Public Methods // Public Methods for Output To construct an ElasticSection3D with an integer identifier tag , an elastic modulus of \\(E\\) , a second moment of area about the local z-axis, \\(I_z\\) , a second moment of area about the local y-axis, \\(I_y\\) , a polar moment of intertia of \\(J\\) , a section area of \\(A\\) , an elastic shear modulus of \\(G\\) , and a shape factor of \\(\\alpha\\) . The integers tag and MAT_TAG_ElasticSection3D, defined in <classTags.h> , are passed to the SectionForceDeformation class constructor. Constructs a blank ElasticSection3D object. Does nothing. Sets the value of the section deformation vector, \\(\\esec\\) to be def . The section deformation vector, \\(\\esec\\) , is defined by \\[\\esec := \\left[ \\begin{array}{c} \\epsilon_a \\\\ \\kappa_z \\\\ \\kappa_y \\\\ \\gamma_y \\\\ \\gamma_z \\\\ \\phi \\end{array} \\right]\\] where \\(\\epsilon_a\\) is the axial strain, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\gamma_y\\) is the shear strain along the local y-axis, \\(\\gamma_z\\) is the shear strain along the local z-axis, and \\(\\phi\\) is the angle of twist. Returns \\(0\\) . Returns the current value of the section deformation vector, \\(\\esec\\) . Returns the section stress resultants, \\(\\ssec\\) , the product of the section stiffness matrix, \\(\\ksec\\) , and the section deformation vector, \\(\\esec\\) , \\[\\ssec = \\ksec \\esec = \\left[ \\begin{array}{c} P \\\\ M_z \\\\ M_z \\\\ V_y \\\\ V_y \\\\ T \\end{array} \\right]\\] where \\(P\\) is the axial force, \\(M_z\\) is the bending moment about the local z-axis, \\(M_y\\) is the bending moment about the local y-axis, \\(V_y\\) is the shear force along the local y-axis, \\(V_z\\) is the shear force along the local z-axis, and \\(T\\) is the torque. Returns the value of \\(\\ssec\\) calculated at the previous state determination. Returns the section stiffness matrix, \\(\\ksec\\) , where \\[\\ksec = \\left[ \\begin{array}{cccccc} EA & 0 & 0 & 0 & 0 & 0 \\\\ 0 & EI_z & 0 & 0 & 0 & 0 \\\\ 0 & 0 & EI_y & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\alpha GA & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\alpha GA & 0 \\\\ 0 & 0 & 0 & 0 & 0 & GJ \\end{array} \\right]\\] Returns the section stiffness matrix, \\(\\ksec\\) . Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) , where \\[\\fsec = \\left[ \\begin{array}{cccccc} \\frac{1}{EA} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{1}{EI_z} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{1}{EI_y} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\frac{1}{GJ} \\end{array} \\right]\\] Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticSection3D object, constructed using the same values of tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the ordering of section response quantities. For this section, axial response is the first quantity, bending about the local z-axis is the second, bending about the local y-axis is the third, shear along the local y-axis is the fourth, shear along the local z-axis is the fifth, and torsion is the sixth. \\[code := \\left[ \\begin{array}{c} 2 \\\\ 1 \\\\ 4 \\\\ 3 \\\\ 5 \\\\ 6 \\end{array} \\right]\\] Returns 6. Creates a Vector of size \\(8\\) into which it places tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Invokes sendVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Returns \\(0\\) if successful, a warning message and a negative number are returned if the Channel object fails to send the Vector. Creates a Vector of size \\(8\\) . Invokes recvVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Using the data in the Vector to set its tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed and a negative number is returned if the Channel object fails to receive the Vector. Prints to the stream s the object\u2019s tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) values.","title":"ElasticSection3D\n"},{"location":"developer/architecture/class_interface/material/section/FiberSection/","text":"FiberSection This file contains the class definition for FiberSection.h. FiberSection provides the abstraction of a section discretized by fibers. The section stiffness and stress resultants are obtained by summing fiber contributions. class FiberSection : public SectionForceDeformation { public : FiberSection (); FiberSection ( int tag , int estNumFibers = 8 ); FiberSection ( int tag , int numFibers , Fiber ** fibers ); ~ FiberSection (); int setTrialSectionDeformation ( const Vector & deforms ); const Vector & getSectionDeformation ( void ); const Vector & getStressResultant ( void ); const Matrix & getSectionTangent ( void ); const Matrix & getInitialTangent ( void ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); SectionForceDeformation * getCopy ( void ); const ID & getType ( void ); int getOrder ( void ) const ; int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); int getResponse ( int responseID , Information & info ); int addFiber ( Fiber & theFiber ); protected : private : int numFibers ; // number of fibers in the section Fiber ** theFibers ; // array of pointers to fibers // that form the section int sizeFibers ; // size of the fibers array int order ; ID * code ; Vector * e ; // section trial deformations Vector * eCommit ; Vector * s ; // section resisting forces (axial force, bending moment) Matrix * ks ; // section stiffness int otherDbTag ; };","title":"FiberSection\n"},{"location":"developer/architecture/class_interface/material/section/SectionForceDeformation/","text":"SectionForceDeformation #include <material/section/SectionForceDeformation.h> class SectionForceDeformation : public Material TaggedObject MovableObject Material SectionForceDeformation provides the interface which all SectionForceDeformation models must implement. Constructor and Destructor SectionForceDeformation ( int tag , int classTag ); To construct a SectionForceDeformation object whose unique integer tag among SectionForceDeformation objects in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. ~ SectionForceDeformation () Does nothing. Public Methods virtual int setTrialSectionDeformation ( const Vector & def ) = 0 ; To set the value of the trial section deformation vector, \\(\\esec\\) to be def . To return \\(0\\) if successful, a negative number if not. virtual const Vector & getSectionDeformation ( void ) = 0 ; To return the trial section deformation vector, \\(\\esec\\) . virtual const Vector & getStressResultant ( void ) = 0 ; To return the section resisting forces, \\(\\ssec\\) , at the current trial state. virtual const Vector & getPrevStressResultant ( void ) = 0 ; To return the section resisting forces, \\(\\ssec\\) , from the previous trial state. virtual const Matrix & getSectionTangent ( void ) = 0 ; To return the section tangent stiffness matrix, \\(\\ksec\\) , at the current trial state. virtual const Matrix & getPrevSectionTangent ( void ) = 0 ; To return the section tangent stiffness matrix, \\(\\ksec\\) , from the previous trialstate. virtual const Matrix & getSectionFlexibility ( void ); Obtains the section tangent stiffness matrix, \\(\\ksec\\) , and returns its inverse, the section flexibility matrix, \\(\\fsec\\) , via an explicit matrix inversion. NOTE: The explicit matrix inversion provides default behavior and may be overridden in subclasses to suit specific SectionForceDeformation implementations. virtual const Matrix & getPrevSectionFlexibility ( void ); Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. NOTE: This function provides default behavior and may be overridden in subclasses to suit specific SectionForceDeformation implementations. virtual int commitState ( void ) = 0 ; To commit the section state. Returns \\(0\\) if successful and a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; To revert the section to its last committed state. Returns \\(0\\) if successful and a negative number if not. virtual int revertToStart ( void ) = 0 ; To revert the section to its initial state. Returns \\(0\\) if successful and a negative number if not. virtual SectionForceDeformation * getCopy ( void ) = 0 ; To return a pointer to a new SectionForceDeformation object, which is a copy of this instance. It is up to the caller to ensure that the destructor is invoked. virtual const ID & getType ( void ) = 0 ; To return the section ID code that indicates the ordering and type of response quantities returned by the section. Lets the calling object (e.g. an Element) know how to interpret the quantites returned by this SectionForceDeformation model. virtual int getOrder ( void ) = 0 ; To return the number of response quantities provided by the section. Output int sendSelf ( int commitTag , Channel & theChannel ); FILL IN. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); FILL IN. void Print ( OPS_Stream & s , int flag = 0 ) = 0 ; To print section information to the stream s based on the value of flag .","title":"SectionForceDeformation\n"},{"location":"developer/architecture/class_interface/recorder/DatastoreRecorder/","text":"DatastoreRecorder #include <recorder/DatastoreRecorder.h> class DatastoreRecorder: public Recorder Recorder A DatastoreRecorder object is used in the program to invoke commitState() on an FE_Datastore object when commit() is invoked on a Domain. The class is included in the framework so that the Domain class does not have to be modified for FE_Datastore objects. // Constructor // Destructor // Public Methods Saves a pointer to the object theDatastore . Does nothing. Returns the result of invoking commitState(commitTag) on theDatastore object. Returns the result of invoking restoreState(commitTag) on theDatastore object. Does nothing.","title":"DatastoreRecorder\n"},{"location":"developer/architecture/class_interface/recorder/MaxNodeDispRecorder/","text":"MaxNodeDispRecorder #include <recorder/MaxNodeDispRecorder.h> class MaxNodeDispRecorder: public Recorder Recorder The MaxNodeDispRecorder class is used to store information about the absolute maximum nodal displacement at a number of specified Nodes for a specified degree of freedom during an analysis. // Constructor // Destructor // Public Methods Creates a \\(0\\) Vector object of size equal to the size of nodeTags to store the maximum nodal displacements and creates an ID object equal to nodeTags to store the Node tags. Does nothing. For each node in nodeTags the value of the dof \u2019th committed displacement is obtained. If the absolute value of this is greater than the value currently stored in the Vector of max displacements, the value in the Vector is updated. If no Node exists in theDomain with the tag or the Node does not have a dof \u2019th degree-of-freedom associated with it \\(0\\) is entered in the Vector. Returns \\(0\\) . Prints to opserr the Vector containing the maximum absolute nodal displacements. Note, at the end of the analysis, what is printed is independent of commitTag . Returns \\(0\\) . Zeros the Vector of maximum nodal displacements.","title":"MaxNodeDispRecorder\n"},{"location":"developer/architecture/class_interface/recorder/Recorder/","text":"Recorder #include <recorder/Recorder.h> class Recorder The Recorder class is an abstract class which is introduced to allow information to be saved during the analysis. The interface defines two pure virtual methods record() and playback() . record() is a method which is called by the Domain object during a commit() . The playback() method can be called by the analyst after the analysis has been performed. Public Methods virtual int record ( int commitTag , double timeStamp ) = 0 ; This is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. More specifically, the method is invoked by the Domain object after commit() has been invoked on all the domain component objects. What the Recorder records depends on the concrete subtype. virtual int setDomain(Domain &theDomain); This is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. virtual int domainChanged ( void ); this is a method called when something major has happened in the Domain, eg. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it\u2019s pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it will have been deleted and it\u2019s old pointer information will no longer be valid.) virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); These methods are called in parallel applications. When invoked the recorders send/recv information about what they are recording. virtual int restart ( void ); Invoked by the Domain object when revertToStart() is invoked on the Domain object. What the Recorder does depends on the concrete subtype. virtual double getRecordedValue ( int clmnId , int rowOffset , bool reset ) { return 0 ; } //added by SAJalali","title":"Recorder\n"},{"location":"developer/architecture/class_interface/system_of_eqn/","text":"Linear Algebra Linear algebraic operations","title":"Linear Algebra\n"},{"location":"developer/architecture/class_interface/system_of_eqn/Solver/","text":"Solver #include <system_of_eqn/Solver.h> class Solver: public MovableObject MovableObject Solver is an abstract class. A Solver object is responsible for performing the numerical operations on its associated SystemOfEqn object. The integer classTag is passed to the MovableObject classes constructor. Does nothing. Provided so the subclasses destructor will be called. Causes the solver to solve the system of equations. Returns \\(0\\) if successful , negative number if not; the actual value depending on the type of Solver.","title":"Solver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/SystemOfEqn/","text":"SystemOfEqn #include <system_of_eqn/SystemOfEqn.h> class SystemOfEqn : public MovableObject MovableObject LinearSOE EigenSOE SystemOfEqn is an abstract class. A SystemOfEqn object is responsible for storing the system of equations it represents. A Solver object, which is associated with the SystemOfEqn object, is responsible for performing the numerical operations to solve for the system of equations. The integer classTag is provided to the constructor for the MovableObject. Does nothing. Declared to allow the subclass destructor to be called. Invoked to cause the system of equation object to solve itself. To return \\(0\\) if successful, negative number if not.","title":"SystemOfEqn\n"},{"location":"developer/architecture/class_interface/system_of_eqn/eigenSOE/","text":"Eigen Equation Systems BandArpack SymArpack SymBandEigenSolver - Solve the GEP of a symmetric banded matrix using the LAPACK subroutine dsbevx . FullGenEigenSolver - Solve the GEP of a general banded matrix using the LAPACK subroutine dggev","title":"Eigen Equation Systems\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/","text":"Linear Equation Systems Linear Systems ( LinearSOE ) FullGenLinSOE BandGenLinSOE BandSPDLinSOE ProfileSPDLinSOE SparseGenColLinSOE SparseGenRowLinSOE UmfpackGenLinSOE SymSparseLinSOE Linear Solvers LinearSOESolver fullGEN FullGenLinSolver FullGenLinLapackSolver bandGEN BandGenLinSolver BandGenLinLapackSolver bandSPD BandSPDLinSolver BandSPDLinLapackSolver BandSPDLinThreadSolver profileSPD ProfileSPDLinSolver ProfileSPDLinDirectSolver ProfileSPDLinDirectBlockSolver ProfileSPDLinDirectThreadSolver ProfileSPDLinDirectSkypackSolver sparseGEN SparseGenColLinSolver SuperLU ThreadedSuperLU SparseGenRowLinSolver UmfpackGenLinSolver SymSparseLinSolver sparseSYM diagonal itpack umfGEN petsc cg","title":"Linear Equation Systems\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/DomainSolver/","text":"DomainSolver #include <system_of_eqn/linearSOE/DomainSolver.h> class DomainSolver: public LinearSOESolver MovableObject Solver LinearSOESolver DomainSolver is an abstract class. DomainSolver objects are responsible for performing the numerical operations required for the domain decomposition methods. Constructor ### Destructor // Public Methods classTag is needed by the LinearSOESolver objects constructor. Causes the condenser to form \\(A_{ee}^* = A_{ee} -A_{ei} A_{ii}^{-1} A_{ie}\\) , where \\(A_{ii}\\) is the first numInt rows of the \\(A\\) matrix. The original \\(A\\) is changed as a result. \\(A_{ee}^*\\) is to be stored in \\(A_{ee}\\) . virtual int condenseRHS ( int numInt ) = 0 ; Causes the condenser to form \\(B_e^* = B_e - A_{ei} A_{ii}^{-1} B_i\\) , where \\(A_{ii}\\) is the first numInt rows of \\(A\\) . The original \\(B\\) is changed as a result. \\(B_e^*\\) is to be stored in \\(B_e\\) . virtual int computeCondensedMatVect ( Vector & u , int numInt ) = 0 ; Causes the condenser to form \\(A_{ee} u\\) . virtual Matrix & getCondensedA ( void ) = 0 ; Returns the contents of \\(A_{ee}\\) as a matrix. virtual Vector & getCondensedRHS ( void ) = 0 ; Returns the contents of \\(B_e\\) as a Vector. virtual Vector & getCondensedMatVect ( void ) = 0 ; Returns the contents of the last call to computeCondensedMatVect() . virtual int setComputedXext ( const Vector & u ) = 0 ; Sets the computed value of the unknowns in \\(X_e\\) corresponding to the external equations to u . The number of external equations is given by the size of vector \\(u\\) . virtual int solveXint ( void ) = 0 ; To compute the internal equation numbers \\(X_i\\) given the value set for the external equations in the last call to setComputedXext() .","title":"DomainSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/LinearSOE/","text":"LinearSOE #include <system_of_eqn/linearSOE/LinearSOE.h> class LinearSOE : public SystmOfEqn MovableObject LinearSOE is an abstract class. A LinearSOE object provides an abstraction of a system of linear equations. A linear system of equation of order \\(n\\) : \\[\\begin{array}{ccccccccc} a_{0,0}x_0 & + & a_{0,1}x_1 & + & ... & + & a_{0,n-1}x_{n-1} & = & b_0 \\\\ a_{1,0}x_0 & + & a_{1,1}x_1 & + & ... & + & a_{1,n-1}x_{n-1} & = & b_1 \\\\ ... & & ... & & & & ... & & ... \\\\ a_{n-1,0}x_0 & + & a_{n-1,1}x_1 & + & ... & + & a_{n-1,n-1}x_{n-1} & = & b_{n-1} \\\\ \\end{array}\\] can be expressed by the matrix equation \\(Ax=b\\) , where \\(A\\) is a matrix of order \\(n\\) X \\(n\\) and \\(b\\) and \\(x\\) are vectors or order \\(n\\) . A LinearSOE object is responsible for storing these equations and for providing methods at the interface to set up and obtain the equations. Each LinearSOE object will be associated with a LinearSOESolver object. It is the LinearSOESolver objects that is responsible for solving the linear system of equations. The integer classTag is passed to the constructor for the SystemOfEqn . The constructor sets sets the pointer for the currently associated LinearSOESolver object to point to theSolver . Does nothing. Causes the SystemOfEqn object to invoke solve() on the currently associated LinearSOESolver object. Returns a \\(0\\) if successful, negative number if not; the actual value depending on the LinearSOESolver. To solve a linear system of equations means to find \\(x\\) such that the equation \\(Ax=b\\) is satisfied. A method which returns the number of equations in the system, i.e. the number of unknowns. Invoked to allow the LinearSOE object to determine the size and sparsity of the matrix \\(A\\) and vectors \\(x\\) and \\(b\\) . This information can be deduced from the number of vertices and the connectivity between the vertices in the Graph object G . To return \\(0\\) if successful, a negative number if not. The LinearSOE object assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += M(i,j)\\) . Numbering in \\(A\\) starts at \\((0,0)\\) , i.e. C style. If a location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . To return \\(0\\) if successful, a negative number if not. virtual int addB(const Vector & theVector, const ID & loc, double fact = 1.0) =0; The LinearSOE object assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . To return \\(0\\) if successful, a negative number if not. virtual int setB ( const Vector & theVector , double fact = 1.0 ) = 0 ; The LinearSOE object sets the vector b to be fact times the Vector V . To return \\(0\\) if successful, a negative number if not. virtual void zeroA ( void ) = 0 ; To zero the matrix \\(A\\) , i.e. set all the components of \\(A\\) to \\(0\\) . virtual void zeroB ( void ) = 0 ; To zero the vector \\(b\\) , i.e. set all the components of \\(b\\) to \\(0\\) . virtual const Vector & getX ( void ) = 0 ; To return, as a Vector object, the vector \\(x\\) . A const reference is returned, meaning the Vector that is returned cannot be modified, i.e. no non-const method can be invoked on the Vector. virtual const Vector & getB ( void ) = 0 ; To return as a Vector object the vector \\(b\\) . A const reference is returned, meaning the Vector that is returned cannot be modified, i.e. no non-const method can be invoked on the Vector. virtual double normRHS ( void ) = 0 ; To return the 2-norm of the vector \\(x\\) . virtual void setX ( int loc , double value ) = 0 ; The LinearSOE object is responsible for setting \\(x(loc) = value\\) . This is needed in domain decomposition methods and could be useful in iterative solution strategies when an initial approximation is known. This is invoked to set the currently associated LinearSOESolver object to be newSolver . Each subclass will provide it\u2019s own variation of setSolver() method (needed so subclasses can verify type of Solver object passed). the subclasses in their variation of the setSolver() method (unless they wish to implement their own solve() method) invoke this method. Returns \\(0\\) . Returns a pointer to the associated LinearSOESolver object.","title":"LinearSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/LinearSOESolver/","text":"LinearSOESolver #include <system_of_eqn/linearSOE/LinearSOESolver.h> class LinearSOESolver: public Solver MovableObject Solver LinearSOESolver is an abstract class. A LinearSOESolver object is responsible for solving the LinearSOE object that it is associated with. That is, to find \\(x\\) such that the matrix equation \\(Ax=b\\) is satisfied. The integer classTag is passed to the Solver. Does nothing. Provided so the subclasses destructor will be called. Causes the LinearSOESolver to solve the system of equations \\(Ax=b\\) for \\(x\\) . Returns \\(0\\) if successful , negative number if not; the actual value depending on the type of LinearSOESolver. The result of the solve are to be stored in the \\(x\\) vector of the LinearSOE by the object. This is invoked by the LinearSOE object when setSize() has been invoked on it. Solvers may sometimes need to store additional data that needs to be updated if the size of the system of equation changes.","title":"LinearSOESolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandGEN/BandGenLinSOE/","text":"BandGenLinSOE #include <system_of_eqn/linearSOE/bandGEN/BandGenLinSOE.h> class BandGenLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE BandGenLinSOE is class which is used to store a banded unsymmetric system with kl subdiagonals and ku superdiagonals. The \\(A\\) matrix is stored in a 1d double array with \\((kl+ku+1)*n\\) elements, where n is the size of the system. \\(A_{i,j}\\) is stored at location \\((ku+1+i-j) + j*(ku+1+kl)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example when \\(n=5\\) , \\(kl = 2\\) and \\(ku=1\\) : \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & 0 & 0 & 0 \\\\ a_{1,0} & a_{1,1} & a_{1,2} & 0 & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & 0 \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{ccccccccccccccccccccc} * & a_{0,0} & a_{1,0} & a_{2,0} & a_{0,1} & a_{1,1} & a_{2,1} & a_{3,1} & a_{1,2} & a_{2,2} & a_{3,2} & a_{4,2} & a_{2,3} & a_{3,3} & a_{4,3} & * & a_{3,4} & a_{4,4} & * & * \\\\ \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(N\\) . To allow the solvers access to this data, the solvers that use this class are all declared as friend classes. The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the theSolver . No memory is allocated for the 3 1d arrays. BandGenLinSOE ( int N , int numSuperDiagonals , int numSubDiagonal , BandGenLinSolver & theSolver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. Sets the size of the system to \\(N\\) , the number of superdiagonals to numSuperDiagonals and number of subdiagonals to numSubDiagonals . Allocates memory for the arrays; if not enough memory is available a warning message is printed and the system size is set to \\(0\\) . Sets the solver to be called when solving the equations to theSolver . Invokes setLinearSOE ( \\ * this ) and setSize() on the theSolver . Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first setting kl and ku equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in kl or ku being increased. Knowing kl , ku and the size of the system (the number of Vertices in G ), a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Prints a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"BandGenLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandGEN/BandGenLinSolver/","text":"BandGenLinSolver #include <~/system_of_eqn/linearSOE/bandGEN/BandGenLinSolver.h> class BandGenLinSolver : public LinearSOESolver MovableObject Solver BandGenLinSolver is an abstract class. The BandGenLinSolver class provides access for each subclass to the BandGenLinSOE object through the pointer theSOE , which is a protected pointer. Constructor Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. virtual int setLinearSOE ( BandGenLinSOE & theSOE ); The method sets up the link between the BandGenLinSOE object and the BandGenLinSolver, that it is sets the pointer the subclasses use.","title":"BandGenLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandSPD/BandSPDLinSOE/","text":"BandSPDLinSOE #include <system_of_eqn/linearSOE/bandSPD/BandSPDLinSOE.h> class BandSPDLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE BandSPDLinSOE is class which is used to store a banded symmetric system with ku superdiagonals. The \\(A\\) matrix is stored in a 1d double array with \\((ku+1)n\\) elements, where \\(n\\) is the size of the system. \\(A_{i,j}\\) is stored at location \\((ku+1+i-j) + j*(ku+1)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example when \\(n=5\\) , \\(ku = 2\\) : \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & a_{0,1} & 0 & 0 \\\\ a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{cccccccccccccccccccc} * & * & a_{0,0} & * & a_{0,1} & a_{1,1} & a_{0,2} & a_{1,2} & a_{2,2} & a_{1,3} & a_{2,3} & a_{3,3} & a_{2,4} & a_{3,4} & a_{4,4}\\\\ \\end{array} \\right]\\] The \\(X\\) and \\(B\\) vectors are stored in 1d double arrays of length \\(N\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. BandSPDLinSOE ( int N , int ku , BandSPDLinSolver & theSolver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. Sets the size of the system to \\(N\\) , the number of superdiagonals to ku . Allocates memory for the arrays; if not enough memory is available a warning message is printed and the system size is set to \\(0\\) . Sets the solver to be called when solving the equations to theSolver . Invokes setLinearSOE ( \\ * this ) and setSize() on the theSolver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor. Calls delete on any arrays created. int setBandSPDSolver ( BandSPDLinSolver & newSolver ); Invokes setLinearSOE (* this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. int getNumEqn ( void ) = 0 ; A method which returns the current size of the system. int setSize ( const Graph & G ); The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first setting ku equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in ku being increased. Knowing ku and the size of the system (the number of Vertices in G , a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Prints a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. int addA ( const Matrix & M , const ID & loc , doublefact = 1.0 ) = 0 ; First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += \\texttt{fact} * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector \\(b\\) to be fact times the Vector \\(V\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . int sendSelf ( int commitTag , Channel & theChannel ); Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. ```cpp int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"BandSPDLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandSPD/BandSPDLinSolver/","text":"BandSPDLinSolver #include <~/system_of_eqn/linearSOE/bandSPD/BandSPDLinSolver.h> class BandSPDLinSolver : public LinearSOESolver MovableObject Solver BandSPDLinSolver is an abstract class. The BandSPDLinSolver class provides access for each subclass to the BandSPDLinSOE object through the pointer theSOE , which is a protected pointer. Constructor Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing. Provided so the subclasses destructor will be called. The method sets up the link between the BandSPDLinSOE object and the BandSPDLinSolver, that it is sets the pointer the subclasses use.","title":"BandSPDLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/fullGEN/FullGenLinSOE/","text":"FullGenLinSOE #include <~/system_of_eqn/linearSOE/fullGEN/FullGenLinSOE.h> class FullGenLinSOE : public LinearSOE MovableObject SystemOfEqn FullGenLinSOE is class which is used to store a full general system. The \\(A\\) matrix is stored in a 1d double array with \\(n*n\\) elements, where \\(n\\) is the size of the system. \\(A_{i,j}\\) is stored at location \\((i + j*(n)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example, when \\(n=3\\) : \\[\\left[ \\begin{array}{ccc} a_{0,0} & a_{0,1} & a_{0,2} \\\\ a_{1,0} & a_{1,1} & a_{1,2} \\\\ a_{2,0} & a_{2,1} & a_{2,2} \\\\ \\end{array} \\right]\\] is stored as: \\[\\left[ \\begin{array}{cccccccccccccccccccc} a_{0,0} & a_{1,0} & a_{2,0} & a_{0,1} & a_{1,1} & a_{2,1} & a_{0,2} & a_{1,2} & a_{2,2} \\\\ \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(n\\) . To allow the solvers access to this data, the solvers that use this class are all declared as friend classes. The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. FullGenLinSOE ( int N , FullGenLinSolver & solver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) and the matrix \\(A\\) is marked as not having been factored. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) and \\(b\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . Invokes setLinearSOE ( \\ * this ) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor. Destructor ~ FullGenLinSOE (); Calls delete on any arrays created. Methods int setFullGEnSolver ( FullGenLinSolver & newSolver ); Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning \\(-1\\) if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. int getNumEqn ( void ) = 0 ; A method which returns the current size of the system. int setSize ( const Graph & theGraph ); The size of the system is determined by invoking getNumVertex() on theGraph . If the old space allocated for the 1d arrays is not big enough, it the old space is returned to the heap and new space is allocated from the heap. Prints a warning message, sets size to \\(0\\) and returns a \\(-1\\) , if not enough memory is available on the heap for the 1d arrays. If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. int addA ( const Matrix & M , const ID & loc , doublefact = 1.0 ) = 0 ; First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\[a_{loc(i),loc(j)} += \\texttt{fact} * M(i,j)\\] . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(\\texttt{loc}) = \\texttt{value}\\) . int sendSelf ( int commitTag , Channel & theChannel ); Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the framework design. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the framework\u2019s design.","title":"FullGenLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/fullGEN/FullGenLinSolver/","text":"#include \\(<\\tilde{ }\\) /system_of_eqn/linearSOE/fullGEN/FullGenLinSolver.h \\(>\\) class FullGenLinSolver: public LinearSOESolver MovableObject Solver LinearSOESolver FullGenLinSolver is an abstract class. The FullGEnLinSolver class provides access for each subclass to the FullGenLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. Sets the link to the FullGEnLinSOE object theSOE . This is the object on which the solver will perform the numerical computations.","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSolver/","text":"UNDER CONSTRUCTION # ProfileSPDLinDirectSolver #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSolver.h> class ProfileSPDLinDirectSolver : public LinearSOESolver MovableObject\\ Solver\\ LinearSOESolver\\ ProfileSPDLinSolver\\ A ProfileSPDLinDirectSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one column at a time using a left-looking approach. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSOE/","text":"ProfileSPDLinSOE #include \"ProfileSPDLinSOE.h\" class ProfileSPDLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE ProfileSPDLinSOE is class which is used to store a symmetric system of equations using a profile storage scheme. The upper triangular part of \\(A\\) is stored in a 1d double array with the diagonals of \\(A\\) located at positions given by an integer array \\(iLoc\\) . For example when \\(n=5\\) and \\(A\\) as shown below: \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & 0 & 0 & a_{0,4} \\\\ a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] this is stored using: \\[A = \\left[ \\begin{array}{cccccccccccccccccccc} a_{0,0} & a_{0,1} & a_{1,1} & a_{1,2} & a_{2,2} & a_{1,3} & a_{2,3} & a_{3,3} & a_{0,4} & 0 & a_{2,4} & a_{3,4} & a_{4,4}\\\\ \\end{array} \\right]\\] and \\[iLoc = \\left[ \\begin{array}{cccccccccccccccccccc} 1 & 3 & 5 & 8 & 13 \\\\ \\end{array} \\right]\\] Note \\(iLoc\\) stores the diagonal locations using Fortran indexing. This is to facilitate calls to Fortran libraries, e.g. Digital\u2019s DXML. The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(N\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 1d arrays. ProfileSPDLinSOE(int N, int *newIloc, ProfileSPDLinSolver &theSolver); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) and the matrix \\(A\\) is marked as not having been factored or condensed. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) , \\(b\\) and \\(iLoc\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . The size of \\(A\\) is given by \\(newIloc(N-1)\\) , if this is not a valid address in newIloc a segmentation fault or erronious results will result. The contents of \\(iLoc\\) are set equal to those of newIloc . Invokes setLinearSOE(*this) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first determining the column height for each Vertex \\(i\\) in G , done by setting \\(iLoc(i)\\) equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in \\(iLoc(i)\\) being increased. Knowing the col height of each column, the values of iLoc can be determined. Knowing iLoc and the size of the system (the number of Vertices in G , a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Printins a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corrseponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"ProfileSPDLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSolver/","text":"ProfileSPDLinSolver #include $ <\\tilde{ }$ProfileSPDLinSolver.h$> $\\ class ProfileSPDLinSolver : public LinearSOESolver Solver LinearSOESolver ProfileSPDLinSolver is an abstract class. The ProfileSPDLinSolver class provides access for each subclass to the ProfileSPDLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. The method sets up the link between the ProfileSPDLinSOE object and the ProfileSPDLinSolver, that it is sets the pointer the subclasses use.","title":"ProfileSPDLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSubstrSolver/","text":"ProfileSPDLinSubstrSolver UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSubstrSolver.h> class ProfileSPDLinSubstrSolver : public DomainSolver , public ProfileSPDLinSubstrSolver\\ MovableObject Solver LinearSOESolver DomainSolver ProfileSPDLinDirectSolver A ProfileSPDLinSubstrSolver object will perform the numerical substructuring operations on a ProfileSPDLinSOE object. EXPAND. Constructor ### Destructor // Public Methods Causes the condenser to form \\(A_{ee}^* = A_{ee} -A_{ei} A_{ii}^{-1} A_{ie}\\) , where \\(A_{ii}\\) is the first numInt rows of the \\(A\\) matrix. The original \\(A\\) is changed as a result. \\(A_{ee}^*\\) is to be stored in \\(A_{ee}\\) . int condenseRHS ( int numInt ); Causes the condenser to form \\(B_e^* = B_e - A_{ei} A_{ii}^{-1} B_i\\) , where \\(A_{ii}\\) is the first numInt rows of \\(A\\) . The original \\(B\\) is changed as a result. \\(B_e^*\\) is to be stored in \\(B_e\\) . int computeCondensedMatVect ( Vector & u , int numInt ); Causes the condenser to form \\(A_{ee} u\\) . Matrix & getCondensedA ( void ); Returns the contents of \\(A_{ee}\\) as a matrix. Vector & getCondensedRHS ( void ); Returns the contents of \\(B_e\\) as a Vector. Vector & getCondensedMatVect ( void ); Returns the contents of the last call to computeCondensedMatVect() . int setComputedXext ( const Vector & u ); Sets the computed value of the unknowns in \\(X_e\\) corresponding to the external equations to u . The number of external equations is given by the size of vector \\(u\\) . int solveXint ( void ); To compute the internal equation numbers \\(X_i\\) given the value set for the external equations in the last call to setComputedXext() .","title":"ProfileSPDLinSubstrSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/sparseGEN/SparseGenColLinSOE/","text":"#include \\(<\\tilde{ }\\) /system_of_eqn/linearSOE/sparseGen/SparseGenColLinSOE.h \\(>\\) class SparseGenColLinSOE: public LinearSOE MovableObject SystemOfEqn LinearSOE SparseGenColLinSOE is class which is used to store the matrix equation \\(Ax=b\\) of order \\(size\\) using a sparse column-compacted storage scheme for \\(A\\) . The \\(A\\) matrix is stored in a 1d double array with \\(nnz\\) elements, where \\(nnz\\) is the number of non-zeroes in the matrix \\(A\\) . Two additional 1d integer arrays \\(rowA\\) and \\(colStartA\\) are used to store information about the location of the coefficients, with \\(colStartA(i)\\) storing the location in the 1d double array of the start of column \\(i\\) and \\(rowA(j)\\) identifying the row in \\(A\\) to which the \\(j'th\\) component in the 1d double array. \\(colStartA\\) is of dimension \\(size+1\\) and \\(rowA\\) of dimension \\(nnz\\) . For example \\[\\left[ \\begin{array}{ccccc} a_{0,0} & 0 & a_{0,2} & a_{0,3} & 0 \\\\ a_{1,0} & a_{1,1} & 0 & 0 & 0 \\\\ 0 & a_{2,1} & a_{2,2} & 0 & 0 \\\\ 0 & 0 & 0 & a_{3,3} & a_{3,4} \\\\ a_{4,0} & a_{4,1} & 0 & 0 & a_{4,4} \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{cccccccccccccc} a_{0,0} & a_{1,0} & a_{4,0} & a_{1,1} & a_{2,1} & a_{4,1} & a_{0,2} & a_{2,2} & a_{0,3} & a_{3,3} & a_{3,4} & a_{4,4} \\\\ \\end{array} \\right]\\] with \\[colStartA = \\left[ \\begin{array}{cccccccccccccc} 0 & 3 & 6 & 8 & 10 & 12 \\end{array} \\right]\\] and \\[rowA = \\left[ \\begin{array}{cccccccccccccc} 0 & 1 & 4 & 1 & 2 & 4 & 0 & 2 & 0 & 3 & 3 & 4 \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(n\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. SparseGenColLinSOE(int N, int NNZ, int *colStartA, int *rowA, SparseGenColLinSolver &theSolver); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) , the number of non-zeros is set to \\(NNZ\\) and the matrix \\(A\\) is marked as not having been factored. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) and \\(b\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . Invokes setLinearSOE(*this) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. It is up to the user to ensure that colStartA and rowA are of the correct size and contain the correct data. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning \\(-1\\) if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined from the Graph object theGraph , which must contain size vertices labelled \\(0\\) through \\(size-1\\) , the adjacency list for each vertex containing the associated vertices in a column of the matrix \\(A\\) . The size is determined by invoking getNumVertex() on theGraph and the number of non-zeros is determined by looking at the size of the adjacenecy list of each vertex in the graph, allowing space for the diagonal term. If the old space allocated for the 1d arrays is not big enough, it the old space is returned to the heap and new space is allocated from the heap. Prints a warning message, sets size to \\(0\\) and returns a \\(-1\\) , if not enough memory is available on the heap for the 1d arrays. If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. The \\(colStartA\\) and \\(rowA\\) are then determined by looping through the vertices, setting \\(colStartA(i) = colStartA(i-1) + 1 +\\) the size of Vertices \\(i\\) adjacency list and placing the contents of \\(i\\) and the adjacency list into \\(rowA\\) in ascending order. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corrseponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/sparseGEN/SuperLU/","text":"SuperLU #include <system_of_eqn/linearSOE/fullGEN/SuperLU.h> class SuperLU : public SparseGenColLinSolver\\ MovableObject Solver LinearSOESolver SparseGenColLinSolver A SuperLU object can be constructed to solve a SparseGenColLinSOE object. It obtains the solution by making calls on the the SuperLU library developed at UC Berkeley by Prof. James Demmel, Xiaoye S. Li and John R. Gilbert. The SuperLU library contains a set of subroutines to solve a sparse linear system \\(AX=B\\) . It uses Gaussian elimination with partial pivoting (GEPP). The columns of A may be preordered before factorization; the preordering for sparsity is completely separate from the factorization and a number of ordering schemes are provided. Constructor ### Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the SparseGenColLinSolver constructor. Saves the values for the arguments permSpec , panelSize , relax and thresh that will be used when calling the SuperLU routines in solve() and setSize() . permSpec defines the ordering routine used in defining the column permutations permC : \\(0\\) uses the original ordering supplied, \\(1\\) defines a min-degree ordering based on \\(A^TA\\) and \\(2\\) a min-degree ordering based on \\(A^T + A\\) . relax defines the min number of columns in a subtree for the subtree to be considered a single supernode. thresh defines the pivoting threshold: at step j of the Gaussian elimination if (abs \\((A_{jj}) \\ge\\) thresh (max \\(i \\ge j\\) abs( \\(A_{ij}\\) )). A value for thresh of \\(0.0\\) definines no pivoting, a value of \\(1.0\\) classical partial pivoting. panelSize defines the number of consecutive columns used as a panel in the elimination. For more information on these values see the SuperLU manual. Invokes delete on permR , permC and etree arrays. First copies \\(B\\) into \\(X\\) and then solves the FullGenLinSOE system it is associated with (pointer kept by parent class) by calling the SeuperLU routine dgstrf() , if the system is marked as not having been factored, or dgstrs() , if system is marked as having been factored. If the solution is successfully obtained, i.e. the SuperLU routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) and sets the char rafact to Y . Obtains the size of the system from it\u2019s associaed SparseGenColLinSOE object. With this information it creates space for the integer arrays permR , permC and etree . It then creates the a SuperMatrix for A by calling the SuperLU routine dCreate_CompCol_Matrix() , sets the column permutation permR by calling the SuperLU routine get_perm_c(permSpec, A, permC) , applies this permutation and determines the elimination tree etree by calling the SuperLU routine sp_preorder() . It then creates a SuperMatrix for X by calling the SuperLU routine dCreate_Dense_Matrix() . Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for the arrays. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"SuperLU\n"},{"location":"developer/architecture/class_interface/utility/","text":"Algebraic Classes Numerical classes are used to pass numerical information between objects and to handle the numerical operations in the solution procedure. The container classes provided include Matrix , Vector , and ID . The abstractions provided by the Matrix and Vector classes should be apparent. The ID class provides the abstraction of an integer array. SysOfEqn provides abstractions for performing linear algebraic operations. Matrix Vector ID SysOfEqn","title":"Algebraic Classes\n"},{"location":"developer/architecture/class_interface/utility/ID/","text":"ID #include <matrix/ID.h> class ID : The ID class provides the abstraction for an integer Vector. The class is introduced in addition to the Vector class, to save memory and casting when integer arrays are required. An ID of order size is an ordered 1d array of size integer values. For example an ID id of order 5: \\(id = [id_0\\) \\(id_1\\) \\(id_2\\) \\(id_3\\) \\(id_4]\\) In the ID class, the data is stored in a 1d integer array of length equal to arraySize, where order <= arraySize. Creating an ID with storage capacity greater than that required allows the ID object to grow without the need to deallocate and allocate more memory. At present time none of the methods are declared as being virtual. THIS MAY CHANGE. To construct an ID of size \\(0\\) . No memory is allocated for the storage of the data. To construct a ID of size idSize . The constructor creates an integer array of size idSize to store the data and zeroes this array by invoking Zero() on itself. If not enough memory is available an error message is printed and an ID of size \\(0\\) is returned. To construct a ID of size idSize . The constructor creates an integer array of size arraySize to store the data and zeroes this array. If arraySize is less than idSize , the new arraySize is set equal to idSize . If not enough memory is available an error message is printed and the program is terminated. This constructor is provided to allow an ID to grow. To construct an ID using another ID M . The new ID will be identical to the ID \\(M\\) , same order and same size of array to hold the integer values. If not enough memory is available a warning message is printed and both the order and arraySize of the ID are set to \\(0\\) . Will invoke delete on the integer array used to store the components. Returns the order of the ID. Zeros out the ID, i.e. sets all the components of the ID to \\(0\\) . This is accomplished by zeroing the first this.Size() components of the array. Will return the location the first location in the ID of the integer x . If x is not in the ID a \\(-1\\) is returned. Will return the last location in the ID of the integer x . If x is not in the ID a \\(-1\\) is returned. All the integer components x are removed from the ID and the length of the ID is reduced by the number of the removed components. The arraySize remains unchanged. Returns the data at location x in the ID. Assumes ( x ) is a valid location in the ID, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the ID. Assumes ( x ) is a valid location in the ID, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the ID. If x is outside the order of the ID the ID is order of the ID is enlarged to x+1 . When increasing the order, a check is first made to see if the current array is large enough; if it is the components between the old end and the new component are set to \\(0\\) and the order of the ID is set to x+1 , if not a new array is created. The size of this array is max( \\(2*\\) old array size, x). A copy of the components of the old array into the new array is made, with any new components set to \\(0\\) . If not enough space is available or x is less than \\(0\\) , a warning message is printed and the contents of ID_ERROR returned. Sets the current ID to be equal to the ID given by M . If the IDs are of different sizes, the current data is deallocated and more space allocated before the contents are copied. If not enough memory is available, the order and arraySize of the current ID is set to \\(0\\) and the ID is returned without copying the components. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const ID & id ); A function to print out the contents of the ID id to the output stream s . Prints out the components into the stream and then sends a newline character. friend istream & operator $ >> $ ( istream & s , const ID & id ); A function to read the contents of the ID id from the input stream s . Sets the components of id equal to the next id.Size() entries in the stream.","title":"ID\n"},{"location":"developer/architecture/class_interface/utility/Matrix/","text":"Matrix #include <matrix/Matrix.h> class Matrix : The Matrix class provides the matrix abstraction. A matrix of order numRows X numCols is an ordered 2d array of numbers arranged in numRows rows and numCols columns. For example, a matrix \\(A\\) of order 2 X 3: $$A = $$ The Matrix class provides the implementation of a general unsymmetric matrix. The data for the matrix is stored in a 1d double array of size numRows*numCols with the data for \\(a_{i,j}\\) located at j*numRows + i in the 1d array. This is similar to the ordering of a Fortran 2d array and will permit calls to numerical Fortran libraries, e.g. BLAS, for certain method calls at a future stage. At present no subclassing is permitted (THIS MAY CHANGE), the reason for this is that the Matrix objects are envisioned to be small scale matrices primarily used for the passing of data between objects in the system. To allow subclassing could reduce the efficiency of the program due to the manner in which virtual functions are implemented. To construct a Matrix with numRows = \\(0\\) , and numCols = \\(0\\) . No memory is allocated to store the data. To construct a Matrix with numRows = nrows , and numCols = ncols and all coefficients equal to \\(0\\) . Allocates memory for the storage of the data. If numRows \\(<\\) \\(0\\) , numCols \\(<\\) \\(0\\) or not enough memory is available available, an error message is printed and a Matrix with numRows = \\(0\\) and numCols = \\(0\\) is returned. Before the Matrix is returned, Zero() is called on the Matrix. To construct a Matrix with numRows = nrows , and numCols = ncols and all coefficients equal to \\(0\\) . The memory for storage of the data is found at the location pointed to by data . Note that this memory must have been previously allocated and it must be of appropriate size, erroneous results and segmentation faults can occur otherwise. No additional memory is allocated for the storage of the data. To construct a Matrix using another Matrix. The new Matrix will be a general matrix that is identical to the Matrix M , i.e. same size and identical components. If not enough memory is available, an error message is printed and a Matrix with numRows = \\(0\\) and numCols = \\(0\\) is returned. The constructor tests for the type of \\(M\\) to see whether the performance can be improved, by avoiding having to call \\(M\\) \u2019s overloaded (i,j) operators if \\(M\\) is of type genMatrix. Free\u2019s up any memory allocated in the constructor. Note that if the third constructor had been invoked, the memory passed is not released back to the system (this must be done later by the user of this constructor). Returns the number of rows, numRows, of the Matrix. The method is declared inline for the compiler to produce faster code which does not require a method call. Returns the number of columns, numCols, of the Matrix. Zero\u2019s out the Matrix, i.e. sets all the components of the matrix to \\(0\\) . The method tests for the type of Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators if the Matrix is of type genMatrix. Assembles into the current Matrix the Matrix M . The contents of the current matrix at location ( rows(i),cols(j) ) is set equal to the current value plus fact times the value of the matrix M at location ( i,j ). A warning is printed for every rows ( i ), cols ( j ) specified which is outside the bounds of the matrix. Will solve the equation \\(Ax=V\\) for the Vector x , which is returned. At the moment the current matrix is assumed to be symmetric positive definite. THIS IS TO CHANGE. A Vector is created using V . If this Vector is not of the correct size or if an error occurs during factorization a warning message is printed and the Vector x is returned. To add a factor fact times the Matrix other to the current Matrix. The size of the other Matrix is first checked to see sizes are compatible; if size are not compatible nothing is done and a warning message is printed. The method tests for the type of other , to see whether the performance can be improved by avoiding having to call other \u2019s overloaded (i,j) operators, if other is of type genMatrix. Returns the data at location( row,col ) in the Matrix. Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( row,col ) in the Matrix. Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Returns a new Matrix of dimension ( rows.Size() , cols.Size() ). The contents of the new matrix are given by the contents of the current matrix at the locations given by the rows and cols objects. For example the contents of the new matrix at location ( i,j ) are equal to the contents of the current matrix at location ( rows(i),cols(j) ). Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Sets the current Matrix to be equal to the Matrix given by M . If the Matrices are of different sizes, the current data is deallocated and additional space allocated before the contents are copied. If not enough space can be allocated for the new data, an error message is printed and a Matrix of size \\(0\\) x \\(0\\) is returned. The method tests for the type of M , to see whether the performance can be improved by avoiding having to call \\(M\\) \u2019s overloaded (i,j) operators, if \\(M\\) is of type genMatrix. This method must be implemented by each subclass. A method to add fact to each component of the current Matrix. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to subtract fact from each component of the current Matrix. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to multiply each component of the current Matrix by fact . The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method which will divide each component of the current Matrix by fact . If fact is equal to zero, an error message is printed and the contents of the Matrix are set to MATRIX_VERY_LARGE_VALUE (defined in <Matrix.h> ). The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Matrix, whose components are equal to the components of the current Matrix plus the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The += operator is then invoked on this Matrix with fact as the argument, and the new Matrix is then returned. A method to return a new Matrix, whose components are equal to the components of the current Matrix minus the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The -= operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Matrix, whose components are equal to the components of the current Matrix times the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The = operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Matrix whose components are equal to the components of the current Matrix divided the value fact . A new Matrix object is constructed by using the current Matrix as the argument to the constructor. The /= operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Vector, of size numRows, whose components are equal to the product of the current Matrix times the Vector V . If the current Matrix and Vector V are not compatible, i.e. V.Size() is not equal to numCols, an error message is printed and a zero Vector of size equal to the number of rows in the current Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Vector, of size numCols, whose components are equal to the product of the transpose of the current Matrix times the Vector V . If the current Matrix and Vector V are not compatible, i.e. V.Size() is not equal to numRows, an error message is printed and a zero Vector of size equal to the number of columns in the current Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Matrix equal to the sum of the current Matrix and the Matrix M . It does this by creating a new matrix passing itself as an argument to the constructor. The addMatrix() method is then invoked on this new Matrix with \\(M\\) and \\(-1\\) as the arguments. The new Matrix is then returned. A method to return a new Matrix equal to the the current Matrix minus the Matrix M . It does this by creating a new matrix passing itself as an argument to the constructor. The addMatrix() method is then invoked on this new Matrix with \\(M\\) and \\(-1\\) as the arguments. The new Matrix is then returned. A method to return a new Matrix equal to the product of the current Matrix and the Matrix M . It does this by first creating a new Matrix of size numRows and M.numCols. The contents of this new Matrix are then determined and the resulting Matrix is returned. If the two matrices are of incompatible sizes, a warning message is printed and a zeroed Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if M is of type genMatrix. A method to return a new Matrix equal to the product of the transpose of the current Matrix and the Matrix M . It does this by first creating a new Matrix of size numRows and M.numRows. The contents of this new Matrix are then determined and the resulting Matrix is returned. If the two matrices are of incompatible sizes, a warning message is printed and a zeroed Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if M is of type genMatrix. To print the contents of the Matrix to the output stream s . The method will print the contents one row at a time. To read the contents of the Matrix from the input stream s . The method expects the components one row at a time. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const Matrix & M ); A function to print out the contents of the Matrix M to the output stream s . Does this by invoking Output() on the Matrix M . friend OPS_Stream & operator $ >> $ ( istream & s , const Matrix & M ); A function to print out the contents of the Matrix M to the output stream s . Does this by invoking Output() on the Matrix M .","title":"Matrix\n"},{"location":"developer/architecture/class_interface/utility/StringContainer/","text":"/* ****************************************************************** OpenSees - Open System for Earthquake Engineering Simulation Pacific Earthquake Engineering Research Center (C) Copyright 1999, The Regents of the University of California All Rights Reserved. Commercial use of this program without express permission of the University of California, Berkeley, is strictly prohibited. See file \u2018COPYRIGHT\u2019 in main directory for information on usage and redistribution, and for a DISCLAIMER OF ALL WARRANTIES. Developed by: Frank McKenna (fmckenna@ce.berkeley.edu) Gregory L. Fenves (fenves@ce.berkeley.edu) Filip C. Filippou (filippou@ce.berkeley.edu) ****************************************************************** */ // $Revision: 1.1 $ // $Date: 2006-11-08 20:06:10 $ // $Source: /usr/local/cvs/OpenSees/SRC/utility/StringContainer.h,v $ // Written: fmk // Created: 11/06 // // Description: This file contains the class definition for StringContainer. // StringContainer is used to store information about a simulation; this // includes start and end times; program version, files opened for reading, files // opened for writing, and all parameters used (specified with pset or -par option // to program) // // What: \u201c@(#) StringContainer.h, revA\u201d #ifndef StringContainer_h #define StringContainer_h class StringContainer { public: StringContainer(); ~StringContainer(); int addString(const char ); const char getString(int) const; const char *operator()(void); int getNumStrings() const; void clear(void); private: char **strings; int numStrings; }; #endif","title":""},{"location":"developer/architecture/class_interface/utility/Timer/","text":"#include \\(<\\tilde{}\\) /Timer/Timer.h \\(>\\) class Timer: public MovableObject MovableObject A Timer object is an object which can be used to measure system resources, i.e. cpu time and memory usage. Currently for Unix systems only. COMPILE FLAG NEEDED. Does nothing. Does nothing. Sets the accounting variables to mark the start of accounting period using the unix functions times() and getrusage . Sets the accounting variables to mark the end of accounting period using the unix functions times() and getrusage . Uses the difference between the starting and ending accounting variables to determine the elapsed real time between the last calls to start() and pause() . Returns this value in units of seconds. Uses the difference between the starting and ending accounting variables to determine the CPU time allocated the process between the last calls to start() and pause() . Returns this value in units of seconds. Uses the difference between the starting and ending accounting variables to determine the number of page faults that required reading of pages from disk between the last calls to start() and pause() . Returns this value. Uses the difference between the starting and ending accounting variables to determine the real time, CPU time, operating system time allocate the process, total number of page faults, number of page faults that required reading of pages from memory, and number of page faults that required no reading from disk between the last calls to start() and pause() . Send these values to s . Invokes Print(s) on the Timer object E .","title":""},{"location":"developer/architecture/class_interface/utility/Vector/","text":"Vector #include \"matrix/Vector.h\" class Vector : The Vector class provides the vector abstraction. A vector of order size is an ordered 1d array of size numbers. For example a vector of order 5: \\(x = [x_0\\) \\(x_1\\) \\(x_2\\) \\(x_3\\) \\(x_4]\\) In the Vector class the data is stored in a 1d double array of length equal to the order of the Vector. At present time none of the methods are declared as being virtual. THIS MAY CHANGE FOR PARALLEL. To construct a Vector of order \\(0\\) . To construct a Vector of order size . The constructor creates an array to store the data and zeroes this array. If not enough memory is available a warning message is printed and a Vector of order \\(0\\) is returned. The Zero() method is invoked on the new Vector before it is returned. To construct a Vector of order size whose data will be stored in the array pointed to by data . The array pointed to by data is not set to zero by the constructor. Note that delete will not be called on this array in the destructor. It is up to the user to ensure that the array pointed to by data is at least as large as size , if this is not the case erroneous results or a segmentation fault may occur. To construct a Vector using another Vector. The new Vector will be identical to the Vector other . The constructor creates an array to store the data and zeroes this array. If not enough memory is available a warning message is printed and a Vector of order \\(0\\) is returned. The contents of the array are then set equal to the contents of other . Will delete any space allocated in the constructors. If the array is passed in the constructor, the space is not deallocated. Returns the order of the Vector, size . Zeros out the Vector, i.e. sets all the components of the Vector to \\(0\\) . Assembles into the current Vector the Vector V . The contents of the current Vector at location ( loc(i) ) is set equal to the current value plus fact times the value of the Vector V at location ( i ). returns \\(0\\) if successful. A warning message is printed for each invalid location in the current Vector or V and a \\(-1\\) is returned. To add a factor fact times the Vector other to the current Vector. returns \\(0\\) if successful. An error message is printed and \\(-1\\) is returned if Vectors are not of the same size. Checks are made to see if the number of operations can be reduced if fact is \\(0\\) or \\(1\\) . To add a factor fact times the Vector formed by the product of the matrix m and the Vector v to the current Vector. No temporary Vector is created. Returns \\(0\\) if successful. Prints a warning message and returns \\(-1\\) if sizes are incompatible. Checks are made to see if the number of operations can be reduced if fact is \\(0\\) or \\(1\\) . Returns the 2 norm of the Vector. Returns the sqrt() of the result of invoking the \\(\\hat{ }\\) operator on the current Vector with the current Vector as the argument. Returns the data at location x in the Vector. Assumes ( x ) is a valid location in the Vector, i.e. \\(0 <= x\\) order, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the Vector. Assumes ( x ) is a valid location in the Vector, i.e. \\(0 <= x <\\) order, a segmentation fault or erroneous results can occur if this is not the case. To safely return the data at location x in the Vector. Checks to ensure x is a valid location, i.e. \\(0 <= x\\) order. If x is not a valid location a warning message is printed and VECTOR_NOT_VALID_ENTRY (a static class variable) is returned. This is a slower but safer version of () const . Used to safely set the data at location( x ) in the Vector. Checks to ensure x is a valid location, i.e. \\(0 <= x\\) order. If x is not a valid location a warning message is printed and VECTOR_NOT_VALID_ENTRY (a static class variable) is modified. This is a slower but safer version of () . Returns a Vector of order loc.Size() . The contents of the new Vector are given by the contents of the current Vector at the locations given by the loc . For example the contents of the new Vector at location \\(i\\) are equal to the contents of the current Vector at location loc(i) . Creates a new Vector, copies the data from the current Vector and returns the new Vector. For each invalid location specified in loc for the current Vector, a warning message is printed. Sets the current Vector to be equal to the Vector given by other . If the Vectors are of different sizes, the current data, if allocated in a constructor, is deallocated and more space allocated before the contents are copied. If not enough memory is available a warning message is printed and the order of the current Vector is set to \\(0\\) . A method to add fact to each component of the current Vector. A method to subtract fact from each component of the current Vector. A method to multiply each component of the current Vector by fact. A method which will divide each component of the current Vector by fact . If fact is equal to zero an warning message is printed and the components of the Vector are set to VECTOR_VERY_LARGE_VALUE (defined in <Vector.h> ). A method to return a new Vector whose components are equal to the components of the current Vector plus the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the += operator is invoked on the matrix with fact . If the new Vector and current Vector are of different size, i.e. constructor fails to get enough memory, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector minus the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the -= operator is invoked on the matrix with fact . If the new Vector and current Vector are of different size, i.e. constructor fails to get enough memory, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector times the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the = operator is invoked on the matrix with fact . If the new Vector and current Vector are of different sizes, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector divided the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the /= operator is invoked on the matrix with fact . Warning messages are printed if fact is equal to \\(0\\) or if the new Vector and current Vector are of different sizes. A method to add the contents of the Vector V to the current Vector. If Vectors are not of same order a warning message is printed and nothing is done. A method to subtract the contents of the Vector V from the current Vector. If Vectors are not of same order a warning message is printed and nothing is done. A method to return a new Vector which is equal to the sum of the the current Vector and the Vector V . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the += operator is invoked on the matrix with V . If the current Vector and V are not of the same size, a warning message is printed and a copy of the current Vector is returned. A warning message is also returned if the new Vector is not of the correct size, i.e. ran out of memory. A method to return a new Vector which is equal to the the current Vector minus the Vector V . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the -= operator is invoked on the matrix with V . If the current Vector and V are not of the same size, a warning message is printed and a copy of the current Vector is returned. A warning message is also returned if the new Vector is not of the correct size, i.e. ran out of memory. A method to return the dot product of the current Vector and the Vector V . If the current Vector and V are not of the same size, a warning message is printed and \\(0\\) returned. A method to return a new Vector, \\(x\\) , equal to the solution of the matrix equation \\(Mx=\\) the current Vector. A new Vector is created for the return of size M.noRows() . A new Matrix is created of order M.noRows() x M.noRows() and set equal to M if M is square, or \\(M^tM\\) if M is not square. The new Vector is then set equal to the result of invoking Solve ( \\ * this ) on the new Matrix. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const Vector & V ); A function to print out the contents of the Vector V to the output stream s . prints out the contents of the Vector in the stream and then prints the newline character. friend istream & operator $ >> $ ( istream & s , const Vector & V ); A function to read the contents of the Vector V from the input stream s . Sets the components of V equal to the next V.Size() entries in the stream.","title":"Vector\n"},{"location":"developer/architecture/class_interface/utility/Vertex/","text":"","title":""},{"location":"developer/architecture/class_interface/utility/utility/","text":"Utility Classes Tagged Timer","title":"Utility Classes\n"},{"location":"developer/architecture/class_interface/utility/tagged/TaggedObject/","text":"TaggedObject #include <tagged/TaggedObject.h> class TaggedObject TaggedObject is used as a base class to represent all classes that may have a integer identifier, a tag, to identify the object. It is used in the framework as a base class for many classes, for example DomainComponent and Vertex. The class is provided so that container classes can be written to store objects and provide access to them. This saves us rewriting container classes for each type of object. (templates will be able to provide this functionality when they are provided with all compilers). // Constructor // Destructor // Public Methods // Protected Methods Constructs a TaggedObject with a tag given by tag . The tag of a component is some unique means of identifying the component among like components, i.e. the tag of a node would be its unique node number. Does nothing. Provided so the concrete subclasses destructors will be called. Returns the tag associated with the object. This function is inlined for performance. A pure virtual function. The component is to output itself to the output stream s . The integer flag can be used to select just what should be output, by default \\(0\\) is passed. Invokes Print(s) on the TaggedObject m . Sets the tag of the object to be newTag . It is provided so that MovableObjects can set their tag in recvSelf() .","title":"TaggedObject\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/ArrayOfTaggedObjects/","text":"ArrayOfTaggedObjects #include <tagged/storage/ArrayOfTaggedObjects.h> class ArrayOfTaggedObjects ArrayOfTaggedObjects is used as a container object to store and provide access to objects of type TaggedObject. A single one dimensional array is used to store the pointers to the objects. As a one dimensional array is used, certain ideas are tried to improve performance: (1) if the array needs to be larger to hold more components, the array size is doubled; (2) when adding/retrieving components, the array location given by the components tag is first checked; and (3) a boolean flag is used to keep track of whether all objects have been stored at the location given by the tags. Constructor ### Destructor // Pure Public Methods Creates an array of size sizeInitialArray to hold pointers to the TaggedObject objects that will be added to the container. This array is created using new() to allow the array to grow as needed. Zeros this array and sets a number of integer values: (1) the size of the array; (2) the last position used in the array is \\(0\\) ; (3) the position in the array through which all previous cells are being used for pointers is \\(0\\) ; (4) the number of components added to the container is \\(0\\) ; and (5) all components have been added at the position given by their tag. If not enough space is available, the warning method is invoked on the global ErrorHandler and the integer outlining the array size is set to \\(0\\) . If memory has been allocated for the array, the object invokes the destructor on the current array. If newSize is valid, i.e. \\(>= 1\\) AND newSize \\(>\\) current size of the array, the object allocates memory for a new array of size newSize . It zeros this array and copies the old components to this array, trying to see if they can be located at the positions given by their tags. If all placed at ideal location last time and new size \\(>=\\) position of last entry straight copy, otherwise we reset and add each again using addComponent() . Finally invokes the destructor on the old array. Returns \\(0\\) if successful. If not successful, the warning method is invoked on the global ErrorHandler and a negative value is returned. To add the object newComponent to the container. First checks to see that an object with a similar tag does not already exist in the container, invokes the warning method on the global ErrorHandler and returns false if one does. It then checks to ensure that array is large enough to hold another pointer, if not setSize() is invoked with twice the size of the current array. (If setSize() fails the warning method is invoked and false is returned: NOTE other objects previously added may now be missing!!. The object is then placed into the array by choosing the first of the following that is successful: If the array is large enough, the location given by the objects tag is first tested to see if being used. If not this location is used. If it won\u2019t go in nicely, we find the first location in the array that is not being used and use this location. We keep a marker to this location for subsequent adds so that don\u2019t start at \\(0\\) location all the time. Finally the integer indicating the numbers of objects in the array is incremented and true is returned. To remove the component whose tag is given by tag from the container and return a pointer to the object. If tag is not too large and all components have been added nicely, the contents of the array at location tag is set to \\(0\\) and its old contents returned. Otherwise if the tag is not too large, the contents at position tag is first checked to see if it is pointing to an object and if this object has the same tag as tag , if it does the contents of the array is set to \\(0\\) and the object returned. If the object is not at it\u2019s nice location, the array is searched from the start to the position holding the last entry to see if the array points to the object with the appropriate tag. If it does the array location is set to \\(0\\) and the object returned, otherwise \\(0\\) is returned. If the object has not been found after the last possible location has been checked, \\(0\\) is returned. Returns the number of components currently stored in the container. To return a pointer to the TaggedObject whose identifier is given by tag . If tag is not too large and all components have been added nicely, the contents of the array at location tag is returned. Otherwise if the tag is not too large, the contents at position tag is first checked to see if it is pointing to an object and if this object has the same tag as tag , the object returned. If the object is not at it\u2019s nice location, the array is searched from the start to the position holding the last entry to see if the array points to the object with the appropriate tag. If it does the object is returned. If the object has not been found after the last possible location has been checked, \\(0\\) is returned. To return an iter for iterating through the objects that have been added to the container. Each container object has its own iter. This iter() is reset to point to the start and a reference to this iter is returned. To return an empty copy of the container. Creates a new ArrayOfTaggedObjects object using the current size of the array as the argument for the constructor. It is up to the user of this method to invoke the destructor on the new object. To remove all objects from the container and to invoke the destructor on these objects . Goes through the array, invoking the destructor on any object pointed to by a cell and then setting this cell to \\(0\\) . Resets the internal member data to indicate that zero components have been added to the container. Invokes Print ( s , flag ) on all objects which have been added to the container.","title":"ArrayOfTaggedObjects\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/MapOfTaggedObjects/","text":"MapOfTaggedObjects #include <tagged/storage/MapOfTaggedObjects.h> class MapOfTaggedObjects A MapOfTaggedObjects object is used as a container to store and provide access to objects of type TaggedObject. A MapOfTaggedObjects creates a map object to store the pointers to these objects. A map is created using a template provided by the standard template library. The key used to identify the pointers stored in the map object is the TaggedObjects tag. Each MapOfTaggedObject object also contains a MapOfTaggedObjectsIter object to iterate through the objects which have been added. Constructor ### Destructor // Pure Public Methods Creates the map object and an iter for iterating through the objects that are added to the map. Does nothing. Checks to see that max size for the map (which is a built in value defined for the template class) is larger than newSize . Returns \\(0\\) if successful. If not successful, the warning method is invoked on the global ErrorHandler and \\(-1\\) is returned. To add the object newComponent to the container. First checks to see if an element with a similar tag already exists in the map. If not, the pointer to newElement is added to the map using the insert() method. A check is then made to ensure that the object has been added. (This is done as insert() returns no error flag). Returns true if successful. If not successful, the warning method is invoked on the global ErrorHandler and false is returned. Note that the map template does not allow items with duplicate keys to be added. To remove the component whose tag is given by tag from the container and return a pointer to the object. Invokes find(tag) on the map to first see if the element is there. If it is erase(tag) is invoked on the map to remove the item. \\(0\\) is returned if the component is not in the map, otherwise a pointer to the component is returned. Returns the number of components currently stored in the container. This is found by invoking size() on the map object. To return a pointer to the TaggedObject whose identifier is given by tag . Invokes find(tag) on the map to determine if the component is in the container. If it is a pointer to the component is returned. If it is not in the map \\(0\\) is returned. To return an iter for iterating through the objects that have been added to the container. Each MapOfTaggedObjects object has its own iter. This iter() is first reset and a reference to this iter is then returned. Returns a pointer to a new MapOfTaggedObjects which was created using new() . The new container that is returned is an empty container. If not enough memory is available to create this object the warning method on the global ErrorHandler is invoked and \\(0\\) is returned. Note that it is the responsibility of the caller to invoke the destructor on the object that is returned. To remove all objects from the container and to invoke the destructor on these objects . Goes through the container, invoking the destructor on any object in the map. It then invokes clear() on the map object to clear it. Invokes Print ( s , flag ) on all objects which have been added to the container.","title":"MapOfTaggedObjects\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/TaggedObjectStorage/","text":"TaggedObjectStorage #include <tagged/storage/TaggedObjectStorage.h> class TaggedObjectStorage TaggedObjectStorage is used as a container object to store and provide access to objects of type TaggedObject. Each TaggedObject object stored in a TaggedObjectStorage object must have a unique integer tag to distinguish it from other the other objects stored. The TaggedObjectStorage class is an abstract base class, it just defines the interface all concrete subclasses must provide. The interface defines methods to add and to remove the components, and methods to obtain access to the components. Constructor ### Destructor // Pure Virtual Public Methods Does nothing. Does nothing. Provided so that the concrete subclasses destructor will be invoked. The subclasses destructor is NOT to delete the objects stored in the object. clearAll() can be invoked by the programmer if this is required. To provide an indication to the container object that newSize components are likely to be added. This is only a hint, it should be acceptable for more or less objects than newSize to be added to the container. To add the object newComponent to the container. To return true if the object was added to the container, false otherwise. The object should not be added if another object with a similar tag already exists in the container. To remove the component whose tag is given by tag from the container. To return a pointer to the removed object if successful, \\(0\\) if not. To return the number of components currently stored in the container. To return a pointer to the TaggedObject whose identifier is given by tag . If the object has not been added to the container \\(0\\) is to be returned. To return an iter for iterating through the objects that have been added to the container. To return an empty copy of the container. To remove all objects from the container and to invoke the destructor on these objects if invokeDestructor is true . To invoke Print ( s , flag ) on all objects which have been added to the container.","title":"TaggedObjectStorage\n"},{"location":"developer/compiling/","text":"Compiling the Application OpenSees uses CMake to provide a consistent cross-platform building experience. A basic walkthrough of this process is developed in build-basic , but users who are new to working with C/C++ projects may first want to read build-tooling . If issues arise while following the basic methodology, it may be necessary to modify some advaced configuration options. For guides on adding new OpenSees components to the CMake build system, see extend . [compile/basic][] [compile/tooling][] [compile/advanced][]","title":"Compiling the Application\n"},{"location":"developer/compiling/advanced/","text":"Advanced Configurations with CMake This section is incomplete Highly customized versions of OpenSees can be configured and built with the help of CMake. In this document, a few special cases are considered: Developing extension libraries for OpenSees. Managing different versions of dependencies like Tcl Linking OpenSees against alternative numerical libraries like BLAS and LAPACK. The CMake build system is primarily composed of 3 files: /Conf.cmake : This file is meant to be modified by intermediate to advanced users who may wish to use non-default configuration options. /ETC/cmake/OpenSeesDependencies*.cmake : This file is used to configure a strategy for locating build dependencies. Users should not have to modify these files for standard builds on common operating systems; a correct strategy should be automatically configured based on the detected OS. /CMakeLists.txt : The root-level CMakeLists.txt defines most of the logic for generating the OpenSees build system. It is responsible for sourcing all other CMake files. Users will not have to modify this file.","title":"Advanced Configurations with CMake\n"},{"location":"developer/compiling/basic/","text":"Compiling Basics The basic steps for building OpenSees can be broken down as follows: Obtain the OpenSees source code Obtain the necessary dependencies Generate and execute the build Before getting started, make sure that you have installed CMake and have suitable C/C++ and Fortran compiler tool chains configured on your computer (see build-chain ). The OpenSees source code repository is hosted on Github and can be downloaded directly from https://github.com/OpenSees/OpenSees . Alternatively, you can clone the repository from a terminal by running the following command: git clone https://github.com/OpenSees/OpenSees If you are planning to contribute changes back to the OpenSees project, you should first fork the repository as mentioned in build-src . Tcl is the only dependency required for a basic OpenSees build that is not already bundled into the source repository on Github. Most Linux distributions and MacOS will already have this installed. A package manager offers the simplest and cleanest way to install such dependencies (see build-pkg ). Explanation needed for adding Tcl paths to CMake config The final step is to generate and run a build system. Users on any platform should be able to use Option I below from a suitable command line environment. Option II outlines an alternative process for building with the graphical Visual Studio environment on Windows. Option I: Command line Open a terminal that is aware of you compiler tool-chain and package manager, or make sure to run any necessary activation scripts to this end. For example, if you are using Anaconda on Windows to manage dependencies, the following steps should be executed through the Anaconda Prompt (on MacOS or Linux this is likely integrated directly into your default terminal application). OpenSees $ mkdir build OpenSees $ cd build build $ cmake .. build $ cmake --build . --target OpenSeesTcl compile/basic-vs.rst Option II: Visual Studio The following steps outline the process of building OpenSees with Visual Studio. This section is incomplete Open Visual Studio. image Select Open a local folder to open the folder containing the OpenSees source repository image Once the directory has been opened, Visual Studio should automatically recognize the CMakeLists.txt file and begin generating the project build files. Once these have been successfully generated, the CMake output console should contain a similar success message to that shown below. image Note In order for this step to succeed, Visual Studio must be correctly configured with a Fortran compiler. See build-chain for more information.","title":"Compiling Basics\n"},{"location":"developer/compiling/dependencies/","text":"Dependencies Try cmake .. ; on Unix-like systems, this is often enough. If a dependency is missing, try one of the following options and run cmake .. again: Install the missing dependency with a system package manager (see below), or Install conan and run conan install .. --build missing from the build directory If a package was successfully installed but CMake still cannot find it, you can manually set one of the variables below: B : use bundled version, S : search operating system ( using CMake\u2019s find_package ) C/S : uses Conan if it has been run, otherwise searches system. Dependency Default Linker variable Compiler include [BLAS] B BLAS_LIBRARIES [LAPACK] [ARPACK] B ARPACK_LIBRARIES - [Tcl] C/S TCL_LIBRARIES TCL_INCLUDE_PATH [SuperLU] B OPS >>> LAPACK: /usr/lib/liblapack.so.3 OPS >>> SUPERLU: OTHER/bin/SuperLU_5.1.1/libSUPERLU.a OPS >>> ARPACK: OTHER/bin/ARPACK/libARPACK.a OPS >>> UMFPACK: OTHER/bin/UMFPACK/libUMFPACK.a OPS >>> CSPARSE: OTHER/bin/CSPARSE/libCSPARSE.a OPS >>> TCL: OPS >>> AMD: OTHER//bin/AMD/libAMD.a OPS >>> BLAS OPS >>> LAPACK OPS >>> SUPERLU APT (Ubuntu, Debian Linux) Dependency Package LAPACK liblapack-dev BLAS libblas-dev SuiteSparse suitesparse-dev SuperLU superlu-dev MySQL* libmysqlclient-dev Tcl* tcl-dev Pacman (Arch, Manjaro Linux) The Pacman package manager Dependency Package LAPACK lapack BLAS blas SuiteSparse suitesparse SuperLU superlu MySQL* mariadb Tcl* tcl Anaconda (Mac, Windows, Linux) Dependency Package Channel LAPACK lapack BLAS blas SuperLU superlu SuiteSparse suitesparse MySQL* mysql conda-forge","title":"Dependencies\n"},{"location":"developer/compiling/tooling/","text":"Tooling This page introduces some basic tools which may be new to users who have not worked with C/C++. Users that are already comfortable with a C/C++ toolchain can skip this page. Source Control A source control tool is like Google Documents, but for source code. It allows developers to track changes that have been made to a project, and easily collaborate by sharing patches. Currently, the industry standard tool for this purpose is Git . Just like Google drive provides a platform for hosting sharing and collaborating on Google documents, GitHub is a platform where developers can host, share and collaborate on software projects. The OpenSees project follows a forking workflow for accepting contributions. The following resources explain more on this matter. For a brief outline on forking we suggest the Atlassians forking workflow page . For a brief introduction to using your new FORK we suggest the Atlassians saving changes . For those interested in programming, you might as well become proficient using git so the link to all of Atlassians git tutorial will make help. Compiler tool-chain ------------------ A compiler tool-chain is the collection of programs that work together to build a final executable program. This includes the actual compiler, a linker, and various other utilities. These programs are typically bundled together and installed collectively in a single step. Different operating systems generally favor a particular tool-chain, but the differences between these can generally be hidden by a build automation tool like CMake. Building OpenSees requires both a C/C++ and a Fortran compiler. Some suggested compilers for various platforms are listed in table-summary Package management APT (Ubuntu, Debian Linux) Dependency Package LAPACK liblapack-dev BLAS libblas-dev SuiteSparse suitesparse-dev SuperLU superlu-dev MySQL* libmysqlclient-dev Tcl* tcl-dev Pacman (Arch, Manjaro Linux) The Pacman package manager Dependency Package LAPACK lapack BLAS blas SuiteSparse suitesparse SuperLU superlu MySQL* mariadb Tcl* tcl Anaconda (Mac, Windows, Linux) Dependency Package Channel LAPACK lapack BLAS blas SuperLU superlu SuiteSparse suitesparse MySQL* mysql conda-forge Command line environments This section is under development Summary The following table gives a brief rundown of the most common configurations for various operating systems. Tool Windows MacOS Linux Source control GitHub Desktop GitHub Desktop Git Build automation CMake CMake CMake Compiler | C++ Visual Studio 2019 Clang GCC Fortran Intel-Fortr an GFortran GFortran Package management Homebrew system","title":"Tooling\n"},{"location":"developer/contributing/","text":"Contributing Bug fixes Link pull request to Bug Report Fill out bug fix template Components Component contributions should include the following: Tests Documentation Extra Resources for contributing Ship small diffs","title":"Contributing\n"},{"location":"developer/extending/10-Add%20A%20New%20Material/","text":"Add A New Material The OpenSees applications allows developers to use their own material modules to the application. Unlike most other programs, the materials are added at run-time and not at compile time. The advantage of this is the the developers: Do not need the OpenSees source files or libraries to compile and link the application. Can share their modules with others without having to provide the source code. <uml> Material <|\u2013 UniaxialMaterial Material <|\u2013 SectionForceDeformation Material <|\u2013 NDMaterial </uml> The material modules can be written using either C++, C, or Fortran. Whatever the language the developer wishes to use, the material modules make use of the OpenSees API . Add a New UniaxialMaterial C++ Add a New UniaxialMaterial C Add a New UniaxialMaterial Fortran Add a New nDMaterial C++ Add a New nDMaterial C Add a New ndMaterial Fortran","title":"Add A New Material\n"},{"location":"developer/extending/11-Add%20A%20New%20Recorder/","text":"Add A New Recorder A Recorder in the interpreted OpenSees applications is used to obtain information from the model during the analysis. To add a new Recorder option into the interpreted applications, the developer must provide a new C++ subclass of the Recorder class and an interface function that will be used to parse the input and create the new recorder. Recorder Class The Recorder class itself is an abstract base class. It inherits from both the TaggedObject class and the MovableObject class. The class has a minimal interface, which is as shown below: The Recorder Class: <source lang=\u201ccpp\u201d> class Recorder: public MovableObject, public TaggedObject { public: Recorder(int classTag); virtual ~Recorder(); virtual int record(int commitTag, double timeStamp) =0; virtual int restart(void); virtual int domainChanged(void); virtual int setDomain(Domain &theDomain); virtual int sendSelf(int commitTag, Channel &theChannel); virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); virtual void Print(OPS_Stream &s, int flag); protected: protected: private: static int lastRecorderTag; }; </source> The most important methods in the interface are: setDomain() - this is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. record() - this is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. Other Important methods are: domainChanged() - this is a method called when something major has happened in the Domain, ie. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it\u2019s pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it wuill have been deleted and it\u2019s old pointer information will no longer be valid.) send/recvSelf() - are two methods called in parallel applications. When invoked the recorders send/recv information about what they are recording. restart() - this method is called if restart() is invoked on the Domain. What the recorder does is up to you the developer. Example - SumElementForcesRecorder In the following section we will provide all necessary code to add a new recorder. The purpose of this recorder will be to sum the forces obtained from the list of inputted elements. The recorder will use the getResistingForce() method in the elements to obtain these forces. A similar class exists in the framework, which uses the setResponse()/getResponse() methods in the element interface. To demonstrate some of the output file options, the result will go to either the screen, a text file, or a binary file. More output options are of course available and the developer should look at existing recorder options. Header The header for thew new class, which we will call SumElementForcesRecorder is as follows: <source lang=\u201ccpp\u201d> ifndef SumElementForcesRecorder_h define SumElementForcesRecorder_h include <Recorder.h> include <Information.h> include <ID.h> class Domain; class Vector; class Matrix; class Element; class Response; class FE_Datastore; class SumElementForcesRecorder: public Recorder { public: // constructors SumElementForcesRecorder(); SumElementForcesRecorder(const ID eleID, bool echoTime, OPS_Stream *theOutputHandler); // destructors ~SumElementForcesRecorder(); // public methods int record(int commitTag, double timeStamp); int restart(void); int domainChanged(void); int setDomain(Domain &theDomain); const char *getClassType(void) const; int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); protected: private: int numEle; // the number of elements Element **theElements;// pointer to array of element pointers ID eleID; // ID (integer list) of element tags to record Domain theDomain; // pointer to domain holding elements OPS_Stream theOutput;// pointer to output location bool echoTimeFlag; // flag indicating if pseudo time to be printed Vector *data; // Vector (double array) to store sum of element forces }; endif </source> The header file defines the interface and variables for the class SumElementForceRecorder. It defines the new class to be a sublass of the Recorder class. In the public interface are 2 constructors and 1 destructor in addition to all the methods defined for the Recorder class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we store data that will be used by the SumElementForceRecorder objects. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Domain, Vector, Element, OPS_Stream) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, SumElementForcesRecorder.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_SumElementForcesRecorder() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. <source lang=\u201ccpp\u201d> include \u201cSumElementForcesRecorder.h\u201d include <elementAPI.h> include <Domain.h> include <Element.h> include <ElementIter.h> include <Matrix.h> include <Vector.h> include <ID.h> include <string.h> include <Response.h> include <Message.h> include <Channel.h> include <FEM_ObjectBroker.h> include <StandardStream.h> include <BinaryFileStream.h> include <DataFileStream.h> include <elementAPI.h> </source> Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. <source lang=\u201ccpp\u201d> SumElementForcesRecorder::SumElementForcesRecorder() Recorder(-1), numEle(0), theElements(0), eleID(0), theDomain(0), theOutput(0), echoTimeFlag(true), data(0) { } SumElementForcesRecorder::SumElementForcesRecorder(const ID ele, bool echoTime, OPS_Stream *theoutput) Recorder(-1), numEle(0), theElements(0), eleID(ele), theDomain(0), theOutput(theoutput), echoTimeFlag(echoTime), data(0) { // set numEle numEle = eleID.Size(); if (numEle == 0) { opserr << \u201cWARNING SumElementForcesRecorder::SumElementForcesRecorder() - no elements tags passed in input!\u201d; } } </source> Destructor The we provide the destructor. In the destructor all memory that the Recorder created or was passed to it in the constructor must be destroyed. Failing to delete this memory, will result in memory leaks. <source lang=\u201ccpp\u201d> SumElementForcesRecorder::~SumElementForcesRecorder() { if (theElements != 0) delete [] theElements; if (data != 0) delete data; if (theOutput != 0) delete theOutput; } </source> record() Method After the destructor, we provide the code for the record() method. It does the following operations: Zeros the vector which will contain the final sum If the time stamp is needed, it places it at the first location in the vector. Loops over all valid elements adding their resting force to the vector. Send the vector to the output handler to be written. Returns success. <source lang=\u201ccpp\u201d> int SumElementForcesRecorder::record(int commitTag, double timeStamp) { // check for initialization if (data == 0) { opserr << \u201cSumElementForcesRecorder::record() - setDomain() has not been called\u201d; return -1; } // zero the data vector data->Zero(); int forceSize = data->Size(); int startLoc = 0; // write the time if echTimeFlag set if (echoTimeFlag == true) { (*data)(0) = timeStamp; forceSize -= 1; startLoc = 1; } // // for each element that has been added to theElements add force contribution // for (int i=0; i< numEle; i++) { if (theElements[i] != 0) { int loc = startLoc; const Vector &force = theElements[i]->getResistingForce(); int forceSize = force.Size(); for (int j=0; j<forceSize; j++, loc++) (*data)(loc) += force(j); } } // // send the response vector to the output handler for o/p // if (theOutput != 0) theOutput->write(*data); // succesfull completion - return 0 return 0; } </source> restart() and domainChanged() methods Afte the record() method, we have the two simple short methods restart() and domainChanged(). restart does nothing and domainChanged simply calls the objects own setDomain() method. <source lang=\u201ccpp\u201d> int SumElementForcesRecorder::restart(void) { return 0; } int SumElementForcesRecorder::domainChanged(void) { if (theDomain != 0) this->setDomain(*theDomain); } </source> setDomain() Method The setDomain() method follows. In this method we perform the following: set the pointer for the enclosing domain object. allocate space from memoory for our array of ponters and our data vector. initialize the array components to be 0 or point to an element given by the eleID. determine the size of the vector that will be used to store the sum of the forces. allocate space for the vector. <source lang=\u201ccpp\u201d> int SumElementForcesRecorder::setDomain(Domain &theDom) { theDomain = &theDom; // set numEle if (numEle == 0) { opserr << \u201cWARNING SumElementForcesRecorder::initialize() - no elements tags passed in input!\u201d; return 0; } // create theElements, an array of pointers to elements theElements = new Element *[numEle]; if (theElements == 0) { opserr << \u201cWARNING SumElementForcesRecorder::initialize() - out of memory\u201d; numEle = 0; // set numEle = 0, in case record() still called return -1; } // // loop over the list of elements, // if element exists add it\u2019s pointer o the array // get its resisting force, check size to determine compatable with others // int sizeArray = -1; for (int i=0; i<numEle; i++) { int eleTag = eleID(i); Element *theEle = theDomain->getElement(eleTag); if (theEle != 0) { const Vector &force = theEle->getResistingForce(); int forceSize = force.Size(); if (sizeArray == -1) { sizeArray = forceSize; theElements[i] = theEle; } else if (sizeArray != forceSize) { opserr << \u201cWARNING: forces mismatch - element:\u201d << eleTag << \u201d will not be included\u201c; theElements[i] = 0; } else { theElements[i] = theEle; } } else { theElements[i] = 0; } } // if echTimeFlag is set, add room for the time to be output if (echoTimeFlag == true) sizeArray++; // create the vector to hold the data data = new Vector(sizeArray); if (data == 0 || data->Size() != sizeArray) { opserr << \u201cSumElementForcesRecorder::initialize() - out of memory\u201d; delete [] theElements; theElements = 0; numEle = 0; } return 0; } </source> sendSelf() and recvSelf() methods These methods only need be provided if the object will be used in a parallel program. We provide their implementation for completeness, though typicall developers are interested in running the code in a sequential application and should just return -1. <source lang=\u201ccpp\u201d> static char myClassType[] = {\u201cSumElementForcesRecorder\u201d}; const char * SumElementForcesRecorder::getClassType(void) const { return myClassType; } int SumElementForcesRecorder::sendSelf(int commitTag, Channel &theChannel) { // send in an ID (integar array) to the receiving object the following: // recorder tag // size of eleID // class tag of handler // echoTimeFlag static ID idData(5); idData(0) = this->getTag();; idData(1) = eleID.Size(); idData(2) = theOutput->getClassTag(); if (echoTimeFlag == true) idData(3) = 1; else idData(3) = 0; if (theChannel.sendID(0, commitTag, idData) < 0) { opserr << \u201cSumElementForcesRecorder::recvSelf() - failed to recv idData\u201d; return -1; } // send eleID to receiving object if (theChannel.sendID(0, commitTag, eleID) < 0) { opserr << \u201cSumElementForcesRecorder::sendSelf() - failed to send idData\u201d; return -1; } // send theOutput to receiving object if (theOutput->sendSelf(commitTag, theChannel) < 0) { opserr << \u201cSumElementForcesRecorder::sendSelf() - failed to send theOutput\u201d; return -1; } return 0; } </source> <source lang=\u201ccpp\u201d> int SumElementForcesRecorder::recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { // receive from the sending object the ID static ID idData(5); if (theChannel.recvID(0, commitTag, idData) < 0) { opserr << \u201cSumElementForcesRecorder::recvSelf() - failed to recv idData\u201d; return -1; } // with the data received // setTag // resize the eleID array // set echoTimeFlag // get an outputHandler this->setTag(idData(0)); eleID.resize(idData(1)); idData(2) = theOutput->getClassTag(); if (idData(3) == 0) echoTimeFlag = true; else echoTimeFlag = false; if (theOutput != 0 && theOutput->getClassTag() != idData(4)) delete theOutput; theOutput = theBroker.getPtrNewStream(idData(4)); if (theOutput == 0) { opserr << \u201cSumElementForcesRecorder::recvSelf() - failed to get Output of correct type\u201d; return -1; } // receive eleID if (theChannel.recvID(0, commitTag, eleID) < 0) { opserr << \u201cSumElementForcesRecorder::recvSelf() - failed to recv eleID\u201d; return -1; } // get theOutput to receive data if (theOutput->recvSelf(commitTag, theChannel, theBroker) < 0) { opserr << \u201cSumElementForcesRecorder::sendSelf() - failed to send theOutput\u201d; return -1; } return 0; } </source> Interface Function At the end of the implementation file is the interface function. This function is required by all new classes. It is a function which will use the api to parse the input based on the input create objects create a recorder object of the correct type, and return it to the calling function. The interface function is the function that is called when the interpreter comes across the command telling it to create a SumElementForcesRecorder. <source lang=\u201ccpp\u201d> ifdef _USRDLL include <windows.h> define OPS_Export extern \u201cC\u201d _declspec(dllexport) elif _MACOSX define OPS_Export extern \u201cC\u201d attribute ((visibility(\u201cdefault\u201d))) else define OPS_Export extern \u201cC\u201d endif static int numSumElementForcesREcorder = 0; OPS_Export void * OPS_SumElementForcesRecorder() { Recorder *theRecorder = 0; int numRemainingArgs = OPS_GetNumRemainingInputArgs(); // check for quick return, possibly parallel case if (numRemainingArgs == 0) { Recorder *theRecorder = new SumElementForcesRecorder(); } // // parse args // int numEle = 0, eleTag; ID eleID(0); OPS_Stream *theOutputStream = 0; int outMode = 0; // standard stream bool echoTime = false; bool doneParsingArgs = false; char data[100]; char outputName[200]; char **eleArgs = 0; int numEleArgs = 0; while (numRemainingArgs > 0) { if (OPS_GetString(data,100) < 0) return 0; // output to standard file if (strcmp(data,\u201c-file\u201d) == 0) { outMode = 1; if (OPS_GetString(outputName,200) < 0) return 0; numRemainingArgs -= 2; } // output to binary file else if (strcmp(data,\u201c-binary\u201d) == 0) { outMode = 2; if (OPS_GetString(outputName,200) < 0) return 0; numRemainingArgs -= 2; } // echo domain time stamp in output else if (strcmp(data,\u201c-time\u201d) == 0) { echoTime = true; numRemainingArgs -= 1; } // read the list of elements & place in an ID else if ((strcmp(data,\u201c-ele\u201d) == 0) || (strcmp(data,\u201c-eles\u201d) == 0) || (strcmp(data,\u201c-element\u201d) == 0)) { numRemainingArgs \u2013; int one = 1; while (numRemainingArgs > 0 && OPS_GetIntInput(&one, &eleTag) == 0) { eleID[numEle] = eleTag; numEle++; numRemainingArgs\u2013; } doneParsingArgs = true; } // // create the output handler // if (outMode == 0) theOutputStream = new StandardStream(); if (outMode == 1) theOutputStream = new DataFileStream(outputName); else if (outMode == 2) theOutputStream = new BinaryFileStream(outputName); // // create the recorder // theRecorder = new SumElementForcesRecorder(eleID, echoTime, theOutputStream); // return it return theRecorder; } </source> Example Script (OpenSeesDeveloper/recorder/example1.tcl) An example OpenSees tcl input file for this new recorder is: <source lang=\u201ctcl\u201d> create the model model basic -ndm 2 -ndf 2 node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 uniaxialMaterial Elastic 1 3000 element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 fix 1 1 1 fix 2 1 1 fix 3 1 1 pattern Plain 1 Linear { apply the load - command: load nodeID xForce yForce load 4 100 -50 } Create the analysis system ProfileSPD constraints Plain integrator LoadControl 1.0 algorithm Linear numberer RCM analysis Static recorder Element -file a.out -time -ele 1 2 3 forces recorder SumElementForcesRecorder -file b.out -time -ele 1 2 3 perform the analysis analyze 10 </source> Example Output The output shows that the model is in equilibrium, and that at node 4 the node the element resisting forces are equal to the applied forces. <source lang=\u201ctcl\u201d> 1 -100 50 100 -50 2 -200 100 200 -100 3 -300 150 300 -150 4 -400 200 400 -200 5 -500 250 500 -250 6 -600 300 600 -300 7 -700 350 700 -350 8 -800 400 800 -400 9 -900 450 900 -450 10 -1000 500 1000 -500 </source>","title":"Add A New Recorder\n"},{"location":"developer/extending/12-Add%20a%20New%20Element%20C%2B%2B/","text":"Add a New Element C++ To add a new Element module using the C++ language, the developer must: provide a new C++ subclass of the Element class provide an interface function that will be used to parse the input and create the new element. Unlike the C and Fortran modules, no information about the state of the model is passed as arguments to the element methods. It is the responsibility of the element to obtain this information using it\u2019s assocaiations. NOTE: This document assumes the reader is familiar with the C++ programming language. Element Class The Element class itself is an abstract base class. It inherits from both the DomainComponent class, which is itself a subclass of TaggedObject class and the MovableObject class. The class has a large number of methods defined in the interface, not all these methods need to be included in a new Element class. The following is the minimal interface that should be considered: The Element Class: <source lang=\u201ccpp\u201d> class Element : public DomainComponent { public: Element(int tag, int classTag); virtual ~Element(); // initialization virtual int setDomain(Domain *theDomain); // methods dealing with nodes and number of external dof virtual int getNumExternalNodes(void) const =0; virtual const ID &getExternalNodes(void) =0; virtual Node **getNodePtrs(void) =0; virtual int getNumDOF(void) =0; // methods dealing with committed state and update virtual int commitState(void); // called when a converged solution has been obtained for a time step virtual int revertToLastCommit(void) = 0; // called when the soln algorithm has failed to converge to a solution at a time step virtual int revertToStart(void); // called when model is rest to initial conditions virtual int update(void); // called when a new trial step has been set at the nodes // methods dealing with element stiffness virtual const Matrix &getTangentStiff(void) =0; virtual const Matrix &getInitialStiff(void) =0; // methods dealing with element forces virtual void zeroLoad(void); virtual int addLoad(ElementalLoad *theLoad, double loadFactor); virtual const Vector &getResistingForce(void) =0; // public methods for output void Print(OPS_Stream &s, int flag =0); virtual Response *setResponse(const char **argv, int argc, OPS_Stream &theHandler); virtual int getResponse(int responseID, Information &eleInformation); // method for database/parallel processing int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); } </source> Example - Truss2D In the following section we will provide all necessary code to add a new 2d planar truss element into an OpenSees interpreter. To demonstrate the power of object-oriented programming, the stress-strain relationship will be provided by a UniaxialMaterial object. Header The header for thew new class, which we will call Truss2D is as follows: <source lang=\u201ccpp\u201d> // include directives include <Element.h> include <Matrix.h> include <Vector.h> // forward declarations class UniaxialMaterial; class Truss2D : public Element { public: // constructors Truss2D(int tag, int Nd1, int Nd2, UniaxialMaterial &theMaterial, double A); Truss2D(); // destructor ~Truss2D(); // initialization int setDomain(Domain *theDomain); // public methods to obtain inforrmation about dof & connectivity int getNumExternalNodes(void) const; const ID &getExternalNodes(void); Node **getNodePtrs(void); int getNumDOF(void); // public methods to set the state of the element int commitState(void); int revertToLastCommit(void); int revertToStart(void); int update(void); // public methods to obtain stiffness const Matrix &getTangentStiff(void); const Matrix &getInitialStiff(void); // public method to obtain resisting force const Vector &getResistingForce(void); // method for obtaining information specific to an element void Print(OPS_Stream &s, int flag =0); Response *setResponse(const char **argv, int argc, OPS_Stream &s); int getResponse(int responseID, Information &eleInformation); // public methods for database/parallel processing int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); void Print(OPS_Stream &s, int flag =0); protected: private: // private member functions - only available to objects of the class double computeCurrentStrain(void) const; // private attributes - a copy for each object of the class UniaxialMaterial theMaterial; // pointer to a material ID externalNodes; // contains the id\u2019s of end nodes Matrix trans; // hold the transformation matrix double L; // length of truss (undeformed configuration) double A; // area of truss Node theNodes[2]; // node pointers // static data - single copy for all objects of the class static Matrix trussK; // class wide matrix for returning stiffness static Vector trussR; // class wide vector for returning residual }; endif </source> The header file defines the interface and variables for the class Truss2D. It defines the new class to be a sublass of the Element class. In the public interface, are two constructors and a destructor in addition to minimal set of methods we showed for the Element class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section, we define one private method, computeCurrentStrain(), and we define a number of private variables and a number of static variables. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Node, UniaxialMaterial) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, Truss2D.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_Truss2D() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. <source lang=\u201ccpp\u201d> include \u201cTruss2D.h\u201d include <elementAPI.h> include <G3Globals.h> include <Information.h> include <Domain.h> include <Node.h> include <Channel.h> include <Message.h> include <FEM_ObjectBroker.h> include <UniaxialMaterial.h> include <Renderer.h> include <ElementResponse.h> include <math.h> include <stdlib.h> include <string.h> </source> Static Variables Next, we initialize the static variables. For this example we are using 2 static-variables (objects shared by each Truss2D object that is created), one to return the tangent matrix and the other to return the resisting force. <source lang=\u201ccpp\u201d> // initialise the class wide variables Matrix Truss2D::trussK(4,4); Vector Truss2D::trussR(4); </source> Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. The first constructor is the one most typically used. The arguments provide the elements tag, the tags of the two end nodes, the element\u2019s area and a copy of the element\u2019s material. The code in the constructor does the following: The elements tag and a 0 are passed to the Element constructor. The matreial pointer, theMaterial, is set to a copy of the material obtained from the material that is passed in the arguments. The externalNodes array is set to be an array of size 2 and it\u2019s values are set to the nodal tags of the 2 nodes. The theNodes array components are set to be 0. It should be noted that the static variables dealing with length, transformations, and nodes are set to 0 in the constructors. They will be filled in when the setDomain() method is invoked on the object. <source lang=\u201ccpp\u201d> Truss2D::Truss2D(int tag, int Nd1, int Nd2, UniaxialMaterial &theMat, double a) Element(tag, 0), externalNodes(2), trans(1,4), L(0.0), A(a) { // get a copy of the material object for our own use theMaterial = theMat.getCopy(); if (theMaterial == 0) { opserr << \u201cFATAL TrussCPP::TrussCPP() - out of memory, could not get a copy of the Material\u201d; exit(-1); } // fill in the ID containing external node info with node id\u2019s if (externalNodes.Size() != 2) { opserr << \u201cFATAL TrussCPP::TrussCPP() - out of memory, could not create an ID of size 2\u201d; exit(-1); } externalNodes(0) = Nd1; externalNodes(1) = Nd2; theNodes[0] = 0; theNodes[1] = 0; } </source> The second constructor is called when paralell processing or the database feature of the OpenSees application is used. It\u2019s pupose is to create a blank Truss2D object, that will be filled in when the recvSelf() method is invoked on the object. <source lang=\u201ccpp\u201d> Truss2D::Truss2D() Element(0, 0), theMaterial(0), externalNodes(2), trans(1,4), L(0.0), A(0.0) { theNodes[0] = 0; theNodes[1] = 0; } </source> Destructor The we provide the destructor. In the destructor all memory that the Truss2D created or was passed to it in the constructor must be destroyed. For our example, we need to invoke the destructor on the copy of the material object. <source lang=\u201ccpp\u201d> Truss2D::~Truss2D() { if (theMaterial != 0) delete theMaterial; } </source> ===== setDomain() Initialization Method The setDomain() method is invoked when the truss element is being added to the Domain. It is in this method that most of the private variables of the object are determined. The method returns 0 if successfull, a negative number if not. In the method we obtain pointers to the end nodes, nodal coordinates are obtained and the elements length and transformation matrix is set once the coordinates have been obtained. <source lang=\u201ccpp\u201d> void Truss2D::setDomain(Domain *theDomain) { // check Domain is not null - invoked when object removed from a domain if (theDomain == 0) { return; } // first ensure nodes exist in Domain and set the node pointers Node end1Ptr, end2Ptr; int Nd1 = externalNodes(0); int Nd2 = externalNodes(1); end1Ptr = theDomain->getNode(Nd1); end2Ptr = theDomain->getNode(Nd2); if (end1Ptr == 0) { opserr << \u201cWARNING Truss2D::setDomain() - at truss\u201d << this->getTag() << \u201d node \u201d << Nd1 << \u201d does not exist in domain\u201c; return; // don\u2019t go any further - otherwise segemntation fault } if (end2Ptr == 0) { opserr <<\u201dWARNING Truss2D::setDomain() - at truss \u201d << this->getTag() << \u201d node \u201d << Nd2 << \u201d does not exist in domain\u201c; return; // don\u2019t go any further - otherwise segemntation fault } theNodes[0] = end1Ptr; theNodes[1] = end2Ptr; // call the DomainComponent class method THIS IS VERY IMPORTANT this->DomainComponent::setDomain(theDomain); // ensure connected nodes have correct number of dof\u2019s int dofNd1 = end1Ptr->getNumberDOF(); int dofNd2 = end2Ptr->getNumberDOF(); if ((dofNd1 != 2) || (dofNd2 != 2)) { opserr << \u201cTruss2D::setDomain(): 2 dof required at nodes\u201d; return; } // now determine the length & transformation matrix const Vector &end1Crd = end1Ptr->getCrds(); const Vector &end2Crd = end2Ptr->getCrds(); double dx = end2Crd(0)-end1Crd(0); double dy = end2Crd(1)-end1Crd(1); L = sqrt(dx dx + dy dy); if (L == 0.0) { opserr << \u201cWARNING Truss2D::setDomain() - Truss2D\u201d << this->getTag() << \u201d has zero length\u201c; return; // don\u2019t go any further - otherwise divide by 0 error } double cs = dx/L; double sn = dy/L; trans(0,0) = -cs; trans(0,1) = -sn; trans(0,2) = cs; trans(0,3) = sn; } </source> Methods Dealing With Nodes Next comes 4 rather simple methods that return basic information about the elements nodes. These are one line methods that should not need any explanation! <source lang=\u201ccpp\u201d> int Truss2D::getNumExternalNodes(void) const { return 2; } const ID & Truss2D::getExternalNodes(void) { return externalNodes; } Node ** Truss2D::getNodePtrs(void) { return theNodes; } int Truss2D::getNumDOF(void) { return 4; } </source> Methods Dealing With Current State <source lang=\u201ccpp\u201d> int Truss2D::commitState() { return theMaterial->commitState(); } int Truss2D::revertToLastCommit() { return theMaterial->revertToLastCommit(); } int Truss2D::revertToStart() { return theMaterial->revertToStart(); } int Truss2D::update() { // determine the current strain given trial displacements at nodes double strain = this->computeCurrentStrain(); // set the strain in the materials theMaterial->setTrialStrain(strain); return 0; } </source> Methods To Return Tangent Matrix In both methods, we obtain the appropriate tangent from the material and use this to return the transformed matrix. <source lang=\u201ccpp\u201d> const Matrix & Truss2D::getTangentStiff(void) { if (L == 0.0) { // length = zero - problem in setDomain() warning message already printed trussK.Zero(); return trussK; } // get the current E from the material for the last updated strain double E = theMaterial->getTangent(); // form the tangent stiffness matrix trussK = trans^trans; trussK = A E/L; // return the matrix return trussK; } const Matrix & Truss2D::getInitialStiff(void) { if (L == 0.0) { // length = zero - problem in setDomain() warning message already printed trussK.Zero(); return trussK; } // get the current E from the material for the last updated strain double E = theMaterial->getInitialTangent(); // form the tangent stiffness matrix trussK = trans^trans; trussK = A E/L; // return the matrix return trussK; } </source> Methods To Return Resisting Force In this method we obtain the stress from the material and use this to return the transformed force vector. <source lang=\u201ccpp\u201d> const Vector & Truss2D::getResistingForce() { if (L == 0.0) { // if length == 0, problem in setDomain() trussR.Zero(); return trussR; } // want: R = Ku - Pext // force = F * transformation double force = A theMaterial->getStress(); for (int i=0; i<4; i++) trussR(i) = trans(0,i) force; return trussR; } </source> Methods Dealing With Output Information is obtained by the user when the print command is invoked by the user and also when the user issues the recorder command. When the print command is invoked the Print method is invoked. This method simply prints information about the element, and then asks the material to do likewise. <source lang=\u201ccpp\u201d> void Truss2D::Print(OPS_Stream &s, int flag) { s << \u201cElement:\u201d << this->getTag(); s << \u201d type: Truss2D iNode: \u201d << externalNodes(0); s << \u201d jNode: \u201d << externalNodes(1); s << \u201d Area: \u201d << A; s << \u201d aterial: \u201d << *theMaterial; } </source> There are two methods used by the element recorders. The first method, setResponse(), is called when the recorder is created. The element informs the recorder that it can respond to a request of that type, if it cannot respond to the request it returns a 0, otherwise it returns an Response object. The response object includes a pointer to the element, an integer flag used to id the response when the getResponse() method is called, and a Vector detailing the size of the response. The second method, getReponse(), is called by the recorder when it is actually recording the information. <source lang=\u201ccpp\u201d> Response * Truss2D::setResponse(const char **argv, int argc, OPS_Stream &output) { Response *theResponse = 0; output.tag(\u201cElementOutput\u201d); output.attr(\u201celeType\u201d,this->getClassType()); output.attr(\u201celeTag\u201d,this->getTag()); int numNodes = this->getNumExternalNodes(); const ID &nodes = this->getExternalNodes(); static char nodeData[32]; for (int i=0; i<numNodes; i++) { sprintf(nodeData,\u201cnode%d\u201d,i+1); output.attr(nodeData,nodes(i)); } if (strcmp(argv[0],\u201cforce\u201d) == 0 || strcmp(argv[0],\u201cforces\u201d) == 0 || strcmp(argv[0],\u201cglobalForce\u201d) == 0 || strcmp(argv[0],\u201cglobalForces\u201d) == 0) { const Vector &force = this->getResistingForce(); int size = force.Size(); for (int i=0; i<size; i++) { sprintf(nodeData,\u201cP%d\u201d,i+1); output.tag(\u201cResponseType\u201d,nodeData); } theResponse = new ElementResponse(this, 1, this->getResistingForce()); } else if (strcmp(argv[0],\u201cdampingForce\u201d) == 0 || strcmp(argv[0],\u201cdampingForces\u201d) == 0) { const Vector &force = this->getResistingForce(); int size = force.Size(); for (int i=0; i<size; i++) { sprintf(nodeData,\u201cP%d\u201d,i+1); output.tag(\u201cResponseType\u201d,nodeData); } theResponse = new ElementResponse(this, 2, this->getResistingForce()); } else if (strcmp(argv[0],\u201caxialForce\u201d) ==0) return new ElementResponse(this, 3, 0.0); output.endTag(); return theResponse; } int Truss2D::getResponse(int responseID, Information &eleInfo) { double strain; switch (responseID) { case -1: return -1; case 1: // global forces return eleInfo.setVector(this->getResistingForce()); case 2: return eleInfo.setVector(this->getRayleighDampingForces()); case 3: theMaterial->setTrialStrain(strain); return eleInfo.setDouble(A * theMaterial->getStress()); default: return 0; } } </source> Methods Dealing With Databases/Parallel Processing There are two methods provided which are required is the user uses to use the database or parallel procesing features of the OpenSees applications. If neither are to be used, the developer need simply return a negative value in both methods. The idea is that the element must pack up it\u2019s information using Vector and ID objects and send it off to a Channel object. On the flip side, the receiving blank element must receive the same Vector and ID data, unpack it and set the variables. <source lang=\u201ccpp\u201d> int Truss2D::sendSelf(int commitTag, Channel &theChannel) { int res; // note: we don\u2019t check for dataTag == 0 for Element // objects as that is taken care of in a commit by the Domain // object - don\u2019t want to have to do the check if sending data int dataTag = this->getDbTag(); // Truss2D packs it\u2019s data into a Vector and sends this to theChannel // along with it\u2019s dbTag and the commitTag passed in the arguments Vector data(5); data(0) = this->getTag(); data(1) = A; data(2) = theMaterial->getClassTag(); int matDbTag = theMaterial->getDbTag(); // NOTE: we do have to ensure that the material has a database // tag if we are sending to a database channel. if (matDbTag == 0) { matDbTag = theChannel.getDbTag(); if (matDbTag != 0) theMaterial->setDbTag(matDbTag); } data(3) = matDbTag; res = theChannel.sendVector(dataTag, commitTag, data); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send Vector\u201d; return -1; } // Truss2D then sends the tags of it\u2019s two end nodes res = theChannel.sendID(dataTag, commitTag, externalNodes); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send ID\u201d; return -2; } // finally Truss2D asks it\u2019s material object to send itself res = theMaterial->sendSelf(commitTag, theChannel); if (res < 0) { opserr << \u201cWARNING Truss2D::sendSelf() - failed to send the Material\u201d; return -3; } return 0; } int Truss2D::recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { int res; int dataTag = this->getDbTag(); // Truss2D creates a Vector, receives the Vector and then sets the // internal data with the data in the Vector Vector data(5); res = theChannel.recvVector(dataTag, commitTag, data); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive Vector\u201d; return -1; } this->setTag((int)data(0)); A = data(1); // Truss2D now receives the tags of it\u2019s two external nodes res = theChannel.recvID(dataTag, commitTag, externalNodes); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive ID\u201d; return -2; } // we create a material object of the correct type, // sets its database tag and asks this new object to recveive itself. int matClass = data(2); int matDb = data(3); theMaterial = theBroker.getNewUniaxialMaterial(matClass); if (theMaterial == 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to create a Material\u201d; return -3; } // we set the dbTag before we receive the material - this is important theMaterial->setDbTag(matDb); res = theMaterial->recvSelf(commitTag, theChannel, theBroker); if (res < 0) { opserr << \u201cWARNING Truss2D::recvSelf() - failed to receive the Material\u201d; return -3; } return 0; }","title":"Add a New Element C++\n"},{"location":"developer/extending/13-Add%20a%20New%20Element%20Fortran/","text":"Add a New Element Fortran to be completed To add a new Element module using the Fortran language, the developer must provide a new Fortran routine for the Element. Some information about the state of the model is passed as arguments to the element methods. The input arguments are: the element object, eleObj the model state, modl the isw switch, isw , which indicates what action is needed for each invocation of the procedure. The output arguments are: the tangent stiffness matrix, tang the residual vector, resid the error code, error The name of the routine is important for the OpenSees interpreter: when it encounters a new element type it will look for a library with the same name of the element. NOTE: This document assumes the reader is familiar with the Fortran programming language. Element Routine It should be noted the command contains all underscores. This is a consequence of the Fortran compiler, which for the compiler used output the procedure is in all lower case. Please note that before calling memory allocated for the pointers the Fortran code must make a call to the Fortran routine c f pointer(). Example - Truss2D In the following section we will provide all necessary code to add a new 2d planar truss element into an OpenSees interpreter. The stress-strain relationship will be provided by a UniaxialMaterial object. Please refer to the comments inserted in the code for further explanations. Please note that the following example has been corrected and expanded by the author of this page. The following code may not match the actual version in the OpenSees repository. <source lang=\u201cfortran\u201d> SUBROUTINE trussf(eleObj,modl,tang,resid,isw,error) !DEC$ IF DEFINED (_DLL) !DEC$ ATTRIBUTES DLLEXPORT :: TRUSSF !DEC$ END IF use elementTypes use elementAPI implicit none type(eleObject)::eleObj type(modelState)::modl double precision tang(4, *) double precision resid(4) integer::isw; integer::error; integer :: tag, nd1, nd2, matTag, numCrd, i, j, numDOF real *8, pointer::theParam(:) integer, pointer::theNodes(:) double precision A, dx, dy, L, cs, sn double precision dLength, force, k integer :: iData(3); integer :: matTags(2); type(c_ptr) :: theCMatPtr type(c_ptr), pointer :: theCMatPtrPtr(:) type(matObject), pointer :: theMat double precision dData(1), nd1Crd(2), nd2Crd(2) double precision d1(2), d2(2), tran(4) double precision strs(1), strn(1), tng(1) integer numData, err, matType </source> The main IF/THEN structure of the routine begins here; it is needed to select the proper code depending on what the flag isw is requesting. <source lang=\u201cfortran\u201d> IF (isw.eq.ISW_INIT) THEN c get the input data - tag? nd1? nd2? A? matTag? numData = 3 err = OPS_GetIntInput(numData, iData) tag = iData(1); nd1 = iData(2); nd2 = iData(3); numData = 1 err = OPS_GetDoubleInput(numData, dData) A = dData(1); numData = 1 err = OPS_GetIntInput(numData, iData) matTag = iData(1); c Allocate the element state eleObj%tag = tag eleObj%nnode = 2 eleObj%ndof = 4 eleObj%nparam = 4 eleObj%nstate = 0 eleObj%nmat = 1 matTags(1) = matTag; matType = OPS_UNIAXIAL_MATERIAL_TYPE; err = OPS_AllocateElement(eleObj, matTags, matType) c Initialize the element properties call c_f_pointer(eleObj%param, theParam, [4]); call c_f_pointer(eleObj%node, theNodes, [2]); numCrd = 2; err = OPS_GetNodeCrd(nd1, numCrd, nd1Crd); err = OPS_GetNodeCrd(nd2, numCrd, nd2Crd); dx = nd2Crd(1)-nd1Crd(1); dy = nd2Crd(2)-nd1Crd(2); L = sqrt(dx dx + dy dy); if (L == 0.0) then c OPS_Error(\u201cWarning - truss element has zero length\u201d, 1); return; end if cs = dx/L; sn = dy/L; theParam(1) = A; theParam(2) = L; theParam(3) = cs; theParam(4) = sn; theNodes(1) = nd1; theNodes(2) = nd2; ELSE IF (isw == ISW_COMMIT) THEN </source> In ISW_COMMIT, the state of the model is saved. If your element uses state variables, save them here. <source lang=\u201cfortran\u201d> call c_f_pointer(eleObj%mats, theCMatPtrPtr, [1]); theCMatPtr = theCMatPtrPtr(1); j=OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) ELSE IF (isw == ISW_REVERT_TO_START) THEN call c_f_pointer(eleObj%mats, theCMatPtrPtr, [1]); theCMatPtr = theCMatPtrPtr(1); j=OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) ELSE IF (isw == ISW_FORM_MASS) THEN </source> In ISW_FORM_MASS, the mass matrix (if given by the element) must be returned in TANG. IMPORTANT: if your element returns no mass, remember to initialize TANG to zero! If not initialized, Fortran will return a mass matrix with random values. Also, do not overwrite RESID! <source lang=\u201cfortran\u201d> ELSE IF (isw == ISW_FORM_TANG_AND_RESID) THEN </source> In ISW_FORM_TANG_AND_RESID, all the trials during a non-linear analysis are performed. DO NOT save state variables here. <source lang=\u201cfortran\u201d> call c_f_pointer(eleObj%param, theParam, [4]); call c_f_pointer(eleObj%node, theNodes, [2]); call c_f_pointer(eleObj%mats, theCMatPtrPtr, [1]); theCMatPtr = theCMatPtrPtr(1); A = theParam(1); L = theParam(2); cs = theParam(3); sn = theParam(4); nd1 = theNodes(1); nd2 = theNodes(2); numDOF = 2; err = OPS_GetNodeDisp(nd1, numDOF, d1); err = OPS_GetNodeDisp(nd2, numDOF, d2); tran(1) = -cs; tran(2) = -sn; tran(3) = cs; tran(4) = sn; dLength = 0.0; do i = 1,2 dLength = dLength - (d2(i)-d1(i)) * tran(i); continue strn(1) = dLength/L; c i = 0 c i=OPS_InvokeMaterial(eleObj, i, modl, strn, strs, tng, isw) j=OPS_InvokeMaterialDirectly(theCMatPtr, modl, strn, strs, + tng, isw) force = A strs(1); k = A tng(1)/L; do i =1,4 resid(i) = force * tran(i); do j = 1,4 tang(i,j) = k tran(i) tran(j); continue continue END IF END IF c return error code error = 0 END SUBROUTINE trussf </source> Compilation Instructions for Visual Studio on Windows The compilation can be carried out with Visual Studio, if Windows machines are used. Intel Visual Fortran can be used, it integrates itself with Visual Studio IDE during installation.","title":"Add a New Element Fortran\n"},{"location":"developer/extending/14-Add%20a%20New%20UniaxialMaterial%20C%2B%2B/","text":"Add a New UniaxialMaterial C++ To add a new Uniaxial Material module using the C++ language, the developer must: provide a new C++ subclass of the UniaxialMaterial class provide an interface function that will be used to parse the input and create the new material. Unlike the C and Fortran modules, no information about the state of the model is passed as arguments to the material methods. It is the responsibility of the material to okeep whatever information it needs. This information will include both parameters (information needed to define the material) and state variables or history variables (information needed by the material to remember it\u2019s current state for the computation of the stress and tangent) NOTE: This document assumes the reader is familiar with the C++ programming language. UniaxialMaterial Class The Uniaxial class itself is an abstract base class. It inherits from both the Material class, which is itself a subclass of TaggedObject class and the MovableObject class. The class has a large number of methods defined in the interface, not all these methods need to be included in a new UniaxialMaterial class. The following is the minimal interface that should be considered: The UniaxialMaterial Class: <source lang=\u201ccpp\u201d> ifndef ElasticPPcpp_h define ElasticPPcpp_h // Written: fmk // // Description: This file contains the class definition for // ElasticPPcpp. ElasticPPcpp provides the abstraction // of an elastic perfectly plastic uniaxial material, // // What: \u201c@(#) ElasticPPcpp.h, revA\u201d include <UniaxialMaterial.h> class UniaxialMaterial : public Material { public: UniaxialMaterial (int tag, int classTag); virtual ~UniaxialMaterial(); virtual int setTrialStrain (double strain, double strainRate =0) =0; virtual double getStrain (void) = 0; virtual double getStrainRate (void); virtual double getStress (void) = 0; virtual double getTangent (void) = 0; virtual double getInitialTangent (void) = 0; virtual int commitState (void) = 0; virtual int revertToLastCommit (void) = 0; virtual int revertToStart (void) = 0; virtual UniaxialMaterial *getCopy (void) = 0; virtual Response *setResponse (const char **argv, int argc, OPS_Stream &theOutputStream); virtual int getResponse (int responseID, Information &matInformation); virtual int sendSelf(int commitTag, Channel &theChannel); virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); virtual void Print(OPS_Stream &s, int flag =0); protected: private: } </source> The methods with =0; are methods that you must implement for the class to link successfully with OpenSees. The other classes are optional. The setTriaStrain() is the method called by an element when a new strain in the material is to be set. Subsequent calls to getTangent() and getStress() are to return thecorresponding tangent and stress values for that stress. setTrialStrain() is invoked as the solution algorithm tries a number of trial solution steps as it goes from one commited solution to the next on the solution path. The commitState() method is invoked when a trial solution has been determined to be on the solution path. It is the responsibility of the material to be able to back track to that solution if a revertToLastCOmmit() is invoked. This will happen if the algorithm fails to find a solution on the solution path. The getCopy() method is invoked by an element in the elements constructor. The material is to return a unique copy of itself to the element. This way different elements can use the same material type with the same properties, with each element having it\u2019s own unique copy. The setResponse()/getResponse() typically do not have to be provided. These are the methods called by a recorder after a commit(). If you are appy with the existing responses fro a UniaxialMaterial which responds to \u201cstress\u201d, \u201cstrain\u201d, \u201ctangent\u201d, \u201cstressANDstrain\u201d you do not have to implement these methods. The example below shows them just for those ew who want additional info out of their materials. The sendSelf()/recvSelf() methods are used in parallel processing with OpenSeesSP and when using the database command. If you don\u2019t envision using the material in these situations you can again ignore these methods. Again I am only showing them in the code for those even fewer who would do this. The commit() method is what is called Example - ElasticPPecpp In the following section we will provide all necessary code to add a new elastic perfectly plastic material into an OpenSees interpreter. Header The header for thew new class, which we will call Truss2D is as follows: <source lang=\u201ccpp\u201d> ifndef ElasticPPcpp_h define ElasticPPcpp_h include <UniaxialMaterial.h> class ElasticPPcpp : public UniaxialMaterial { public: ElasticPPcpp(int tag, double E, double eyp); ElasticPPcpp(); ~ElasticPPcpp(); int setTrialStrain(double strain, double strainRate = 0.0); double getStrain(void); double getStress(void); double getTangent(void); double getInitialTangent(void) {return E;}; int commitState(void); int revertToLastCommit(void); int revertToStart(void); UniaxialMaterial *getCopy(void); int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); void Print(OPS_Stream &s, int flag =0); protected: private: double fyp, fyn; // positive and negative yield stress double ezero; // initial strain double E; // elastic modulus double ep; // plastic strain at last commit double trialStrain; // trial strain double trialStress; // current trial stress double trialTangent; // current trial tangent double commitStrain; // last commited strain double commitStress; // last commited stress double commitTangent; // last committed tangent </source> The header file defines the interface and variables for the class ElasticPPcpp. It defines the new class to be a sublass of the UniaxialMaterial class. In the public interface, are two constructors and a destructor in addition to minimal set of methods we showed for the UniaxialMaterial class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we define a number of private variables and a number of variables. Some of these are parameter variable which do not change with each commit, e.g. E, and some state variable which do change, e.g. ep, fyp, and fyn. Implementation It another file, ElasticPPcpp.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_ElasticPPcpp() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. <source lang=\u201ccpp\u201d> include \u201cElasticPPcpp.h\u201d include <elementAPI.h> include <Vector.h> include <Channel.h> include <math.h> include <float.h> </source> Static Variables Next, we initialize the static variables. For this example we are using 1 static-variables to keep track of the number of times the external procedure to parse and create such an object is called. <source lang=\u201ccpp\u201d> static int numElasticPPcpp = 0; </source> Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0 if you use pointers in your class. We will use none here. The first constructor is the one most typically used. The arguments provide the materials tag, youngs modulus and initial yield point strain values. material. The code in the constructor simply computes the positive and negative yield stress based on the input provided. <source lang=\u201ccpp\u201d> ElasticPPcpp::ElasticPPcpp(int tag, double e, double eyp) UniaxialMaterial(tag, 0), ezero(0.0), E(e), ep(0.0), trialStrain(0.0), trialStress(0.0), trialTangent(E), commitStrain(0.0), commitStress(0.0), commitTangent(E) { fyp = E*eyp; fyn = -fyp; } </source> The second constructor is called when paralell processing or the database feature of the OpenSees application is used. It\u2019s purpose is to create a blank TElasticPPcpp object, that will be filled in when the recvSelf() method is invoked on the object. <source lang=\u201ccpp\u201d> ElasticPPcpp::ElasticPPcpp() UniaxialMaterial(0, 0), fyp(0.0), fyn(0.0), ezero(0.0), E(0.0), ep(0.0), trialStrain(0.0), trialStress(0.0), trialTangent(E), commitStrain(0.0), commitStress(0.0), commitTangent(E) { } </source> Destructor The we provide the destructor. In the destructor all memory that the the object created or was passed to it in the constructor must be destroyed. For this example we have no such memory. We could have left the destructor out entirely. Hoowever, it is good practice to leave it in your source code. <source lang=\u201ccpp\u201d> ElasticPPcpp::~ElasticPPcpp() { // does nothing } </source> getCopy() Method This is the method called by each element or section to get unique copies of a material. <source lang=\u201ccpp\u201d> UniaxialMaterial ElasticPPcpp::getCopy(void) { ElasticPPcpp theCopy = new ElasticPPcpp(this->getTag(),E,fyp/E); theCopy->ep = this->ep; return theCopy; } </source> setTrialStrain() Method This, as mentioned, is the method called when the element has computed a nw strain for the element. The element will make subsequent calls to getStress() and getTangent() to obtain new values of these for the new strain. This is typically the most complicated method to write and to determine the theory for before you even write the code. ALl subsequent methods are trivial. <source lang=\u201ccpp\u201d> int ElasticPPcpp::setTrialStrain(double strain, double strainRate) { if (fabs(trialStrain - strain) < DBL_EPSILON) return 0; trialStrain = strain; double sigtrial; // trial stress double f; // yield function // compute trial stress sigtrial = E * ( trialStrain - ezero - ep ); //sigtrial = E * trialStrain; //sigtrial -= E * ezero; //sigtrial -= E * ep; // evaluate yield function if ( sigtrial >= 0.0 ) f = sigtrial - fyp; else f = -sigtrial + fyn; double fYieldSurface = - E * DBL_EPSILON; if ( f <= fYieldSurface ) { // elastic trialStress = sigtrial; trialTangent = E; } else { // plastic if ( sigtrial > 0.0 ) { trialStress = fyp; } else { trialStress = fyn; } trialTangent = 0.0; } return 0; } </source> Trivial Methods Next comes 3 rather simple methods that return basic information computed in the setTrialStrain(). You do of course have the option to ignore the setTrialStrain() method and compute the stress and tangent quantities again in the interests of saving memory. <source lang=\u201ccpp\u201d> double ElasticPPcpp::getStrain(void) { return trialStrain; } double ElasticPPcpp::getStress(void) { return trialStress; } double ElasticPPcpp::getTangent(void) { return trialTangent; } </source> Methods Dealing With Current State As mentioned, when the algorithm finds a solution state as it goes from one converged solution to the next. As it attempts to find these solutions it goes through a number of trial steps (each setTrialStrain() is invoked in each of these steps). Once it finds a trial step that is on the solution path it will stop and invoke commitState() on the material. Any state variables that the material uses needs to be updated at this time. Should the algorithm fail to find a solution it may return to the last converged step or indeed the start. You the developer must provide code so that your mateial can indeed go back to these states and report correct getTangent() and getStress() values for subsequent analysis atte,pts. <source lang=\u201ccpp\u201d> int ElasticPPcpp::commitState(void) { double sigtrial; // trial stress double f; // yield function // compute trial stress sigtrial = E * ( trialStrain - ezero - ep ); // evaluate yield function if ( sigtrial >= 0.0 ) f = sigtrial - fyp; else f = -sigtrial + fyn; double fYieldSurface = - E * DBL_EPSILON; if ( f > fYieldSurface ) { // plastic if ( sigtrial > 0.0 ) { ep += f / E; } else { ep -= f / E; } } commitStrain = trialStrain; commitTangent=trialTangent; commitStress = trialStress; return 0; } int ElasticPPcpp::revertToLastCommit(void) { trialStrain = commitStrain; trialTangent = commitTangent; trialStress = commitStress; return 0; } int ElasticPPcpp::revertToStart(void) { trialStrain = commitStrain = 0.0; trialTangent = commitTangent = E; trialStress = commitStress = 0.0; ep = 0.0; return 0; } </source> Methods Dealing With Output Information is obtained by the user when the print command is invoked by the user and also when the user issues the recorder command. When the print command is invoked the Print method is invoked. This method simply prints information about the element, and then asks the material to do likewise. <source lang=\u201ccpp\u201d> void ElasticPPcpp::Print(OPS_Stream &s, int flag) { s << \u201cElasticPPcpp tag:\u201d << this->getTag() << endln; s << \u201d E: \u201d << E << endln; s << \u201d ep: \u201d << ep << endln; s << \u201d stress: \u201d << trialStress << \u201d tangent: \u201d << trialTangent << endln; } </source> There are two methods used by the element recorders. The first method, setResponse(), is called when the recorder is created. The element informs the recorder that it can respond to a request of that type, if it cannot respond to the request it returns a 0, otherwise it returns an Response object. The response object includes a pointer to the element, an integer flag used to id the response when the getResponse() method is called, and a Vector detailing the size of the response. The second method, getReponse(), is called by the recorder when it is actually recording the information. <source lang=\u201ccpp\u201d> </source> Methods Dealing With Databases/Parallel Processing There are two methods provided which are required is the user uses to use the database or parallel procesing features of the OpenSees applications. If neither are to be used, the developer need simply return a negative value in both methods. The idea is that the material must pack up it\u2019s information using Vector and ID objects and send it off to a Channel object. On the flip side, the receiving blank element must receive the same Vector and ID data, unpack it and set the variables. <source lang=\u201ccpp\u201d> int ElasticPPcpp::sendSelf(int cTag, Channel &theChannel) { int res = 0; static Vector data(9); data(0) = this->getTag(); data(1) = ep; data(2) = E; data(3) = ezero; data(4) = fyp; data(5) = fyn; data(6) = commitStrain; data(7) = commitStress; data(8) = commitTangent; res = theChannel.sendVector(this->getDbTag(), cTag, data); if (res < 0) opserr << \u201cElasticPPcpp::sendSelf() - failed to send data\u201d; return res; } int ElasticPPcpp::recvSelf(int cTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { int res = 0; static Vector data(9); res = theChannel.recvVector(this->getDbTag(), cTag, data); if (res < 0) opserr << \u201cElasticPPcpp::recvSelf() - failed to recv data\u201d; else { this->setTag(data(0)); ep = data(1); E = data(2); ezero = data(3); fyp = data(4); fyn = data(5); commitStrain=data(6); commitStress=data(7); commitTangent=data(8); trialStrain = commitStrain; trialTangent = commitTangent; trialStress = commitStress; } return res; } </source> External Procedure This is the all importat extenal procedure that the interpreter will parse when it comes accross your element on the command line. You need to parse the command line, create a material using the command line arguments you parsed and then return this material. The name of the procedure must be OPS_YourClassName (no exceptions). If this procedure is missing or the name is incorrect, your material will fail to load. NOTE: parsing the command line is easy with some other procedures that are defined in the elementAPI.h file. In the example we show how to get integer and double values from the command line. Other options such as character strings and obtaining the number of input arguments are also available. The #ifdef stuff at the start is required for different operating systems. <source lang=\u201ccpp\u201d> ifdef _USRDLL define OPS_Export extern \u201cC\u201d _declspec(dllexport) elif _MACOSX define OPS_Export extern \u201cC\u201d attribute ((visibility(\u201cdefault\u201d))) else define OPS_Export extern \u201cC\u201d endif OPS_Export void * OPS_ElasticPPcpp() { // print out some KUDO\u2019s if (numElasticPPcpp == 0) { opserr << \u201cElasticPPcpp unaxial material - Written by fmk UC Berkeley Copyright 2008 - Use at your Own Peril\u201d; numElasticPPcpp =1; } // Pointer to a uniaxial material that will be returned UniaxialMaterial *theMaterial = 0; // // parse the input line for the material parameters // int iData[1]; double dData[2]; int numData; numData = 1; if (OPS_GetIntInput(&numData, iData) != 0) { opserr << \u201cWARNING invalid uniaxialMaterial ElasticPP tag\u201d << endln; return 0; } numData = 2; if (OPS_GetDoubleInput(&numData, dData) != 0) { opserr << \u201cWARNING invalid E & ep\u201d; return 0; } // // create a new material // theMaterial = new ElasticPPcpp(iData[0], dData[0], dData[1]); if (theMaterial == 0) { opserr << \u201cWARNING could not create uniaxialMaterial of type ElasticPPCpp\u201d; return 0; } // return the material return theMaterial; } </source>","title":"Add a New UniaxialMaterial C++\n"},{"location":"developer/extending/FeapElement/","text":"Feap Elements Introduction In this document we will look at the C++ code that is required to introduce a new Truss element, fElmt02, into g3. The new class will call a fortran element subroutine elmt02(), which implements a linear elastic truss element using the FEAP (http://www.ce.berkeley.edu/rlt/feap) element interface. To introduce the new class into g3, two new files are created, fElmt02.h and fElmt02.cpp , to define the class interface and implementation. In addition, two existing files are modified, TclPlaneTruss.cpp and FEM_ObjectBroker.cpp . The new files are outlined in the following subsections. The changes to the two existing files are similar to those outlined in \u2018How to Introduce a New Element into g3\u2019. It should be noted that some additional work may be required by the authors to get other feap element subroutines into g3. This is a consequence of the information the element routines are obtaining from the common blocks. The files outlined in this document can be found in the SRC/element/feap directory of the software distribution. fElmt02.h The file fElmt02.h defines the class interface and details information about the instance variables associated with the objects of type fElmt02 . The interface first declares that the fElmt02 class inherits from the fElement class. class fElmt02 : public fElement { The fElement class is an abstract class which has been provided to hide most of the details of interfacing FEAP element subroutines with g3. It is the fElement class which is responsible for invoking the FEAP subroutine with the appropriate arguments and for managing the data (property and history data) associated with each element. Each new subclass of fElement is responsible for providing the fElement class with information about the element identifier, element end nodes, size of property data, and size of history data associated with the element. The fElmt02 interface then defines three constructors and a destructor. The first two constructors can be used by the analyst to construct the fElmt05 objects. The arguments passed to these constructors include the elements id and the id\u2019s of the two end nodes. In addition to these, the first constructor takes the elements cross sectional area, youngs modulus, and an optional mass density. If no mass density is specified \\(0\\) is assumed. This information is not passed in the second constructor. Instead it is obtained by calling the fortran element subroutine with the isw switch set to \\(1\\) . The third constructor is used in parallel and database programming. The destructor is the method called when the object is being destroyed. It is called so that memory associated with the object is returned to the system. public : // constructors fElmt02 ( int tag , int Nd1 , int Nd2 , double A , double E , double M = 0.0 ); fElmt02 ( int tag , int Nd1 , int Nd2 , int iow ); fElmt02 (); // destructor ~ fElmt02 (); // not actually needed There are no public or protected members defined for this class and no class or instance variables associated with objects of this class. The parent class fElement defines the methods and instance variables. fElmt02.cpp The fElmt02.cpp file contains the implementation. This file contains the implementation of the three constructors and the destructor defined in the interface. The first constructor takes as arguments the objects identifier, the identifiers of the two end nodes, the objects area, youngs modulus and mass density. The constructor first invokes the fElement constructor with the objects identifier, a class identifier, the integer value \\(2\\) indicating that the FEAP subroutine elmt02() is to be invoked, the integer \\(3\\) indicating the number of element properties associated with the subroutine (i.e. size of d), the integer \\(2\\) indicating two nodes are associated with the element, the integer \\(2\\) indicating the dimension of the mesh, the integer \\(2\\) indicating the number of degrees-of-freedom per node, and two integers \\(0\\) and \\(0\\) indicating the sizes of \\(nh1\\) and \\(nh3\\) are \\(0\\) for this FEAP element. The constructor then fills in the property Vector, data, and the ID, connectedNodes, with the appropriate information. Note that data and connectedNodes, which are pointers to the Vector and ID objects, are declared as protected variables in fElement class interface. This constructor basically does the work typically performed when the FEAP subroutine is invoked with isw switch set to \\(1\\) . fElmt02 :: fElmt02 ( int tag , int nd1 , int nd2 , double E , double A , double rho ) : fElement ( tag , ELE_TAG_fElmt02 , 2 , 3 , 2 , 0 , 0 ) { // fill in the property data - feap routine: d(1)=A,d(2)=E,d(3)=rho (* data )( 0 ) = A ; (* data )( 1 ) = E ; (* data )( 2 ) = rho ; // fill in the two end nodes - feap routine: ix(1)=nd1, ix(2)=nd2 (* connectedNodes )( 0 ) = nd1 ; (* connectedNodes )( 1 ) = nd2 ; } The second constructor takes as arguments the objects identifier, the identifiers of the two end nodes, and an integer indicating an output file where the element data will be written. The constructor first invokes the fElement constructor with the objects identifier, a class identifier, the integer value \\(2\\) indicating that the FEAP subroutine elmt02() is to be invoked, the integer \\(3\\) indicating the number of element properties associated with the subroutine (i.e. size of d), the integer \\(2\\) indicating two nodes are associated with the element, the integer \\(2\\) indicating the dimension of the mesh, the integer \\(2\\) indicating the number of degrees-of-freedom per node, and the integer iow. The fElement() constructor will in turn invoke the fortran element subroutine elmt02(), with the isw switch set to \\(1\\) , to read in the element data and set the sizes of \\(nh1\\) and \\(nh3\\) . Note that to use this constructor, the feap input routines pinput() and tinput() have to be overridden . After the base constructor has been called, the constructor then fills in the ID, connectedNodes, with the appropriate node information. fElmt02::fElmt02(int tag, int nd1, int nd2, int iow) :fElement(tag, ELE_TAG_fElmt02, 2, 3, 2, 2, 2, iow) { // fill in the two end nodes - feap routine: ix(1)=nd1, ix(2)=nd2 (*connectedNodes)(0) = nd1; (*connectedNodes)(1) = nd2; } The third constructor and the destructor are then provided. The second constructor, which is used by an FEM_ObjectBroker, simply invokes an fElement constructor with the classTag. Nothing more is required. The destructor does nothing (might even remove it?) fElmt02::fElmt02() :fElement(ELE_TAG_fElmt02) { // does nothing } fElmt02::~fElmt02() { // does nothing } Example The g3 interpreter can now be modified to include this new element. The modifications to allow the introduction of the new command fTruss eleId iNodeID jNodeId A E into g3 are similar to those outlined in \u2018How to Introduce a New Element into g3\u2019. The example g3tcl script for the static analysis of a simple linear three bar truss example, shown in figure [example1] , is given below: Tcl script #create the ModelBuilder object model Tcl2dTruss # build the model # add nodes - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # add the fElmt02 elements - command: fTruss eleID node1 node2 A E fTruss 1 1 4 10.0 3000 fTruss 2 2 4 5.0 3000 fTruss 3 3 4 5.0 3000 # set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 # apply the load - command: load nodeID xForce yForce load 4 100 -50 # build the components for the analysis object system BandSPD constraints Plain integrator LoadControl 1 algorithm Linear numberer RCM # create the analysis object analysis Static 1 # perform the analysis analyze # print the results at node 4 and at all elements print node 4 print ele Input script for FEAP Feap ** example 1 4,3,2,2,2,2 coordinates 1 0 0.0 0.0 2 0 144.0 0.0 3 0 168.0 0.0 4 0 72.0 96.0 elements 1 0 1 1 4 2 0 2 2 4 3 0 2 3 4 boundary restraints 1 0 1 1 2 0 1 1 3 0 1 1 forces 4 0 100.0 -50.0 mate,1 user,2 10,3000,0 mate,2 user,2 5,3000,0 end batch tang,,1 disp,,4 stre,all end interactive stop When g3 is run and the commands outlined above are input by the analyst at the interpreter prompt, or are sourced in from a file, the following output is generated: Node: 4 Coordinates : 72 96 commitDisps: 0.530093 -0.177894 unbalanced Load: 100 -50 Element: 1 type: elmt02 iNode: 1 jNode: 4 Area: .100E+02 Youngs Modulus: .300E+04 Rho: .000E+00 strain: 0.14645E-02 axial force: 0.43935E+02 Element: 2 type: elmt02 iNode: 2 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.38364E-02 axial force: -0.57546E+02 Element: 3 type: elmt02 iNode: 3 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.36874E-02 axial force: -0.55311E+02 The following can be found at the end of the FEAP output file: Feap ** example 1 N o d a l D i s p l a c e m e n t s Time 0.00000E+00 Prop. Ld. 1.00000E+00 Node 1 Coord 2 Coord 1 Displ 2 Displ 4 7.2000E+01 9.6000E+01 5.3009E-01 -1.7789E-01 *Macro 3 * stre all v: 0.00 0.00 0.00 t= 0.07 0.05 Element: 1 type: elmt02 iNode: 1 jNode: 4 Area: .100E+02 Youngs Modulus: .300E+04 Rho: .000E+00 strain: 0.14645E-02 axial force: 0.43935E+02 Element: 2 type: elmt02 iNode: 2 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.38364E-02 axial force: -0.57546E+02 Element: 3 type: elmt02 iNode: 3 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.36874E-02 axial force: -0.55311E+02 How to Introduce a FEAP Element into g3 Version 0.1 - Preliminary Draft December 20, 1999 Frank McKenna and Gregory L. Fenves PEER, University of California at Berkeley","title":"Feap Elements\n"},{"location":"developer/extending/NewElement/","text":"New Elements Introduction This document is intended to demonstrate the steps necessary to introduce a new element into the OpenSees interpreter. OpenSees is an object-oriented framework under construction for finite element analysis. A key feature of OpenSees is the interchangeably of components and the ability to integrate existing libraries and new components into the framework (not just new element classes) without the need to change the existing code. Core components, that is the abstract base classes, define the minimal interface (minimal to make adding new component classes easier but large enough to ensure all that is required can be accommodated). The OpenSees interpreter is an extension of the Tcl scripting language. Tcl is a string based procedural command language which allows substitution, loops, mathematical expressions, and procedures. The OpenSees interpreter adds commands to Tcl to allow users to create objects from the OpenSees framework and invoke methods on those objects once they have been created. Each of these commands is associated (bound) with a C++ procedure that is provided. It is this procedure that is called upon by the interpreter to parse the command. In this document we provide a simple example of a script that can be used with the OpenSees interpreter to analyze a simple model. We then outline the C++ code necessary to introduce a new element into the framework. In addition, we demonstrate what must be done in addition to use the element with the interpreter. Finally, we show the changes to the script that are needed to use this new element. Note, that all the code and example scripts mentioned in this document can be found in OpenSees/EXAMPLES/NewElement . A Simple Truss Example In this section the example script, example1.tcl, for the static analysis of the simple linear three bar truss example shown in figure [example1] is presented. For a more comprehensive set of examples showing the reader should is referred to the OpenSees examples manual, which can be found at http://opensees.berkeley.edu/OpenSees/OpenSeesExamples.pdf. In the script, the analyst first creates a ModelBuilder object. In this example a BasicBuilder object is created. The construction of this object adds new commands to the interpreter, i.e. node, material, element, fix and load. It is these commands which can be used by the analyst to construct the model. # create the ModelBuilder object model BasicBuilder -ndm 2 -ndf 2 The analyst then constructs the model. This is done by creating the four Node objects, a Material object, three Element objects, some Constraint objects, and finally a Load object. # build the model # node nodeId xLoc yLoc node 1 0 0 node 2 144 0 node 3 168 0 node 4 72 96 # material matId type <type args> uniaxialMaterial Elastic 1 3000 # element truss trussId iNodeId jNodeId Area matId element truss 1 1 4 10 1 element truss 2 2 4 5 1 element truss 3 3 4 5 1 # constraint nodeId xFix? yFix? fix 1 1 1 fix 2 1 1 fix 3 1 1 # pattern type patternID TimeSeries pattern Plain 1 Linear { # load nodeID xForce yForce load 4 100 -50 } After the model has been defined, the analyst then constructs the Analysis. This is done by first constructing the components of the Analysis object. In this example a BandSPD linear system of equation and a lapack solver (default for BandSPD), a ConstraintHandler object which deals with homogeneous single point constraints, an Integrator object of type LoadControl with a load step increment of one, an Algorithm object of type Linear, and a DOF_Numberer object of type RCM (reverse Cuthill-Mckee). Once these objects have been created, the StaticAnalysis object is constructed. # build the components for the analysis object system BandSPD constraints Plain integrator LoadControl 1 algorithm Linear numberer RCM # create the analysis object analysis Static After the Analysis object is constructed a Recorder object is created. In this example we create a NodeRecorder to record the load factor and the two nodal displacements at Node 4, the results are stored in the file example.out. # create a Recorder object for the nodal displacements at node 4 recorder Node example.out disp -load -nodes 4 -dof 1 2 Finally the analysis is performed and the results are printed. # perform the analysis analyze 1 # print the results at node 4 and at all elements print node 4 print ele playback 1 When OpenSees is run and the commands outlined above are input by the analyst at the interpreter prompt, or are sourced from a file using the source filename command, the following is output by the program. Node: 4 Coordinates : 72 96 commitDisps: 0.530093 -0.177894 unbalanced Load: 100 -50 Element: 1 type: Truss iNode: 1 jNode: 4 Area: 10 strain: 0.00146451 axial load: 43.9352 unbalanced load: 26.3611 35.1482 -26.3611 -35.1482 Material: ElasticMaterialModel: 1 E: 3000 Element: 2 type: Truss iNode: 2 jNode: 4 Area: 5 strain: -0.00383642 axial load: -57.5463 unbalanced load: 34.5278 -46.0371 -34.5278 46.0371 Material: ElasticMaterialModel: 1 E: 3000 Element: 3 type: Truss iNode: 3 jNode: 4 Area: 5 strain: -0.00368743 axial load: -55.3114 unbalanced load: 39.1111 -39.1111 -39.1111 39.1111 Material: ElasticMaterialModel: 1 E: 3000 1 0.530093 -0.177894 Introducing a New Element into OpenSees We will look at the C++ code that is required to introduce a new Truss element, MyTruss, into the framework and a new command myTruss into the interpreter. The new class will work in planar problems where each node has two degrees-of-freedom. The new type will be complicated by the fact that each instance will be associated with a UniaxialMaterial object, this is done to show what this entails for parallel and database processing. To introduce the new class into OpenSees three new files must be created, MyTruss.h and MyTruss.cpp, to define the class interface and implementation, and TclMyTrussCommand.cpp, to define the procedure to be invoked when the Tcl command myTruss is invoked. In addition two existing files must be modified, TclElementCommands.cpp, and FEM_ObjectBroker.C and FEM_ObjectBroker.C. The new files and modifications to existing files are outlined in the following subsections. All the files can be found in the OpenSees/EXAMPLES/ExampleNewElement directory. MyTruss.h The file MyTruss.h defines the class interface and details information about the instance variables associated with the objects of type MyTruss. The interface first declares that the MyTruss class inherits from the Element class. class MyTruss : public Element { The interface then defines two constructors and a destructor. The first constructor is used to construct each object by the analyst. The arguments passed include the elements id, the id\u2019s of the two end nodes, a reference to a Material object (a copy of which is created by the MyTruss object), and the Area of the bar. In addition the analyst may specify a mass per unit volume, if none is specified \\(0\\) is assumed. The second is used in parallel and database programming. The destructor is the method called when the object is being destroyed. It is called so that memory associated with the object is returned to the system. public : // constructors MyTruss ( int tag , int Nd1 , int Nd2 , UniaxialMaterial & theMat , double A , double rho = 0.0 ); MyTruss (); // destructor ~ MyTruss (); After the destructor comes the public member functions, these define the methods that all other objects in the program will be able to invoke on objects of type MyTruss. These methods are all inherited from the Element class and each subclass of Element must declare them. public: // public methods to obtain information about dof & connectivity int getNumExternalNodes(void) const; const ID &getExternalNodes(void); int getNumDOF(void); // public methods to set the state of the element void setDomain(Domain *theDomain); int commitState(void); int revertToLastCommit(void); int revertToStart(void); int update(void); // public methods to obtain stiffness, mass, damping and residual information const Matrix &getTangentStiff(void); const Matrix &getSecantStiff(void); const Matrix &getDamp(void); const Matrix &getMass(void); void zeroLoad(void); const Vector &getResistingForce(void); const Vector &getResistingForceIncInertia(void); // public methods for output int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); int displaySelf(Renderer &theViewer, int displayMode, float fact); void Print(OPS_Stream &s, int flag =0); Response *setResponse(char **argv, int argc, Information &eleInformation); int getResponse(int responseID, Information &eleInformation); Following the declaration of the public member functions comes the declaration of a private member function, computeStrain(), which can only be called by objects of type MyTruss. private : // private member function - only available to objects of the class double computeCurrentStrain ( void ) const ; After the private member function is defined all the private variables, data which can only be accessed by objects of this type. First the instance variables associated with each object of this class are defined. Each object of this type will store its length, area, mass per unit volume, a pointer to a UniaxialMaterial object, a pointer to each of it\u2019s end nodes, a pointer to a transformation matrix and an ID (integer array) object containing the node identifiers. private : // private attributes - a copy for each object of the class UniaxialMaterial * theMaterial ; // pointer to a material ID externalNodes ; // contains the id's of end nodes Matrix trans ; // hold the transformation matrix double L ; // length of MyTruss based on undeformed configuration double A ; // area of MyTruss double M ; // weight per unit volume Node * end1Ptr , * end2Ptr ; // two pointers to the trusses nodes. After the instance variable is defined some class variables. There is one instance of each of these variables shared by all objects of this class. The class variables comprise of a 3 matrices to return the stiffness, mass and damping matrices from the member functions and a vector to return the residual force. While the class variables could also be declared as instance variables, declaring them as class variables reduces the amount of memory required by each object of type MyTruss. private : // private class attributes - single copy for all objects of the class static Matrix trussK ; // class wide matrix for returning stiffness static Matrix trussD ; // class wide matrix for returning damping static Matrix trussM ; // class wide matrix for returning mass static Vector trussR ; // class wide vector for returning residual MyTruss.C The MyTruss.C file contains the implementation. The file first initializes the class variables defined in the MyTruss.h file. Here the three matrices are initialized to be of size 4*4 and the Vector of size 4. It should be noted that access to the data stored in these objects is done using the C indexing notation, which starts at 0. // initialize the class wide variables Matrix MyTruss :: trussK ( 4 , 4 ); Matrix MyTruss :: trussM ( 4 , 4 ); Matrix MyTruss :: trussD ( 4 , 4 ); Vector MyTruss :: trussR ( 4 ); After the initialization of the class variables, the constructors for the class are implemented. The first constructor takes as arguments the objects identifier, the identifiers of the two end nodes, a reference to the objects material and the objects area. The constructor initializes the instance variables with the appropriate values. In addition, the constructor makes a copy of the Material object; it is this copy that will be used by the MyTruss object. The second constructor, which takes no arguments, is used in parallel and database programming for constructing an empty object whose instance variables will be filled in by the object itself when recvSelf() is invoked on the object. MyTruss::MyTruss(int tag, int Nd1, int Nd2, UniaxialMaterial &theMat, double a, double rho) :Element(tag,ELE_TAG_MyTruss), externalNodes(2), trans(1,4), L(0.0), A(a), M(rho), end1Ptr(0), end2Ptr(0) { // create a copy of the material object theMaterial = theMat.getCopy(); // fill in the ID containing external node info with node id's externalNodes(0) = Nd1; externalNodes(1) = Nd2; } // constructor which should be invoked by an FE_ObjectBroker only MyTruss::MyTruss() :Element(0,ELE_TAG_MyTruss), theMaterial(0), externalNodes(2), trans(1,4), L(0.0), A(0.0), M(0.0), end1Ptr(0), end2Ptr(0) { // does nothing } After the two constructors comes the destructor for the class. This is the function that is invoked when the object is removed from the system. Each object is responsible for cleaning up after itself, anything the object created using the new operator. The destructor is also responsible for memory allocated by other objects, in this case the UniaxialMaterial object. MyTruss::~MyTruss() { if (theMaterial != 0) delete theMaterial; } After the destructor comes a number of utility methods that each Element type must provide. These include the methods getNumberExternalNodes() to return the number of end nodes, getExternalNodes() an ID object containing the identifiers of these nodes, and getNumDOF() to return the number of degrees of freedom associated with the Element. In addition, there is the method setDomain() that is called when the object is added to a Domain object. When this method is invoked each MyTruss object completes the initialization of it\u2019s instance variables. For example, if the two end nodes exist in the Domain the pointers to these end nodes are now set. int MyTruss::getNumExternalNodes(void) const { return 2; } const ID & MyTruss::getExternalNodes(void) { return externalNodes; } int MyTruss::getNumDOF(void) { return 4; } void MyTruss::setDomain(Domain *theDomain) { // first ensure nodes exist in Domain and set the node pointers int Nd1 = externalNodes(0); int Nd2 = externalNodes(1); end1Ptr = theDomain->getNode(Nd1); end2Ptr = theDomain->getNode(Nd2); if (end1Ptr == 0) return; // don't go any further - otherwise segmentation fault if (end2Ptr == 0) return; // don't go any further - otherwise segmentation fault // call the DomainComponent class method. note: THIS IS VERY VERY IMPORTANT this->DomainComponent::setDomain(theDomain); // ensure connected nodes have correct number of dof's int dofNd1 = end1Ptr->getNumberDOF(); int dofNd2 = end2Ptr->getNumberDOF(); if ((dofNd1 != 2) || (dofNd2 != 2)) return; // don't go any further - otherwise segmentation fault // now determine the length & transformation matrix const Vector &end1Crd = end1Ptr->getCrds(); const Vector &end2Crd = end2Ptr->getCrds(); double dx = end2Crd(0)-end1Crd(0); double dy = end2Crd(1)-end1Crd(1); L = sqrt(dx*dx + dy*dy); if (L == 0.0) return; // don't go any further - otherwise divide by 0 error double cs = dx/L; double sn = dy/L; trans(0,0) = -cs; trans(0,1) = -sn; trans(0,2) = cs; trans(0,3) = sn; // determine the nodal mass for lumped mass approach M = M * A * L/2; // remember M was set to rho in the constructor } Following the methods comes a number of methods related to the solution algorithm. These methods include commitState(), which is invoked when a point on the solution path has been achieved for a step in the analysis, revertToLastCommit() which is a method invoked to inform the Element that convergence to an acceptable solution was not achieved and that the Element is to return to the state it was at when the last commit() method was invoked on it. The method revertToStart() is invoked to tell the Element that it is to return to the state it was at the beginning of the analysis. For a MyTruss element type, which has no state information, the object itself will simply invoke the corresponding method on it\u2019s associated material object. int MyTruss::commitState() { return theMaterial->commitState(); } int MyTruss::revertToLastCommit() { return theMaterial->revertToLastCommit(); } int MyTruss::revertToStart() { return theMaterial->revertToStart(); } int MyTruss::update() { // determine the current strain given trial displacements at nodes double strain = this->computeCurrentStrain(); // set the strain in the materials theMaterial->setTrialStrain(strain); return 0; } After these come the implementation of the typical Element methods to obtain the current linearized stiffness, mass and damping matrices, and the residual vector. In each of these methods, a call is made to the objects computeCurrentStrain() method. Once the strain has been computed the tangent matrices and residual vector are computed using standard matlab like operations. It should be noted that the results are placed into the class matrices and vectors. const Matrix & MyTruss::getTangentStiff(void) { if (L == 0) { // if length == zero - we zero and return trussK.Zero(); return trussK; } // get the current E from the material for the strain that was set // at the material when the update() method was invoked double E = theMaterial->getTangent(); // form the tangent stiffness matrix trussK = trans^trans; trussK *= A*E/L; return trussK; } const Matrix & MyTruss::getSecantStiff(void) { if (L == 0) { // if length == zero - we zero and return trussK.Zero(); return trussK; } // get the current strain from the material double strain = theMaterial->getStrain(); // get the current stress from the material double stress = theMaterial->getStress(); // compute the tangent double E = stress/strain; // form the tangent stiffness matrix trussK = trans^trans; trussK *= A*E/L; return trussK; } const Matrix & MyTruss::getDamp(void) { // no damping associated with this type of element return trussD; } const Matrix & MyTruss::getMass(void) { if (L == 0) { // if length == zero - we zero and return trussM.Zero(); return trussM; } // determine mass matrix assuming lumped mass double nodeMass = M * A * L/2; for (int i=0; i<4; i++) trussM(i,i) = nodeMass; return trussM; } void MyTruss::zeroLoad(void) { // does nothing - no element loads associated with this object } const Vector & MyTruss::getResistingForce() { if (L == 0) { // if length == zero - we zero and return trussR.Zero(); return trussR; } // R = Ku - Pext // force = F * transformation double force = A*theMaterial->getStress(); for (int i=0; i<4; i++) trussR(i) = trans(0,i)*force; return trussR; } const Vector & MyTruss::getResistingForceIncInertia() { // R = Ku - Pext + Ma // determine the resisting force sans mass this->getResistingForce(); // now include the mass portion if (L != 0 && M != 0) { double nodeMass = M * A * L/2; const Vector &accel1 = end1Ptr->getTrialAccel(); const Vector &accel2 = end2Ptr->getTrialAccel(); for (int i=0; i<2; i++) { trussR(i) = trussR(i) - nodeMass*accel1(i); trussR(i+2) = trussR(i+2) - nodeMass*accel2(i); } } return trussR; } After the more standard Element methods come two pairwise methods that are required for parallel and database processing, sendSelf() and recvSelf(). Each Element object is responsible for sending enough information to a Channel object such that an Element of similar type, on the other end of the Channel, will be able to initialize itself so that the geometry and state information in the two objects are the same. When sending this data to a Channel a MyTruss object initially sends its tag, it\u2019s unique database tag, it\u2019s area, the Material objects tag in a vector object to the Channel. The MyClass object then sends it\u2019s ID to the Channel and finally the MaterialObject is told to send itself. When receiving itself from a Channel a MyTruss object will receive this information. It should be noticed that before the object can invoke recvSelf() on its Material object it must create the appropriate type of Material object, this it does using the FEM_ObjectBroker object and the Material objects class tag. int MyTruss::sendSelf(int commitTag, Channel &theChannel) { // note: we don't check for dataTag == 0 for Element // objects as that is taken care of in a commit by the Domain // object - don't want to have to do the check if sending data int dataTag = this->getDbTag(); // MyTruss packs it's data into a Vector and sends this to theChannel // along with it's dbTag and the commitTag passed in the arguments Vector data(5); data(0) = this->getTag(); data(1) = A; data(4) = M; data(2) = theMaterial->getClassTag(); int matDbTag = theMaterial->getDbTag(); // NOTE: we do have to ensure that the material has a database // tag if we are sending to a database channel. if (matDbTag == 0) { matDbTag = theChannel.getDbTag(); if (matDbTag != 0) theMaterial->setDbTag(matDbTag); } data(3) = matDbTag; theChannel.sendVector(dataTag, commitTag, data); // MyTruss then sends the tags of it's two end nodes theChannel.sendID(dataTag, commitTag, externalNodes); // finally MyTruss asks it's material object to send itself theMaterial->sendSelf(commitTag, theChannel); return 0; } int MyTruss::recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { int dataTag = this->getDbTag(); // MyTruss creates a Vector, receives the Vector and then sets the // internal data with the data in the Vector Vector data(5); theChannel.recvVector(dataTag, commitTag, data); this->setTag((int)data(0)); A = data(1); M = data(4); // MyTruss now receives the tags of it's two external nodes theChannel.recvID(dataTag, commitTag, externalNodes); // we create a material object of the correct type, // sets its database tag and asks this new object to receive itself. int matClass = data(2); int matDb = data(3); theMaterial = theBroker.getNewUniaxialMaterial(matClass); // we set the dbTag before we receive the material - this is important theMaterial->setDbTag(matDb); theMaterial->recvSelf(commitTag, theChannel, theBroker); return 0; } To display graphically an Element in an image the displaySelf() method is invoked on an Element object. What is displayed depends on the flag and display factor values provided as arguments. The display factor is used to magnify the nodal displacements at the member ends so that distortion of the structure is visible. The flag is used to indicate what measure is to be displayed. A MyTruss object will display the strain in the object if a \\(1\\) is passed, otherwise the force in the object is displayed. int MyTruss::displaySelf(Renderer &theViewer, int displayMode, float fact) { // first determine the two end points of the truss based on // the display factor (a measure of the distorted image) // store this information in 2 3d vectors v1 and v2 const Vector &end1Crd = end1Ptr->getCrds(); const Vector &end2Crd = end2Ptr->getCrds(); const Vector &end1Disp = end1Ptr->getDisp(); const Vector &end2Disp = end2Ptr->getDisp(); Vector v1(3); Vector v2(3); for (int i=0; i<2; i++) { v1(i) = end1Crd(i)+end1Disp(i)*fact; v2(i) = end2Crd(i)+end2Disp(i)*fact; } if (displayMode == 3) { // use the strain as the drawing measure double strain = theMaterial->getStrain(); return theViewer.drawLine(v1, v2, strain, strain); } else if (displayMode == 2) { // otherwise use the material stress double stress = A*theMaterial->getStress(); return theViewer.drawLine(v1,v2, stress, stress); } else { // use the axial force double force = A * theMaterial->getStress(); return theViewer.drawLine(v1,v2, force, force); } } To print the state of the Element, to a file or to the screen, the Print() method is invoked on the Element object. What is printed by the object, depends on the flag passed as an argument. A MyTruss object prints a detailed description of its state if \\(0\\) is passed, a shortened version if \\(1\\) is passed, and nothing at all if anything else is passed. void MyTruss::Print(OPS_Stream &s, int flag) const { // compute the strain and axial force in the member double strain, force; if (L == 0.0) { strain = 0; force = 0.0; } else { strain = theMaterial->getStrain(); force = A * theMaterial->getStress(); } for (int i=0; i<4; i++) trussR(i) = trans(0,i)*force; if (flag == 0) { // print everything s << \"Element: \" << this->getTag(); s << \" type: MyTruss iNode: \" << externalNodes(0); s << \" jNode: \" << externalNodes(1); s << \" Area: \" << A; if (M != 0) s << \" Mass (PerUnitVolume): \" << M; s << \" \\n\\t strain: \" << strain; s << \" axial load: \" << force; s << \" \\n\\t unbalanced load: \" << trussR; s << \" \\t Material: \" << *theMaterial; s << endln; } else if (flag == 1) { // just print ele id, strain and force s << this->getTag() << \" \" << strain << \" \" << force << endln; } } To allow the analyst to obtain information specific to the Truss element the methods setResponse() and getResponse() are provided. The setResponse() method is used to obtain an integer code that is used in subsequent requests to the MyTruss object for information. The integer returned depends on the array of strings passed to the element. A MyTruss object responds to requests for the axial force, \u2018axialForce\u2019, and the tangent stiffness matrix, \u2018stiffness\u2019. Requests for material information are passed to the material object. A \\(-1\\) is returned if the MyTruss does not supply this information. it should be noted that for information returned in ID, vector and Matrix objects the MyTruss elements allocate these objects from the heap, this is done to reduce memory overhead in the elements. The getResponse() method is used to obtain the information. Response * MyTruss::setResponse(char **argv, int argc, Information &eleInformation) { // // we compare argv[0] for known response types for the Truss // // axial force if (strcmp(argv[0],\"axialForce\") ==0) return new ElementResponse(this, 1, 0.0); // a material quantity else if (strcmp(argv[0],\"material\") == 0) return theMaterial->setResponse(&argv[1], argc-1, eleInformation); else return 0; } int MyTruss::getResponse(int responseID, Information &eleInformation) { switch (responseID) { case -1: return -1; case 1: return eleInfo.setDouble(A * theMaterial->getStress()); default: return 0; } } Finally the private member function for determining the current strain in the element if defined. This method uses the nodal pointers to look at the current trial displacements at the nodes from which the strain can be determined. double MyTruss::computeCurrentStrain(void) const { // determine the strain const Vector &disp1 = end1Ptr->getTrialDisp(); const Vector &disp2 = end2Ptr->getTrialDisp(); double dLength = 0.0; for (int i=0; i<2; i++) dLength -= (disp2(i)-disp1(i)) * trans(0,i); double strain = dLength/L; return strain; } TclElementCommands.cpp The TclElementCommands.cpp file contains the C++ procedure TclModelBuilderElementCommand(). It is this procedure that is invoked every time the element command is invoked. This file is modified to allow the analyst to construct a new element of type MyTruss with the command: element myTruss eleId iNodeID jNodeId area materialID massPerUnitVolume To do this in the prototypes section of the file the the procedure TclModelBuilder_addMyTruss() is declared to be an externally defined procedure. (NOTE that the whole element myTruss command could be parsed in this file. However, to keep things modular and allow the command to work with other interpreters that may be developed it has been the convention to place the procedure in a seperate file). extern int TclModelBuilder_MyTruss(ClientData , Tcl_Interp *, int, char **, Domain*, TclModelBuilder *, int); Then in the body of the procedure we inform the interpreter that, if the second argument of the element command is the string myTruss , that the external procedure is to be invoked. This is done by adding the following 4 lines of code: } else if (strcmp(argv[1],\"myTruss\") == 0) { int result = TclModelBuilder_MyTruss(clientData, interp, argc, argv, theTclDomain, theTclBuilder); return result; TclMyTrussCommand.cpp In this file we place the procedure, TclModelBuilder_MyTruss(), that was defined to be external in TclElementCommands.cpp. In this procedure a check is first made to insure that the correct number of arguments have been provided. The arguments are then parsed. A MyTruss element object is finally constructed with the parsed arguments and added to the domain. int TclModelBuilder_MyTruss(ClientData clientData, Tcl_Interp *interp, int argc, char **argv) { // make sure at least one other argument to contain type of system if (argc != 7 && argc != 8) { blah->result = \"WARNING bad command - myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } // get the id, x_loc and y_loc int trussId, iNode, jNode, matID; double A, M = 0.0; if (Tcl_GetInt(interp, argv[2], &trussId) != TCL_OK) { blah->result = \"WARNING invalid eleId- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } if (Tcl_GetInt(interp, argv[3], &iNode) != TCL_OK) { blah->result = \"WARNING invalid iNode- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } if (Tcl_GetInt(interp, argv[4], &jNode) != TCL_OK) { blah->result = \"WARNING invalid jNode- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv[5], &A) != TCL_OK) { blah->result = \"WARNING invalid A- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } if (Tcl_GetInt(interp, argv[6], &matID) != TCL_OK) { blah->result = \"WARNING invalid matId- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } if (argc == 8 && Tcl_GetDouble(interp, argv[7], &M) != TCL_OK) { blah->result = \"WARNING invalid matId- myTruss eleId iNode jNode Area matID\"; return TCL_ERROR; } UniaxialMaterial *theMaterial = theModelBuilder->getUniaxialMaterial(matID); if (theMaterial == 0) { opserr << \"WARNING TclPlaneTruss - truss - no Material found with tag \"; opserr << matID << endln; return TCL_ERROR; } // now create the truss and add it to the Domain MyTruss *theTruss = new MyTruss(trussId,iNode,jNode,*theMaterial,A,M); if (theTruss == 0) { opserr << \"WARNING TclPlaneTruss - addMyTruss - ran out of memory for node \"; opserr << trussId << endln; return TCL_ERROR; } if (theDomain->addElement(theTruss) == false) { delete theTruss; opserr << \"WARNING TclPlaneTruss - addTruss - could not add Truss to domain \"; opserr << trussId << endln; return TCL_ERROR; } // if get here we have successfully created the node and added it to the domain return TCL_OK; } FEM_ObjectBroker.cpp An FEM_ObjectBroker is the object responsible for creating blank objects of a specific type. This object is required for parallel and database programming. The MyTruss.h file is first included in the list of element header files. Then code in the getNewElement() method is revised to return a new MyTruss element if requested. Element * FEM_ObjectBroker :: getNewElement ( int classTag ) { switch ( classTag ) { // existing code ... // new two lines of code added for MyTruss element case ELE_TAG_MyTruss : return new MyTruss (); ... Modification to Example Script To use the new element in the new OpenSees interpreter, the code in example1.tcl is modified. The modified code can be found in example2.tcl. The lines with the element command in example1.tcl : # element truss trussId iNodeId jNodeId Area matId element truss 1 1 4 10 1 element truss 2 2 4 5 1 element truss 3 3 4 5 1 are replaced with the following lines in example2.tcl : # element truss trussId iNodeId jNodeId Area matId element myTruss 1 1 4 10 1 element myTruss 2 2 4 5 1 element myTruss 3 3 4 5 1 Frank McKenna and Gregory L. Fenves Pacific Earthquake Engineering Research Center University of California, Berkeley August 21, 2000 Version 1.0","title":"Introducing a New Element into OpenSees"},{"location":"developer/extending/NewMaterial/","text":"Material Models Introduction This document shows how to add a new material implementation to OpenSees. The hierarchical nature of the OpenSees software architecture allows new material models to be seamlessly added to the framework. By keeping element and material implementations separate, a new material model can be used in an existing element without modifying the element implementation, and vice versa. The programming language C++ directly supports the data encapsulation and run-time binding necessary to achieve this complete separation of material from element. Material Abstractions Currently, there are three Material abstractions in OpenSees, each of which can be used across a wide range of element implementations: UniaxialMaterial - Provides the interface for all one-dimensional material models, either stress-strain or force-deformation. UniaxialMaterial models define the stress-strain response of a truss element, uniaxial fiber behavior in a beam-column section, or the force-deformation response of a beam section or zero-length element. NDMaterial - The multi-dimensional generalization of UniaxialMaterial; provides the stress-strain response at a point in a solid element, or multi-dimensional fiber behavior in a plate or beam-column section. SectionForceDeformation - Defines the interface for stress resultant models which are used to describe both plate and beam-column force-deformation response as well as the constitutive response of more general zero-length elements, e.g., for isolator bearings. Each interface listed above is essentially the same with minor differences. The NDMaterial and SectionForceDeformation abstractions both represent multi-dimensional constitutive response. However, a distinction is made between stress and stress resultant response to allow for safer element implementations. Furthermore, the stress-strain equations for continuum material models can be written in terms of tensors. This is not the case for stress resultant models. Lastly, to avoid returning matrices and vectors or tensors of size one, the UniaxialMaterial abstraction is made distinct for reasons of efficiency, as scalar values describe the behavior of a one-dimensional model. ::: {.center} {#fig:Material} ::: As indicated in figure [fig:Material] , each material abstraction is a subclass of Material. The Material class is a subclass of both the TaggedObject and MovableObject classes, and therefore inherits the functionality of these two classes. As a result, it can be said that a Material \u201cis a\u201d TaggedObject as well as a MovableObject. Furthermore, since each of UniaxialMaterial, NDMaterial, and SectionForceDeformation \u201cis a\u201d Material, each is also a TaggedObject and a MovableObject. The TaggedObject class provides functionality for identifying materials, through a tag, during model building; and the MovableObject class provides functionality for parallel processing and database programming. Rather than show examples of implementing a material model under each interface, only the UniaxialMaterial interface is covered herein. The basic concepts of adding a material model to OpenSees carry directly over from UniaxialMaterial to NDMaterial and SectionForceDeformation. The remainder of this document is laid out as follows. First, the UniaxialMaterial interface is listed and explained. Then, an example UniaxialMaterial implementation, HardeningMaterial, is presented. Along with the C++ implementation, it is shown how to 1) add the new model to the OpenSees Tcl model builder, and 2) make the new model \u201cmovable\u201d for parallel processing and database programming. Finally, a FORTRAN interface for programming UniaxialMaterial models in OpenSees is described. UniaxialMaterial Interface Implementations of the UniaxialMaterial interface are used in several contexts within the OpenSees modeling framework. Due to their simplicity, these models can define both stress-strain and force-deformation relationships. It is up to the calling object, be it an element object or another material object, to interpret the meaning appropriately. Listed below is the UniaxialMaterial class interface. All methods in the UniaxialMaterial interface are public, there are no protected or private data or methods. Following the UniaxialMaterial class interface listing, each method in the interface is described. #include <Material.h> class Response; class Information; class UniaxialMaterial : public Material { public: UniaxialMaterial(int tag, int classTag); virtual ~UniaxialMaterial(void); virtual int setTrialStrain(double strain, double strainRate = 0.0) = 0; virtual double getStrain(void) = 0; virtual double getStrainRate(void); virtual double getStress(void) = 0; virtual double getTangent(void) = 0; virtual double getDampTangent(void); virtual double getSecant(void); virtual int commitState(void) = 0; virtual int revertToLastCommit(void) = 0; virtual int revertToStart(void) = 0; virtual UniaxialMaterial *getCopy(void) = 0; virtual Response *setResponse(char **argv, int argc, Information &matInfo); virtual int getResponse(int responseID, Information &matInfo); protected: private: }; A note about the C++ syntax seen in the UniaxialMaterial interface. The keyword \u201cvirtual\u201d at the start of a method declaration indicates this method may be overridden by a subclass of UniaxialMaterial. The UniaxialMaterial base class provides default implementations for its virtual methods. The notation \u201c= 0\u201d at the end of the method declaration indicates the method is pure virtual, meaning it must be defined by subclasses because the UniaxialMaterial base class does not provide a default implementation. The UniaxialMaterial base class constructor takes a tag and classTag as its arguments. The tag passed to the constructor identifies this UniaxialMaterial as unique among all other UniaxialMaterial objects, and the classTag is used primarily for parallel processing and database programming. Class tags are defined in the file classTags.h. The tag and classTag arguments are passed to the Material class constructor, where they are in turn passed to the TaggedObject and MovableObject class constructors, respectively. The UniaxialMaterial destructor is declared, but does not do anything as the UniaxialMaterial base class contains no data. The method setTrialStrain() takes one or two arguments, an updated strain and strain rate. The strain rate is an optional argument, with default value \\(0.0\\) . This method is pure virtual, so it must be implemented in all subclasses of UniaxialMaterial. The next two methods, getStrain() and getStrainRate() , are to return the current strain and strain rate of this UniaxialMaterial. The method getStrain() is pure virtual, while getStrainRate() is only virtual; by default it returns \\(0.0\\) , but may be overridden in subclasses if needed. double UniaxialMaterial::getStrainRate(void) { return 0.0; } The next method is getStress() , which is to return the current stress of this UniaxialMaterial. The current stress is a function of the current strain, \\(\\varepsilon\\) , and the current strain rate, \\(\\dot{\\varepsilon}\\) , \\[\\sigma = \\sigma(\\varepsilon,\\dot{\\varepsilon}) \\: .\\] The getStress() method is pure virtual and must be implemented by subclasses of UniaxialMaterial. The current material tangent is returned by the next method, getTangent() . The material tangent is the partial derivative of the material stress with respect to the current strain, \\[D_t = \\frac{\\partial{\\sigma}}{\\partial{\\varepsilon}} \\: .\\] The getTangent() is also pure virtual and must be implemented in all UniaxialMaterial subclasses. The getDampTangent() method is next, and is to return the current damping tangent, which is the partial derivative of the current stress with respect to the current strain rate, \\[\\eta = \\frac{\\partial{\\sigma}}{\\partial{\\dot{\\varepsilon}}} \\: .\\] By default, this method returns \\(0.0\\) , and it may be overridden in subclasses of UniaxialMaterial where there is strain rate dependence. double UniaxialMaterial::getDampTangent(void) { return 0.0; } Finally, the getSecant() method is provided to return the material secant, which is the current stress divided by the current strain, \\[D_s = \\frac{\\sigma}{\\varepsilon} \\: .\\] By default, this method returns the result of dividing the current stress by the current strain. If the current strain is zero, the current tangent is returned instead. double UniaxialMaterial::getSecant(void) { double strain = this->getStrain(); double stress = this->getStress(); if (strain != 0.0) return stress/strain; else return this->getTangent(); } The next set of methods deal with possible path dependent behavior of UniaxialMaterial models. All Material objects in OpenSees are responsible for keeping track of and updating their own history variables. First, the method commitState() is invoked to inform a UniaxialMaterial object that its current state is on the converged solution path and its internal history variables should be updated accordingly. Next, the method revertToLastCommit() is provided to let a UniaxialMaterial object know that it should return to its last committed state at. Finally, revertToStart() informs the UniaxialMaterial object to revert to its initial state, i.e., at the start of the analysis. All three of these methods are pure virtual, and thus must be implemented in all subclasses of UniaxialMaterial. The getCopy() method is declared so a calling object, be it an Element, Fiber, or another Material object, can obtain an exact copy of this UniaxialMaterial object. A pointer to the new object is returned by this function, and the calling object is responsible for deleting this dynamically allocated memory. This method is pure virtual because only a subclass of UniaxialMaterial knows the internal representation of its data. The final two methods, setResponse() and getResponse() , are declared for recording UniaxialMaterial state information. These methods have default implementations to record the material stress, strain, and tangent. These methods may be overridden, but their implementations are not shown in this document. Example \u2013 HardeningMaterial In this section, it is shown how the rate-independent uniaxial hardening material model given in Simo & Hughes, Computational Inelasticity (1998) is implemented in OpenSees. First, the class implementation is shown, followed by its inclusion in the Tcl model builder. Class Implementation The HardeningMaterial class interface is shown below. Here, no methods are virtual since this class provides implementations for the corresponding methods inherited from the UniaxialMaterial class. Note, three additional methods not declared in the UniaxialMaterial interface, sendSelf() , recvSelf() , and Print() , must be defined in implementations of UniaxialMaterial. These methods are inherited from higher level classes in the OpenSees framework, particularly, TaggedObject and MovableObject. An explanation of these methods is provided in what follows. #include <UniaxialMaterial.h> class HardeningMaterial : public UniaxialMaterial { public: HardeningMaterial(int tag, double E, double sigmaY, double Hiso, double Hkin); HardeningMaterial(); ~HardeningMaterial(); int setTrialStrain(double strain, double strainRate = 0.0); double getStrain(void); double getStress(void); double getTangent(void); int commitState(void); int revertToLastCommit(void); int revertToStart(void); UniaxialMaterial *getCopy(void); int sendSelf(int commitTag, Channel &theChannel); int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); void Print(OPS_Stream &s, int flag = 0); protected: private: // Material parameters double E; // Elastic modulus double sigmaY; // Yield stress double Hiso; // Isotropic hardening modulus double Hkin; // Kinematic hardening modulus // Committed history variables double CplasticStrain; // Committed plastic strain double CbackStress; // Committed back stress; double Chardening; // Committed internal hardening variable // Trial history variables double TplasticStrain; // Trial plastic strain double TbackStress; // Trial back stress double Thardening; // Trial internal hardening variable // Trial state variables double Tstrain; // Trial strain double Tstress; // Trial stress double Ttangent; // Trial tangent }; The first two methods defined for HardeningMaterial are the constructors. The first constructor takes the material tag and the material parameters: elastic modulus, \\(E\\) , yield stress, \\(\\sigma_y\\) , isotropic hardening modulus, \\(H_{iso}\\) , and kinematic hardening modulus, \\(H_{kin}\\) . The UniaxialMaterial base class constructor is invoked with the arguments tag and MAT_TAG_Hardening (defined in classTags.h). The material parameters for this object are initialized in the initialization list with the arguments passed to the constructor, and all history variables are initialized by invoking revertToStart() . The second constructor is a default constructor which sets all material parameters to \\(0.0\\) then invokes revertToStart() . HardeningMaterial::HardeningMaterial(int tag, double e, double s, double hi, double hk) :UniaxialMaterial(tag,MAT_TAG_Hardening), E(e), sigmaY(s), Hiso(hi), Hkin(hk) { // Initialize variables this->revertToStart(); } HardeningMaterial::HardeningMaterial() :UniaxialMaterial(0,MAT_TAG_Hardening), E(0.0), sigmaY(0.0), Hiso(0.0), Hkin(0.0) { // Initialize variables this->revertToStart(); } The next method defined is the destructor, which does nothing since no memory is dynamically allocated by a HardeningMaterial object. HardeningMaterial::~HardeningMaterial() { // Does nothing } The following methods deal with the material state determination. The return mapping algorithm is coded in setTrialStrain() . The stress and tangent of this HardeningMaterial object are computed and stored in the instance variables Tstress and Ttangent and returned by the methods getStress() and getTangent() , respectively. The trial strain, stored in the instance variable Tstrain, is returned by the method getStrain() . int HardeningMaterial::setTrialStrain(double strain, double strainRate) { // Set total strain Tstrain = strain; // Elastic trial stress Tstress = E * (Tstrain-CplasticStrain); // Compute trial stress relative to committed back stress double xsi = Tstress - CbackStress; // Compute yield criterion double f = fabs(xsi) - (sigmaY + Hiso*Chardening); // Elastic step ... no updates required if (f <= 0.0) { // Set trial tangent Ttangent = E; } // Plastic step ... perform return mapping algorithm else { // Compute consistency parameter double dGamma = f / (E+Hiso+Hkin); // Find sign of xsi int sign = (xsi < 0) ? -1 : 1; // Bring trial stress back to yield surface Tstress -= dGamma*E*sign; // Update plastic strain TplasticStrain = CplasticStrain + dGamma*sign; // Update back stress TbackStress = CbackStress + dGamma*Hkin*sign; // Update internal hardening variable Thardening = Chardening + dGamma; // Set trial tangent Ttangent = E*(Hkin+Hiso) / (E+Hkin+Hiso); } return 0; } double HardeningMaterial::getStress(void) { return Tstress; } double HardeningMaterial::getTangent(void) { return Ttangent; } double HardeningMaterial::getStrain(void) { return Tstrain; } The next set of methods deal with the path dependent behavior of this HardeningMaterial object. The method commitState() sets the committed history variables to be their corresponding trial values. Nothing needs to be done in the method revertToLastCommit() , and all history variables are set to \\(0.0\\) in revertToStart() . int HardeningMaterial::commitState(void) { // Commit trial state variables CplasticStrain = TplasticStrain; CbackStress = TbackStress; Chardening = Thardening; return 0; } int HardeningMaterial::revertToLastCommit(void) { // Nothing to do here return 0; } int HardeningMaterial::revertToStart(void) { // Reset committed history variables CplasticStrain = 0.0; CbackStress = 0.0; Chardening = 0.0; // Reset trial history variables TplasticStrain = 0.0; TbackStress = 0.0; Thardening = 0.0; // Initialize state variables Tstrain = 0.0; Tstress = 0.0; Ttangent = E; return 0; } The getCopy() method is defined so this HardeningMaterial object can provide a clone of itself to a calling object, be it an Element, Fiber, or other Material object. The constructor is invoked to create a new object, then all instance variables are copied to the new object. The calling object is responsible for deleting this dynamically allocated memory. UniaxialMaterial* HardeningMaterial::getCopy(void) { HardeningMaterial *theCopy = new HardeningMaterial(this->getTag(), E, sigmaY, Hiso, Hkin); // Copy committed history variables theCopy->CplasticStrain = CplasticStrain; theCopy->CbackStress = CbackStress; theCopy->Chardening = Chardening; // Copy trial history variables theCopy->TplasticStrain = TplasticStrain; theCopy->TbackStress = TbackStress; theCopy->Thardening = Thardening; // Copy trial state variables theCopy->Tstrain = Tstrain; theCopy->Tstress = Tstress; theCopy->Ttangent = Ttangent; return theCopy; } The next two methods are defined for parallel processing and database programming, and are inherited from MovableObject. The first method, sendSelf() , packs the material properties and committed history variables in a Vector, then sends the Vector across the Channel object passed as an argument to the method. The second method, recvSelf() , receives data from the Channel object, then populates the data of this HardeningMaterial object with the received data. int HardeningMaterial::sendSelf(int cTag, Channel &theChannel) { static Vector data(8); data(0) = this->getTag(); data(1) = E; data(2) = sigmaY; data(3) = Hiso; data(4) = Hkin; data(5) = CplasticStrain; data(6) = CbackStress; data(7) = Chardening; int res = theChannel.sendVector(this->getDbTag(), cTag, data); if (res < 0) opserr << \"HardeningMaterial::sendSelf() - failed to send data\\n\"; return res; } int HardeningMaterial::recvSelf(int cTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { static Vector data(8); int res = theChannel.recvVector(this->getDbTag(), cTag, data); if (res < 0) { opserr << \"HardeningMaterial::recvSelf() - failed to receive data\\n\"; this->setTag(0); } else { this->setTag((int)data(0)); E = data(1); sigmaY = data(2); Hiso = data(3); Hkin = data(4); CplasticStrain = data(5); CbackStress = data(6); Chardening = data(7); // Set the trial state variables revertToLastCommit(); } return res; } The final HardeningMaterial method is Print() , which writes the material name, tag, and parameters to the output stream passed as an argument. This method is inherited from TaggedObject. void HardeningMaterial::Print(OPS_Stream &s, int flag) { s << \"HardeningMaterial, tag: \" << this->getTag() << endln; s << \" E: \" << E << endln; s << \" sigmaY: \" << sigmaY << endln; s << \" Hiso: \" << Hiso << endln; s << \" Hkin: \" << Hkin << endln; } Tcl Model Builder The new HardeningMaterial model must be added to the OpenSees Tcl model builder in order for it to be used by analysis models defined in Tcl script files. The general from of the uniaxialMaterial command is as follows: uniaxialMaterial materialType tag <specific material parameters> So, for a HardeningMaterial object, it is necessary to read in the material parameters that are passed to its constructor, namely the elastic modulus, yield stress, and isotropic and kinematic hardening moduli. The general form of the command will be: uniaxialMaterial Hardening tag E sigmaY Hiso Hkin An example command to add a HardeningMaterial object with tag \\(1\\) , elastic modulus of \\(30000.0\\) , yield stress of \\(60.0\\) , isotropic hardening modulus of \\(0.0\\) , and kinematic hardening modulus of \\(1000.0\\) may then look like: uniaxialMaterial Hardening 1 30000.0 60.0 0.0 1000.0 How these values are parsed and used to construct a HardeningMaterial object is described next. The parsing of input data for all UniaxialMaterial models is done in the function TclModelBuilderUniaxialMaterialCommand contained in the file TclModelBuilderUniaxialMaterialCommand.cpp. In this file there are multiple if/else statements, one for each UniaxialMaterial that can be added to the model builder. To add the new model only requires adding an additional case with the accompanying code to parse the Tcl command line. The above command is split into an array of character strings (argv) by the Tcl interpreter, then sent to the TclModelBuilderUniaxialMaterialCommand function. argv[0] contains the command name \u201cuniaxialMaterial,\u201d argv[1] holds the material keyword \u201cHardening,\u201d argv[2] contains the material tag, and the remaining entries in the argv array hold the specific material parameters. These parameters are the arguments needed to call the HardeningMaterial constructor. The number of elements in the argv array is stored in the variable argc. Calls are made to the Tcl routines Tcl_GetInt and Tcl_GetDouble to get integer and double values from the character strings contained in argv. These routines perform error checking and return the pre-defined value TCL_OK if there was no error. Once the UniaxialMaterial has been allocated, it is added to the Tcl model builder at the end of the TclModelBuilderUniaxialMaterialCommand function, after the multiple if/else statement has ended. int TclModelBuilderUniaxialMaterialCommand(ClientData clienData, Tcl_Interp *interp, int argc, char **argv, TclModelBuilder *theTclBuilder) { // Pointer to a UniaxialMaterial that will be added to the model builder UniaxialMaterial *theMaterial = 0; if (strcmp(argv[1],\"Elastic\") == 0) { // // Additional code not shown // } else if (strcmp(argv[1],\"Hardening\") == 0) { if (argc < 7) { opserr << \"WARNING insufficient arguments\\n\"; printCommand(argc,argv); opserr << \"Want: uniaxialMaterial Hardening tag E sigmaY Hiso Hkin\" << endln; return TCL_ERROR; } int tag; double E, sigmaY, Hiso, Hkin; if (Tcl_GetInt(interp, argv[2], &tag) != TCL_OK) { opserr << \"WARNING invalid uniaxialMaterial Hardening tag\" << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv[3], &E) != TCL_OK) { opserr << \"WARNING invalid E\\n\"; opserr << \"uniaxialMaterial Hardening: \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv[4], &sigmaY) != TCL_OK) { opserr << \"WARNING invalid sigmaY\\n\"; opserr << \"uniaxialMaterial Hardening: \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv[5], &Hiso) != TCL_OK) { opserr << \"WARNING invalid Hiso\\n\"; opserr << \"uniaxialMaterial Hardening: \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv[6], &Hkin) != TCL_OK) { opserr << \"WARNING invalid Hkin\\n\"; opserr << \"uniaxialMaterial Hardening: \" << tag << endln; return TCL_ERROR; } // Parsing was successful, allocate the material theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin); } // // Additional code not shown // // Now add the material to the modelBuilder if (theTclBuilder->addUniaxialMaterial(*theMaterial) < 0) { opserr << \"WARNING could not add uniaxialMaterial to the model builder\\n\"; opserr << *theMaterial << endln; delete theMaterial; // invoke the material objects destructor, // otherwise memory leak return TCL_ERROR; } return TCL_OK; } FEM_ObjectBroker In order for the new HardeningMaterial object to be used for parallel processing and database programming, the getNewUniaxialMaterial() method in the FEM_ObjectBroker class must be modified. An additional case statement should be added, as shown below. The MAT_TAG_Hardening classTag is the same pre-defined value passed to the UniaxialMaterial constructor by the HardeningMaterial constructor described earlier. The FEM_ObjectBroker simply returns a blank HardeningMaterial object, whose data can be subsequently populated by invoking recvSelf() . UniaxialMaterial* FEM_ObjectBroker::getNewUniaxialMaterial(int classTag) { switch(classTag) { case MAT_TAG_Hardening: return new HardeningMaterial(); // // Additional cases not shown // default: opserr << \"FEM_ObjectBroker::getPtrNewUniaxialMaterial - \"; opserr << \" - no UniaxialMaterial type exists for class tag \"; opserr << classTag << endln; return 0; } } A FORTRAN Interface for UniaxialMaterial Models Subclasses of UniaxialMaterial hide their implementation details from calling objects, i.e., calling objects only see the public interface defined in the UniaxialMaterial base class. How the interface is implemented is encapsulated by each subclass of UniaxialMaterial. Thus, a particular UniaxialMaterial implementation need not be written in C++ as long as the implementation conforms to the UniaxialMaterial interface. As an example, the FEDEAS uniaxial material library developed by F.C. Filippou is used as a FORTRAN interface for UniaxialMaterial models in OpenSees. This example is meant to demonstrate the process of linking OpenSees with other material libraries and is not limited to just the FEDEAS library. Material libraries with any well-defined interface, e.g. DRAIN, may be linked in a similar manner. Similar concepts carry directly over to implementing NDMaterial and SectionForceDeformation models in FORTRAN. FEDEAS subroutine interface The subroutine interface defined for a FEDEAS uniaxial material model named \u201cML1D\u201d is shown below. subroutine ML1D(matpar,hstvP,hstv,epsP,sigP,deps,sig,tang,ist) The subroutine arguments are given as follows: matpar - a double array of material parameters (in) hstvP - a double array of committed history variables (in) hstv - a double array of trial history variables (out) epsP - strain at the last committed state (in) sigP - stress at the last committed state (in) deps - change in strain from the last committed state (in) sig - the stress at the current trial state (out) tang - the tangent at the current trial state (out) ist - integer indicating the operation to be performed (in): 0 - return number of material parameters and history variables, 1 - compute stress and tangent, 2 - compute stress and secant FedeasMaterial Implementation in OpenSees This section presents an implementation of UniaxialMaterial capable of wrapping any subroutine that conforms to the FEDEAS interface described in the previous section. This implementation, FedeasMaterial, manages the data arrays sent to the FEDEAS subroutine, i.e., FedeasMaterial is responsible for storing the material parameters and history variables, as well as for swapping trial and committed history variables. FedeasMaterial is a subclass of UniaxialMaterial, as shown in figure [fig:Fedeas] . Subclasses of FedeasMaterial are responsible for defining constructors which take the appropriate material parameters. All other functionality (state determination, swapping of history variables, etc.) is common to all subclasses of FedeasMaterial. Therefore, this functionality is defined in the base class, FedeasMaterial. The FedeasMaterial class interface is shown below. All methods are declared as virtual so they may be overridden by subclasses of FedeasMaterial. #include <UniaxialMaterial.h> class FedeasMaterial : public UniaxialMaterial { public: FedeasMaterial(int tag, int classTag, int nhv, int ndata); virtual ~FedeasMaterial(); virtual int setTrialStrain(double strain, double strainRate = 0.0); virtual double getStrain(void); virtual double getStress(void); virtual double getTangent(void); virtual int commitState(void); virtual int revertToLastCommit(void); virtual int revertToStart(void); virtual UniaxialMaterial *getCopy(void); virtual int sendSelf(int commitTag, Channel &theChannel); virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); virtual void Print(OPS_Stream &s, int flag = 0); protected: // Invokes the FORTRAN subroutine virtual int invokeSubroutine(int ist); double *data; // Material parameters array double *hstv; // History array: first half is committed, second is trial int numData; // Number of material parameters int numHstv; // Number of history variables double epsilonP; // Committed strain double sigmaP; // Committed stress private: double epsilon; // Trial strain double sigma; // Trial stress double tangent; // Trial tangent }; Instance variables are declared in FedeasMaterial to store history variables and material parameters. First, data is a double array of size numData, the number of material parameters for this object. Next, hstv is a double array of size 2*numHstv, where numHstv is the number of history variables needed for this FedeasMaterial object. Note that committed history variables are stored in the first half of the hstv array, while the trial values are kept in the second half. The values epsilonP and sigmaP are the committed strain and stress, respectively, of this FedeasMaterial object, as they are required by the FEDEAS subroutine interface. Finally, three trial state variables, epsilon, sigma, and tangent are defined to store the current strain, stress, and tangent. The FedeasMaterial constructor initializes the number of history variables and number of material parameters with arguments passed to the constructor. The UniaxialMaterial base class constructor is invoked with the tag and classTag arguments. The trial and committed strain and stress are initialized to \\(0.0\\) . Then, the history variable and material parameter arrays are allocated. All entries in the history variable and material parameter arrays are initialized to \\(0.0\\) . FedeasMaterial::FedeasMaterial(int tag, int classTag, int nhv, int ndata) :UniaxialMaterial(tag,classTag), data(0), hstv(0), numData(ndata), numHstv(nhv), epsilonP(0.0), sigmaP(0.0), epsilon(0.0), sigma(0.0), tangent(0.0) { if (numHstv < 0) numHstv = 0; if (numHstv > 0) { // Allocate history array hstv = new double[2*numHstv]; if (hstv == 0) g3ErrorHandler->fatal(\"%s -- failed to allocate history array -- type %d\", \"FedeasMaterial::FedeasMaterial\", this->getClassTag()); // Initialize to zero for (int i = 0; i < 2*numHstv; i++) hstv[i] = 0.0; } if (numData < 0) numData = 0; if (numData > 0) { // Allocate material parameter array data = new double[numData]; if (data == 0) g3ErrorHandler->fatal(\"%s -- failed to allocate data array -- type %d\", \"FedeasMaterial::FedeasMaterial\", this->getClassTag()); // Initialize to zero for (int i = 0; i < numData; i++) data[i] = 0.0; } } The FedeasMaterial destructor deallocates the memory allocated in the constructor to hold the history variables and material parameters. FedeasMaterial::~FedeasMaterial() { if (hstv != 0) delete [] hstv; if (data != 0) delete [] data; } The next group of FedeasMaterial methods deals with material state determination. First, setTrialStrain() stores the trial strain, then invokes the FEDEAS subroutine with ist = 1, indicating that normal stress and tangent quantities should be computed. The methods getStrain() , getStress() , and getTangent() return the strain, stress, and tangent of this FedeasMaterial. int FedeasMaterial::setTrialStrain(double strain, double strainRate) { // Store the strain epsilon = strain; // Tells subroutine to do normal operations for stress and tangent int ist = 1; // Call the subroutine return this->invokeSubroutine(ist); } double FedeasMaterial::getStrain(void) { return epsilon; } double FedeasMaterial::getStress(void) { return sigma; } double FedeasMaterial::getTangent(void) { return tangent; } The next three methods deal with the path dependent behavior of this FedeasMaterial object. The commitState() method copies the trial history variables from the second half of the hstv array to the first half, where the committed values are stored. The committed values are copied to the trial values in revertToLastCommit() , and all values are set to \\(0.0\\) in the revertToStart() method. int FedeasMaterial::commitState(void) { // Set committed values equal to corresponding trial values for (int i = 0; i < numHstv; i++) hstv[i] = hstv[i+numHstv]; epsilonP = epsilon; sigmaP = sigma; return 0; } int FedeasMaterial::revertToLastCommit(void) { // Set trial values equal to corresponding committed values for (int i = 0; i < numHstv; i++) hstv[i+numHstv] = hstv[i]; epsilon = epsilonP; sigma = sigmaP; return 0; } int FedeasMaterial::revertToStart(void) { // Set all trial and committed values to zero for (int i = 0; i < 2*numHstv; i++) hstv[i] = 0.0; epsilonP = 0.0; sigmaP = 0.0; return 0; } A copy of this FedeasMaterial object is returned by getCopy() . First, the FedeasMaterial constructor is called with the necessary tag, type, and array size data. Then, the committed strain and stress, all history variables, and material parameters are copied to the new object before it is returned. UniaxialMaterial* FedeasMaterial::getCopy(void) { FedeasMaterial *theCopy = new FedeasMaterial(this->getTag(), this->getClassTag(), numHstv, numData); // Copy history variables int i; for (i = 0; i < 2*numHstv; i++) theCopy->hstv[i] = hstv[i]; for (i = 0; i < numData; i++) theCopy->data[i] = data[i]; theCopy->epsilonP = epsilonP; theCopy->sigmaP = sigmaP; return theCopy; } The next two methods are defined for parallel processing and database programming. The first method, sendSelf() , packs the tag and array size information for this FedeasMaterial object into an ID vector and sends it across the Channel. Then, the material properties and committed history variables are put in a Vector, and sent as well. The second method, recvSelf() , receives both the ID and Vector data from the Channel object, then populates the data of this FedeasMaterial object with the appropriate data. int FedeasMaterial::sendSelf(int commitTag, Channel &theChannel) { int res = 0; static ID idData(3); idData(0) = this->getTag(); idData(1) = numHstv; idData(2) = numData; res += theChannel.sendID(this->getDbTag(), commitTag, idData); if (res < 0) opserr << \"FedeasMaterial::sendSelf() - failed to send ID data\\n\"; Vector vecData(numHstv+numData+2); int i, j; // Copy only the committed history variables into vector for (i = 0; i < numHstv; i++) vecData(i) = hstv[i]; // Copy material properties into vector for (i = 0, j = numHstv; i < numData; i++, j++) vecData(j) = data[i]; vecData(j++) = epsilonP; vecData(j++) = sigmaP; res += theChannel.sendVector(this->getDbTag(), commitTag, vecData); if (res < 0) opserr << \"FedeasMaterial::sendSelf() - failed to send Vector data\\n\"; return res; } int FedeasMaterial::recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) { int res = 0; static ID idData(3); res += theChannel.recvID(this->getDbTag(), commitTag, idData); if (res < 0) { opserr << \"FedeasMaterial::recvSelf() - failed to receive ID data\\n\"; return res; } this->setTag(idData(0)); numHstv = idData(1); numData = idData(2); Vector vecData(numHstv+numData+2); res += theChannel.recvVector(this->getDbTag(), commitTag, vecData); if (res < 0) { opserr << \"FedeasMaterial::recvSelf() - failed to receive Vector data\\n\"; return res; } int i, j; // Copy committed history variables from vector for (i = 0; i < numHstv; i++) hstv[i] = vecData(i); // Copy material properties from vector for (i = 0, j = numHstv; i < numData; i++, j++) data[i] = vecData(j); epsilonP = vecData(j++); sigmaP = vecData(j++); return res; } The Print() method outputs the name of this FedeasMaterial object to the stream passed as an argument. More cases can be added to the switch statement as additional subroutines are added. void FedeasMaterial::Print(OPS_Stream &s, int flag) { s << \"FedeasMaterial, type: \"; switch (this->getClassTag()) { case MAT_TAG_FedeasHardening: s << \"Hardening\" << endln; break; // Add more cases as needed default: s << \"Material identifier = \" << this->getClassTag() << endln; break; } } In order to link the FORTRAN subroutine with the OpenSees C++ libraries, the following external function declarations are needed. There are two syntactic styles for these declarations, one for Win32 and the other for everything else. The preprocessor directives put the proper declaration into the source code. Additional declarations may be added as more subroutines are included in OpenSees. #ifdef _WIN32 extern \"C\" int _stdcall HARD_1(double *matpar, double *hstvP, double *hstv, double *strainP, double *stressP, double *dStrain, double *tangent, double *stress, int *ist); #define hard_1_ HARD_1 // Add more declarations as needed #else extern \"C\" int hard_1_(double *matpar, double *hstvP, double *hstv, double *strainP, double *stressP, double *dStrain, double *tangent, double *stress, int *ist); // Add more declarations as needed #endif The method invokeSubroutine() calls the appropriate subroutine based on the material classTag. The FedeasMaterial instance variables are passed to the FORTRAN subroutine from this method. Additional cases in the switch statement can be added as more subroutines are linked with OpenSees. int FedeasMaterial::invokeSubroutine(int ist) { // Compute strain increment double dEpsilon = epsilon-epsilonP; switch (this->getClassTag()) { case MAT_TAG_FedeasHardening: hard_1_(data, hstv, &hstv[numHstv], &epsilonP, &sigmaP, &dEpsilon, &sigma, &tangent, &ist); break; // Add more cases as needed default: g3ErrorHandler->fatal(\"%s -- unknown material type\", \"FedeasMaterial::invokeSubroutine\"); return -1; } return 0; } Example \u2013 FedeasHardeningMaterial The material data array defined in FedeasMaterial is populated by its subclasses. As an example, consider the case where the uniaxial hardening material is coded in a FORTRAN subroutine. In order to link this subroutine with OpenSees, a subclass of FedeasMaterial, FedeasHardeningMaterial, must be created (see figure fig:FedeasHardening ). The functionality of this subclass is to populate the material parameter array and to determine the number of history variables required for analysis. Fedeas hardening material As additional FEDEAS subroutines are added to OpenSees, new subclasses of FedeasMaterial must be added in order to populate the data array. This is all that need be done in the derived class as the base class, FedeasMaterial, contains all the computational code and keeps track of path dependent behavior. This functionality is inherited from the FedeasMaterial base class. However, the FedeasMaterial class must be modified such that the appropriate subroutine is called during state determination from the method invokeSubroutine() . FEDEAS Hardening Subroutine This section contains the implementation of the uniaxial hardening material coded as a FORTRAN subroutine using the FEDEAS interface. The subroutine declares local variables to store the material parameters passed through the matpar array. The committed history variables are received from hstvP, and the trial history variables are written to hstv upon return. The trial stress and tangent are also set upon return in the variables sig and tang. FORTRAN source code subroutine Hard_1(matpar,hstvP,hstv,epsP,sigP,deps,sig,tang,ist) c I matpar contains fixed properties ( 4 ) c E = Elastic modulus -- > matpar( 1 ) c sigY = Yield stress -- > matpar( 2 ) c Hiso = Isotropic hardening modulus -- > matpar( 3 ) c Hkin = Kinematic hardening modulus -- > matpar( 4 ) c c I hstvP contains committed history variables: c ep = hstvP( 1 ) -- > plastic strain c alpha = hstvP( 2 ) -- > internal hardening variable c kappa = hstvP( 3 ) -- > back stress for kinematic hardening c c O hstv will be set to the corresponding trial values of hstvP c hstv( 1 ) = ep c hstv( 2 ) = alpha c hstv( 3 ) = kappa c c I epsP: strain at last committed state c I sigP: stress at last committed state c I deps: current strain increment c O sig : updated stress c O tang: updated tangent c I ist : tangent calculation switch c 1 = tangent, 2 = incremental secant, 3 = total secant implicit none c Arguments integer ist real*8 matpar( 4 ),hstvP( 3 ),hstv( 3 ) real*8 epsP,sigP,deps real*8 sig,tang c Local variables real*8 E,sigY,Hiso,Hkin real*8 ep,alpha,kappa real*8 eps,f,xsi,dGamma integer sgn c Material parameters E = matpar( 1 ) sigY = matpar( 2 ) Hiso = matpar( 3 ) Hkin = matpar( 4 ) c History variables ep = hstvP( 1 ) alpha = hstvP( 2 ) kappa = hstvP( 3 ) c Current strain eps = epsP + deps c Elastic predictor sig = E * (eps - ep) c Stress relative to back stress xsi = sig - kappa c Yield function f = dabs (xsi) - (sigY + Hiso * alpha) c Inside yield surface if (f <= 0.0 ) then tang = E c Outside yield surface ... do return mapping else c Consistency parameter dGamma = f / (E + Hiso + Hkin) c Normal to yield surface if (xsi <= 0.d0 ) then sgn = - 1 else sgn = 1 endif c Updated stress sig = sig - dGamma * E * sgn c Updated plastic strain ep = ep + dGamma * sgn c Updated back stress kappa = kappa + dGamma * Hkin * sgn c Updated internal hardening variable alpha = alpha + dGamma c Elasto - plastic tangent tang = E * (Hkin + Hiso) / (E + Hkin + Hiso) endif c Update history variables hstv( 1 ) = ep hstv( 2 ) = alpha hstv( 3 ) = kappa c Compute requested tangent if (ist == 2 .and. deps /= 0.d0 ) then tang = (sig - sigP) / deps else if (ist == 3 .and. eps /= 0.d0 ) then tang = sig / eps else c add additional cases, if needed endif return end subroutine FedeasHardeningMaterial Subclass As stated previously, the functionality of the FedeasHardeningMaterial class is to read in the material parameters required for the Hard_1 subroutine invoked from the FedeasMaterial method invokeSubroutine() . In addition, the required number of history variables must be passed to the FedeasMaterial base class. The class interface for FedeasHardeningMaterial is shown below. The constructor takes the tag and material parameters as arguments. No other methods are declared in the FedeasHardeningMaterial interface as all functionality is inherited from FedeasMaterial. #include <FedeasMaterial.h> class FedeasHardeningMaterial : public FedeasMaterial { public: FedeasHardeningMaterial(int tag, double E, double sigmaY, double Hiso, double Hkin); FedeasHardeningMaterial(void); ~FedeasHardeningMaterial(); protected: private: }; The constructor takes the tag, elastic modulus, yield stress, and isotropic and kinematic hardening moduli as arguments. The FedeasMaterial class constructor is called with the tag and classTag MAT_TAG_FedeasHardening defined in classTags.h and the number of history variables and material parameters required for this particular material model. Then the material parameters are inserted into the data array. The default constructor simply invokes the base class constructor, and the destructor does nothing. FedeasHardeningMaterial::FedeasHardeningMaterial(int tag, double E, double sigmaY, double Hiso, double Hkin): // 3 history variables and 4 material parameters FedeasMaterial(tag, MAT_TAG_FedeasHardening, 3, 4) { data[0] = E; data[1] = sigmaY; data[2] = Hiso; data[3] = Hkin; } FedeasHardeningMaterial::FedeasHardeningMaterial(void): FedeasMaterial(0, MAT_TAG_FedeasHardening, 3, 4) { // Does nothing } FedeasHardeningMaterial::~FedeasHardeningMaterial(void) { // Does nothing } Important Polymorphic Note Should any method in the FedeasMaterial class need to be overridden, e.g., if a subclass does not want all of its history variables set to \\(0.0\\) in revertToStart() , the getCopy() method must also be overridden to return a pointer to the subclass. If getCopy() is not overridden, the dynamic type of the returned pointer will be of the FedeasMaterial type and the overridden method, e.g., revertToStart() , will not be called. Tcl Model Builder Adding the FedeasHardeningMaterial model to the Tcl model builder is done in exactly the same manner as for HardeningMaterial since both models have the same material parameters. Only the material allocation would change. The following line in TclModelBuilderUniaxialMaterialCommand.cpp // Parsing was successful, allocate the material theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin); would be changed to // Parsing was successful, allocate the material theMaterial = new FedeasHardeningMaterial ( tag , E , sigmaY , Hiso , Hkin ); FEM_ObjectBroker As for the HardeningMaterial class, an additional case needs to be added to the getNewUniaxialMaterial() method in FEM_ObjectBroker in order for the FedeasHardeningMaterial class to be used for parallel processing and database programming. UniaxialMaterial* FEM_ObjectBroker::getNewUniaxialMaterial(int classTag) { switch(classTag) { case MAT_TAG_Hardening: return new HardeningMaterial(); case MAT_TAG_FedeasHardening: return new FedeasHardeningMaterial(); // // Additional cases not shown // default: opserr << \"FEM_ObjectBroker::getPtrNewUniaxialMaterial - \"; opserr << \" - no UniaxialMaterial type exists for class tag \"; opserr << classTag << endln; return 0; } } Michael H. Scott and Gregory L. Fenves PEER, University of California, Berkeley August 21, 2001 Version 1.1","title":"New Material Models"},{"location":"developer/extending/NewRecorder/","text":"Recorder This page is adapted from the OpenSees Wiki. A Recorder in the interpreted OpenSees applications is used to obtain information from the model during the analysis. To add a new Recorder option into the interpreted applications, the developer must provide a new C++ subclass of the Recorder class and an interface function that will be used to parse the input and create the new recorder. Recorder Class The Recorder class itself is an abstract base class. It inherits from both the TaggedObject class and the MovableObject class. The class has a minimal interface, which is as shown below: The Recorder Class: class Recorder : public MovableObject , public TaggedObject { public : Recorder ( int classTag ); virtual ~ Recorder (); virtual int record ( int commitTag , double timeStamp ) = 0 ; virtual int restart ( void ); virtual int domainChanged ( void ); virtual int setDomain ( Domain & theDomain ); virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag ); protected : protected : private : static int lastRecorderTag ; }; The most important methods in the interface are: setDomain() - this is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. record() - this is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. Other Important methods are: domainChanged() - this is a method called when something major has happened in the Domain, ie. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it's pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it wuill have been deleted and it's old pointer information will no longer be valid.) send/recvSelf() - are two methods called in parallel applications. When invoked the recorders send/recv information about what they are recording. restart() - this method is called if restart() is invoked on the Domain. What the recorder does is up to you the developer. Example - SumElementForcesRecorder In the following section we will provide all necessary code to add a new recorder. The purpose of this recorder will be to sum the forces obtained from the list of inputted elements. The recorder will use the getResistingForce() method in the elements to obtain these forces. A similar class exists in the framework, which uses the setResponse()/getResponse() methods in the element interface. To demonstrate some of the output file options, the result will go to either the screen, a text file, or a binary file. More output options are of course available and the developer should look at existing recorder options. Header The header for thew new class, which we will call SumElementForcesRecorder is as follows: #ifndef SumElementForcesRecorder_h #define SumElementForcesRecorder_h #include <Recorder.h> #include <Information.h> #include <ID.h> class Domain ; class Vector ; class Matrix ; class Element ; class Response ; class FE_Datastore ; class SumElementForcesRecorder : public Recorder { public : // constructors SumElementForcesRecorder (); SumElementForcesRecorder ( const ID eleID , bool echoTime , OPS_Stream * theOutputHandler ); // destructors ~ SumElementForcesRecorder (); // public methods int record ( int commitTag , double timeStamp ); int restart ( void ); int domainChanged ( void ); int setDomain ( Domain & theDomain ); const char * getClassType ( void ) const ; int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : int numEle ; // the number of elements Element ** theElements ; // pointer to array of element pointers ID eleID ; // ID (integer list) of element tags to record Domain * theDomain ; // pointer to domain holding elements OPS_Stream * theOutput ; // pointer to output location bool echoTimeFlag ; // flag indicating if pseudo time to be printed Vector * data ; // Vector (double array) to store sum of element forces }; #endif The header file defines the interface and variables for the class SumElementForceRecorder. It defines the new class to be a sublass of the Recorder class. In the public interface are 2 constructors and 1 destructor in addition to all the methods defined for the Recorder class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we store data that will be used by the SumElementForceRecorder objects. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Domain, Vector, Element, OPS_Stream) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, SumElementForcesRecorder.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_SumElementForcesRecorder() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. #include \"SumElementForcesRecorder.h\" #include <elementAPI.h> #include <Domain.h> #include <Element.h> #include <ElementIter.h> #include <Matrix.h> #include <Vector.h> #include <ID.h> #include <string.h> #include <Response.h> #include <Message.h> #include <Channel.h> #include <FEM_ObjectBroker.h> #include <StandardStream.h> #include <BinaryFileStream.h> #include <DataFileStream.h> #include <elementAPI.h> Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. SumElementForcesRecorder :: SumElementForcesRecorder () : Recorder (- 1 ), numEle ( 0 ), theElements ( 0 ), eleID ( 0 ), theDomain ( 0 ), theOutput ( 0 ), echoTimeFlag ( true ), data ( 0 ) { } SumElementForcesRecorder :: SumElementForcesRecorder ( const ID ele , bool echoTime , OPS_Stream * theoutput ) : Recorder (- 1 ), numEle ( 0 ), theElements ( 0 ), eleID ( ele ), theDomain ( 0 ), theOutput ( theoutput ), echoTimeFlag ( echoTime ), data ( 0 ) { // set numEle numEle = eleID . Size (); if ( numEle == 0 ) { opserr << \"WARNING SumElementForcesRecorder::SumElementForcesRecorder() - no elements tags passed in input! \\n \" ; } } Destructor The we provide the destructor. In the destructor all memory that the Recorder created or was passed to it in the constructor must be destroyed. Failing to delete this memory, will result in memory leaks. SumElementForcesRecorder ::~ SumElementForcesRecorder () { if ( theElements != 0 ) delete [] theElements ; if ( data != 0 ) delete data ; if ( theOutput != 0 ) delete theOutput ; } record() Method After the destructor, we provide the code for the record() method. It does the following operations: Zeros the vector which will contain the final sum If the time stamp is needed, it places it at the first location in the vector. Loops over all valid elements adding their resting force to the vector. Send the vector to the output handler to be written. Returns success. int SumElementForcesRecorder :: record ( int commitTag , double timeStamp ) { // check for initialization if ( data == 0 ) { opserr << \"SumElementForcesRecorder::record() - setDomain() has not been called \\n \" ; return - 1 ; } // zero the data vector data -> Zero (); int forceSize = data -> Size (); int startLoc = 0 ; // write the time if echTimeFlag set if ( echoTimeFlag == true ) { (* data )( 0 ) = timeStamp ; forceSize -= 1 ; startLoc = 1 ; } // // for each element that has been added to theElements add force contribution // for ( int i = 0 ; i < numEle ; i ++) { if ( theElements [ i ] != 0 ) { int loc = startLoc ; const Vector & force = theElements [ i ]-> getResistingForce (); int forceSize = force . Size (); for ( int j = 0 ; j < forceSize ; j ++, loc ++) (* data )( loc ) += force ( j ); } } // // send the response vector to the output handler for o/p // if ( theOutput != 0 ) theOutput -> write (* data ); // succesfull completion - return 0 return 0 ; } restart() and domainChanged() methods Afte the record() method, we have the two simple short methods restart() and domainChanged(). restart does nothing and domainChanged simply calls the objects own setDomain() method. int SumElementForcesRecorder :: restart ( void ) { return 0 ; } int SumElementForcesRecorder :: domainChanged ( void ) { if ( theDomain != 0 ) this -> setDomain (* theDomain ); } setDomain() Method The setDomain() method follows. In this method we perform the following: set the pointer for the enclosing domain object. allocate space from memoory for our array of ponters and our data vector. initialize the array components to be 0 or point to an element given by the eleID. determine the size of the vector that will be used to store the sum of the forces. allocate space for the vector. int SumElementForcesRecorder :: setDomain ( Domain & theDom ) { theDomain = & theDom ; // set numEle if ( numEle == 0 ) { opserr << \"WARNING SumElementForcesRecorder::initialize() - no elements tags passed in input! \\n \" ; return 0 ; } // create theElements, an array of pointers to elements theElements = new Element *[ numEle ]; if ( theElements == 0 ) { opserr << \"WARNING SumElementForcesRecorder::initialize() - out of memory \\n \" ; numEle = 0 ; // set numEle = 0, in case record() still called return - 1 ; } // // loop over the list of elements, // if element exists add it's pointer o the array // get its resisting force, check size to determine compatable with others // int sizeArray = - 1 ; for ( int i = 0 ; i < numEle ; i ++) { int eleTag = eleID ( i ); Element * theEle = theDomain -> getElement ( eleTag ); if ( theEle != 0 ) { const Vector & force = theEle -> getResistingForce (); int forceSize = force . Size (); if ( sizeArray == - 1 ) { sizeArray = forceSize ; theElements [ i ] = theEle ; } else if ( sizeArray != forceSize ) { opserr << \"WARNING: forces mismatch - element: \" << eleTag << \" will not be included \\n \" ; theElements [ i ] = 0 ; } else { theElements [ i ] = theEle ; } } else { theElements [ i ] = 0 ; } } // if echTimeFlag is set, add room for the time to be output if ( echoTimeFlag == true ) sizeArray ++; // create the vector to hold the data data = new Vector ( sizeArray ); if ( data == 0 || data -> Size () != sizeArray ) { opserr << \"SumElementForcesRecorder::initialize() - out of memory \\n \" ; delete [] theElements ; theElements = 0 ; numEle = 0 ; } return 0 ; } sendSelf() and recvSelf() methods These methods only need be provided if the object will be used in a parallel program. We provide their implementation for completeness, though typicall developers are interested in running the code in a sequential application and should just return -1. static char myClassType [] = { \"SumElementForcesRecorder\" }; const char * SumElementForcesRecorder :: getClassType ( void ) const { return myClassType ; } int SumElementForcesRecorder :: sendSelf ( int commitTag , Channel & theChannel ) { // send in an ID (integar array) to the receiving object the following: // recorder tag // size of eleID // class tag of handler // echoTimeFlag static ID idData ( 5 ); idData ( 0 ) = this -> getTag ();; idData ( 1 ) = eleID . Size (); idData ( 2 ) = theOutput -> getClassTag (); if ( echoTimeFlag == true ) idData ( 3 ) = 1 ; else idData ( 3 ) = 0 ; if ( theChannel . sendID ( 0 , commitTag , idData ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return - 1 ; } // send eleID to receiving object if ( theChannel . sendID ( 0 , commitTag , eleID ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send idData \\n \" ; return - 1 ; } // send theOutput to receiving object if ( theOutput -> sendSelf ( commitTag , theChannel ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send theOutput \\n \" ; return - 1 ; } return 0 ; } int SumElementForcesRecorder :: recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ) { // receive from the sending object the ID static ID idData ( 5 ); if ( theChannel . recvID ( 0 , commitTag , idData ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return - 1 ; } // with the data received // setTag // resize the eleID array // set echoTimeFlag // get an outputHandler this -> setTag ( idData ( 0 )); eleID . resize ( idData ( 1 )); idData ( 2 ) = theOutput -> getClassTag (); if ( idData ( 3 ) == 0 ) echoTimeFlag = true ; else echoTimeFlag = false ; if ( theOutput != 0 && theOutput -> getClassTag () != idData ( 4 )) delete theOutput ; theOutput = theBroker . getPtrNewStream ( idData ( 4 )); if ( theOutput == 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to get Output of correct type \\n \" ; return - 1 ; } // receive eleID if ( theChannel . recvID ( 0 , commitTag , eleID ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv eleID \\n \" ; return - 1 ; } // get theOutput to receive data if ( theOutput -> recvSelf ( commitTag , theChannel , theBroker ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send theOutput \\n \" ; return - 1 ; } return 0 ; } Interface Function At the end of the implementation file is the interface function. This function is required by all new classes. It is a function which will use the api to parse the input based on the input create objects create a recorder object of the correct type, and return it to the calling function. The interface function is the function that is called when the interpreter comes across the command telling it to create a SumElementForcesRecorder. #ifdef _USRDLL #include <windows.h> #define OPS_Export extern \"C\" _declspec ( dllexport ) #elif _MACOSX #define OPS_Export extern \"C\" __attribute__((visibility( \"default\" ))) #else #define OPS_Export extern \"C\" #endif static int numSumElementForcesREcorder = 0 ; OPS_Export void * OPS_SumElementForcesRecorder () { Recorder * theRecorder = 0 ; int numRemainingArgs = OPS_GetNumRemainingInputArgs (); // check for quick return, possibly parallel case if ( numRemainingArgs == 0 ) { Recorder * theRecorder = new SumElementForcesRecorder (); } // // parse args // int numEle = 0 , eleTag ; ID eleID ( 0 ); OPS_Stream * theOutputStream = 0 ; int outMode = 0 ; // standard stream bool echoTime = false ; bool doneParsingArgs = false ; char data [ 100 ]; char outputName [ 200 ]; char ** eleArgs = 0 ; int numEleArgs = 0 ; while ( numRemainingArgs > 0 ) { if ( OPS_GetString ( data , 100 ) < 0 ) return 0 ; // output to standard file if ( strcmp ( data , \"-file\" ) == 0 ) { outMode = 1 ; if ( OPS_GetString ( outputName , 200 ) < 0 ) return 0 ; numRemainingArgs -= 2 ; } // output to binary file else if ( strcmp ( data , \"-binary\" ) == 0 ) { outMode = 2 ; if ( OPS_GetString ( outputName , 200 ) < 0 ) return 0 ; numRemainingArgs -= 2 ; } // echo domain time stamp in output else if ( strcmp ( data , \"-time\" ) == 0 ) { echoTime = true ; numRemainingArgs -= 1 ; } // read the list of elements & place in an ID else if (( strcmp ( data , \"-ele\" ) == 0 ) || ( strcmp ( data , \"-eles\" ) == 0 ) || ( strcmp ( data , \"-element\" ) == 0 )) { numRemainingArgs --; int one = 1 ; while ( numRemainingArgs > 0 && OPS_GetIntInput (& one , & eleTag ) == 0 ) { eleID [ numEle ] = eleTag ; numEle ++; numRemainingArgs --; } doneParsingArgs = true ; } // // create the output handler // if ( outMode == 0 ) theOutputStream = new StandardStream (); if ( outMode == 1 ) theOutputStream = new DataFileStream ( outputName ); else if ( outMode == 2 ) theOutputStream = new BinaryFileStream ( outputName ); // // create the recorder // theRecorder = new SumElementForcesRecorder ( eleID , echoTime , theOutputStream ); // return it return theRecorder ; } Example Script (OpenSeesDeveloper/recorder/example1.tcl) An example OpenSees tcl input file for this new recorder is: #create the model model basic -ndm 2 -ndf 2 node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 uniaxialMaterial Elastic 1 3000 element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 fix 1 1 1 fix 2 1 1 fix 3 1 1 pattern Plain 1 Linear { # apply the load - command: load nodeID xForce yForce load 4 100 -50 } # Create the analysis system ProfileSPD constraints Plain integrator LoadControl 1.0 algorithm Linear numberer RCM analysis Static recorder Element -file a.out -time -ele 1 2 3 forces recorder SumElementForcesRecorder -file b.out -time -ele 1 2 3 # perform the analysis analyze 10 Example Output The output shows that the model is in equilibrium, and that at node 4 the node the element resisting forces are equal to the applied forces. 1 -100 50 100 -50 2 -200 100 200 -100 3 -300 150 300 -150 4 -400 200 400 -200 5 -500 250 500 -250 6 -600 300 600 -300 7 -700 350 700 -350 8 -800 400 800 -400 9 -900 450 900 -450 10 -1000 500 1000 -500","title":"Recorder\n"},{"location":"developer/extending/component/","text":"Compiling Inside each module-level CMakeLists.txt file there is a function call with the form: target_sources ( OPS_Module PRIVATE <some source files>... PUBLIC <some header files>... ) Simple materials and elements can be added to the CMake build simply by including them in the relevant CMake target_sources call. For example, a new element might be implemented in a file called ElasticFoo.cpp with header ElasticFoo.h in the directory OpenSees/SRC/element/ . These files would simply need to be added to the function call target_sources(OPS_Element ...) in the file OpenSees/SRC/element/CMakeLists.txt .","title":"Compiling\n"},{"location":"developer/extending/element/","text":"Internal CMake use New Elements The ASDEmbeddedNodeElement has been added with the following files: SRC/element/CEqElement/ASDEmbeddedNodeElement.h SRC/element/CEqElement/ASDEmbeddedNodeElement.cpp Create SRC/element/CEqElement/CMakeLists.txt Append to SRC/element/CMakeLists.txt Append to /Conf.cmake Optionally OPSDEF_ELEMENT_CEQ","title":"New Elements\n"},{"location":"gallery/","text":"Gallery .grid.cards>:-webkit-any(ul,ol) { display: contents !important; } ul { list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } .grid { grid-gap: .4rem; display: grid !important; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .grid>.card { text-size-adjust: none; -webkit-font-smoothing: antialiased; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; box-sizing: inherit; grid-gap: .4rem; display: grid; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .li { text-size-adjust: none; --md-text-font: \"Roboto\"; --md-code-font: \"Roboto Mono\"; -webkit-font-smoothing: antialiased; --md-text-font-family: var(--md-text-font,_),-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif; --md-code-font-family: var(--md-code-font,_),SFMono-Regular,Consolas,Menlo,monospace; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); --md-default-fg-color: rgba(0,0,0,.87); --md-default-fg-color--light: rgba(0,0,0,.54); --md-default-fg-color--lighter: rgba(0,0,0,.32); --md-default-fg-color--lightest: rgba(0,0,0,.07); --md-default-bg-color: #fff; --md-default-bg-color--light: hsla(0,0%,100%,.7); --md-default-bg-color--lighter: hsla(0,0%,100%,.3); --md-default-bg-color--lightest: hsla(0,0%,100%,.12); --md-shadow-z1: 0 0.2rem 0.5rem rgba(0,0,0,.05),0 0 0.05rem rgba(0,0,0,.1); --md-shadow-z2: 0 0.2rem 0.5rem rgba(0,0,0,.1),0 0 0.05rem rgba(0,0,0,.25); --md-shadow-z3: 0 0.2rem 0.5rem rgba(0,0,0,.2),0 0 0.05rem rgba(0,0,0,.35); --md-typeset-table-sort-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m18 21-4-4h3V7h-3l4-4 4 4h-3v10h3M2 19v-2h10v2M2 13v-2h7v2M2 7V5h4v2H2Z\"/></svg>'); --md-typeset-table-sort-icon--asc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 17h3l-4 4-4-4h3V3h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-typeset-table-sort-icon--desc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7h3l-4-4-4 4h3v14h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-toc-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2Z\"/></svg>'); --md-search-result-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h7c-.41-.25-.8-.56-1.14-.9-.33-.33-.61-.7-.86-1.1H6V4h7v5h5v1.18c.71.16 1.39.43 2 .82V8l-6-6m6.31 16.9c1.33-2.11.69-4.9-1.4-6.22-2.11-1.33-4.91-.68-6.22 1.4-1.34 2.11-.69 4.89 1.4 6.22 1.46.93 3.32.93 4.79.02L22 23.39 23.39 22l-3.08-3.1m-3.81.1a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5Z\"/></svg>'); --md-source-forks-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M5 3.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm0 2.122a2.25 2.25 0 1 0-1.5 0v.878A2.25 2.25 0 0 0 5.75 8.5h1.5v2.128a2.251 2.251 0 1 0 1.5 0V8.5h1.5a2.25 2.25 0 0 0 2.25-2.25v-.878a2.25 2.25 0 1 0-1.5 0v.878a.75.75 0 0 1-.75.75h-4.5A.75.75 0 0 1 5 6.25v-.878zm3.75 7.378a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm3-8.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5z\"/></svg>'); --md-source-repositories-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2 2.5A2.5 2.5 0 0 1 4.5 0h8.75a.75.75 0 0 1 .75.75v12.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 1 1 0-1.5h1.75v-2h-8a1 1 0 0 0-.714 1.7.75.75 0 0 1-1.072 1.05A2.495 2.495 0 0 1 2 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 0 1 1-1h8zM5 12.25v3.25a.25.25 0 0 0 .4.2l1.45-1.087a.25.25 0 0 1 .3 0L8.6 15.7a.25.25 0 0 0 .4-.2v-3.25a.25.25 0 0 0-.25-.25h-3.5a.25.25 0 0 0-.25.25z\"/></svg>'); --md-source-stars-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25zm0 2.445L6.615 5.5a.75.75 0 0 1-.564.41l-3.097.45 2.24 2.184a.75.75 0 0 1 .216.664l-.528 3.084 2.769-1.456a.75.75 0 0 1 .698 0l2.77 1.456-.53-3.084a.75.75 0 0 1 .216-.664l2.24-2.183-3.096-.45a.75.75 0 0 1-.564-.41L8 2.694v.001z\"/></svg>'); --md-source-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2.5 7.775V2.75a.25.25 0 0 1 .25-.25h5.025a.25.25 0 0 1 .177.073l6.25 6.25a.25.25 0 0 1 0 .354l-5.025 5.025a.25.25 0 0 1-.354 0l-6.25-6.25a.25.25 0 0 1-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.75 1.75 0 0 1 1 7.775zM6 5a1 1 0 1 0 0 2 1 1 0 0 0 0-2z\"/></svg>'); --md-tag-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m5.41 21 .71-4h-4l.35-2h4l1.06-6h-4l.35-2h4l.71-4h2l-.71 4h6l.71-4h2l-.71 4h4l-.35 2h-4l-1.06 6h4l-.35 2h-4l-.71 4h-2l.71-4h-6l-.71 4h-2M9.53 9l-1.06 6h6l1.06-6h-6Z\"/></svg>'); --md-tooltip-width: 20rem; --md-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 320 512\"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d=\"m310.6 246.6-127.1 128c-7.1 6.3-15.3 9.4-23.5 9.4s-16.38-3.125-22.63-9.375l-127.1-128C.224 237.5-2.516 223.7 2.438 211.8S19.07 192 32 192h255.1c12.94 0 24.62 7.781 29.58 19.75s3.12 25.75-6.08 34.85z\"/></svg>'); --md-footnotes-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.42L5.83 13H21V7h-2Z\"/></svg>'); --md-details-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42Z\"/></svg>'); --md-tasklist-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-tasklist-icon--checked: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-accent-fg-color: #526cfe; --md-accent-fg-color--transparent: rgba(82,108,254,.1); --md-accent-bg-color: #fff; --md-accent-bg-color--light: hsla(0,0%,100%,.7); --md-primary-fg-color: #4051b5; --md-primary-fg-color--light: #5d6cc0; --md-primary-fg-color--dark: #303fa1; --md-primary-bg-color: #fff; --md-primary-bg-color--light: hsla(0,0%,100%,.7); --md-code-fg-color: #36464e; --md-code-bg-color: #f5f5f5; --md-code-hl-color: rgba(255,255,0,.5); --md-code-hl-number-color: #d52a2a; --md-code-hl-special-color: #db1457; --md-code-hl-function-color: #a846b9; --md-code-hl-constant-color: #6e59d9; --md-code-hl-keyword-color: #3f6ec6; --md-code-hl-string-color: #1c7d4d; --md-code-hl-name-color: var(--md-code-fg-color); --md-code-hl-operator-color: var(--md-default-fg-color--light); --md-code-hl-punctuation-color: var(--md-default-fg-color--light); --md-code-hl-comment-color: var(--md-default-fg-color--light); --md-code-hl-generic-color: var(--md-default-fg-color--light); --md-code-hl-variable-color: var(--md-default-fg-color--light); --md-typeset-color: var(--md-default-fg-color); --md-typeset-a-color: var(--md-primary-fg-color); --md-typeset-mark-color: rgba(255,255,0,.5); --md-typeset-del-color: rgba(245,80,61,.15); --md-typeset-ins-color: rgba(11,213,112,.15); --md-typeset-kbd-color: #fafafa; --md-typeset-kbd-accent-color: #fff; --md-typeset-kbd-border-color: #b8b8b8; --md-typeset-table-color: rgba(0,0,0,.12); --md-admonition-fg-color: var(--md-default-fg-color); --md-admonition-bg-color: var(--md-default-bg-color); --md-footer-fg-color: #fff; --md-footer-fg-color--light: hsla(0,0%,100%,.7); --md-footer-fg-color--lighter: hsla(0,0%,100%,.3); --md-footer-bg-color: rgba(0,0,0,.87); --md-footer-bg-color--dark: rgba(0,0,0,.32); --md-mermaid-font-family: var(--md-text-font-family),sans-serif; --md-mermaid-edge-color: var(--md-code-fg-color); --md-mermaid-node-bg-color: var(--md-accent-fg-color--transparent); --md-mermaid-node-fg-color: var(--md-accent-fg-color); --md-mermaid-label-bg-color: var(--md-default-bg-color); --md-mermaid-label-fg-color: var(--md-code-fg-color); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; list-style-type: disc; box-sizing: inherit; border: .05rem solid var(--md-default-fg-color--lightest); border-radius: .1rem; display: block; margin: 0; padding: .8rem; transition: border .25s,box-shadow .25s; } Basic Structures Install mkdocs-material with pip and get up and running in minutes Getting started Components Studies Focus on your content and generate a responsive and searchable static site Reference Geotech Change the colors, fonts, language, icons, logo and more with a few lines Customization Continua Material for MkDocs is licensed under MIT and available on GitHub License","title":"Gallery\n"},{"location":"gallery/BasicPrimer/","text":"Basic Structures Basic Truss Concrete Frame Learn more \u2026or other spreadsheet programs will find that many of the concepts are transferrable to pandas. Three Dimensional Frame Frank McKenna and Michael Scott Pacific Earthquake Engineering Research Center University of California, Berkeley August 20, 2001 Version 1.2","title":"Basic Structures\n"},{"location":"gallery/BasicPrimer/example_1/","text":"Simple Truss The first example is a simple truss structure. The purpose of this example is to show that model generation in OpenSees can resemble typical finite element analysis programs with the definition of nodes, materials, elements, loads and constraints. The example also demonstrates how an analysis object is \u2018built\u2019 from component objects. Example 1.1 \u2013 Linear elasticity This example is of a linear-elastic three bar truss, as shown in figure example1 , subject to static loads. Example1.1.tcl The model consists of four nodes, three truss elements, a single load pattern with a nodal load acting at node 4, and constraints at the three support nodes. Since the truss elements have the same elastic material, a single Elastic material object is created. Example 1.1 The model is linear, so we use a solution Algorithm of type Linear . Even though the solution is linear, we have to select a procedure for applying the load, which is called an Integrator . For this problem, a LoadControl integrator advances the solution. The equations are formed using a banded system, so the System is BandSPD (banded, symmetric positive definite). This is a good choice for most moderate size models. The equations have to be numbered, so typically an RCM numberer object is used (for Reverse Cuthill-McKee). The constraints are most easily represented with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used. When the analysis is complete the state of node 4 and all three elements will be printed to the screen. Nothing is recorded for later use. The Tcl script for the example is shown below. A comment is indicated by a # symbol. In the comments below, the syntax for important commands are given. Tcl source # OpenSees Example 1.1 # OpenSees Primer # # Units: kips, in, sec # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 2 DOF/node) model BasicBuilder -ndm 2 -ndf 2 # Create nodes # ------------ # Create nodes & add to Domain - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 # Define materials for truss elements # ----------------------------------- # Create Elastic material prototype - command: uniaxialMaterial Elastic matID E uniaxialMaterial Elastic 1 3000 # Define elements # --------------- # Create truss elements - command: element truss trussID node1 node2 A matID element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 # Define loads # ------------ # Create a Plain load pattern with a linear TimeSeries pattern Plain 1 \"Linear\" { # Create the nodal load - command: load nodeID xForce yForce load 4 100 -50 } # End of model generation # ------------------------------ # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a SPD using a band storage scheme system BandSPD # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the constraint handler, a Plain handler is used as homo constraints constraints Plain # Create the integration scheme, the LoadControl scheme using steps of 1.0 integrator LoadControl 1.0 # Create the solution algorithm, a Linear algorithm is created algorithm Linear # create the analysis object analysis Static # End of analysis generation # ------------------------------ # ------------------------------ # Start of recorder generation # ------------------------------ # create a Recorder object for the nodal displacements at node 4 recorder Node -file example.out -load -node 4 -dof 1 2 disp # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Perform the analysis analyze 1 # Print the current state at node 4 and at all elements print node 4 print ele Node: 4 Coordinates : 72 96 commitDisps: 0.530093 -0.177894 unbalanced Load: 100 -50 Element: 1 type: Truss iNode: 1 jNode: 4 Area: 10 Total Mass: 0 strain: 0.00146451 axial load: 43.9352 unbalanced load: -26.3611 -35.1482 26.3611 35.1482 Material: Elastic tag: 1 E: 3000 eta: 0 Element: 2 type: Truss iNode: 2 jNode: 4 Area: 5 Total Mass: 0 strain: -0.00383642 axial load: -57.5463 unbalanced load: -34.5278 46.0371 34.5278 -46.0371 Material: Elastic tag: 1 E: 3000 eta: 0 Element: 3 type: Truss iNode: 3 jNode: 4 Area: 5 Total Mass: 0 strain: -0.00368743 axial load: -55.3114 unbalanced load: -39.1111 39.1111 39.1111 -39.1111 Material: Elastic tag: 1 E: 3000 eta: 0 For the node, displacements and loads are given. For the truss elements, the axial strain and force are provided along with the resisting forces in the global coordinate system. The file example.out , specified in the recorder command, provides the nodal displacements for the x and y directions of node 4. The file consists of a single line of code: 1.0 0.530093 -0.177894 The \\(1.0\\) corresponds to the load factor (pseudo time) in the model at which point the recorder was invoked. The \\(0.530093\\) and \\(-0.177894\\) correspond to the response at node \\(4\\) for the 1 and 2 degree-of-freedom. Note that if more analysis steps had been peformed, the line would contain a line for every analysis step that completed successfully.","title":"Simple Truss\n"},{"location":"gallery/BasicPrimer/example_3/","text":"Portal Frame Examples This next set of examples covers the nonlinear analysis of a reinforced concrete frame. The nonlinear beam column element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, the if-then-else control structure, and procedures are demonstrated in several elaborations of the example. Example 3.1 This example is of a reinforced concrete portal frame, as shown in figure [example3] , subject to gravity loads. Example3.1.tcl A nonlinear model of the portal frame shown in figure [example3] is created. The model consists of four nodes, two nonlinear beam-column elements, 1 and 2, to model the columns and an elastic beam element, 3, to model the beam. For the column elements a section, identical to the section used in Example 2, is created using steel and concrete fibers. Example 3.1 A single load pattern with a linear time series, two vertical nodal loads acting at nodes 3 and 4, and single point constraints to constrain nodes 1 and 2 are created. The model contains material non-linearities, so a solution algorithm of type Newton is used. The solution algorithm uses a ConvergenceTest which tests convergence of the equilibrium solution with the norm of the displacement increment vector. For this nonlinear problem, the gravity loads are applied incrementally until the full load is applied. To achieve this, a LoadControl integrator which advances the solution with an increment of 0.1 at each load step is used. The equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used. To achieve the full gravity load, 10 load steps are performed. At end of analysis, the state at nodes 3 and 4 is output. The state of element 1 is also output. # OpenSees Example 3.1 # OpenSees Primer # # Units: kips, in, sec # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 3 DOF/node) model basic -ndm 2 -ndf 3 # Create nodes # ------------ # Set parameters for overall model geometry set width 360 set height 144 # Create nodes # tag X Y node 1 0.0 0.0 node 2 $width 0.0 node 3 0.0 $height node 4 $width $height # Fix supports at base of columns # tag DX DY RZ fix 1 1 1 1 fix 2 1 1 1 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 - 6.0 - 0.004 - 5.0 - 0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 - 5.0 - 0.002 0.0 - 0.006 # STEEL # Reinforcing steel set fy 60.0 ; # Yield stress set E 30000.0 ; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $fy $E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some paramaters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60 ; # area of no. 7 bars # some variables derived from the parameters set y1 [expr $colDepth / 2.0 ] set z1 [expr $colWidth / 2.0 ] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [expr $cover - $y1 ] [expr $cover - $z1 ] [expr $y1 - $cover ] [expr $z1 - $cover ] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [expr - $y1 ] [expr $z1 - $cover ] $y1 $z1 patch rect 2 10 1 [expr - $y1 ] [expr - $z1 ] $y1 [expr $cover - $z1 ] patch rect 2 2 1 [expr - $y1 ] [expr $cover - $z1 ] [expr $cover - $y1 ] [expr $z1 - $cover ] patch rect 2 2 1 [expr $y1 - $cover ] [expr $cover - $z1 ] $y1 [expr $z1 - $cover ] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $As [expr $y1 - $cover ] [expr $z1 - $cover ] [expr $y1 - $cover ] [expr $cover - $z1 ] layer straight 3 2 $As 0.0 [expr $z1 - $cover ] 0.0 [expr $cover - $z1 ] layer straight 3 3 $As [expr $cover - $y1 ] [expr $z1 - $cover ] [expr $cover - $y1 ] [expr $cover - $z1 ] } # Define column elements # ---------------------- # Geometry of column elements # tag geomTransf Linear 1 # Number of integration points along length of element set np 5 # Create the coulumns using Beam-column elements # tag ndI ndJ nsecs secID transfTag element nonlinearBeamColumn 1 1 3 $np 1 1 element nonlinearBeamColumn 2 2 4 $np 1 1 # Define beam elment # ----------------------------- # Geometry of column elements # tag geomTransf Linear 2 # Create the beam element # tag ndI ndJ A E Iz transfTag element elasticBeamColumn 3 3 4 360 4030 8640 2 # Define gravity loads # -------------------- # Set a parameter for the axial load set P 180 ; # 10% of axial capacity of columns # Create a Plain load pattern with a Linear TimeSeries pattern Plain 1 \"Linear\" { # Create nodal loads at nodes 3 & 4 # nd FX FY MZ load 3 0.0 [expr - $P ] 0.0 load 4 0.0 [expr - $P ] 0.0 } # ------------------------------ # End of model generation # ------------------------------ # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a sparse solver with partial pivoting system BandGeneral # Create the constraint handler, the transformation method constraints Transformation # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0e-12 10 3 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, the LoadControl scheme using steps of 0.1 integrator LoadControl 0.1 # Create the analysis object analysis Static # initialize in case we need to do an initial stiffness iteration initialize # ------------------------------ # End of analysis generation # ------------------------------ # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node -file nodeGravity.out -time -node 3 4 -dof 1 2 3 disp # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # perform the gravity load analysis, requires 10 steps to reach the load level analyze 10 # Print out the state of nodes 3 and 4 print node 3 4 # Print out the state of element 1 print ele 1 2 Node: 3 Coordinates : 0 144 commitDisps: 1.7109e-18 -0 .0183736 -2 .81893e-20 unbalanced Load: 0 -180 0 ID : 3 4 5 Node: 4 Coordinates : 360 144 commitDisps: 1.71095e-18 -0 .0183736 -2 .79765e-20 unbalanced Load: 0 -180 0 ID : 0 1 2 Element: 1 Type: NLBeamColumn2d Connected Nodes: 1 3 Number of Sections: 5 Mass density: 0 End 1 Forces (P V M): 180 7.0121e-31 -8 .88178e-16 End 2 Forces (P V M): -180 -7 .0121e-31 8.88178e-16 Element: 2 Type: NLBeamColumn2d Connected Nodes: 2 4 Number of Sections: 5 Mass density: 0 End 1 Forces (P V M): 180 0 -8 .88178e-16 End 2 Forces (P V M): -180 0 8.88178e-16 For the two nodes, displacements and loads are given. For the beam-column elements, the element end forces in the local system are provided. The nodeGravity.out file contains ten lines, each line containing 7 entries. The first entry is time in the domain at end of the load step. The next 3 entries are the displacements at node 3, and the final 3 entries the displacements at node 4. Example 3.2 In this example the nonlinear reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a pushover analysis. Example3.2.tcl Example3.1.tcl After performing the gravity load analysis on the model, the time in the domain is reset to 0.0 and the current value of all loads acting are held constant. A new load pattern with a linear time series and horizontal loads acting at nodes 3 and 4 is then added to the model. The static analysis used to perform the gravity load analysis is modified to take a new DisplacementControl integrator. At each new step in the analysis the integrator will determine the load increment necessary to increment the horizontal displacement at node 3 by 0.1 in. 60 analysis steps are performed in this new analysis. For this analysis the nodal displacements at nodes 3 and 4 will be stored in the file nodePushover.out for post-processing. In addition, the end forces in the local coordinate system for elements 1 and 2 will be stored in the file elePushover.out. At the end of the analysis, the state of node 3 is printed to the screen. # OpenSees Example 3.2 # OpenSees Primer # # Units: kips, in, sec # ---------------------------------------------------- # Start of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # Do operations of Example3.1 by sourcing in the tcl file source Example3. 1. tcl puts ``Gravity load analysis completed'' # Set the gravity loads to be constant & reset the time in the domain loadConst -time 0.0 # ---------------------------------------------------- # End of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # ---------------------------------------------------- # Start of additional modeling for lateral loads # ---------------------------------------------------- # Define lateral loads # -------------------- # Set some parameters set H 10.0 ; # Reference lateral load # Set lateral load pattern with a Linear TimeSeries pattern Plain 2 \"Linear\" { # Create nodal loads at nodes 3 & 4 # nd FX FY MZ load 3 $H 0.0 0.0 load 4 $H 0.0 0.0 } # ---------------------------------------------------- # End of additional modeling for lateral loads # ---------------------------------------------------- # ---------------------------------------------------- # Start of modifications to analysis for push over # ---------------------------------------------------- # Set some parameters set dU 0.1 ; # Displacement increment # Change the integration scheme to be displacement control # node dof init Jd min max integrator DisplacementControl 3 1 $dU 1 $dU $dU # ---------------------------------------------------- # End of modifications to analysis for push over # ---------------------------------------------------- # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node -file node32.out -time -node 3 4 -dof 1 2 3 disp # Create a recorder to monitor element forces in columns recorder Element -file ele32.out -time -ele 1 2 localForce # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Set some parameters set maxU 6.0 ; # Max displacement set numSteps [expr int( $maxU / $dU ) ] # Perform the analysis analyze $numSteps puts ``Pushover analysis completed'' # Print the state at node 3 print node 3 Gravity load analysis completed Setting time in domain to be : 0.0 Pushover analysis completed Node: 3 Coordinates : 0 144 commitDisps: 6 0.488625 -0 .00851377 unbalanced Load: 71.8819 -180 0 In addition to what is displayed on the screen, the file node32.out and ele32.out have been created by the script. Each line of node32.out contains the time, DX, DY and RZ for node 3 and DX, DY and RZ for node 4 at the end of an iteration. Each line of eleForce.out contains the time, and the element end forces in the local coordinate system. A plot of the load-displacement relationship at node 3 is shown in figure [lateral32] . Load displacement curve for node 3 Example 3.3 In this example the reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a uniform earthquake excitation. Example3.3.tcl Example3.1.tcl ReadSMDFile.tcl After performing the gravity load analysis, the time in the domain is reset to 0.0 and the current value of all active loads is set to constant. Mass terms are added to nodes 3 and 4. A new uniform excitation load pattern is created. The excitation acts in the horizontal direction and reads the acceleration record and time interval from the file ARL360.g3 . The file ARL360.g3 is created from the PEER Strong Motion Database (http://peer.berkeley.edu/smcat/) record ARL360.at2 using the Tcl procedure ReadSMDFile contained in the file ReadSMDFile.tcl . The static analysis object and its components are first deleted so that a new transient analysis object can be created. A new solution Algorithm of type Newton is then created. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the displacement increment vector. The integrator for this analysis will be of type Newmark with a \\(\\gamma\\) of 0.25 and a \\(\\beta\\) of 0.5. The integrator will add some stiffness proportional damping to the system, the damping term will be based on the last committed stifness of the elements, i.e. \\(C = a_c K_{commit}\\) with \\(a_c = 0.000625\\) . The equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 time steps are performed with a time step of 0.01. In addition to the transient analysis, two eigenvalue analysis are performed on the model. The first is performed after the gravity analysis and the second after the transient analysis. For this analysis the nodal displacenments at Nodes 3 and 4 will be stored in the file nodeTransient.out for post-processing. In addition the section forces and deformations for the section at the base of column 1 will also be stored in two seperate files. The results of the eigenvalue analysis will be displayed on the screen. # OpenSees Example 3.3 # OpenSees Primer # # Units: kips, in, sec # ---------------------------------------------------- # Start of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # Do operations of Example3.1 by sourcing in the tcl file source Example3. 1. tcl puts \"Gravity load analysis completed\" # Set the gravity loads to be constant & reset the time in the domain loadConst -time 0.0 # ---------------------------------------------------- # End of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # ---------------------------------------------------- # Start of additional modeling for dynamic loads # ---------------------------------------------------- # Define nodal mass in terms of axial load on columns set g 386.4 set m [expr $P / $g ] ; # expr command to evaluate an expression # tag MX MY RZ mass 3 $m $m 0 mass 4 $m $m 0 # Define dynamic loads # -------------------- # Set some parameters set outFile ARL360.g3 set accelSeries \"Path -filePath $ outFile -dt $ dt -factor $ g\" # Source in TCL proc to read a PEER Strong Motion Database record source ReadSMDFile.tcl # Perform the conversion from SMD record to OpenSees record and obtain dt # inFile outFile dt ReadSMDFile ARL360.at2 $outFile dt # Create UniformExcitation load pattern # tag dir pattern UniformExcitation 2 1 -accel $accelSeries # set the rayleigh damping factors for nodes & elements rayleigh 0.0 0.0 0.0 0.000625 # ---------------------------------------------------- # End of additional modeling for dynamic loads # ---------------------------------------------------- # --------------------------------------------------------- # Start of modifications to analysis for transient analysis # --------------------------------------------------------- # Delete the old analysis and all its component objects wipeAnalysis # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0e-12 10 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, Newmark with gamma = 0.5 and beta = 0.25 integrator Newmark 0.5 0.25 # Create the system of equation, a banded general storage scheme system BandGeneral # Create the constraint handler, a plain handler as homogeneous boundary conditions constraints Plain # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the analysis object analysis Transient # --------------------------------------------------------- # End of modifications to analysis for transient analysis # --------------------------------------------------------- # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node -time -file node33.out -node 3 4 -dof 1 2 3 disp # Create recorders to monitor section forces and deformations # at the base of the left column recorder Element -time -file ele1secForce.out -ele 1 section 1 force recorder Element -time -file ele1secDef.out -ele 1 section 1 deformation # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Perform an eigenvalue analysis puts \"eigen values at start of transient: [eigen 2]\" # set some variables set tFinal [expr 2000 * 0.01 ] set tCurrent [ getTime ] set ok 0 # Perform the transient analysis while { $ok == 0 && $tCurrent < $tFinal } { set ok [ analyze 1 . 01 ] # if the analysis fails try initial tangent iteration if { $ok != 0 } { puts \"regular newton failed .. lets try an initail stiffness for this step\" test NormDispIncr 1.0e-12 100 0 algorithm ModifiedNewton -initial set ok [ analyze 1 . 01 ] if { $ok == 0 } {puts \"that worked .. back to regular newton\" } test NormDispIncr 1.0e-12 10 algorithm Newton } set tCurrent [ getTime ] } # Print a message to indicate if analysis succesfull or not if { $ok == 0 } { puts \"Transient analysis completed SUCCESSFULLY\" ; } else { puts \"Transient analysis completed FAILED\" ; } # Perform an eigenvalue analysis puts \"eigen values at end of transient: [eigen 2]\" # Print state of node 3 print node 3 Gravity load analysis completed eigen values at start of transient: 2.695422e+02 1.750711e+04 Transient analysis completed SUCCESSFULLY eigen values at start of transient: 1.578616e+02 1.658481e+04 Node: 3 Coordinates : 0 144 commitDisps: -0.0464287 -0.0246641 0.000196066 Velocities : -0.733071 1.86329e-05 0.00467983 commitAccels: -9.13525 0.277302 38.2972 unbalanced Load: -3.9475 -180 0 Mass : 0.465839 0 0 0 0.465839 0 0 0 0 Eigenvectors: -1.03587 -0.0482103 -0.00179081 0.00612275 0.00663473 3.21404e-05 The two eigenvalues for the eigenvalue analysis are printed to the screen. The state of node 3 at the end of the analysis is also printed. The information contains the last committed displacements, velocities and accelerations at the node, the unbalanced nodal forces and the nodal masses. In addition, the eigenvector components of the eigenvector pertaining to the node 3 is also displayed. In addition to the contents displayed on the screen, three files have been created. Each line of nodeTransient.out contains the domain time, and DX, DY and RZ for node 3. Plotting the first and second columns of this file the lateral displacement versus time for node 3 can be obtained as shown in figure [lateral33] . Each line of the files ele1secForce.out and ele1secDef.out contain the domain time and the forces and deformations for section 1 (the base section) of element 1. These can be used to generate the moment-curvature time history of the base section of column 1 as shown in figure [element1MK] . Lateral displacement at node 3 Column section moment-curvature results","title":"Portal Frame Examples\n"},{"location":"gallery/BasicPrimer/example_4/","text":"Multibay Two Story Frame In this next example the use of variable substitution and the Tcl loop control structure for building models is demonstrated. Example 4.1 This example is of a reinforced concrete multibay two story frame, as shown in figure [example4] , subject to gravity loads. Example4.1.tcl A model of the frame shown in figure example4 is created. The number of objects in the model is dependent on the parameter numBay. The \\((\\) numBay \\(+1)*3)\\) nodes are created, one column line at a time, with the node at the base of the columns fixed in all directions. Three materials are constructed, one for the concrete core, one for the concrete cover and one for the reinforcement steel. Three fiber discretized sections are then built, one for the exterior columns, one for the interior columns and one for the girders. Each of the members in the frame is modelled using nonlinear beam-column elements with 4 (nP) integration points and a linear geometric transformation object. For gravity loads, a single load pattern with a linear time series and two vertical nodal loads acting at the first and second floor nodes of each column line is used. The load at the lower level is twice that of the upper level and the load on the interior columns is twice that of the exterior columns. For the lateral load analysis, a second load pattern with a linear time series is introduced after the gravity load analysis. Associated with this load pattern are two nodal loads acting on nodes 2 and 3, with the load level at node 3 twice that acting at node 2. A solution Algorithm of type Newton is created. The solution algorithm uses a ConvergenceTest based on the norm of the displacement increment vector. The integrator for the analysis will be LoadControl with a load step increment of 0.1. The storage for the system of equations is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once the components of the analysis have been defined, the analysis object is then created. For this problem a Static analysis object is used and 10 steps are performed to load the model with the desired gravity load. After the gravity load analysis has been performed, the gravity loads are set to constant and the time in the domain is reset to 0.0. A new LoadControl integrator is now added. The new LoadControl integrator has an initial load step of 1.0, but this can vary between 0.02 and 2.0 depending on the number of iterations required to achieve convergence at each load step. 100 steps are then performed. For the pushover analysis the lateral displacements at nodes 2 and 3 will be stored in the file Node41.out for post-processing. In addition, if the variable displayMode is set to \u201cdisplayON\u201d the load-displacement curve for horizontal displacements at node 3 will be displayed in a window on the user\u2019s terminal. # OpenSees Example 4.1 # OpenSees Primer # # Units: kips, in, sec # Parameter identifying the number of bays set numBay 3 # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 3 DOF/node) model BasicBuilder -ndm 2 -ndf 3 # Create nodes # ------------ # Set parameters for overall model geometry set bayWidth 288 set nodeID 1 # Define nodes for {set i 0} {$i <= $numBay} {incr i 1} { set xDim [expr $i * $bayWidth] # tag X Y node $nodeID $xDim 0 node [expr $nodeID+1] $xDim 180 node [expr $nodeID+2] $xDim 324 incr nodeID 3 } # Fix supports at base of columns for {set i 0} {$i <= $numBay} {incr i 1} { # node DX DY RZ fix [expr $i*3+1] 1 1 1 } # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE # Cover concrete # tag -f'c -epsco -f'cu -epscu uniaxialMaterial Concrete01 1 -4.00 -0.002 0.0 -0.006 # Core concrete uniaxialMaterial Concrete01 2 -5.20 -0.005 -4.70 -0.02 # STEEL # Reinforcing steel # tag fy E0 b uniaxialMaterial Steel01 3 60 30000 0.02 # Define cross-section for nonlinear columns # ------------------------------------------ # Interior column section - Section A section Fiber 1 { # mat nfIJ nfJK yI zI yJ zJ yK zK yL zL patch quadr 2 1 12 -11.5 10 -11.5 -10 11.5 -10 11.5 10 patch quadr 1 1 14 -13.5 -10 -13.5 -12 13.5 -12 13.5 -10 patch quadr 1 1 14 -13.5 12 -13.5 10 13.5 10 13.5 12 patch quadr 1 1 2 -13.5 10 -13.5 -10 -11.5 -10 -11.5 10 patch quadr 1 1 2 11.5 10 11.5 -10 13.5 -10 13.5 10 # mat nBars area yI zI yF zF layer straight 3 6 1.56 -10.5 9 -10.5 -9 layer straight 3 6 1.56 10.5 9 10.5 -9 } # Exterior column section - Section B section Fiber 2 { patch quadr 2 1 10 -10 10 -10 -10 10 -10 10 10 patch quadr 1 1 12 -12 -10 -12 -12 12 -12 12 -10 patch quadr 1 1 12 -12 12 -12 10 12 10 12 12 patch quadr 1 1 2 -12 10 -12 -10 -10 -10 -10 10 patch quadr 1 1 2 10 10 10 -10 12 -10 12 10 layer straight 3 6 0.79 -9 9 -9 -9 layer straight 3 6 0.79 9 9 9 -9 } # Girder section - Section C section Fiber 3 { patch quadr 1 1 12 -12 9 -12 -9 12 -9 12 9 layer straight 3 4 1.00 -9 9 -9 -9 layer straight 3 4 1.00 9 9 9 -9 } # Define column elements # ---------------------- # Number of integration points set nP 4 # Geometric transformation geomTransf Linear 1 set beamID 1 # Define elements for {set i 0} {$i <= $numBay} {incr i 1} { # set some parameters set iNode [expr $i*3 + 1] set jNode [expr $i*3 + 2] for {set j 1} {$j < 3} {incr j 1} { # add the column element (secId == 2 if external, 1 if internal column) if {$i == 0} { element nonlinearBeamColumn $beamID $iNode $jNode $nP 2 1 } elseif {$i == $numBay} { element nonlinearBeamColumn $beamID $iNode $jNode $nP 2 1 } else { element nonlinearBeamColumn $beamID $iNode $jNode $nP 1 1 } # increment the parameters incr iNode 1 incr jNode 1 incr beamID 1 } } # Define beam elements # ---------------------- # Number of integration points set nP 4 # Geometric transformation geomTransf Linear 2 # Define elements for {set j 1} {$j < 3} {incr j 1} { # set some parameters set iNode [expr $j + 1] set jNode [expr $iNode + 3] for {set i 1} {$i <= $numBay} {incr i 1} { element nonlinearBeamColumn $beamID $iNode $jNode $nP 3 2 # increment the parameters incr iNode 3 incr jNode 3 incr beamID 1 } } # Define gravity loads # -------------------- # Constant gravity load set P -192 # Create a Plain load pattern with a Linear TimeSeries pattern Plain 1 Linear { # Create nodal loads at nodes for {set i 0} {$i <= $numBay} {incr i 1} { # set some parameters set node1 [expr $i*3 + 2] set node2 [expr $node1 + 1] if {$i == 0} { load $node1 0.0 $P 0.0 load $node2 0.0 [expr $P/2.0] 0.0 } elseif {$i == $numBay} { load $node1 0.0 $P 0.0 load $node2 0.0 [expr $P/2.0] 0.0 } else { load $node1 0.0 [expr 2.0*$P] 0.0 load $node2 0.0 $P 0.0 } } } # ------------------------------ # End of model generation # ------------------------------ # ------------------------------------------------ # Start of analysis generation for gravity analysis # ------------------------------------------------- # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0e-8 10 0 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, the LoadControl scheme using steps of 0.1 integrator LoadControl 0.1 1 0.1 0.1 # Create the system of equation, a SPD using a profile storage scheme system BandGeneral # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the constraint handler, the transformation method constraints Plain # Create the analysis object analysis Static # ------------------------------------------------ # End of analysis generation for gravity analysis # ------------------------------------------------- # ------------------------------ # Perform gravity load analysis # ------------------------------ # perform the gravity load analysis, requires 10 steps to reach the load level analyze 10 # set gravity loads to be const and set pseudo time to be 0.0 # for start of lateral load analysis loadConst -time 0.0 # ------------------------------ # Add lateral loads # ------------------------------ # Reference lateral load for pushover analysis set H 10 # Reference lateral loads # Create a Plain load pattern with a Linear TimeSeries pattern Plain 2 Linear { load 2 [expr $H/2.0] 0.0 0.0 load 3 $H 0.0 0.0 } # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder which writes to Node.out and prints # the current load factor (pseudo-time) and dof 1 displacements at node 2 & 3 recorder Node -file Node41.out -time -node 2 3 -dof 1 disp # Source in some commands to display the model # comment out one of lines set displayMode \"displayON\" #set displayMode \"displayOFF\" if {$displayMode == \"displayON\"} { # a window to plot the nodal displacements versus load for node 3 recorder plot Node41.out Node_3_Xdisp 10 340 300 300 -columns 3 1 -dT 0.1 } # ------------------------------ # End of recorder generation # ------------------------------ # ------------------------------ # Start of lateral load analysis # ------------------------------ # Change the integrator to take a min and max load increment integrator LoadControl 1.0 4 0.02 2.0 # Perform the analysis # Perform the pushover analysis # Set some parameters set maxU 10.0; # Max displacement set controlDisp 0.0; set ok 0; while {$controlDisp < $maxU && $ok == 0} { set ok [analyze 1] set controlDisp [nodeDisp 3 1] if {$ok != 0} { puts \"... trying an initial tangent iteration with Newton\" test NormDispIncr 1.0e-8 4000 0 algorithm ModifiedNewton -initial set ok [analyze 1] test NormDispIncr 1.0e-8 10 0 algorithm Newton } } if {$ok != 0} { puts \"Pushover analysis FAILED\" } else { puts \"Pushover analysis completed SUCCESSFULLY\" } The output consists of the file Node41.out containing a line for each step of the lateral load analysis. Each line contains the load factor, the lateral displacements at nodes 2 and 3. A plot of the load-displacement curve for the frame is given in figure [twostory] .","title":"Multibay Two Story Frame\n"},{"location":"gallery/BasicPrimer/example_5/","text":"Three-Dimensional Rigid Frame Example 5.1 This example is of a three-dimensional reinforced concrete rigid frame, as shown in figure [example5] , subjected to bi-directional earthquake ground motion. Example5.1.tcl RCsection.tcl tabasFN.txt tabasFP.txt A model of the rigid frame shown in figure [example5] is created. The model consists of three stories and one bay in each direction. Rigid diaphragm multi-point constraints are used to enforce the rigid in-plane stiffness assumption for the floors. Gravity loads are applied to the structure and the 1978 Tabas acceleration records are the uniform earthquake excitations. Nonlinear beam column elements are used for all members in the structure. The beam sections are elastic while the column sections are discretized by fibers of concrete and steel. Elastic beam column elements may have been used for the beam members; but, it is useful to see that section models other than fiber sections may be used in the nonlinear beam column element. Example 5.1 A solution Algorithm of type Newton is used for the nonlinear problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. The integrator for this analysis will be of type Newmark with a \\(\\gamma\\) of 0.25 and a \\(\\beta\\) of 0.5. Due to the presence of the multi-point constraints, a Transformation constraint handler is used. The equations are formed using a sparse storage scheme which will perform pivoting during the equation solving, so the System is SparseGeneral. As SparseGeneral will perform it\u2019s own internal numbering of the equations, a Plain numberer is used which simply assigns equation numbers to the degrees-of-freedom. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 steps are performed with a time step of 0.01. The nodal displacements at nodes 9, 14, and 19 (the retained nodes for the rigid diaphragms) will be stored in the file node51.out for post-processing. # OpenSees Example 5.1 # OpenSees Primer # # Units: kips, in, sec # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model BasicBuilder -ndm 3 -ndf 6 # Define geometry # --------------- # Set parameters for model geometry set h 144.0; # Story height set by 240.0; # Bay width in Y-direction set bx 240.0; # Bay width in X-direction # Create nodes # tag X Y Z node 1 [expr -$bx/2] [expr $by/2] 0 node 2 [expr $bx/2] [expr $by/2] 0 node 3 [expr $bx/2] [expr -$by/2] 0 node 4 [expr -$bx/2] [expr -$by/2] 0 node 5 [expr -$bx/2] [expr $by/2] $h node 6 [expr $bx/2] [expr $by/2] $h node 7 [expr $bx/2] [expr -$by/2] $h node 8 [expr -$bx/2] [expr -$by/2] $h node 10 [expr -$bx/2] [expr $by/2] [expr 2*$h] node 11 [expr $bx/2] [expr $by/2] [expr 2*$h] node 12 [expr $bx/2] [expr -$by/2] [expr 2*$h] node 13 [expr -$bx/2] [expr -$by/2] [expr 2*$h] node 15 [expr -$bx/2] [expr $by/2] [expr 3*$h] node 16 [expr $bx/2] [expr $by/2] [expr 3*$h] node 17 [expr $bx/2] [expr -$by/2] [expr 3*$h] node 18 [expr -$bx/2] [expr -$by/2] [expr 3*$h] # Retained nodes for rigid diaphragm # tag X Y Z node 9 0 0 $h node 14 0 0 [expr 2*$h] node 19 0 0 [expr 3*$h] # Set base constraints # tag DX DY DZ RX RY RZ fix 1 1 1 1 1 1 1 fix 2 1 1 1 1 1 1 fix 3 1 1 1 1 1 1 fix 4 1 1 1 1 1 1 # Define rigid diaphragm multi-point constraints # normalDir retained constrained rigidDiaphragm 3 9 5 6 7 8 rigidDiaphragm 3 14 10 11 12 13 rigidDiaphragm 3 19 15 16 17 18 # Constraints for rigid diaphragm retained nodes # tag DX DY DZ RX RY RZ fix 9 0 0 1 1 1 0 fix 14 0 0 1 1 1 0 fix 19 0 0 1 1 1 0 # Define materials for nonlinear columns # -------------------------------------- # CONCRETE # Core concrete (confined) # tag f'c epsc0 f'cu epscu uniaxialMaterial Concrete01 1 -5.0 -0.005 -3.5 -0.02 # Cover concrete (unconfined) set fc 4.0 uniaxialMaterial Concrete01 2 -$fc -0.002 0.0 -0.006 # STEEL # Reinforcing steel # tag fy E b uniaxialMaterial Steel01 3 60 30000 0.02 # Column width set d 18.0 # Source in a procedure for generating an RC fiber section source RCsection.tcl # Call the procedure to generate the column section # id h b cover core cover steel nBars area nfCoreY nfCoreZ nfCoverY nfCoverZ RCsection 1 $d $d 2.5 1 2 3 3 0.79 8 8 10 10 # Concrete elastic stiffness set E [expr 57000.0*sqrt($fc*1000)/1000]; # Column torsional stiffness set GJ 1.0e10; # Linear elastic torsion for the column uniaxialMaterial Elastic 10 $GJ # Attach torsion to the RC column section # tag uniTag uniCode secTag section Aggregator 2 10 T -section 1 set colSec 2 # Define column elements # ---------------------- #set PDelta \"ON\" set PDelta \"OFF\" # Geometric transformation for columns if {$PDelta == \"ON\"} { # tag vecxz geomTransf LinearWithPDelta 1 1 0 0 } else { geomTransf Linear 1 1 0 0 } # Number of column integration points (sections) set np 4 # Create the nonlinear column elements # tag ndI ndJ nPts secID transf element nonlinearBeamColumn 1 1 5 $np $colSec 1 element nonlinearBeamColumn 2 2 6 $np $colSec 1 element nonlinearBeamColumn 3 3 7 $np $colSec 1 element nonlinearBeamColumn 4 4 8 $np $colSec 1 element nonlinearBeamColumn 5 5 10 $np $colSec 1 element nonlinearBeamColumn 6 6 11 $np $colSec 1 element nonlinearBeamColumn 7 7 12 $np $colSec 1 element nonlinearBeamColumn 8 8 13 $np $colSec 1 element nonlinearBeamColumn 9 10 15 $np $colSec 1 element nonlinearBeamColumn 10 11 16 $np $colSec 1 element nonlinearBeamColumn 11 12 17 $np $colSec 1 element nonlinearBeamColumn 12 13 18 $np $colSec 1 # Define beam elements # -------------------- # Define material properties for elastic beams # Using beam depth of 24 and width of 18 # -------------------------------------------- set Abeam [expr 18*24]; # \"Cracked\" second moments of area set Ibeamzz [expr 0.5*1.0/12*18*pow(24,3)]; set Ibeamyy [expr 0.5*1.0/12*24*pow(18,3)]; # Define elastic section for beams # tag E A Iz Iy G J section Elastic 3 $E $Abeam $Ibeamzz $Ibeamyy $GJ 1.0 set beamSec 3 # Geometric transformation for beams # tag vecxz geomTransf Linear 2 1 1 0 # Number of beam integration points (sections) set np 3 # Create the beam elements # tag ndI ndJ nPts secID transf element nonlinearBeamColumn 13 5 6 $np $beamSec 2 element nonlinearBeamColumn 14 6 7 $np $beamSec 2 element nonlinearBeamColumn 15 7 8 $np $beamSec 2 element nonlinearBeamColumn 16 8 5 $np $beamSec 2 element nonlinearBeamColumn 17 10 11 $np $beamSec 2 element nonlinearBeamColumn 18 11 12 $np $beamSec 2 element nonlinearBeamColumn 19 12 13 $np $beamSec 2 element nonlinearBeamColumn 20 13 10 $np $beamSec 2 element nonlinearBeamColumn 21 15 16 $np $beamSec 2 element nonlinearBeamColumn 22 16 17 $np $beamSec 2 element nonlinearBeamColumn 23 17 18 $np $beamSec 2 element nonlinearBeamColumn 24 18 15 $np $beamSec 2 # Define gravity loads # -------------------- # Gravity load applied at each corner node # 10% of column capacity set p [expr 0.1*$fc*$h*$h] # Mass lumped at retained nodes set g 386.4; # Gravitational constant set m [expr (4*$p)/$g] # Rotary inertia of floor about retained node set i [expr $m*($bx*$bx+$by*$by)/12.0] # Set mass at the retained nodes # tag MX MY MZ RX RY RZ mass 9 $m $m 0 0 0 $i mass 14 $m $m 0 0 0 $i mass 19 $m $m 0 0 0 $i # Define gravity loads pattern Plain 1 Constant { foreach node {5 6 7 8 10 11 12 13 15 16 17 18} { load $node 0.0 0.0 -$p 0.0 0.0 0.0 } } # Define earthquake excitation # ---------------------------- # Set up the acceleration records for Tabas fault normal and fault parallel set tabasFN \"Path -filePath tabasFN.txt -dt 0.02 -factor $g\" set tabasFP \"Path -filePath tabasFP.txt -dt 0.02 -factor $g\" # Define the excitation using the Tabas ground motion records # tag dir accel series args pattern UniformExcitation 2 1 -accel $tabasFN pattern UniformExcitation 3 2 -accel $tabasFP # ----------------------- # End of model generation # ----------------------- # ---------------------------- # Start of analysis generation # ---------------------------- # Create the convergence test # tol maxIter printFlag test EnergyIncr 1.0e-8 20 3 # Create the solution algorithm algorithm Newton # Create the system of equation storage and solver system SparseGeneral -piv # Create the constraint handler constraints Transformation # Create the time integration scheme # gamma beta integrator Newmark 0.5 0.25 # Create the DOF numberer numberer RCM # Create the transient analysis analysis Transient # -------------------------- # End of analysis generation # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- # Record DOF 1 and 2 displacements at nodes 9, 14, and 19 recorder Node -file node51.out -time -node 9 14 19 -dof 1 2 disp # -------------------------- # End of recorder generation # -------------------------- # -------------------- # Perform the analysis # -------------------- # Analysis duration of 20 seconds # numSteps dt analyze 2000 0.01 The results consist of the file node.out, which contains a line for every time step. Each line contains the time and the horizontal and vertical displacements at the diaphragm retained nodes (9, 14 and 19) i.e. time Dx9 Dy9 Dx14 Dy14 Dx19 Dy19. The horizontal displacement time history of the first floor diaphragm node 9 is shown in figure [example4disp] . Notice the increase in period after about 10 seconds of earthquake excitation, when the large pulse in the ground motion propogates through the structure. The displacement profile over the three stories shows a soft-story mechanism has formed in the first floor columns. The numerical solution converges even though the drift is \\(\\approx 20 \\%\\) . The inclusion of P-Delta effects shows structural collapse under such large drifts.","title":"Three-Dimensional Rigid Frame\n"},{"location":"gallery/continuua/example_6/","text":"Simply Supported Beam In this example a simple problem in solid dynamics is considered. The structure is a simply supported beam modelled with two dimensional solid elements. Example6.1.tcl For two dimensional analysis, a typical solid element is defined as a volume in two dimensional space. Each node of the analysis has two displacement degrees of freedom. Thus the model is defined with \\(ndm := 2\\) and \\(ndf := 2\\) . pp For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4} are prescribed to define the two dimensional domain of the beam, which is of size \\(40\\times10\\) . Three possible quadrilateral elements can be used for the analysis. These may be created using the terms \u201cbbarQuad,\u201d \u201cenhancedQuad\u201d or \u201cquad.\u201d This is a plane strain problem. An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and two vertical nodal loads are used. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Ten static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic -ndm 2 -ndf 2 # create the material nDMaterial ElasticIsotropic 1 1000 0.25 6.75 # Define geometry # --------------- # define some parameters set Quad quad set Quad bbarQuad set Quad enhancedQuad if {$Quad == \"enhancedQuad\" } { set eleArgs \"PlaneStrain2D 1\" } if {$Quad == \"quad\" } { set eleArgs \"1 PlaneStrain2D 1\" } if {$Quad == \"bbarQuad\" } { set eleArgs \"1\" } set nx 8; # NOTE: nx MUST BE EVEN FOR THIS EXAMPLE set ny 2 set bn [expr $nx + 1 ] set l1 [expr $nx/2 + 1 ] set l2 [expr $l1 + $ny*($nx+1) ] # now create the nodes and elements using the block2D command block2D $nx $ny 1 1 $Quad $eleArgs { 1 0 0 2 40 0 3 40 10 4 0 10 } # Single point constraints # node u1 u2 fix 1 1 1 fix $bn 0 1 # Gravity loads pattern Plain 1 Linear { load $l1 0.0 -1.0 load $l2 0.0 -1.0 } # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-12 10 0 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 10 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node -file Node.out -time -node $l1 -dof 2 disp recorder plot Node.out CenterNodeDisp 625 10 625 450 -columns 1 2 # create the display recorder display SimplySupportedBaam 10 10 800 200 -wipe prp 20 5.0 100.0 vup 0 1 0 viewWindow -30 30 -10 10 display 10 0 5 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-12 10 0 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (50 sec) # numSteps dt analyze 100 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the bottom center of the beam. The time history is shown in figure [beamdisp] .","title":"Simply Supported Beam\n"},{"location":"gallery/continuua/example_7/","text":"Dynamic Shell Analysis In this example a simple problem in shell dynamics is considered. The structure is a curved hoop shell structure that looks like the roof of a Safeway. Example7.1.tcl For shell analysis, a typical shell element is defined as a surface in three dimensional space. Each node of a shell analysis has six degrees of freedom, three displacements and three rotations. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 6\\) . For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4, 5,7,9} are defined such that the structure is curved in three dimensional space. The OpenSees shell element is constructed using the command \u201cShellMITC4\u201d. An elastic membrane-plate material section model, appropriate for shell analysis, is constructed using the \u201cElasticMembranePlateSection\u201d command. In this case, the elastic modulus \\(E := 3.0e3\\) , Poisson\u2019s ratio \\(\\nu := 0.25\\) , the thickness \\(h := 1.175\\) and the mass density per unit volume \\(\\rho := 1.27\\) For initial gravity load analysis, a single load pattern with a linear time series and three vertical nodal loads are used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1, 0,1,1}. All degrees-of-freedom are fixed except rotation about the x-axis, which is free. The same boundary conditions are applied where the z-coordinate is \\(40.0\\) . A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(250\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- model basic -ndm 3 -ndf 6 # create the material section ElasticMembranePlateSection 1 3.0e3 0.25 1.175 1.27 # set some parameters for node and element generation set Plate ShellMITC4 set eleArgs \"1\" #these should both be even set nx 8 set ny 2 #loaded nodes set mid [expr ( ($nx+1)*($ny+1)+1 ) / 2 ] set side1 [expr ($nx + 2)/2 ] set side2 [expr ($nx+1)*($ny+1) - $side1 + 1 ] # generate the nodes and elements block2D $nx $ny 1 1 $Plate $eleArgs { 1 -20 0 0 2 -20 0 40 3 20 0 40 4 20 0 0 5 -10 10 20 7 10 10 20 9 0 10 20 } # add some loads pattern Plain 1 Linear { load $mid 0.0 -0.5 0.0 0.0 0.0 0.0 load $side1 0.0 -0.25 0.0 0.0 0.0 0.0 load $side2 0.0 -0.25 0.0 0.0 0.0 0.0 } # define the boundary conditions # rotation free about x-axis (remember right-hand-rule) fixZ 0.0 1 1 1 0 1 1 fixZ 40.0 1 1 1 0 1 1 # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system SparseGeneral -piv #system ProfileSPD # Analysis for gravity load #analysis Transient analysis Static # Perform the gravity load analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node -file Node.out -time -node $mid -dof 2 disp recorder plot Node.out CenterNodeDisp 625 10 625 450 -columns 1 2 recorder display shellDynamics 10 10 600 600 -wipe prp -100 20 30 vup 0 1 0 display 1 0 100 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain #integrator GeneralizedMidpoint 0.50 integrator Newmark 0.50 0.25 analysis Transient # Perform the transient analysis analyze 250 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the upper center of the hoop structure. The time history is shown in figure [shelldisp] .","title":"Dynamic Shell Analysis\n"},{"location":"gallery/continuua/example_8/","text":"Cantilever Beam In this example a simple problem in solid dynamics is considered. The structure is a cantilever beam modelled with three dimensional solid elements. Example8.1.tcl For three dimensional analysis, a typical solid element is defined as a volume in three dimensional space. Each node of the analysis has three displacement degrees of freedom. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 3\\) . For this model, a mesh is generated using the \u201cblock3D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) , the number of nodes in the local y-direction of the block is \\(ny\\) and the number of nodes in the local z-direction of the block is \\(nz\\) . The block3D generation nodes {1,2,3,4,5,6,7,8} are prescribed to define the three dimensional domain of the beam, which is of size \\(2\\times2\\times10\\) . Two possible brick elements can be used for the analysis. These may be created using the terms stdBrick or bbarBrick . An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and a single nodal loads is used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1} , fully fixed. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 2.0\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic -ndm 3 -ndf 3 # create the material nDMaterial ElasticIsotropic 1 100 0.25 1.27 # Define geometry # --------------- # define some parameters set eleArgs \"1\" set element stdBrick #set element BbarBrick set nz 6 set nx 2 set ny 2 set nn [expr ($nz+1)*($nx+1)*($ny+1) ] # mesh generation block3D $nx $ny $nz 1 1 $element $eleArgs { 1 -1 -1 0 2 1 -1 0 3 1 1 0 4 -1 1 0 5 -1 -1 10 6 1 -1 10 7 1 1 10 8 -1 1 10 } set load 0.10 # Constant point load pattern Plain 1 Linear { load $nn $load $load 0.0 } # boundary conditions fixZ 0.0 1 1 1 # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test NormUnbalance 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node -file Node.out -time -node $nn -dof 1 disp recorder plot Node.out CenterNodeDisp 625 10 625 450 -columns 1 2 recorder display ShakingBeam 0 0 300 300 -wipe prp -100 100 120.5 vup 0 1 0 display 1 0 1 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # add some mass proportional damping rayleigh 0.01 0.0 0.0 0.0 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (20 sec) # numSteps dt analyze 100 2.0 } The results consist of the file cantilever.out, which contains a line for every time step. Each line contains the time and the horizontal displacement at the upper right corner the beam. The time history is as plotted on the screen. figure [cantileverdisp] .","title":"Cantilever Beam\n"},{"location":"gallery/geotech/","text":"Geotechnical Examples","title":"Geotechnical Examples\n"},{"location":"gallery/geotech/02_StaticPile/","text":"Laterally-Loaded Pile Example prepared by: Christopher McGann and Pedro Arduino, University of Washington This article describes the OpenSees implementation of a simple laterally-loaded pile example. The problem is modeled as a beam on a nonlinear Winkler foundation (BNWF), utilizing displacement-based beam elements for the pile and nonlinear spring elements which represent the vertical and lateral response of the surrounding soil. This example considers a static analysis only. Provided with this article are the files needed to execute this analysis in OpenSees; the main input file, staticBNWFpile.tcl three procedures to define the soil constitutive behavior, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl a file to define the pile section behavior, elasticPileSection.tcl Download them all in a compressed file: staticBNWFanalysis.zip To run this example, the user must download each of the above files and place them in a single directory. Once this has been done, the user can then type \"source staticBNWFpile.tcl\" into the interpreter of the OpenSees.exe application to run the analysis. Representative results are presented in this article to verify the correct implementation of this example. Additionally, the pile response obtained from this analysis is compared to a similar analysis conducted using the commercial program LPile (http://www.ensoftinc.com) to provide verification the results of the OpenSees analysis. Model Description Fig 1. Schematic representation of the BNWF model. The BNWF model simulates the laterally-loaded pile problem using displacement-based beam elements to represent the pile and a series of nonlinear springs to represent the soil. The soil springs are generated using zero-length elements assigned separate uniaxial material objects in the lateral and vertical directions. An idealized schematic of the laterally-loaded pile model is provided in Fig. 1. The pile axis is oriented in the z-coordinate direction, and all of the nodes are initially located on the z-axis (x- and y- coordinates are zero). Node numbering for each set of nodes begins at the bottom of the pile. The model is created with three separate sets of nodes: fixed spring nodes (numbers 1-85 in example) slave spring nodes (numbers 101-185 in example) pile nodes (numbers 201-285 in example) Geometry and Mesh The geometry is rather simple in this example. There is only a single layer of cohesionless soil, and the groundwater table is assumed to be well below the tip of the pile. The pile geometry controls the meshing of the problem. The user can specify the length of the pile head (above the ground surface), L1, and the embedded pile length (below the ground surface), L2. The default values in staticBNWFpile.tcl are L1 = 1 m, and L2 = 20 m. The pile is also assigned a diameter of 1 m. This value is used in the soil constitutive modeling. The mesh is defined by the number of elements specified in the pile. The default value in this example is 84 elements (85 nodes). For the default pile geometry, this results in 80 elements over the embedded length and 4 elements above the ground surface. Note: The input file is only set up to handle up to 100 nodes. Modifications would need to be made to the node numbering scheme to accommodate a larger number of nodes. Spring Nodes The spring nodes are created with three dimensions and three translational degrees-of-freedom. The input file is set up to automatically generate the necessary spring nodes and elements based upon the input geometry (pile head length, $L1 , embedded length, $L2 , and number of pile elements, $nElePile ). Spring nodes are only created over the embedded length of pile. Since zero-length elements are used for the springs, the two sets of nodes share the same set of locations. One set of spring nodes, the fixed-nodes, are initially fixed in all three degrees-of-freedom. The other set of nodes, the slave nodes, are initially fixed in only two degrees-of-freedom, and are later given equal degrees-of-freedom with the pile nodes. Spring Constitutive Behavior The constitutive behavior of the springs is defined such that the springs oriented in the lateral direction represent p-y springs, and the vertically-oriented springs represent t-z and Q-z springs for the pile shaft and tip, respectively. Three procedures are used to properly define the p-y/t-z/Q-z behavior with depth, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl Several input soil properties are necessary to define these springs: soil unit weight, $gamma soil internal friction angle, $phi soil shear modulus, $Gsoil The default values are set at $gamma = 17 kN/m 3 , $phi = 36 degrees, and $Gsoil = 150000 kPa. The procedure get_pyParam.tcl , which defines the p-y springs, has several options which must be selected. The first switch, $puSwitch, specifies the variation in ultimate lateral resistance with depth. The default, $puSwitch = 1, uses the recommendations of the American Petroleum Institute (API) (1993). The alternative method is that of Brinch Hansen (1961). The second switch, $kSwitch, specifies the variation in initial stiffness with depth. The default, $kSwitch = 1, specifies a linear variation of initial stiffness with depth (API 1993). The alternative uses a modified version of the API stiffness which varies parabolically with depth after Boulanger et al. (2003). The presence of groundwater can be accounted for in the initial stiffness using the third switch, $gwtSwitch. Default, $gwtSwitch = 1, is for no groundwater. The other procedures, get_tzParam.tcl and get_qzParam.tcl , have no input options in this example. The t-z springs have behavior defined using the work of Mosher (1984) and Kulhawy (1991). The Q-z behavior is based on the work of Meyerhof (1976), Vijayvergiya (1977), and Kulhawy and Mayne (1990). The p-y spring constitutive behavior is obtained using the PySimple1 uniaxial material object. The t-z and Q-z springs are defined using the TzSimple1 and QzSimple1 uniaxial materials, respectively. The main input file is set up to automatically generate the required spring material objects based upon the input geometry and soil properties. Spring Elements Zero-length elements are used for the soil springs using the element zeroLength . These elements connect the fixed and slave spring nodes. The the PySimple1 material objects are incorporated in the x-direction (direction of loading), while the TzSimple1 , and at the pile tip, the QzSimple1 , material objects are incorporated in the z-direction (vertical direction). Pile Nodes The pile nodes are created with three dimensions and six degrees-of-freedom (3 translational, 3 rotational). The input file is set up to automatically generate the necessary pile nodes and elements based upon the input geometry. A linear coordinate-transformation object is specified for the orientation of the pile in this example. With the exemption of the uppermost pile head node, the pile nodes are fixed against translation in the y-direction and rotations about the x- and z- axes. The pile head node, where the load is applied, is separated to allow the user to specify a free-head (no rotational fixity) or fixed-head (full rotational fixity) condition at the loading point. The pile nodes over the embedded length of the pile are use linked with the slave spring nodes using the equalDOF command. The pile nodes are the master nodes in this example. These two sets of nodes share equal degrees-of-freedom in the x- and z- translational directions only. Pile Constitutive Behavior and Elements In this example, the pile is given elastic behavior for simplicity. Instead of using the elasticBeamColumn element, this is done using an elastic section object in conjunction with the displacement-based beam element, dispBeamColumn . This was done to facilitate future incorporation of elastoplastic pile section behavior using fiber section models by the user. The properties of the elastic section for this example are defined in the file, elasticPileSection.tcl . The pile is defined with appropriately computed values for the cross-sectional area and the moments of inertia for its 1 m diameter, and is assigned a modulus of elasticity, E = 25000000, and shear modulus, G = 9615385. Recorders Several recorders are defined for this model. The displacements at the pile nodes in all three translational dof are recorded for use in extracting the displaced shape of the pile. The reaction forces in the p-y springs are recorded for use in visualizing the lateral soil response. The element forces in the pile elements are recorded in order to obtain shear and moment diagrams for the pile. The recorders are set up to only record values at 0.5 second increments of pseudo-time during the analysis to facilitate the use of smaller load steps. This is done with the variable $timeStep. A display recorder is included in the input file to allow the user to visualize the deformation of the pile in \"real time\" during the analysis. The parameters are set up for the orientation of the pile in this example. Loading This example considers a 3500 kN load applied in the positive x-direction at the head of the pile (uppermost pile node). This is accomplished in the model using a plain pattern with optional time-series parameters. The load increases linearly from 0 kN to 3500 kN over a 10 second increment of pseudo-time (between 10 and 20 seconds) and is then held constant after the loading period. Setting up the loading object in this manner allows for more control over the analysis. Analysis The analysis is conducted using the load-controlled integrator with a loading step of 0.05. This value is selected based on the 10 second interval specified in the loading object. 200 steps with a loading step of 0.05 will put the last step exactly at 10 seconds of pseudo-time. 201 steps are used in this example to make sure that the last recorded step is at the full loading magnitude. The variables $startT and $endT are used to print the cpu time needed to complete the analysis in the standard output or the OpenSees interpreter. The remaining analysis commands are well-documented in the OpenSees command manual. Representative Results Fig. 2 Lateral soil response after application of full lateral load. A user can verify their downloaded files by running the main input file, staticBNWFpile.tcl , in OpenSees and comparing the recorded results to some representative results included here. The simplest verification is to use the spring reaction forces recorded in the file reaction.out. A plot of the recorded spring reaction forces vs. depth in the final recorded pseudo-time step (20.05) should create something similar to that shown in Fig. 2. The response is negative from the ground surface to about 7.5 m deep, then transitions to positive until about 13 m deep, has a second smaller negative section, and then is nearly zero near the tip of the pile. This verification plot can be made fairly simply using spreadsheet software. For those who prefer Matlab (http://www.mathworks.com/), the following lines will extract the desired information when pasted into an m-file. % create depth vector depth = linspace(-20,1,85); % load data react = load('reaction.out'); % remove pseudo-time information react(:,1) = []; % create plotting variable (divide by tributary area of pile to get force/length) reactPlot = react(end,:)/0.25; plot(reactPlot,depth) The shear and moment diagram plots in the following section can also be used for verification purposes. Comparison of OpenSees Results with LPile Fig. 3 Comparison of OpenSees and LPile analyses for free-head case. Fig. 4 Comparison of OpenSees and LPile analyses for fixed-head case. The commercial pile analysis program LPile (http://www.ensoftinc.com) is used to verify the results obtained using the OpenSees laterally-loaded pile model. The LPile analysis used the same geometric and constitutive parameters defined in the OpenSees analysis, and two cases were considered: A free-head case where there is no rotational fixity about the y-axis at the pile head A fixed-head case where full rotational fixity is enforced at the pile head. The two analysis methods are compared via the recorded pile and soil responses. Figs. 3 and 4 present these comparisons for the free-head and fixed-head cases, respectively. Shown in these figures are the shear and moment diagrams, displaced pile shapes, and the lateral soil response recorded from each analysis. As shown, the LPile and OpenSees results are fairly similar, especially for the free-head case. The main reason for the differences shown in Figs. 3 and 4 is that the p-y curves used in LPile are not the same as those used in the OpenSees analysis. The LPile curves are defined using the method of Reese et al. (1974), while the backbone of the p-y curves for the PySimple1 uniaxial material approximate the API (1993) recommendations. These two sets of curves are similar, and in fact have identical initial and ultimate responses, however, they vary in form over intermediate displacements. This is shown in Fig. 5, which plots the actual p-y response obtained in the OpenSees simulation alongside the p-y curves used by LPile for several depths. As shown, the hyperbolic tangent curves recommended by the API do not match those used by LPile, especially for displacements between approximately 0.001 and 0.037 m. The force returned by the PySimple1 material object for displacements in this range will therefore be greater than corresponding forces used by LPile. This is confirmed by the soil response comparison plots in Figs. 3 and 4. Where the pile displacements are large, the LPile and OpenSees soil reactions are nearly identical, but as the displacements become smaller with increasing depth, the recorded soil reactions begin to differ. This difference in lateral soil response is the main reason behind the small variability observed in the recorded shear and moment diagrams and displaced shapes. [ Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.](pyComp.png \u201d Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.\u201d) Overall, the agreement between the OpenSees and LPile analyses verifies that the BNWF model implemented in OpenSees is capable of returning sensible results for laterally-loaded pile simulations. There are differences between the results, however, these are relatively minor. The OpenSees simulation predicts maximum pile shear, moment, and deflection demands which are similar to those obtained from LPile, and the discrepancies are attributable to known differences between the two analysis methods. References 1. American Petroleum Institute (API) (1987). Recommended Practice for Planning, Designing and Constructing Fixed Offshore Platforms. API Recommended Practice 2A(RP-2A), Washington D.C, 17th edition. 2. Brinch Hansen, J. (1961). \u201cThe ultimate resistance of rigid piles against transversal forces.\u201d Bulletin No. 12, Geoteknisk Institute, Copenhagen, 59. 3. Boulanger, R. W., Kutter, B. L., Brandenberg, S. J., Singh, P., and Chang, D. (2003). Pile Foundations in liquefied and laterally spreading ground during earthquakes: Centrifuge experiments and analyses. Center for Geotechnical Modeling, University of California at Davis, Davis, CA. Rep. UCD/CGM-03/01. 4. Kulhawy, F.H. (1991). \"Drilled shaft foundations.\" Foundation engineering handbook, 2nd Ed., Chap 14, H.-Y. Fang ed., Van Nostrand Reinhold, New York. 5. Kulhawy, F.H. and Mayne, P.W. (1990). Manual on Estimating Soil Properties for Foundation Design. Electrical Power Research Institute. EPRI EL-6800, Project 1493-6 Final Report. 6. Meyerhof G.G. (1976). \"Bearing capacity and settlement of pile foundations.\" J. Geotech. Eng. Div., ASCE, 102(3), 195-228. 7. Mosher, R.L. (1984). \u201cLoad transfer criteria for numerical analysis of axial loaded piles in sand.\u201d U.S. Army Engineering and Waterways Experimental Station, Automatic Data Processing Center, Vicksburg, Miss. 8. Reese, L.C. and Van Impe, W.F. (2001), Single Piles and Pile Groups Under Lateral Loading. A.A. Balkema, Rotterdam, Netherlands. 9. Vijayvergiya, V.N. (1977). \u201cLoad-movement characteristics of piles.\u201d Proc., Ports 77 Conf., ASCE, New York.","title":"Laterally-Loaded Pile"},{"location":"gallery/sections/section_building/","text":"/home/claudio/brace/Scripts/SectionRegions/Tests_2.ipynb","title":"Damage Monitoring Tools\n"},{"location":"gallery/sections/section_limits/","text":"Elastic Limits /home/claudio/projects/SectionEccentricity/SectionLimits-3D.ipynb","title":"Elastic Limits\n"},{"location":"gallery/sections/MomentCurvature/","text":"Moment-Curvature (Concrete) This next example covers the moment-curvature analysis of a reinforced concrete section. The zero-length element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, and procedures are demonstrated. Example 2.1 In this example, a moment-curvature analysis of the fiber section is undertaken. Figure [rcsection4] shows the fiber discretization for the section. Example2.1.tcl MomentCurvature.tcl The model consists of two nodes and a ZeroLengthSection element. A depiction of the element geometry is shown in figure [zerolength] . The drawing on the left of figure [zerolength] shows an edge view of the element where the local z-axis, as seen on the right side of the figure and in figure [rcsection0] , is coming out of the page. Node 1 is completely restrained, while the applied loads act on node 2. A compressive axial load, P, of 180 kips is applied to the section during the moment-curvature analysis. For the zero length element, a section discretized by concrete and steel is created to represent the resultant behavior. UniaxialMaterial objects are created to define the fiber stress-strain relationships: confined concrete in the column core, unconfined concrete in the column cover, and reinforcing steel. The dimensions of the fiber section are shown in figure [rcsection0] . The section depth is 24 inches, the width is 15 inches, and there are 1.5 inches of cover around the entire section. Strong axis bending is about the section z-axis. In fact, the section z-axis is the strong axis of bending for all fiber sections in planar problems. The section is separated into confined and unconfined concrete regions, for which separate fiber discretizations will be generated. Reinforcing steel bars will be placed around the boundary of the confined and unconfined regions. The fiber discretization for the section is shown in figure [rcsection4] . ::: {.center} ::: The section analysis is performed by the Tcl procedure MomentCurvature defined in the file MomentCurvature.tcl. The arguments to the procedure are the tag of the section to be analyzed, the axial load applied to the section, the maximum curvature, and the number of displacement increments to reach the maximum curvature. The output for the moment-curvature analysis will be the section forces and deformations, stored in the file section1.out. In addition, an estimate of the section yield curvature is printed to the screen. In the script below variables, are set and can then be used with the syntax of $variable . Expressions can be evaluated, although the Tcl syntax at first appears cumbersome. An expression is given by an expr command enclosed in square brackets [] \u2019s. Typically, the result of an expression is then set to another variable. A simple example to add 2.0 to a parameter is shown below: set v 3.0 set sum [expr $v + 2.0 ] puts $sum ; # print the sum Comments with # can appear on the same line as a command, but then the command must be terminated with a semi-colon. # OpenSees Example 2.1 # OpenSees Primer # # Units: kips, in, sec # Define model builder # -------------------- model BasicBuilder -ndm 2 -ndf 3 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 -6.0 -0.004 -5.0 -0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 -5.0 -0.002 0.0 -0.006 # STEEL # Reinforcing steel set fy 60.0; # Yield stress set E 30000.0; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $fy $E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some parameters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60; # area of no. 7 bars # some variables derived from the parameters set y1 [expr $colDepth/2.0] set z1 [expr $colWidth/2.0] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [expr $cover-$y1] [expr $cover-$z1] [expr $y1-$cover] [expr $z1-$cover] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [expr -$y1] [expr $z1-$cover] $y1 $z1 patch rect 2 10 1 [expr -$y1] [expr -$z1] $y1 [expr $cover-$z1] patch rect 2 2 1 [expr -$y1] [expr $cover-$z1] [expr $cover-$y1] [expr $z1-$cover] patch rect 2 2 1 [expr $y1-$cover] [expr $cover-$z1] $y1 [expr $z1-$cover] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $As [expr $y1-$cover] [expr $z1-$cover] [expr $y1-$cover] [expr $cover-$z1] layer straight 3 2 $As 0.0 [expr $z1-$cover] 0.0 [expr $cover-$z1] layer straight 3 3 $As [expr $cover-$y1] [expr $z1-$cover] [expr $cover-$y1] [expr $cover-$z1] } # Estimate yield curvature # (Assuming no axial load and only top and bottom steel) set d [expr $colDepth-$cover] ;# d -- from cover to rebar set epsy [expr $fy/$E] ;# steel yield strain set Ky [expr $epsy/(0.7*$d)] # Print estimate to standard output puts \"Estimated yield curvature: $Ky\" # Set axial load set P -180 set mu 15; # Target ductility for analysis set numIncr 100; # Number of analysis increments # Call the section analysis procedure source MomentCurvature.tcl MomentCurvature 1 $P [expr $Ky*$mu] $numIncr The Tcl procedure to perform the moment-curvature analysis follows. In this procedure, the nodes are defined to be at the same geometric location and the ZeroLengthSection element is used. A single load step is performed for the axial load, then the integrator is changed to DisplacementControl to impose nodal displacements, which map directly to section deformations. A reference moment of 1.0 is defined in a Linear time series. For this reference moment, the DisplacementControl integrator will determine the load factor needed to apply the imposed displacement. A node recorder is defined to track the moment-curvature results. The load factor is the moment, and the nodal rotation is in fact the curvature of the element with zero thickness. # Arguments # secTag -- tag identifying section to be analyzed # axialLoad -- axial load applied to section (negative is compression) # maxK -- maximum curvature reached during analysis # numIncr -- number of increments used to reach maxK (default 100) # # Sets up a recorder which writes moment-curvature results to file # section$secTag.out ... the moment is in column 1, and curvature in column 2 proc MomentCurvature {secTag axialLoad maxK {numIncr 100} } { # Define two nodes at (0,0) node 1 0.0 0.0 node 2 0.0 0.0 # Fix all degrees of freedom except axial and bending at node 2 fix 1 1 1 1 fix 2 0 1 0 # Define element # tag ndI ndJ secTag element zeroLengthSection 1 1 2 $secTag # Create recorder recorder Node -file section$secTag.out -time -node 2 -dof 3 disp # Define constant axial load pattern Plain 1 \"Constant\" { load 2 $axialLoad 0.0 0.0 } # Define analysis parameters integrator LoadControl 0 1 0 0 system SparseGeneral -piv; test NormUnbalance 1.0e-9 10 numberer Plain constraints Plain algorithm Newton analysis Static # Do one analysis for constant axial load analyze 1 # Define reference moment pattern Plain 2 \"Linear\" { load 2 0.0 0.0 1.0 } # Compute curvature increment set dK [expr $maxK/$numIncr] # Use displacement control at node 2 for section analysis integrator DisplacementControl 2 3 $dK 1 $dK $dK # Do the section analysis analyze $numIncr } Estimated yield curvature: 0.000126984126984 The file section1.out contains for each committed state a line with the load factor and the rotation at node 3. This can be used to plot the moment-curvature relationship as shown in figure [momcurv] .","title":"Moment-Curvature (Concrete)"},{"location":"gallery/sections/example_9/","text":"Section Building For the case of the uniaxial section, moment-curvature and axial force-deformation curves are defined independently, and numerically. For the case of the fiber sections (steel and RC), uniaxial materials are defined numerically (stress-strain relationship) and are combined into a fiber section where moment-curvature and axial force-deformation characteristics and their interaction are calculated computationally. 2D vs. 3D While this distinction does not affect the section definition itself, it affects the degree-of-freedom associated with moment and curvature in the subsequent analysis. There are two differences between the two models: The space defined with the model command (Defining the model builder, ndm=#dimension ndf=#dofs ) In the 3D model, torsional stiffness needs to be aggregated to the section. Uniaxial Section Notes Flexure and axial behavior are uncoupled in this type of section Fiber Section: AISC Standard W Section Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Unconfined Concrete Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Confined Concrete Core Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Section Notes Coupled biaxial flexure and axial behavior generic rectangular section Fiber Section: Reinforced Concrete Section \u2013 Circular Section, Confined Core Notes Coupled biaxial flexure and axial behavior generic circular section Fiber Section: Reinforced Concrete Hollow Section \u2013 Symmetric Section, Confined Concrete Notes Coupled biaxial flexure and axial behavior Moment-Curvature Analysis This example introduces the moment-curvature procedures for sections in 2D or 3D space, as built in the previous section. (the only difference between them is the degree-of-freedom corresponding to curvature). The moment-curvature analysis of a section is by creating a zero-length rotational-spring element. This section is subjected to a user-defined constant axial load and to a linearly-increasing moment to a user-defined maximum curvature. 2D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature2D.tcl MomentCurvature2D.tcl Notes 3D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature3D.tcl MomentCurvature3D.tcl Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Uniaxial-Section Model, 2D puts \" --------------------------------- 2D Model ---------------\" puts \" a. Uniaxial Section\" source Ex9a.build.UniaxialSection2D.tcl source Ex9.analyze.MomentCurvature2D.tcl To run RC Section: Rectangular, Confined, Symmetric Model, 3D puts \" --------------------------------- 3D Model ---------------\" puts \" d. RC Section: Rectangular, Confined, Symmetric\" source Ex9d.build.RCSection.RectConfinedSymm3D.tcl source Ex9.analyze.MomentCurvature3D.tcl","title":"Section Building\n"},{"location":"guides/01_install/","text":"Installing OpenSeesRT is distributed primarily as a Python package. For those familiar with Python, you can just run pip install opensees New to Python If you are new to Python, a great way to get started is to install Anaconda.","title":"Installing\n"},{"location":"guides/01_starting/","text":"Getting Started A simulation with opensees is generally configured in the following steps: Modeling : This consists of defining a collection of mathematical abstractions and their relationships with the objective of representing some phenomenon. This generally includes creating Element , Node , LoadPattern and Constraint objects that define the model. Analysis : Once a model is defined, the next step is to create an Analysis. Some common analysis routines are the following: Static Analysis Load or displacement controlled Spectral Decomposition Transient Direct Integration Transient Modal Integration Moment-Curvature Analysis Ultimate N-M Surface Analysis These routines are configured and refined in terms of analysis abstractions which generally may include an Integrator , SolutionAlgorithm , and ConstraintHandler strategy. Post-processing : Once the model and analysis have been defined, the user has the option of specifying what is to be monitored during the analysis. This, for example, could be the displacement history at a node or internal state of an element in a transient analysis or the entire state of the model at each step in the solution procedure. Several Recorder objects are created to store what the user wants to examine. Runtime and Numerics : When working on advanced problems, fine-grained control over details such as the analysis runtime, parallelization, and numeric strategies becomes important. Numerics : when the computational cost of an analysis becomes prohibitive, selecting the right numeric strategy can be important. Refinements typically consist of choosing an appropriate linear or eigenvalue solver which appropriatly accounts for the structure of a linear system. Parallelization may also be considered.","title":"Getting Started\n"},{"location":"guides/02_runtime/","text":"Runtime record recorder printModel POST render.elastica(model, displ): ... MODLEING (MOVE TO LIBRARY?) remove setElementRayleighDampingFactors modalDamping ANALYSIS? def eig(model, number, ** runtime) -> (freq, displ): ... def rha(model, pattern, ** runtime) -> (): ... def rt.incr( self , model, pattern, force | displ =< float > ) sdfResponse InitialStateAnalysis systemSize getLoadFactor testIter testNorm numFact numIter - loadConst ? setNumthread getNumthread Runtime [ getTime ] setTime setNodeCoord setNodeDisp setNodeVel setNodeAccel reactions setPrecision updateElementDomain updateMaterialStage reset wipe wipeAnalysis Utilities convertBinaryToText convertTextToBinary stripXML restore save database sectionForce sectionDeformation sectionStiffness sectionFlexibility sectionLocation sectionWeight getEleTags eleDynamicalForce eleForce eleNodes eleResponse basicDeformation basicForce basicStiffness getNodeTags nodeDisp nodeAccel nodeVel nodeBounds nodeCoord nodeEigenvector nodeDOFs nodeMass nodePressure nodeReaction nodeResponse nodeUnbalance printA printB printGID version logFile","title":"Runtime\n"},{"location":"guides/03_simulation/","text":"Simulation Process Build the model model dimensions and degrees-of-freedom nodal coordinates nodal constraints, boundary conditions nodal masses elements and element connectivity recorders for output Define & apply gravity load nodal or element load static-analysis parameters (tolerances & load increments) analyze hold gravity loads constant reset time to zero Define and apply lateral load load pattern (nodal loads for static analysis, support ground motion for earthquake) lateral-analysis parameters (tolerances & displacement/time increments) Static Lateral-Load Analysis define the displacement increments and displacement path Dynamic Lateral-Load Analysis define the input motion and all associated parameters, such as scaling and input type define analysis duration and time increment define damping analyze","title":"Simulation Process\n"},{"location":"guides/cli/","text":"Command Line Use","title":"Command Line Use\n"},{"location":"guides/object_oriented/","text":"Object oriented interfaces Object oriented interfaces are available for the following types: Element SectionForceDeformation UniaxialMaterial NdMaterial Node HystereticBackbone","title":"Object oriented interfaces\n"},{"location":"guides/BeamTheory/","text":"Beam-Column Elements in OpenSees This document provides a brief description of the interaction between a beam-column element and the SectionForceDeformation and CoordTransformation classes in OpenSees. Material and geometric nonlinearities are abstracted, or separated, from the element formulation by using the SectionForceDeformation and CoordTransformation classes. As a result, an element can be programmed in the \u201cbasic system\u201d to account for material nonlinearities, then use one of many transformation types to pick up geometric nonlinearities. A displacement based, distributed plasticity formulation is presented as an example of how a beam-column element is formulated in the basic system. Geometric Nonlinearity In general, the transformation of nodal displacements, \\(\\mathbf{u}\\) , in the global system to deformations, \\(\\mathbf{v}\\) , in the basic system is described by a nonlinear function, \\[%\\label{eq:v=v(u)} \\mathbf{v} = \\mathbf{v}(\\mathbf{u}).\\] In a similar manner, the transformation of basic forces, \\(\\mathbf{q}\\) , to forces \\(\\mathbf{p}\\) in the global frame of reference is given by \\[%\\label{eq:p=p(q,u)} \\mathbf{p} = \\mathbf{p}(\\mathbf{q}(\\mathbf{u}), \\mathbf{u}),\\] where \\(\\mathbf{p}\\) is implicitly a function of \\(\\mathbf{u}\\) via the basic forces, \\(\\mathbf{q}\\) , as well as an explicit function of \\(\\mathbf{u}\\) . The explicit dependence on \\(\\mathbf{u}\\) takes into account approximate geometric nonlinearities such as P- \\(\\Delta\\) . These transformations are shown schematically in figure @fig:Transformation . {#fig:Transformation} As seen in figure [fig:BeamClass] , a beam-column element acquires geometric nonlinearity from the CoordTransformation class, and material nonlinearity from the SectionForceDeformation class. Material Nonlinearity At every cross-section along the element length, a force-deformation relationship holds, providing section stress resultants, \\(\\mathbf{s}\\) , as a function of section deformations, \\(\\mathbf{e}\\) , \\[%\\label{eq:s=s(e)} \\mathbf{s}(x) = \\mathbf{s}(\\mathbf{e}(x)).\\] Linearizing the force-deformation relationship with respect to deformations reveals the section tangent stiffness, \\(\\mathbf{k}_s\\) , \\[\\begin{aligned} \\Delta\\mathbf{s} &= \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\Delta\\mathbf{e} \\\\ \\Delta\\mathbf{s} &= \\mathbf{k}_s \\Delta\\mathbf{e},\\end{aligned}\\] where \\(\\mathbf{k}_s = \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}}\\) , the partial derivative of the section stress resultants with respect to the section deformations. A beam-column element obtains material nonlinearity through use of the SectionForceDeformation class, as seen in figure [fig:BeamClass] . Class Hierarchy Figure [fig:BeamClass] shows the class interaction between a beam-column element and the CoordTransformation and SectionForceDeformation classes. An element can use any one of Linear, \\(P-\\Delta\\) , or Corotational transformations; and any one of ElasticSection or FiberSection constitutive models. When a new transformation or section class is added to the framework, the element can use the new class without modification. Displacement Based Element Formulation This section describes the formulation of a displacement based, distributed plasticity beam-column element. The governing compatibility and equilibrium equations are covered along with the consistent element stiffness. Bending deformations are assumed to be small, and shear deformations are neglected. Compatibility For displacement based elements, there is a strong form of compatibility between basic displacements, \\(\\mathbf{v}\\) , and section deformations \\(\\mathbf{e}\\) , satisfied pointwise along the element length, \\[%\\label{eq:e=av} \\mathbf{e}(x) = \\left[ \\begin{array}{c} \\varepsilon(x) \\\\ \\kappa(x) \\end{array} \\right] = \\mathbf{a}(x) \\mathbf{v},\\] where \\(\\mathbf{a}\\) is the strain-displacement matrix. The section deformations are the axial strain, \\(\\varepsilon\\) , and curvature, \\(\\kappa\\) . Assuming linear axial displacement and transverse displacement based on cubic Hermitian polynomials, the shape functions in the basic system are \\[%\\label{eq:N} \\mathbf{N}(x) = \\left[ \\begin{array}{c} N_1(x) \\\\ \\\\ N_2(x) \\\\ \\\\ N_3(x) \\end{array} \\right] = \\left[ \\begin{array}{c} \\frac{x}{L} \\\\ \\\\ L\\left( \\frac{x}{L} - 2\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\\\ \\\\ L\\left( -\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\end{array} \\right].\\] The strain-displacement matrix contains the shape function derivatives. Axial strain is the first derivative of the axial displacement, and curvature is the second derivative of the transverse displacement, \\[\\mathbf{a}(x) = \\left[ \\begin{array}{ccc} N_{1,x} & 0 & 0 \\\\ \\\\ 0 & N_{2,xx} & N_{3,xx} \\end{array} \\right].\\] Using the shape functions defined in equation [eq:N] , the strain-displacement matrix is then, \\[\\mathbf{a}(x) = \\frac{1}{L} \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ \\\\ 0 & -4+6\\frac{x}{L} & -2+6\\frac{x}{L} \\end{array} \\right].\\] The basic displacements, \\(\\mathbf{v}\\) , can be obtained by invoking the method getBasicTrialDisp() . After computing section deformations from basic displacements via equation @eq:e =av , the method setTrialSectionDeformation() may be invoked with the updated deformations, \\(\\mathbf{e}\\) . Equilibrium Using the principle of virtual displacements (virtual work), equilibrium between element end forces, \\(\\mathbf{q}\\) , and section stress resultants, \\(\\mathbf{s}\\) , is satisfied weakly, or in an average sense, along the element length, \\[%\\label{eq:q} \\mathbf{q} = \\int_0^L \\mathbf{a}(x)^T \\mathbf{s}(x) \\: dx,\\] where the section stress resultants are the axial force, \\(P\\) , and bending moment, \\(M\\) , \\[\\mathbf{s}(x) = \\left[ \\begin{array}{c} P(x) \\\\ M(x) \\end{array} \\right].\\] To obtain the current value of section stress resultants, \\(\\mathbf{s}\\) , the method getStressResultant() must be invoked. To perform the transformation from basic to global resisting force (equation [eq:p=p(q,u)] ), the method getGlobalResistingForce() should be invoked. Element Stiffness To solve the structural system of equations, the element stiffness must be assembled along with the resisting force. The element stiffness is obtained by taking the partial derivative of equation [eq:p=p(q,u)] with respect to displacements, \\(\\mathbf{u}\\) . \\[\\begin{aligned} \\mathbf{k} &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}}\\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ \\mathbf{k} &= %\\label{eq:stiff} \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\mathbf{k}_b \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q}\\end{aligned}\\] The basic element stiffness, \\(\\mathbf{k}_b\\) , is the partial derivative of the basic forces, \\(\\mathbf{q}\\) , with respect to the basic displacements, \\(\\mathbf{v}\\) . Differentiating equation [eq:q] gives, \\[\\begin{aligned} \\mathbf{k}_b &= \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{v}} \\: dx \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\frac{\\partial\\mathbf{e}}{\\partial\\mathbf{v}} \\: dx \\\\ \\mathbf{k}_b &= %\\label{eq:kb} \\boxed{ \\int_0^L \\mathbf{a}(x)^T \\mathbf{k}_s(x) \\mathbf{a}(x) \\: dx} \\end{aligned}\\] The section tangent stiffness matrix, \\(\\mathbf{k}_s\\) , is returned upon invoking the method getSectionTangent() . After computing the basic stiffness, \\(\\mathbf{k}_b\\) , the method getGlobalStiffMatrix() should be invoked to perform the transformation in equation [eq:stiff] . The remaining partial derivatives in equation [eq:stiff] are computed by the getGlobalStiffMatrix() method. Numerical Quadrature In general, the element integrals, equations [eq:q] and [eq:kb] , cannot be evaluated in closed form due to nonlinearities in the section constitutive model. These integrals must be approximately evaluated by numerical quadrature, \\[\\begin{aligned} %\\label{eq:qapprox} \\mathbf{q} &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{s}(x_i) \\: W_i \\\\ %\\label{eq:kbapprox} \\mathbf{k}_b &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{k}_s(x_i) \\mathbf{a}(x_i) \\: W_i ,\\end{aligned}\\] where \\(N_s\\) is the number of integration points, i.e., the number of section sample points along the element length. Integration points, \\(\\xi_i\\) , and weights, \\(\\omega_i\\) , are typically defined over a fixed domain such as \\(\\left[-1,1\\right]\\) or \\(\\left[0,1\\right]\\) , then mapped to the element domain \\(\\left[0,L\\right]\\) , where \\(L\\) is the element length. Assuming points and weights defined on \\(\\left[-1,1\\right]\\) , the following relationships hold, \\[\\begin{aligned} x_i &= \\frac{L}{2} \\left( \\xi_i+1 \\right) \\\\ W_i &= \\frac{L}{2} \\: \\omega_i .\\end{aligned}\\] After mapping the points and weights to the element domain, equations [eq:qapprox] and [eq:kbapprox] can be evaluated. Michael H. Scott August 22, 2001 PEER, University of California, Berkeley","title":"Beam-Column Elements in OpenSees\n"},{"location":"libraries/","text":"Library Reference The opensees package can be divided by the following objectives: Modeling Analysis Runtime Utilities Post-processing Modeling Libraries opensees.element Materials opensees.uniaxial opensees.material opensees.backbone Sections opensees.section opensees.patch opensees.layer opensees.fiber Utilities opensees.units","title":"Library Reference"},{"location":"libraries/analysis/","text":"Analysis Capabilities Linear equation solvers, time integration schemes, and solution algorithms are the core of the OpenSees computational framework. The components of a solution strategy are interchangeable, allowing analysts to find sets suited to their particular problem. Outlined here are the available solution strategies. New parts of the solution strategy may be seamlessly plugged in to the existing framework. Static Integrators Determing the next time step for an analysis is done by the following schemes Load Control \u2013 Specifies the incremental load factor to be applied to the loads in the domain Displacement Control \u2013 Specifies the incremental displacement at a specified DOF in the domain Minimum Unbalanced Displacement Norm \u2013 Specifies the incremental load factor such that the residual displacement norm in minimized Arc Length \u2013 Specifies the incremental arc-length of the load-displacement path Transient Integrators Determing the next time step for an analysis including inertial effects is done by the following schemes Newmark \u2013 The two parameter time-stepping method developed by Newmark HHT \u2013 The three parameter Hilbert-Hughes-Taylor time-stepping method Generalized Alpha \u2013 Generalization of the HHT algorithm with improved numerical damping Central Difference \u2013 Approximates velocity and acceleration by centered finite differences of displacement Solution Algorithms Iteration from the last time step to the current is done by the following methods Linear \u2013 Uses the solution at the first iteration and continues Newton \u2013 Uses the tangent at the current iteration to iterate to convergence Modified Newton \u2013 Uses the tangent at the first iteration to iterate to convergence Convergence Tests Accepting the current state of the domain as being on the converged solution path is accomplished by the following tests Norm Unbalance \u2013 Specifies a tolerance on the norm of the unbalanced load at the current iteration Norm Displacement Increment \u2013 Specifies a tolerance on the norm of the displacement increments at the current iteration Energy Increment \u2013 Specifies a tolerance on the inner product of the unbalanced load and displacement increments at the current iteration Constraint Handlers The constraints defined on the domain can be handled by the following methods Plain \u2013 Removes constrained degrees of freedom from the system of equations Lagrange \u2013 Uses the method of Lagrange multipliers to enforce constraints Penalty \u2013 Uses penalty numbers to enforce constraints Transformation \u2013 Performs a condensation of constrained degrees of freedom","title":"Analysis Capabilities\n"},{"location":"libraries/analysis/ConvergenceTest/CTestEnergyIncr/","text":"CTestEnergyIncr #include <convergenceTest/CTestEnergyIncr.h> class CTestEnergyIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestEnergyIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestEnergyIncr class tests using the energy increment, 0.5 times the absolute value of the dot product of the LinearSOE objects solution and rhs Vectors, and a user specified tolerance value. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol and the max number of iterations to be performed to maxNumIter . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if 0.5 times the absolute value of the dot product of the LinearSOE objects X and B Vectors is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.y","title":"CTestEnergyIncr\n"},{"location":"libraries/analysis/ConvergenceTest/CTestNormDispIncr/","text":"CTestNormDispIncr #include <convergenceTest/CTestNormDispIncr.h> class CTestNormDispIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestNormDispIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormDispIncr class tests using the norm of the solution Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects X Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormDispIncr\n"},{"location":"libraries/analysis/ConvergenceTest/CTestNormUnbalance/","text":"CTestNormUnbalance #include <convergenceTest/CTestNormUnbalance.h> class CTestNormUnbalance : public ConvergenceTest MovableObject ConvergenceTest A CTestNormUnbalance object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormUnbalance class tests using the norm of the right hand side Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects B Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 2, puts the tolerance value tol and numIncr in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 2, invokes recvVector() on theChannel , and sets the values of tol and numIncr . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormUnbalance\n"},{"location":"libraries/analysis/StaticIntegrator/ArcLength/","text":"THE IMPLEMENTATION WILL HAVE TO CHANGE FOR DOMAIN-DECOMPOSITION ANALYSIS .. AS DOES THE CONVERGENCE TEST STUFF .. THIS IS BECAUSE USING DOT PRODUCTS OF VECTORS OBTAINED STRAIGHT FROM SYSTEM OF EQUATION .. MAYBE MODIFY LinearSOE TO DO THE DOT PRODUCT .. WILL WORK IN DD IF ALL USE ONE SOE .. WHAT PetSC DOES, TALK WITH P. DEMMEL ABOUT WHAT HE WILL PROVIDE. ArcLength #include <analysis/integrator/ArcLength.h> class ArcLength : public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator ArcLength is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using an arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation [staticFormTaylor] to produce a linear system of \\(N+1\\) unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of \\(N\\) unknowns using the method of ??(REF). Rewriting equation [staticFormTaylor] as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] substituting for \\(\\Delta {{\\bf U}_n^{(i)}}\\) using equation [splitForm] this can be expressed as: \\[\\Delta \\lambda_n^{(i)^2} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 \\right) + 2* \\Delta \\lambda_n^{(i)} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2d \\lambda^{(i)} \\right)\\] \\[+ \\left (\\Delta \\overline{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} \\right) =0\\] which is a quadratic in \\(\\Delta \\lambda_n^{(i)}\\) , which can be solved for two roots. The root chosen is the one which will keep a positive angle between the incremental displacement before and after this step. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\Delta U $ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength\n"},{"location":"libraries/analysis/StaticIntegrator/ArcLength1/","text":"ArcLength1 #include <analysis/integrator/ArcLength1.h> class ArcLength1 : public StaticIntegrator MovableObject Integrator IncrementalIntegrator ArcLength1 is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a simplified form of the arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation [staticFormTaylor] to produce a linear system of \\(N+1\\) unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of \\(N\\) unknowns using the method of ??(REF). Rewriting equation [staticFormTaylor] as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] For our ArcLength1 method we make the ADDITIONAL assumption that \\(2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)}\\) \\(>>\\) \\(\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2\\) the constraint equation at step \\(i\\) reduces to \\[{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] hence if the class was to solve an \\(N+1\\) system of equations at each step, the system would be: \\[\\left[ \\begin{array}{cc} {\\bf K}_n^{(i)} & -{\\bf P} \\\\ {d{\\bf U}^{(i)}}^T & \\alpha^2 d\\lambda^{(i)} \\end{array} \\right] \\left\\{ \\begin{array}{c} \\Delta {\\bf U}_n^{(i)} \\\\ \\Delta \\lambda_n^{(i)} \\end{array} \\right\\} = \\left\\{ \\begin{array}{c} \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) \\\\ 0 \\end{array} \\right\\}\\] instead of solving an \\(N+1\\) system, equation [splitForm] is used to give \\[{d{\\bf U}^{(i)}}^T \\left(\\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)}\\right) + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] which knowing \\(\\dot{\\bf U}_n^{(i)}\\) and \\(\\overline{\\bf U}_n^{(i)}\\) can be solved for \\(\\Delta \\lambda_n^{(i)}\\) \\[\\Delta \\lambda_n^{(i)} = -\\frac{{d{\\bf U}^{(i)}}^T \\Delta \\overline{\\bf U}_n^{(i)}}{{d{\\bf U}^{(i)}}^T \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)}}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength 1 (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\Delta U $ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength1\n"},{"location":"libraries/analysis/StaticIntegrator/EQPath/","text":"EQPath integrator EQPath $arc_length $type References Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 849 - 878 DOI: https://doi.org/10.12989/sem.2013.48.6.849 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part I : Formulation and characteristics of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/264146397_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_I_Formulation_and_characteristics_of_the_methods Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 879 - 914 DOI: https://doi.org/10.12989/sem.2013.48.6.879 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part II : Comparing efficiencies of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/263361974_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_II_Comparing_efficiencies_of_the_methods Written: M. Salehi opensees.net@gmail.com Created: 02/19","title":"EQPath\n"},{"location":"libraries/analysis/TransientIntegrator/GeneralizedAlpha/","text":"GeneralizedAlpha \\(\\alpha_F\\) and \\(\\alpha_M\\) are defined differently than in the paper, we use \\(\\alpha_F = (1-\\alpha_f)\\) and \\(\\alpha_M=(1-\\gamma_m)\\) where \\(\\alpha_f\\) and \\(\\alpha_m\\) are those used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha_M = 1.0, \\alpha_F = 1.0\\) produces the Newmark Method. \\(\\alpha_M = 1.0\\) corresponds to the HHT method. The method is second-order accurate provided \\(\\gamma = \\tfrac{1}{2} + \\alpha_M - \\alpha_F\\) - The method is unconditionally stable provided \\(\\alpha_M >= \\alpha_F >= \\tfrac{1}{2}, \\beta>=\\tfrac{1}{4} +\\tfrac{1}{2}(\\gamma_M - \\gamma_F)\\) \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is unconditionally stable, second order accurate and high frequency dissipation is maximized. The defaults are: \\[\\gamma = \\tfrac{1}{2} + \\gamma_M - \\gamma_F\\] and \\[\\beta = \\tfrac{1}{4}(1 + \\gamma_M - \\gamma_F)^2\\] Theory The Generalized \\(\\alpha\\) method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. As with the HHT method, the following Newmark approximations are used: \\[ U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t} \\\\ \\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[ R_{t + \\alpha_M \\Delta t} = F_{t+\\Delta t}^\\text{ext} - M \\ddot U_{t + \\alpha_M \\Delta t} - C \\dot U_{t+\\alpha_F \\Delta t} - F^\\text{int}(U_{t + \\alpha_F \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[\\mathbf{d}_{t+ \\alpha_F \\Delta t} = (1 - \\alpha_F) U_t + \\alpha_F U_{t + \\Delta t} \\\\ \\mathbf{v}_{t+\\alpha_F \\Delta t} = (1-\\alpha_F) \\dot U_t + \\alpha_F \\dot U_{t + \\Delta t} \\\\ \\mathbf{a}_{t+\\alpha_M \\Delta t} = (1-\\alpha_M) \\ddot U_t + \\alpha_M \\ddot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, linearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\(K_{t+\\Delta t}^{*i} = \\alpha_F K_t + \\frac{\\alpha_F \\gamma}{\\beta \\Delta t} C_t + \\frac{\\alpha_M}{\\beta \\Delta t^2} M\\) and \\[ R_{t+\\Delta t}^i = F_{t + \\Delta t}^\\text{ext} - F(U_{t + \\alpha F \\Delta t}^{i-1})^\\text{int} - C \\dot U_{t+\\alpha F \\Delta t}^{i-1} - M \\ddot U_{t+ \\alpha M \\Delta t}^{i-1} \\] The linear equations are used to solve for \\(U_{t+\\alpha F \\Delta t}, \\dot U_{t + \\alpha F \\Delta t} \\ddot U_{t+ \\alpha M \\Delta t}\\) . Once convergence has been achieved the displacements, velocities and accelerations at time \\(t + \\Delta t\\) can be computed. REFERENCES J. Chung, G.M.Hubert. \u201cA Time Integration Algorithm for Structural Dynamics with Improved Numerical Dissipation: The Generalized- \\(\\alpha\\) Method\u201d ASME Journal of Applied Mechanics, 60, 371:375, 1993.","title":"GeneralizedAlpha\n"},{"location":"libraries/analysis/TransientIntegrator/HHT/","text":"HHT #include <analysis/integrator/HHT.h> class HHT : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator HHT is a subclass of TransientIntegrator which implements the Hilber-Hughes-Taylor (HHT) method. In the HHT method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , by solving the following equilibrium equation \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\alpha \\Delta t},{\\bf U}_{t + \\alpha \\Delta t})\\] where \\[{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) {\\bf U}_t + \\alpha {\\bf U}_{t + \\Delta t}\\] \\[\\dot{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] and the velocities and accelerations at time \\(t + \\Delta t\\) are determined using the Newmark relations. The HHT method results in the following for determining the response at \\(t + \\Delta t\\) \\[ \\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\alpha \\gamma}{\\beta \\Delta t} {\\bf C} + \\alpha {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)},{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)}\\right) \\] // Constructors // Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_HHT is passed to the TransientIntegrator constructor. \\(\\alpha\\) , \\(\\beta\\) and \\(\\gamma\\) are set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1\\alpha {\\bf K} + c2\\alpha \\D + c3 {\\bf M}\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group \\ * theDof ); This performs the following: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(8\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) , and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double \u0394t ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 ; c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta * \\Delta t)\\) and c3 to \\(1/ (\\beta * \\Delta t^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) are set using the difference approximations. \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 ${\\bf U}_{t + \\alpha \\Delta t} = {\\bf U}_t$\\ \\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t \\] \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} = (1 - \\alpha) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements and velocities at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & \u0394U ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The displacement Vector at time \\(t + \\alpha \\Delta t\\) is incremented by \\(c1 \\alpha \\Delta U\\) and the velocity Vector by \\(c2 \\alpha \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement and velocity at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. ::: {.tabbing} while \u0304 while w\u0304hile \u0304 \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) \\({\\bf U}_{t + \\alpha \\Delta t} += \\alpha \\Delta \\U\\) \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} += \\frac{\\alpha \\gamma}{\\beta \\Delta t} \\Delta \\U\\] theModel -> setResponse ( U_t_alpha_\u0394t , \\dot { \\bf U } _ { t + \\alpha \\Delta t }, \\ddot { \\bf U } _ { t + \\Delta t }) theModel -> updateDomain () Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"HHT\n"},{"location":"libraries/analysis/TransientIntegrator/Newmark/","text":"Newmark #include <analysis/integrator/Newmark.h> class Newmark: public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator Newmark is a subclass of TransientIntegrator which implements the Newmark method. In the Newmark method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , the equilibrium equation (expressed for the TransientIntegrator) is typically solved at time \\(t + \\Delta t\\) for \\({\\bf U}_{t+\\Delta t}\\) , i.e. solve: \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] for \\({\\bf U}_{t+\\Delta t}\\) . The following difference relations are used to relate \\(\\dot{\\bf U}_{t + \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\Delta t}\\) to \\({\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\Delta t} = \\frac{\\gamma}{\\beta \\Delta t} \\left( {\\bf U}_{t + \\Delta t} - {\\bf U}_t \\right) + \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = \\frac{1}{\\beta {\\Delta t}^2} \\left( {\\bf U}_{t+\\Delta t} - {\\bf U}_t \\right) - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] which results in the following \\[\\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\gamma}{\\beta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] An alternative approach, which does not involve \\(\\Delta t\\) in the denumerator (useful for impulse problems), is to solve for the accelerations at time \\(t + \\Delta t\\) \\[{\\bf R} (\\ddot{\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] where we use following functions to relate \\({\\bf U}_{t + \\Delta t}\\) and \\(\\dot{\\bf U}_{t + \\Delta t}\\) to \\(\\ddot{\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\left[ \\left(\\frac{1}{2} - \\beta\\right)\\ddot{\\bf U}_t + \\beta \\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t^2\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\left[ \\left(1 - \\gamma\\right)\\ddot{\\bf U}_t + \\gamma\\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t\\] which results in the following \\[\\left[ {\\bf M} + \\gamma \\Delta t {\\bf C} + \\beta \\Delta t^2 {\\bf K} \\right] \\Delta \\ddot{\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] Constructors ### Destructor // Public Methods // Public Methods for Output Sets \\(\\gamma\\) to \\(1/2\\) and \\(\\beta\\) to \\(1/4\\) . Sets a flag indicating whether the incremental solution is done in terms of displacement, \\(\\Delta \\U\\) , if dispFlag is true , or acceleration, \\(\\Delta \\ddot \\U\\) , if dispFlag is false . In addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\gamma\\) to gamma and \\(\\beta\\) to beta . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\gamma\\) to gamma , \\(\\beta\\) to beta , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 {\\bf K} + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 if (RayleighDamping == false) { theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1) theEle- \\(>\\) addCtoTang(c2) theEle- \\(>\\) addMtoTang(c3) } else { theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1 + c2 * \\(\\beta_K\\) ) theEle- \\(>\\) addMtoTang(c3 + c2 * \\(\\alpha_M\\) ) } int formNodTangent ( DOF_Group \\ * theDof ); The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() if (RayleighDamping == false) theDof- \\(>\\) addMtoTang(c3) else theDof- \\(>\\) addMtoTang(c3 + c2 * \\(\\alpha_M\\) ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE- \\(>\\) getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\Delta t $ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 depending on the flag indicating whether incremental displacements or accelerations are being solved for at each iteration. If dispFlag was true , c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta \\Delta t)\\) and c3 to \\(1/ (\\beta \\Delta t^2)\\) . If the flag is false c1 is set to \\(\\beta \\Delta t^2\\) , c2 to \\(\\gamma \\Delta t\\) and c3 to \\(1.0\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) are set using the difference approximations if dispFlag was true . (displacement and velocity if false ). while w\u0304hile w\u0304hile w\u0304hile \u0304 if (displIncr == true) { \\(\\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\) } else { \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\frac{\\Delta t^2}{2}\\ddot{\\bf U}_t\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\Delta t \\ddot{\\bf U}_t\\) } The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with new quantities for time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\Delta U $ ); Invoked this causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response at the DOF_Group objects are then updated by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. while w\u0304hile w\u0304hile w\u0304hile \u0304 if (displIncr == true) { \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) } else { \\(\\ddot{\\bf U}_{t + \\Delta t} += \\Delta \\Udd\\) \\({\\bf U}_{t + \\Delta t} += \\beta \\Delta t^2 \\Delta \\Udd\\) \\(\\dot{\\bf U}_{t + \\Delta t} += \\gamma \\Delta t \\Delta \\Udd\\) } theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) theModel- \\(>\\) setUpdateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\delta U\\) are of different sizes. int sendSelf(int commitTag, Channel &theChannel); Places in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, \\(\\gamma\\) is set to 0.5, \\(\\beta\\) to 0.25 and the Rayleigh damping flag set to false , and a \\(-1\\) is returned, if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"Newmark\n"},{"location":"libraries/analysis/TransientIntegrator/WilsonTheta/","text":"WilsonTheta #include <analysis/integrator/WilsonTheta.h> class WilsonTheta : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator WilsonTheta is a subclass of TransientIntegrator which implements the Wilson- \\(\\Theta\\) method. In the Wilson- \\(\\Theta\\) method, to determine the velocities, accelerations and displacements at time \\(t + \\theta \\Delta t\\) , \\(\\theta \\ge 1.37\\) , for \\({\\bf U}_{t+ \\theta \\Delta t}\\) \\[{\\bf R} ({\\bf U}_{t + \\theta \\Delta t}) = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+ \\theta \\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\theta \\Delta t},{\\bf U}_{t + \\theta \\Delta t})\\] where we use following functions to relate \\(\\dot{\\bf U}_{t + \\theta \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\theta \\Delta t}\\) to \\({\\bf U}_{t + \\theta \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\theta \\Delta t} = \\frac{3}{\\theta \\Delta t} \\left( {\\bf U}_{t + \\theta \\Delta t} - {\\bf U}_t \\right) - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\theta \\Delta t} = \\frac{6}{\\theta^2 \\Delta t^2} \\left( {\\bf U}_{t+\\theta \\Delta t} - {\\bf U}_t \\right) - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\] which results in the following for determining the responses at \\(t + \\theta \\Delta t\\) \\[\\left[ \\frac{6}{\\theta^2 \\Delta t^2} {\\bf M} + \\frac{3}{\\theta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\theta \\Delta t}^{(i)} = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\theta \\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\theta \\Delta t}^{(i-1)},{\\bf U}_{t + \\theta \\Delta t}^{(i-1)}\\right)\\] The response quantities at time \\(t + \\Delta t\\) are then determined using the following \\[\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\] \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_WilsonTheta is passed to the TransientIntegrator constructor. \\(\\Theta\\) is set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 \\K + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group * theDof ); This performs the following: theDof -> zeroUnbalance () if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) (between newStep() and commit() the \\(t + \\Delta t\\) quantities store \\(t + \\Theta \\Delta t\\) quantities). The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\Delta t $ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 : c1 is set to \\(1.0\\) , c2 to \\(3 / (\\Theta \\Delta t)\\) and c3 to \\(6 / (\\Theta \\Delta t)^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Theta \\Delta t\\) are set using the difference approximations, \\({\\bf U}_{t + \\theta \\Delta t} = {\\bf U}_t\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} = - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} = - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\) The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Theta \\Delta t\\) . \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\theta \\Delta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\] current time is obtained from the AnalysisModel, incremented by \\(\\Theta \\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\Delta U $ ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Theta \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements, velocities and accelerations at time \\(t + \\Theta \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. \\({\\bf U}_{t + \\theta \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} += \\frac{3}{\\theta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} += \\frac{6}{\\theta^2 \\Delta t^2} \\Delta \\U\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\alpha \\theta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\) theModel- \\(>\\) updateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the quantities at time \\(t + \\Delta t\\) are determined using the quantities at time \\(t\\) and \\(t + \\Theta \\Delta t\\) . Then the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . The time is obtained from the AnalysisModel and \\((\\Theta - 1) \\Delta t\\) is subtracted from the value. The time is set in the Domain by invoking setCurrentDomainTime(time) on the AnalysisModel. Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. \\(\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\) \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+ \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) time = theModel- \\(>\\) getDomainTime() time -= \\((\\theta -1) * \\Delta t\\) theModel- \\(>\\) setTime(time) theModel- \\(>\\) commitDomain() Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places \\(\\Theta\\) , rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) in a vector if size 4 and invokes sendVector on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 4 the value of \\(\\Theta\\) , the rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) .. Returns \\(0\\) if successful, a warning message is printed, \\(\\Theta\\) is set to \\(0\\) , the rayleigh damping flag to false , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) .","title":"WilsonTheta\n"},{"location":"libraries/analysis/constraint_enforcement/Lagrange/","text":"Lagrange This command is used to construct a LagrangeMultiplier constraint handler, which enforces the constraints by introducing Lagrange multiplies to the system of equation. The following is the command to construct a plain constraint handler: constraints Lagrange < $alphaS $alphaM > $alphaS \\(\\alpha_S\\) factor on singe points. optional, default = 1.0 $alphaM \\(\\alpha_M\\) factor on multi-points, optional default = 1.0; NOTES: The Lagrange multiplier method introduces new unknowns to the system of equations. The diagonal part of the system corresponding to these new unknowns is 0.0. This ensure that the system IS NOT symmetric positive definite. THEORY: Code Developed by: fmk C++ Interface #include <analysis/handler/LagrangeConstraintHandler.h> class LagrangeConstraintHandler : public ConstraintHandler ; The LagrangeConstraintHandler class is a class which deals with both single and multi point constraints using the Lagrange method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating a LagrangeDOF_Group object and either a LagrangeSP_FE or a LagrangeMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by modifying the tangent matrix and residual vector. The integer HANDLER_TAG_LagrangeConstraintHandler (defined in <classTags.h> ) is passed to the LagrangeConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the LagrangeSP_FE and LagrangeMP_FE objects in handle() . Destructor Currently invokes clearAll() , this will change when clearAll() is rewritten. Methods Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mappinging between Elements and FE_Elements, SP_Constraints and LagrangeSP_FEs, MP_Constraints and LagrangeMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a LagrangeSP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a LagrangeMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf ( int commitTag , Channel & theChannel ); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Lagrange\n"},{"location":"libraries/analysis/constraint_enforcement/Penalty/","text":"Penalty #include <analysis/handler/PenaltyConstraintHandler.h> class PenaltyConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The PenaltyConstraintHandler class is a class which deals with both single and multi point constraints using the penalty method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a PenaltySP_FE or a PenaltyMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PenaltyConstraintHandler (defined in <classTags.h> ) is passed to the PenaltyConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the PenaltySP_FE and PenaltyMP_FE objects in handle() . Currently invokes clearAll() , this will change when clearAll() is rewritten. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements, SP_Constraints and PenaltySP_FEs, MP_Constraints and PenaltyMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a PenaltySP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a PenaltyMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Penalty\n"},{"location":"libraries/analysis/constraint_enforcement/Plain/","text":"Plain #include <analysis/handler/PlainHandler.h> class PlainHandler: public ConstraintHandler MovableObject ConstraintHandler The PlainHandler class is a class which only deals with homogeneous single point constraints. To do this it creates regular FE_Element and DOF_Group objects and enforces the constraints by specifying that degrees-of-freedom which are constrained are not assigned an equation number. Pointers to the DOF_Group and FE_Element objects are kept in two arrays. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PlainHandler (defined in <classTags.h> ) is passed to the PlainHandler constructor. Invokes the destructor on all the FE_Element and DOF_Group objects created in handle . Then invokes the destructor on the two pointer arrays. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements and Nodes and DOF_Groups) Creates two arrays of pointers to store the FE_elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) if no SP_Constraint exists for the dof, or \\(-1\\) if a SP_Constraint exists or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. If any MP_Constraint objects exist in the Domain a warning message is printed and \\(-6\\) is returned. If all is successful, the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Returns \\(0\\) . int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) .","title":"Plain\n"},{"location":"libraries/analysis/constraint_enforcement/Transformation/","text":"Transformation UNDER CONSTRUCTION. #include <analysis/handler/TransformationConstraintHandler.h> class TransformationConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The TransformationConstraintHandler class is a class which deals with both single and multi point constraints using the Transformation method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a TransformationSP_FE or a TransformationMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_TransformationConstraintHandler (defined in <classTags.h> ) is passed to the TransformationConstraintHandler constructor. Currently invokes clearAll() , this will change when clearAll() is rewritten.","title":"Transformation\n"},{"location":"libraries/analysis/nonlinear_solve/30-BFGS%20Algorithm/","text":"This command is used to construct a Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm object. The BFGS method is one of the most effective matrix-update or quasi Newton methods for iteration on a nonlinear system of equations. The method computes new search directions at each iteration step based on the initial jacobian, and subsequent trial solutions. The unlike regular Newton-Raphson does not require the tangent matrix be reformulated and refactored at every iteration, however unlike ModifiedNewton it does not rely on the tangent matrix from a previous iteration. algorithm BFGS REFERNCES: Denis, J.E \"A Brief Survey of Convergence Methods for Quasi_Newton Methods\", SIAMS-AMS Proceedings, Vol (9), 185-200, 1976. K.J. Bathe and A.P.Cimento \"Some Practical Procedures for the Solution of Nonlinear Finte Element Equations\", Computer Methods in Applied Mechanics and Engineering, Vol(22) 59-85, 1980. THEORY: Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/356-Krylov-Newton%20Algorithm/","text":"This command is used to construct a KrylovNewton algorithm object which uses a Krylov subspace accelerator to accelerate the convergence of the modified newton method. The command is of the following form: algorithm KrylovNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim> $tangIter tangent to iterate on, options are current, initial, noTangent. default is current. $tangIncr tangent to increment on, options are current, initial, noTangent. default is current $maxDim max number of iterations until the tangent is reformed and the acceleration restarts (default = 3). NOTES: REFERENCES: Scott, M.H. and G.L. Fenves. \"A Krylov Subspace Accelerated Newton Algorithm: Application to Dynamic Progressive Collapse Simulation of Frames.\" Journal of Structural Engineering, 136(5), May 2010. DOI Code Developed by: <span style=\"color:blue\"> Michael Scott, Oregon State University </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/368-Linear%20Algorithm/","text":"This command is used to construct a Linear algorithm object which takes one iteration to solve the system of equations. <math> \\Delta U = - K^{-1}R(U),\\!</math> algorithm Linear <-initial> <-factorOnce> -secant optional flag to indicate to use secant stiffness -initial optional flag to indicate to use initial stiffness -factorOnce optional flag to indicate to only set up and factor matrix once NOTES 1) as the tangent matrix typically will not change during the analysis in case of an elastic system it is highly advantageous to use the -factorOnce option. Do not use this option if you have a nonlinear system and you want the tangent used to be actual tangent at time of the analysis step. Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/398-Modified%20Newton%20Algorithm/","text":"This command is used to construct a ModifiedNewton algorithm object, which uses the modified newton-raphson algorithm to solve the nonlinear residual equation. The command is of the following form: algorithm ModifiedNewton <-initial> -initial optional flag to indicate to use initial stiffness iterations. NOTES: THEORY: The theory for the ModifiedNewton method is similar to that for the Newton-Raphson method . The difference is that the tangent at the initial guess is used in the iterations, instead of the current tangent. The Modified Newmark method is thus an iterative method in which, starting at a good initial guess <math>U_0</math> we keep iterating until <math>\\Delta U</math> is small enough using the following: : <math> \\Delta U = - K_0^{-1}R(U_n),\\!</math> : <math> U_{n+1} = U_n + \\Delta U\\,\\!</math> where: <math>K_0 = \\frac{\\partial R(U_0)}{\\partial U}\\,\\!</math> The advantage of this method over the regular Newton method, is that the system Jacobian is formed only once at the start of the step and factored only once if a direct solver is used. The drawback of this method is that it requires more iterations than Newton's method. note: when -initial flag is provided <math>K_0</math> is Jacobian from undeformed configuration. Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/417-Newton%20Algorithm/","text":"This command is used to construct a NewtonRaphson algorithm object which is uses the Newton-Raphson algorithm to solve the nonlinear residual equation. The Newton-Raphson method is the most widely used and most robust method for solving nonlinear algebraic equations. The command is of the following form: algorithm Newton <-initial> <-initialThenCurrent> -initial optional flag to indicate to use initial stiffness iterations -initialThenCurrent optional flag to indicate to use initial stiffness on first step, then use current stiffness for subsequent steps REFERENCES: Read the page at Wikipedia THEORY: The Newton method used in finite element analysis is identical to that taught in basic calculus courses. It is just extended for the n unknown degrees-of-freedom. The method as taught in basic calculus, is a root-finding algorithm that uses the first few terms of the Taylor series of a function <math>f(x)\\,\\!</math> in the vicinity of a suspected root <math>x_n\\,\\!</math> to find the root <math>x_{n+1}\\,\\!</math>. Newton's method is sometimes also known as Newton's iteration, although in this work the latter term is reserved to the application of Newton's method for computing square roots. The Taylor series of <math>r(x)\\,\\!</math> about the point <math>x=x_n+\\Delta x\\,\\!</math> is given by : <math>f(x_n+\\Delta x) = f(x_n)+r^{'}(x_n)\\Delta x + 1/2r^{''}(x_n) \\Delta x^2+.\u2026\\,\\!</math> Keeping terms only to first order, <math>f(x_n+\\Delta x) \\approx f(x_n)+r^'(x_n)\\Delta x = f(x_n)+ \\frac{df(x_n)}{dx}\\Delta x</math> and since at the root we wish to find <math>x_n + \\Delta x</math>, the function equates to 0, i.e. <math>f(x_n+\\Delta x) = 0</math>, we can solve for an approximate <math>\\Delta x</math> : <math> \\Delta x \\approx -\\frac{f(x_n)}{f^'(x_n)} = - \\frac{df(x_n)}{dx}^{-1}f(x_n)</math> The Newmark method is thus an iterative method in which, starting at a good initial guess <math>x_0\\,\\!</math> we keep iterating until our convergence criteria is met with the following: : <math> \\Delta x = - \\frac{df(x_n)}{dx}^{-1}f(x_n)\\,\\!</math> : <math> x_{n+1} = x_n + \\Delta x\\,\\!</math> The method is generalized to n unknowns by replacing the above scalar equations with matrix ones. : <math>R(U_n+\\Delta x) = R(U_n)+\\frac{\\partial R(U_n)}{\\partial U} \\Delta U + O(\\Delta U ^2) \\,\\!</math> The matrix <math>\\frac{\\partial R(U_n)}{\\partial U}\\,\\!</math> is called the system Jacobian matrix and will be denoted K: : <math>K = \\frac{\\partial R(U_n)}{\\partial U}\\,\\!</math> resulting in our iterative procedure where starting from a good initial guess we iterate until our convergence criteria is met with the following: : <math> \\Delta U = - K^{-1}R(U_n),\\!</math> : <math> U_{n+1} = U_n + \\Delta U\\,\\!</math> Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/418-Newton%20with%20Line%20Search%20Algorithm/","text":"This command is used to construct a NewtonLineSearch algorithm object which introduces line search to the Newton-Raphson algorithm to solve the nonlinear residual equation. Line search increases the effectiveness of the Newton method when convergence is slow due to roughness of the residual. The command is of the following form: algorithm NewtonLineSearch <-type $typeSearch> <-tol $tol> <-maxIter $maxIter> <-minEta $minEta> <-maxEta $maxEta> $typeSearch line search algorithm. optional default is InitialInterpoled. valid types are: Bisection, Secant, RegulaFalsi, InitialInterpolated $tol tolerance for search. optional, defeulat = 0.8 $maxIter max num of iterations to try. optional, default = 10 $minEta a min <math>\\eta\\!</math> value. optional, default = 0.1 $maxEta a max <math>\\eta\\!</math> value. optional, default = 10.0 REFERENCES: M.A. Crisfield, \"Nonlinear Finite Element Analysis of Solids and Structures, Volume 1:Essentials\", Wiley, 1991. THEORY: The rationale behin line search is that: the direction <math>\\Delta U\\,\\!</math> found by the Newton-Raphson method is often a good direction, but the step size <math>\\parallel\\Delta U\\parallel</math> is not. It is cheaper to compute the residual for several points along <math>\\Delta U\\,\\!</math> rather than form and factor a new system Jacobian In NewtonLineSearch the regular Newton-Raphson method is used to compute the <math>\\Delta U\\,\\!</math>, but the update that is used is modified. The modified update is: : <math> U_{n+1} = U_n + \\eta \\Delta U\\,\\!</math> The different line search algorithms use different root finding methods to obtain <math>\\eta\\,\\!</math>, a root to the function <math>s(\\eta)</math> defined as: : <math> s(\\eta) = \\Delta U R(U_{n} + \\eta \\Delta U)\\,\\!</math> with <math> s_0 = \\Delta U R(U_n),\\!</math> Interpolated Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\frac{\\eta_n *s0}{s0 -s_{n+1}} ,\\!</math> } __NOTOC__ RegulaFalsi Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\eta_U - \\frac{s_U*(\\eta_L-\\eta_U)}{s_L-S_U} ,\\!</math> : if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> : if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Bisection Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\frac{\\eta_L - \\eta_U}{2.0} ,\\!</math> if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Secant Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\eta_j - \\frac{s_j*(\\eta_{j-1}-\\eta_j)}{s_{j-1}-S_j} ,\\!</math> : if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> : if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/618-Secant%20Newton%20Algorithm/","text":"This command is used to construct a SecantNewton algorithm object which uses the two-term update to accelerate the convergence of the modified newton method. The command is of the following form: algorithm SecantNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim> $tangIter tangent to iterate on, options are current, initial, noTangent. default is current. $tangIncr tangent to increment on, options are current, initial, noTangent. default is current $maxDim max number of iterations until the tangent is reformed and acceleration restarts (default = 3) NOTES: The default \"cut-out\" values recommended by Crisfield (R1=3.5, R2=0.3) are used. REFERENCES: Crisfield, M.A. \"Non-linear Finite Element Analysis of Solids and Structures\", Vol. 1, Wiley, 1991. Code Developed by: <span style=\"color:blue\"> Michael Scott, Oregon State University </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/67-Broyden%20Algorithm/","text":"This command is used to construct a Broyden algorithm object for general unsymmetric systems which performs successive rank-one updates of the tangent at the first iteration of the current time step. algorithm Broyden <$count> $count number of iterations within a time step until a new tangent is formed Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/Linear/","text":"Linear #include <analysis/algorithm/equiSolnAlgo/Linear.h> class Linear : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The Linear class is an algorithmic class which uses the linear solution algorithm to solve the equations. This is based on a Taylor expansion of the linear system \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}_{a}\\) . \\[\\R(\\U) = \\R({\\bf U}_{a}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}_{a}}\\right] \\left( {\\bf U} - {\\bf U}_{a} \\right)\\] which can be expressed as: \\[{\\bf K}_{a} \\Delta {\\bf U} = {\\bf R}({\\bf U}_{a})\\] which is solved for \\(\\Delta \\U\\) to give the approximation \\({\\bf U} = {\\bf U}_{a} + \\Delta \\U\\) . To start the iteration \\({\\bf U}_a = {\\bf U}_\\text{trial}\\) , i.e. the current trial response quantities are chosen as approximate solution quantities. Constructor Destructor Public Methods // Public Methods for Output The integer EquiALGORITHM_TAGS_Linear (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. This method performs the linear solution algorithm: // form {\\bf K}_{a} theIntegrator -> formTangent () // form \\R({\\bf U}_{a}) theIntegrator -> formUnbalance () // solve for \\Delta \\U theSOE -> solveX () // set U = Ua + DU theIntegrator -> update ( theSOE -> getX ()) The method returns a 0 if successful, otherwise warning message is printed and a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. int sendSelf ( int commitTag , Channel & theChannel ); Does nothing. Returns 0. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Does nothing. Returns 0. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string 'Linear Algorithm' to the stream.","title":"Linear\n"},{"location":"libraries/analysis/nonlinear_solve/ModifiedNewton/","text":"ModifiedNewton #include <analysis/algorithm/equiSolnAlgo/ModifiedNewton.h> class ModifiedNewton : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The ModifiedNewton class is an algorithmic class which obtains a solution to a non-linear system using the modified Newton-Raphson iteration scheme. The Newton-Rapson iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\(\\U{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[\\ {\\bf K}^{(i)} \\Delta \\U{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. in the modified version the tangent is formed only once, i.e \\[\\ {\\bf K}^{(1)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors and Destructors The constructor takes as an argument the ConvregenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_ModifiedNewton (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_ModofiedNewton. recvSelf() must be invoked on this object. ~ ModifiedNewton (); Does nothing. Public Methods int solveCurrentStep ( void ); When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the modified Newton-Raphson iteration algorithm: theTest -> start (); theIntegrator -> formTangent (); do { theIntegrator -> formUnbalance (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. void setTest ( ConvergenceTest & theTest ); A method to set the tolerance criteria of the algorithm to be equal to the value theTol . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018ModifiedNewton\u2019 to the stream if flag equals \\(0\\) .","title":"ModifiedNewton\n"},{"location":"libraries/analysis/nonlinear_solve/NewtonRaphson/","text":"NewtonRaphson C++ Interface #include <analysis/algorithm/equiSolnAlgo/NewtonRaphson.h> class NewtonRaphson : public EquiSolnAlg ; MovableObject / SolutionAlgorithm / EquiSolnAlgo The NewtonRaphson class is an algorithmic class which obtains a solution to a non-linear system using the Newton-Raphson iteration scheme. The iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}^{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[ {\\bf K}^{(i)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors Destructor // Public Member Functions // Public Methods for Output The constructor takes as an argument the ConvergenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_NewtonRaphson (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_NewtonRaphson is passed. recvSelf() must be invoked on this object. Does nothing. When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the Newton-Raphson iteration algorithm: theTest -> start () theIntegrator -> formUnbalance (); do { theIntegrator -> formTangent (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); theIntegrator -> formUnbalance (); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. NOTE it is up to ConvergenceTest to ensure an infinite loop situation is not encountered. void setTest ( ConvergenceTest & theTest ); A method to set the ConvergenceTest object associated with the Algorithm to be theTest . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. * int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018NewtonRaphson\u2019 to the stream if flag equals \\(0\\) .","title":"NewtonRaphson\n"},{"location":"libraries/modeling/","text":"Modeling Capabilities Elements ( opensees.element ) Beam-column \u2013 3D elements with the following integration rules Linear elastic material (closed form), Concentrated plasticity integrated over specified hinge lengths, or Distributed plasticity integrated along the element length. Zero length \u2013 3D element which uses multiple uniaxial materials to model the element force-deformation relation. Truss \u2013 3D element with material non-linearity modeled by Uniaxial material stress-strain integrated over cross-sectional area, or Section force-deformation relationship. Quad \u2013 2D bilinear isoparametric element which uses ND materials at each of its integration points. Geometric Transforms Linear \u2013 first order geometry, P-Delta \u2013 second order \u201cleaning truss\u201d transformation, or Corotational \u2013 large displacement transformation. Cross Sections ( openseees.section ) Fiber \u2013 discretized by fibers which collectively define section response. The fiber models available are opensees.patch opensees.fiber opensees.layer Elastic \u2013 uncoupled axial and bending response. Uniaxial2d/3d \u2013 associates with a uniaxial material and enforces the Bernoulli beam assumption for axial and uni/bi-directional bending Generic1d/Nd \u2013 map stresses from uniaxial and ND materials to section stress resultants. For example, a uniaxial material can be used to model section moment-curvature behavior, or an ND plasticity model can be used to model section moment-axial-shear interaction. Aggregator \u2013 combination of a section and multiple uncoupled uniaxial materials used to define additional section force-deformation relations. For example, a fiber section can be combined with an uncoupled shear force-deformation relation. Backbone Materials Popovic\u2019s (Mander) Hognestad (Kent-Park) Uniaxial Materials ( opensees.uniaxial ) Core Elastic \u2013 linear elastic material tangent with optional linear damping tangent ElasticPP \u2013 elastic-perfectly plastic ElasticPPGap \u2013 one-sided EPP with an initial gap Hardening \u2013 bilinear model with combined linear isotropic and kinematic hardening Parallel \u2013 multiple uniaxial materials in parallel Series \u2013 multiple uniaxial materials in series FEDEAS Steel01 \u2013 bilinear steel model with linear kinematic and exponential isotropic hardening Concrete01 \u2013 concrete model with Kent-Park envelope, degraded linear unloading/reloading, and no tensile strength Hysteretic \u2013 trilinear backbone with pinching, damage, and degraded unloading stiffness SNAP BiLinear \u2013 bilinear hysteretic model with degradation Clough \u2013 Clough type hysteretic model with degradation Pinch \u2013 pinching hysteretic model with degradation ND Materials ElasticIsotropic \u2013 plane stress and plane strain formulations for use with the quad element.","title":"Modeling Capabilities\n"},{"location":"libraries/modeling/backbone/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } backbone Mander (name, **kwds) name Tag ReeseSoftClay (name, pu, y50, n, **kwds) name Tag pu Num y50 Num n Num ReeseSand (name, kx, ym, pm, yu, pu, **kwds) name Tag kx Num ym Num pm Num yu Num pu Num ReeseStiffClayBelowWS (name, Esi, y50, As, Pc, **kwds) name Tag Esi Num y50 Num As Num Pc Num Raynor (name, Es, fy, fsu, Epsilonsh, Epsilonsm, C1, Ey, **kwds) name Tag Es Num fy Num fsu Num Epsilonsh Num Epsilonsm Num C1 Num Ey Num LinearCapped (name, backbone, eCap, E, sRes, **kwds) name Tag backbone Ref(backbone) eCap Num E Num sRes Num","title":"backbone\n"},{"location":"libraries/modeling/backbone/ArctangentBackbone/","text":"Arctangent This file contains the implementation of ArctangentBackbone, which is a continuous function given by K1*atan(K2*strain) as developed by Ranzo and Petrangeli (1998) Written: MHS Created: Aug 2000 class ArctangentBackbone : public HystereticBackbone { public : ArctangentBackbone ( int tag , double K1 , double gammaY , double alpha ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double K1 ; double K2 ; double gammaY ; double alpha ; };","title":"Arctangent\n"},{"location":"libraries/modeling/backbone/CappedBackbone/","text":"Capped This file contains the implementation of CappedBackbone, which overlays two backbone curves. Written: MHS Created: Aug 2000 class CappedBackbone : public HystereticBackbone { public: CappedBackbone(int tag, HystereticBackbone &backbone, HystereticBackbone &cap); int setVariable(char *argv); int getVariable(int varID, double &theValue); private: HystereticBackbone *theBackbone; HystereticBackbone *theCap; double eCap; };","title":"Capped\n"},{"location":"libraries/modeling/backbone/CementedSoil/","text":"CementedSoil the Evans and Duncan (1982) SILT model at http://www.findapile.com/p-y-curves/p-y-curves-models class CementedSoil : public HystereticBackbone { public : CementedSoil ( int tag , double pM , double pU , double Kpy , double z , double b ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double pm ; double pu ; double kpy ; double depth ; double diameter ; };","title":"CementedSoil\n"},{"location":"libraries/modeling/backbone/LinearCappedBackbone/","text":"LinearCapped This file contains the implementation of LinearCappedBackbone, which is a linear cap given by a cap deformation and a slope imposed on a hysteretic backbone. Written: MHS Created: Aug 2000 class LinearCappedBackbone : public HystereticBackbone { public : LinearCappedBackbone ( int tag , HystereticBackbone & backbone , double def , double slope , double resStrength ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : HystereticBackbone * theBackbone ; double eCap ; double sCap ; double E ; double eRes ; double sRes ; };","title":"LinearCapped\n"},{"location":"libraries/modeling/backbone/LiquefiedSand/","text":"LiquefiedSand https://www.pilegroups.com/single-post/p-y-curve-model-of-liquefied-sand-rollins-et-al-2005 class LiquefiedSand : public HystereticBackbone { public : LiquefiedSand ( int tag , double x , double d , double kn , double m ); private : double X ; double D ; double kN ; double meter ; double yu ; };","title":"LiquefiedSand\n"},{"location":"libraries/modeling/backbone/ManderBackbone/","text":"Mander This file contains the implementation of ManderBackbone, which the concrete backbone function given by Mander, Priestly, and Park (1988) Written: MHS Created: Mar 2001 class ManderBackbone : public HystereticBackbone { public : ManderBackbone ( int tag , double fc , double epsc , double Ec ); private : double fpc ; double epsc ; double Ec ; };","title":"Mander\n"},{"location":"libraries/modeling/backbone/MaterialBackbone/","text":"Material Description: This file contains the implementation of MaterialBackbone, which treats a uniaxial material as a hysteretic backbone by removing path dependency, i.e. commitState is never called on the uniaxial material. Written: MHS Created: Aug 2000 C++ Interface class MaterialBackbone : public HystereticBackbone { public : MaterialBackbone ( int tag , UniaxialMaterial & material ); private : UniaxialMaterial * theMaterial ; };","title":"Material\n"},{"location":"libraries/modeling/backbone/MultilinearBackbone/","text":"Multilinear MultilinearBackbone is a backbone defined by many points. C++ Interface class MultilinearBackbone : public HystereticBackbone { public : MultilinearBackbone ( int tag , int numPoints , const Vector & e , const Vector & s ); private : double * E ; double * e ; double * s ; double * c ; int numPoints ; }; Written: MHS Created: Aug 2000","title":"Multilinear\n"},{"location":"libraries/modeling/backbone/RaynorBackbone/","text":"Raynor C++ Interface class RaynorBackbone : public HystereticBackbone { public : RaynorBackbone ( int tag , double es , double f1 , double f2 , double epsh , double epsm , double c1 , double ey ); private : double Es ; double fy ; double fsu ; double Epsilonsh ; double Epsilonsm ; double C1 ; double Ey ; };","title":"Raynor\n"},{"location":"libraries/modeling/backbone/ReeseSandBackbone/","text":"ReeseSand class ReeseSandBackbone : public HystereticBackbone { public : ReeseSandBackbone ( int tag , double kx , double ym , double pm , double yu , double pu ); private : double kx ; double ym ; double pm ; double yu ; double pu ; }; Written: MHS Created: Aug 2000","title":"ReeseSand\n"},{"location":"libraries/modeling/backbone/ReeseSoftClayBackbone/","text":"ReeseSoftClay Description: This file contains the implementation of ReeseSoftClayBackbone. class ReeseSoftClayBackbone : public HystereticBackbone { public : ReeseSoftClayBackbone ( int tag , double pu , double y50 , double n ); private : double pu ; double y50 ; double n ; }; Written: MHS Created: Aug 2000","title":"ReeseSoftClay\n"},{"location":"libraries/modeling/backbone/ReeseStiffClayAboveWS/","text":"ReeseStiffClayAboveWS Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 336 C++ Interface class ReeseStiffClayAboveWS : public HystereticBackbone { public : ReeseStiffClayAboveWS ( int tag , double pu , double y50 ); ReeseStiffClayAboveWS (); ~ ReeseStiffClayAboveWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double pu ; double y50 ; double hl ; };","title":"ReeseStiffClayAboveWS\n"},{"location":"libraries/modeling/backbone/ReeseStiffClayBelowWS/","text":"ReeseStiffClayBelowWS Response of Stiff Clay below the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 328 class ReeseStiffClayBelowWS : public HystereticBackbone { public : ReeseStiffClayBelowWS ( int tag , double esi , double y , double as , double pc ); ReeseStiffClayBelowWS (); ~ ReeseStiffClayBelowWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Esi ; double y50 ; double As ; double Pc ; };","title":"ReeseStiffClayBelowWS\n"},{"location":"libraries/modeling/backbone/TrilinearBackbone/","text":"Trilinear This file contains the implementation of TrilinearBackbone, which is a trilinear backbone Written: MHS Created: Aug 2000 class TrilinearBackbone : public HystereticBackbone { public : TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 , double e3 , double s3 ); TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 ); TrilinearBackbone (); ~ TrilinearBackbone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double E1 , E2 , E3 ; double e1 , e2 , e3 ; double s1 , s2 , s3 ; };","title":"Trilinear\n"},{"location":"libraries/modeling/backbone/VuggyLimestone/","text":"VuggyLimestone Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 348 class VuggyLimestone : public HystereticBackbone { public : VuggyLimestone ( int tag , double b , double su ); VuggyLimestone (); ~ VuggyLimestone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double diameter ; double shearStrength ; };","title":"VuggyLimestone\n"},{"location":"libraries/modeling/backbone/WeakRock/","text":"WeakRock on page 56 of this manual https://www.dropbox.com/s/h3s9qvvz3pb4tlf/Weak%20Rock%20Reference%20Book.pdf?dl=0 class WeakRock : public HystereticBackbone { public : WeakRock ( int tag , double kir , double pur , double yrm ); WeakRock (); ~ WeakRock (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Kir ; double pur ; double yrm ; };","title":"WeakRock\n"},{"location":"libraries/modeling/constraint/rigidBeam/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } RigidBeam RigidBeamLink (name, nodes, **kwds) name Tag nodes [nodes1,nodes2] nodes1 Ref(uniaxial) nodes2 Ref(uniaxial)","title":"RigidBeam\n"},{"location":"libraries/modeling/damping/rayleigh/","text":"Rayleigh","title":"Rayleigh\n"},{"location":"libraries/modeling/element/Brick/","text":"Brick?N The Eight Node Brick Element element Brick8N eletag? node1? node2? node3? node4? node5? node6? node7? node8? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, eight nodes ordered according to Figure 1 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick8N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cpqall\u201d, \u201cgausspoint\u201d, \u201cplastic\u201d or \u201cplasticGPC\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. If the stress states at all gauss points need to be printed, use the query \u201cpqall\u201d. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. But the coordinates have to be output separated. If one needs to output the gauss point coordinates together with the plastic strain, the query \u201cplasticGPC\u201d needs to be used. {#8node width=\u201c9.0cm\u201d} The Twenty Node Brick Element element Brick20N eletag? node1? node2? node3? node4? node5? node6? node7? node8? node9? node10? node11? node12? node13? node14? node15? node16? node17? node18? node19? node20? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, twenty nodes ordered according to Figure 2 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick20N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cgausspoint\u201d, or \u201cplastic\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. {#20node width=\u201c9cm\u201d}","title":"Brick?N\n"},{"location":"libraries/modeling/element/dispBeamColumn/","text":"dispBeamColumn opensees.element.DisplBeamColumn opensees.element.ForceBeamColumn","title":"dispBeamColumn\n"},{"location":"libraries/modeling/element/zeroLength/","text":"ZeroLength opensees.element.ZeroLength","title":"ZeroLength\n"},{"location":"libraries/modeling/nD/BidirectionalMaterial/","text":"BidirectionalMaterial #include <material/nD/BidirectionalMaterial.h> class BidirectionalMaterial : public NDMaterial TaggedObject MovableObject Material NDMaterial BidirectionalMaterial is an implementation of NDMaterial. BidirectionalMaterial is a two-dimensional elasto-plastic material model with combined linear isotropic and kinematic hardening. The yield surface is circular with a specified radius. A radial return map algorithm is used in the state determination. Constructors Destructor // Public Methods // Public Methods for Output Constructs a BidirectionalMaterial whose unique integer among NDMaterials in the domain is given by tag . Sets the elastic modulus to E , initial yield stress to fy , and isotropic and kinematic hardening moduli to Hiso and Hkin , respectively. Sets all committed history variables to \\(0.0\\) . The integers tag and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Constructs a BidirectionalMaterial with tag 0. All material parameters and committed history variables are set to \\(0.0\\) . The integers 0 and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Does nothing. Sets the trial strain of this material to be strain . Returns 0. Returns the current trial strain of this material. Returns the current stress computed by the radial return mapping algorithm. This is the 2d generalization of the 1d algorithm described in Simo & Hughes (1998), Box \\(1.5\\) . Returns the tangent consistent with the stress computed by the radial return mapping algorithm in getStress() . Sets the committed history variables to be their corresponding trial values. Returns 0. Does nothing. Returns 0. Sets all committed history variables to \\(0.0\\) . Returns 0. Returns a pointer to a new instance of BidirectionalMaterial with the same tag, elastic modulus, initial yield stress, and hardening moduli. Copies the committed history variables to the new object. It is up to the caller to invoke the destructor. Returns 0 if successful and a negative number if any of the send operation fails. Returns 0 if successful and a negative number if any of the receive operation fails. Prints the tag of this object and its elastic modulus, initial yield stress, and hardening moduli to the stream s .","title":"BidirectionalMaterial\n"},{"location":"libraries/modeling/nD/ElasticCrossAnisotropic/","text":"ElasticCrossAnisotropic","title":"ElasticCrossAnisotropic\n"},{"location":"libraries/modeling/nD/ElasticIsotropicPlaneStrain2D/","text":"ElasticIsotropicPlaneStrain2D #include <material/nD/ElasticIsotropicPlaneStrain2D.h> class ElasticIsotropicPlaneStrain2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStrain2D provides the implementation of an elastic isotropic material which exhibits plane strain behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStrain2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ \\begin{array}{ccc} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & 1-2\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStrain2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStrain2D\n"},{"location":"libraries/modeling/nD/ElasticIsotropicPlaneStress2D/","text":"ElasticIsotropicPlaneStress2D #include <material/nD/ElasticIsotropicPlaneStress2D.h> class ElasticIsotropicPlaneStress2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStress2D provides the implementation of an elastic isotropic material which exhibits plane stress behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStress2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{1-\\nu^2} \\left[ \\begin{array}{ccc} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & 1-\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStress2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStress2D\n"},{"location":"libraries/modeling/nD/Template3Dep/","text":"Template Elasto-Plastic Framework Yield Surface Command set ys \"-YieldSurfaceType <parameter list>\" This command sets the yield surface variable ys to be the specified type. A list of paramaters can be passed to define the yield surface and the number of parameters depend on the type of yield surface. Valid strings for YieldSurfaceType are DP , VM , CC , and RMC01 , which are described in the following subsections. Drucker-Prager Yield Surface set ys \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Yield Surface set ys \"-VM\" VM stands for von Mises type, i.e. cylinder shaped yield surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Yield Surface set ys \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped yield surface. For CC type yield surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Yield Surface set ys \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager yield surface. Potential Surface Command set ps \"-PotentialSurfaceType <parameter list>\" This command sets the potential surface variable ps to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for PotentialSurfaceType are DP , VM , and CC , which are described in the following subsections. Drucker-Prager Potential Surface set ps \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped potential surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Potential Surface set ps \"-VM\" VM stands for von Mises type, i.e. cylinder shaped potential surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Potential Surface set ps \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped potential surface. For CC type potential surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Potential Surface set ps \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped Potential surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager Potential surface. Evolution Law Command set el \"-EvolutionLawType <parameter list>\" This command sets the evolution law variable el to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for EvolutionLawType are Leq , NLp , and ``, which are described in the following subsections. Linear Scalar Evolution Law set el \"-Leq a?\" Leq stands for Linear Scalar Evolution Law. This hardening rule is based on the equivalent deviatoric plastic strain \\(\\epsilon_q^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any scalar internal variable, such as the slope of Drucker\u2013Prager yield surface, the diameter of von Mises yield surface, and so on. Nonlinear Scalar Evolution Law set el \"-NLp e0? lambda? kappa? \" NLp stands for Nonlinear Scalar Evolution Law. This hardening rule is based on the volumetic plastic strain \\(\\epsilon_p^{pl}\\) . In this case, parameters including void ration e0 , lambda and kappa need to be supplied. This hardening rule is primarily for the evolution of the tip stress \\(p^{'}_{o}\\) in Cam-Clay model. Linear Tensorial Evolution Law set et \"-LEij a?\" LEij stands for Linear Tensorial Evolution Law. This hardening rule is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. Nonlinear Tensorial Evolution Law (Armstrong-Frederick model ) set et \"-NLEij ha? Cr?\" NLEij stands for Nonlinear Tensorial Evolution Law from Armstrong\u2013Frederick nonlinear model. This kinematic hardening law is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, nonlinear hardening coefficients ha and Cr need to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. EPState Command <set sts \"Sxx? Sxy? Sxz? Syx? Syy? Syz? Szx? Szy? Szz?\"> set eps \"<-NOD nt?> -NOS ns? sc1? sc2? ... <-stressp sts>\" First statement sets the initial stress tensor to variable sts (if it is not stated here, no initial stress by default). Second statement assigns to the Elasto-Plastic state variable eps the specified state parameters, including number of tensorial internal variables nt (if it is not stated here, \\(nt=0\\) by default), number of scalar internal variables ns and corresponding initial values sc1 , sc2 , ..., and initial stresses defined in $sts (if it has been previously defined). Template Elasto-Plastic Material Command nDMaterial Template3Dep mTag? -YS $ys? -PS $ps? -EPS $eps? <-ELS1 $el?> <$-ELT1 et?> A template elasto-plastic material is constructed using nDMaterial command. The argument mTag is used to uniquely identify this nDMaterial object among nDMaterial objects in the BasicBuilder object. The other parameters include previously defined yield surface object ys , potential surface object ps , elasto-plastic state object eps , scalar evolution law object el , and tensorial evolution law object et . Examples von Mises Model # Yield surface set ys \"-VM\" # Potential surface set ps \"-VM\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # EPState #______________k=f(Cu) set EPS \"-NOD 0 -NOS 1 20\"# # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 -YS $ys -PS $ps -EPS $EPS -ELS1 $ES1 Drucker\u2013Prager Model # Yield surface set ys \"-DP\" # Potential surface set ps \"-DP 0.1\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" # EPState #______________alpha___k set EPS \"-NOD 0 -NOS 2 0.2 0.0 -stressp $ sts\" # # where #alpha = 2 sin(phi) / (3^0.5) / (3-sin(phi) ), phi is the friction angle # and k is the cohesion # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 -YS $ys -PS $ps -EPS $EPS -ELS1 $ES1 Cam-clay Model # Yield surface M = 1.2 set ys \"-CC 1.2\" # Potential surface M = 1.2 set ps \"-CC 1.2\" # Scalar evolution law___void ratio___Lamda___Kappa set ES1 \"-NLp 0.85 0.19 0.06\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" #________________po set EPS \"-NOS 1 200.1 -stressp $ sts\" # nDMaterial Template3Dep 1 -YS $ys -PS $ps -EPS $EPS -ELS1 $ES1","title":"Template Elasto-Plastic Framework\n"},{"location":"libraries/modeling/section/GenericSection1D/","text":"GenericSection1D #include <material/section/GenericSection1D.h> class GenericSection1D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSection1D provides a wrapper around a UniaxialMaterial so that any UniaxialMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSection1D whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the UniaxialMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the UniaxialMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the UniaxialMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the UniaxialMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Sets the section flexibility matrix, \\(\\fsec\\) , to be the inverse of the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\fsec\\) . This function overrides the base class implementation. Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. This function overrides the base class implementation. Invokes commitState() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToStart() on the UniaxialMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSection1D, using the same tag, UniaxialMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantity returned by this instance of GenericSection1D. Returns 1. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the UniaxialMaterial using the same values of s and flag .","title":"GenericSection1D\n"},{"location":"libraries/modeling/section/GenericSectionND/","text":"GenericSectionND #include <material/section/GenericSectionND.h> class GenericSectionND : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSectionND provides a wrapper around a NDMaterial so that any NDMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSectionND whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the NDMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the NDMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the NDMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the NDMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the NDMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Invokes commitState() on the NDMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the NDMaterial and returns the result of that invocation. Invokes revertToStart() on the NDMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSectionND, using the same tag, NDMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantities returned by this instance of GenericSectionND. Returns the result of invoking getOrder() on the NDMaterial. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the NDMaterial using the same values of s and flag .","title":"GenericSectionND\n"},{"location":"libraries/modeling/section/Patch/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } patch A patch is used to generate a number of fibers over a cross-sectional area. Currently there are three types of patches that fibers can be generated over: quadrilateral, rectangular and circular. All patches have the following attributes: area Total area of the patch. moic Second moment of area matrix of the patch about its centroidal axis ixc Second moment of inertia of the patch about its \\(x\\) axis iyc Second moment of inertia of the patch about its \\(y\\) axis fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). Fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). rect (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num quad (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num circ (material, \u2003\u2003\u2003divs, \u2003\u2003\u2003center, \u2003\u2003\u2003intRad, \u2003\u2003\u2003extRad, \u2003\u2003\u2003startAng, \u2003\u2003\u2003endAng, \u2003\u2003\u2003**kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [circ,rad] circ Int number of subdivisions (fibers) in the circumferential direction (number of wedges) rad Int number of subdivisions (fibers) in the radial direction (number of rings) center = [0.0, 0.0] [y,z] \\(y\\) & \\(z\\) -coordinates of the center of the circle y Num z Num intRad Num internal radius extRad Num external radius startAng Num starting angle endAng = 6.283185307179586 Num ending angle line (material, divs, fiber_area, vertices, **kwds) material Ref(Material) Reference to previously created material ( UniaxialMaterial for a FiberSection or NDMaterial for use in an NDFiberSection ) divs Int number of fibers along line area Num area of each fiber vertices [[y,z],[y,z]] start [y,z] \\(y\\) and \\(z\\) -coordinates of first fiber in line (local coordinate system) y Num z Num end [y,z] \\(y\\) and \\(z\\) -coordinates of last fiber in line (local coordinate system) y Num z Num","title":"patch\n"},{"location":"libraries/modeling/transform/Corotational/","text":"Corotational This command is used to construct the Corotational Coordinate Transformation ( CorotCrdTransf ) object. Corotational transformation can be used in large displacement-small strain problems. NOTE: Currently the transformation does not deal with element loads and will ignore any that are applied to the element. For a two-dimensional problem: geomTransf Corotational $transfTag <-jntOffset $dXi $dYi $dXj $dYj > For a three-dimensional problem: geomTransf Corotational $transfTag $vecxzX $vecxzY $vecxzZ $transfTag integer tag identifying transformation $vecxzX $vecxzY $vecxzZ X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. $dXi $dYi joint offset values -- absolute offsets specified with respect to the global coordinate system for element-end node i (optional) $dXj $dYj joint offset values -- absolute offsets specified with respect to the global coordinate system for element-end node j (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane -- vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking cross product of x and new y. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. Example Element 1 : tag 1 : vecxZ = zaxis tcl geomTransf Corotational 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf Corotational 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Corotational\n"},{"location":"libraries/modeling/uniaxial/730-UVCuniaxial%20%28Updated%20Voce-Chaboche%29/","text":"UVCuniaxial (Updated Voce-Chaboche) This command is used to construct an Updated Voce-Chaboche (UVC) material for uniaxial stress states (e.g., beam elements). This material is a refined version of the classic nonlinear isotropic/kinematic hardening material model based on the Voce isotropic hardening law and the Chaboche kinematic hardening law. The UVC model contains an updated isotropic hardening law, with parameter constraints, to simulate the permanent decrease in yield stress with initial plastic loading associated with the discontinuous yielding phenomenon in mild steels. Details regarding the model, its implementation, and calibration can be found in the references cited at the end. The multiaxial (e.g., for solid/brick elements) and plane-stress (e.g., for quad/plate/shell elements) versions are also available. The multiaxial and plane-stress implementations have the exact same hardening rules as this uniaxial model, and only differ in their purpose and numerical implementation. Available in OpenSees version 3.1.0+. uniaxialMaterial UVCuniaxial $matTag $E $fy $QInf $b $DInf $a $N $C1 \\(gamma1 &lt;\\) C2 $gamma2 $C3 $gamma3 \u2026 $C8 \\(gamma8&gt;</strong></p></td> </tr> </tbody> </table> <hr /> <table> <tbody> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">matTag</code></td> <td><p>Integer tag identifying the material.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">E</code></td> <td><p>Elastic modulus of the steel material.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">fy</code></td> <td><p>Initial yield stress of the steel material.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">QInf</code></td> <td><p>Maximum increase in yield stress due to cyclic hardening (isotropic hardening).</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">b</code></td> <td><p>Saturation rate of QInf, b &gt; 0.</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">DInf</code></td> <td><p>Decrease in the initial yield stress, to neglect the model updates set DInf = 0.</p></td> </tr> <tr class=\"odd\"> <td><code class=\"parameter-table-variable\">a</code></td> <td><p>Saturation rate of DInf, a &gt; 0. If DInf == 0, then a is arbitrary (but still a &gt; 0).</p></td> </tr> <tr class=\"even\"> <td><code class=\"parameter-table-variable\">N</code></td> <td><p>Number of backstresses to define, N &gt;= 1.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>\\) C1 Kinematic hardening parameter associated with backstress component 1. \\(gamma1</strong></p></td> <td><p>Saturation rate of kinematic hardening associated with backstress component 1.</p></td> </tr> <tr class=\"odd\"> <td><p><strong>&lt;\\) C2 $gamma2 $C3 $gamma3 \u2026 $C8 $gamma8> Additional backstress parameters, up to 8 may be specified. If C is specified, then the corresponding gamma must also be specified. Note that only the first N backstresses will be read by the parser. Examples 1. Validation with Abaqus: This first example compares the response of the UVC model with the built-in nonlinear isotropic/kinematic material model in Abaqus v6.14. For this validation the model updates are neglected by simply setting DInf = 0.0 and a = 1.0. The model parameters are: E = 179800 MPa, fy = 318.5 MPa, QInf = 100.7 MPa, b = 8.0, DInf = 0.0 MPa, a = 1.0, C1 = 11608.2 MPa, gamma1 = 145.2, C2 = 1026.3 MPa, gamma2 = 4.7 Figure 1 shows that the UVC implementation in OpenSees agrees with the built-in Abaqus model to the level of machine precision. Therefore, you can use the UVC model in place of the nonlinear isotropic/kinematic hardening material model provided in Abaqus and many other finite element simulation platforms. The finite element models used to validate the Abaqus and OpenSees responses can be found at https://github.com/ahartloper/UVC_MatMod . Figure 1. Validation of UVC model with built-in nonlinear isotropic/kinematic material in Abaqus. 2. Comparison with structural steels: The applicability of the UVC material model for structural steels is demonstrated through two comparisons with experimental data from uniaxial coupon tests. A comparison with a North American steel, A992 Gr. 50 (nominal fy = 345 MPa), is shown in Figure 2. A comparison with a European steel, S355J2+N (nominal fy = 355 MPa), is shown in Figure 3. In both cases the UVC model is able to represent well the initial yield stress as well as the material behavior in later loading cycles. The parameters used for the A992 Gr. 50 and S355J2+N steels, along with other common structural steels, are provided and discussed in the next section. <center> <gallery widths=400px heights=300px> File:A992_flange_UVC.png | Figure 2. Comparison of UVC model with uniaxial coupon test data from the A992 Gr. 50 W14X82 flange data set. File:S355j2_UVC.png | Figure 3. Comparison of UVC model with uniaxial coupon test data from the S355J2+N 25 mm plate data set. </gallery> </center> UVC model parameters for structural steels Below is a list of UVC model parameters for twelve structural steels from Reference [1] using two backstresses. These parameters are applicable for all implementations of the UVC model (uniaxial, plane-stress, multiaxial). References [1,3] contain detailed information on the calibration procedure used to obtain the model parameters. All of the parameters provided in the table below were obtained by minimizing the total squared-strain energy across at least five uniaxial coupon tests of distinct strain histories subject to the constraint that the material response is non-softening. Therefore, the UVC material model parameters should be representative of steel material behavior for arbitrarily imposed strains. Note that although the parameters in this table are considered representative of a specific sample of each material, significant variations can exist between different samples of the same material. All the parameters in the table are obtained through the UVC model calibration procedure implemented in the open-source Python package RESSPyLab . The RESSPyLab package can be used to generate UVC model parameters for other steel materials if the data is available. Details and examples on the calibration are provided on the RESSPyLab web page. Note that the parameters provided in the table below were calibrated using the true stress-strain definition, i.e., e_true = ln(1+(L-L_0)/L_0) and s_true = F/A_0 * (1 + (L-L_0)/L_0). UVC Material Parameters Material - S355J2+N (25 mm plate) S355J2+N (50 mm plate) S355J2+N (HEB500 flange) S355J2+N (HEB500 web) S460NL (25 mm plate) S690QL (25 mm plate) A992 Gr. 50 (W14X82 web) A992 Gr. 50 (W14X82 flange) A500 Gr. B (HSS305X16) BCP325 (22 mm plate) BCR295 (HSS350X22) HYP400 (27mm plate) References : Please use Reference [1] when citing the UVC model. [1] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. \u201cConstitutive Modeling of Structural Steels: Nonlinear Isotropic/Kinematic Hardening Material Model and its Calibration\u201d, https://doi.org/10.1061/(ASCE)ST.1943-541X.0002964 . [2] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cSensitivity of Simulated Steel Column Instabilities to Plasticity Model Assumptions\u201d. 12th Canadian Conference on Earthquake Engineering, Quebec City, QC, Canada. https://infoscience.epfl.ch/record/267788 [3] Hartloper, A. R., de Castro e Sousa A., and Lignos D.G. (2019). \u201cA Nonlinear Isotropic/Kinematic Hardening Model for Materials with Discontinuous Yielding\u201d. Report No. 271062, Resilient Steel Structures Laboratory (RESSLab), EPFL, Lausanne, Switzerland. https://infoscience.epfl.ch/record/271062 . Code developed, implemented, and maintained by: <span style=\u201ccolor:blue\u201d> Alex Hartloper (EPFL). Issues, bugs, and feature requests can be opened at the github repository .","title":"UVCuniaxial (Updated Voce-Chaboche)\n"},{"location":"libraries/modeling/uniaxial/Concrete01/","text":"UNDER CONSTRUCTION. Concrete01 #include <material/Concrete01.h> class Concrete01: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial Provides a uniaxial Kent-Scott-Park concrete model with linear unloading/reloading according to the work of Karsan-Jirsa and no strength in tension. The model contains a compressive strength of fpc, a strain at the compressive strength of epsc0, a crushing strength of fpcu, and a strain at the crushing strength of epscu. Compressive concrete parameters should be input as negative numeric values for this model to behave properly. Specification of minimum and maximum failure strains through the -min and -max switches is optional. The argument matTag is used to uniquely identify the material object among material objects in the BasicBuilder object. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"Concrete01\n"},{"location":"libraries/modeling/uniaxial/ElasticMaterial/","text":"ElasticMaterial #include <material/ElasticMaterial.h> class ElasticMaterial : public MaterialModel\\ TaggedObject MovableObject MaterialModel UniaxialMaterial ElasticMaterial provides the abstraction of an elastic uniaxial material, i.e. the stress-strain relationship is given by the linear equation \\(\\sigma = E * \\epsilon\\) . Constructor ### Destructor // Public Methods // Public Methods for Output To construct an ElasticMaterial with an integer identifier tag , an elastic tangent modulus of \\(E\\) and a current strain \\(\\epsilon\\) of \\(0.0\\) . The integers tag and MAT_TAG_ElasticMaterial, defined in <classTags.h> , are passed to the UniaxialMaterial classes constructor. Does nothing. Sets the value of the trial strain, \\(\\epsilon\\) to be strain . Returns \\(0\\) . Returns the product of \\(E * \\epsilon\\) , where \\(\\epsilon\\) is the current trial strain. Returns the value of \\(E\\) passed in the constructor. Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . returns a pointer to a new ElasticMaterial object, constructed using the same values of tag and \\(E\\) . It is up to the caller to ensure that the destructor is invoked. Creates a Vector of size \\(2\\) into which it places tag and E . Invokes sendVector() on theChannel using the ElasticMaterialObjects dbTag , the integer commitTag and the Vector as arguments. Returns \\(0\\) if successful, a warning message and a negative number are returned if the Channel object fails to send the Vector. Creates a Vector of size \\(2\\) . Invokes recvVector() on theChannel using the ElasticMaterialObjects dbTag , the integer commitTag and the Vector as arguments. Using the data in the Vector to set it\u2019s tag and \\(E\\) . Returns \\(0\\) if successful, a warning message is printed, tag and \\(E\\) are set to \\(0.0\\) , and a negative number is returned if the Channel object fails to receive the Vector. Prints to the stream s the objects tag and \\(E\\) values.","title":"ElasticMaterial\n"},{"location":"libraries/modeling/uniaxial/ElasticPPMaterial/","text":"UNDER CONSTRUCTION. ElasticPPModel #include <material/ElasticPPModel.h> class ElasticPPMaterial: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial ElasticPPMaterial provides the abstraction of an elastic perfectly plastic uniaxial material, i.e. the stress-strain relationship is given by the linear equation \\(\\sigma = E * \\epsilon\\) while the material is elastic and \\(| \\sigma = E * \\epsilon_p |\\) while the material is undergoing plastic deformation. SOME MORE THEORY. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"ElasticPPModel\n"},{"location":"libraries/modeling/uniaxial/ParallelMaterial/","text":"UNDER CONSTRUCTION. POSSIBLE NAME CHANGE IF MATERIAL GENERAL. ParallelModel #include <material/ParallelModel.h> class ParallelModel: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial A ParallelModel object is an aggregation of UniaxialMaterial objects all considered acting in parallel. SOME THEORY. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"ParallelModel\n"},{"location":"libraries/modeling/uniaxial/Steel01/","text":"UNDER CONSTRUCTION. Steel01 #include <material/Steel01.h> class Steel01 : public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial Steel01 provides the abstraction of a bilinear steel model with isotropic hardening. The model contains a yield strength of fy, an initial elastic tangent of E0, and a hardening ratio of b. The optional parameters a1, a2, a3, and a4 control the amount of isotropic hardening (default values are provided). Specification of minimum and maximum failure strains through the -min and -max switches is optional and must appear after the specification of the hardening parameters, if present. The argument matTag is used to uniquely identify the material object among material objects in the BasicBuilder object. Constructor ### Destructor // Public Methods // Public Methods for Output // Private Methods Does nothing.","title":"Steel01\n"},{"location":"libraries/modeling/uniaxial/ConcreteCM/","text":"Developed and Implemented by: [mailto:kkolozvari@fullerton.edu Kristijan Kolozvari ], California State University, Fullerton Kutay Orakcal , Bogazici University, Istanbul, Turkey John Wallace , Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial ConcreteCM (Kolozvari et al., 2015), which is a uniaxial hysteretic constitutive model for concrete developed by Chang and Mander (1994). This model is a refined, rule-based, generalized, and non-dimensional constitutive model that allows calibration of the monotonic and hysteretic material modeling parameters, and can simulate the hysteretic behavior of confined and unconfined, ordinary and high-strength concrete, in both cyclic compression and tension (Figure 1). The model addresses important behavioral features, such as continuous hysteretic behavior under cyclic compression and tension, progressive stiffness degradation associated with smooth unloading and reloading curves at increasing strain values, and gradual crack closure effects. Details of the model are available in the report by Chang and Mander (1994). [[File:ConcreteCM_0.png|500px|thumb|center|Figure 1. Hysteretic Constitutive Model for Concrete by Chang and Mander (1994)]] The Chang and Mander (1994) model successfully generates continuous hysteretic stress-strain relationships with slope continuity for confined and unconfined concrete in both compression and tension. The compression envelope curve of the model is defined by the initial tangent slope, (E c ), the peak coordinate ( \\(\\epsilon\\) \u2019 c , f\u2019 c ), a parameter (r c ) from Tsai\u2019s (1988) equation defining the shape of the envelope curve, and a parameter ( \\(\\epsilon^-_{cr}\\) ) to define normalized (with respect to \\(\\epsilon\\) \u2019 c ) strain where the envelope curve starts following a straight line, until zero compressive stress is reached at the spalling strain, \\(\\epsilon\\) sp . These parameters can be controlled based on specific experimental results for a refined calibration of the compression envelope (Figure 2). Chang and Mander (1994) proposed empirical relationships for parameters E c , \\(\\epsilon'\\) c , and r c for unconfined concrete with compressive strength \\(f^\\prime_c\\) , based on review of previous research. Parameters \\(f^\\prime_c\\) , \\(\\epsilon^\\prime_c\\) , E c , r c , and \\(\\epsilon\\) - cr can also be calibrated to represent the stress-strain behavior of confined concrete in compression, to follow the constitutive relationships for confined concrete proposed by Mander et al (1988) or similar. [[File:ConcreteCM_1.png|500px|thumb|center|Figure 2. Compression and Tension Envelope Curves]] The shape of the tension envelope curve in the model is the same as that of the compression envelope; however, the tension envelope curve is shifted to a new origin that is based on the unloading strain from the compression envelope (Figure 2). As well, the strain ductility experienced previously on the compression envelope is also reflected on the tension envelope. The parameters associated with the tension envelope curve include the tensile strength of concrete ( \\(f_t\\) ), the monotonic strain at tensile strength ( \\(\\epsilon\\) t ), a parameter ( \\(r_t\\) ) from Tsai\u2019s (1988) equation defining the shape of the tension envelope curve, and a parameter ( \\(\\epsilon\\) + cr ) to define normalized (with respect to \\(\\epsilon\\) t ) strain where the tension envelope curve starts following a straight line, until zero tensile stress is reached at a strain of \\(\\epsilon\\) crk . These parameters can also be controlled and calibrated based on specific experimental results or empirical relations proposed by other researchers (e.g., Belarbi and Hsu, 1994) to model the behavior of concrete in tension and the tension stiffening phenomenon. Concrete experiencing tension stiffening can be considered not to crack completely; that is, a large value for parameter \\(\\epsilon\\) + cr (e.g., 10000) can be defined. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Parameters {| | style=\u201cbackground:yellow; color:black; width:800px\u201d | uniaxialMaterial ConcreteCM $mattag $fpcc $epcc $Ec $rc $xcrn $ft $et $rt $xcrp <-GapClose $gap> |} {| | style=\u201cwidth:150px\u201d | $mattag || Unique \u2018\u2019uniaxialMaterial\u2019\u2019 tag |- | $fpcc || Compressive strength (f\u2019 c ) |- | $epcc || Strain at compressive strength ( \\(\\epsilon\\) \u2019 c ) |- | $Ec || Initial tangent modulus (E c ) |- | $rc || Shape parameter in Tsai\u2019s equation defined for compression (r c ) |- | $xcrn || Non-dimensional critical strain on compression envelope ( \\(\\epsilon\\) - cr , where the envelope curve starts following a straight line) |- | $ft || Tensile strength ( \\(f_t\\) ) |- | $et || Strain at tensile strength ( \\(\\epsilon\\) t ) |- | $rt || Shape parameter in Tsai\u2019s equation defined for tension ( \\(r_t\\) ) |- | $xcrp || Non-dimensional critical strain on tension envelope ( \\(\\epsilon\\) + cr , where the envelope curve starts following a straight line \u2013 large value [e.g., 10000] recommended when tension stiffening is considered) |- | <-GapClose $gap> || gap = 0, less gradual gap closure (default); gap = 1, more gradual gap closure |} Example uniaxialMaterial ConcreteCM 1 -6.2 -0.0021 4500 7 1.035 0.30 0.00008 1.2 10000 Example of hysteretic stress\u2013strain history generated by the model code is illustrated in Figure 3. [[File:ConcreteCM_2.PNG|500px|thumb|center|Figure 3. Concrete Stress-Strain Behavior]] ### Discussion An optional input parameter gap is introduced in the ConcreteCM model implemented in OpenSees for providing the users with the opportunity to control the intensity of gap closure in the stress-strain behavior of concrete, which in-turn influences the level of pinching in the lateral load-displacement behavior of a RC wall. The original Chang and Mander (1994) model adopts a non-zero tangent stiffness at zero stress level upon unloading from the tension envelope, which is represented by gap = 1 in ConcreteCM . Using gap = 0 (default) produces less gradual gap closure, since it assumes zero tangent stiffness at zero stress level upon unloading from the tension envelope, and is suitable for most analyses. Figure 4 illustrates the effect of plastic stiffness upon unloading from tension envelope ( \\(E^+_{pl}\\) ) on crack closure, i.e. use of more gradual ( gap = 1) or less gradual ( gap = 0) gap closure. The effect of parameter gap on predictions of flexural behavior of a RC wall is illustrated in Example 1 of [http://opensees.berkeley.edu/wiki/index.php/MVLEM_-_Multiple-Vertical-Line-Element-Model_for_RC_Walls MVLEM ] element. [[File:ConcreteCM_3.png|500px|thumb|center|Figure 4. Effect of Plastic Stiffness upon Unloading from Tension Envelope (Epl+) on Crack Closure]] Constitutive stress-strain concrete behavior is also implemented in OpenSees in uniaxialMaterial [http://opensees.berkeley.edu/wiki/index.php/Concrete07_%E2%80%93_Chang_%26_Mander%E2%80%99s_1994_Concrete_Model Cocnrete07 ]. However, ConcreteCM incorporates sophisticated unloading/reloading rules defined originally by Chang and Mander (1994), as opposed to Concrete07 that adopts simplified hysteretic rules. Comparison between stress-strain response predicted using ConcreteCM and Concrete07 is shown in Figure 5. [[File:ConcreteCMvsConcrete07.png|500px|thumb|center|Figure 5. Comparison of ConcreteCM and Concrete07]] References: Belarbi H. and Hsu T.C.C. (1994), \u201cConstitutive Laws of Concrete in Tension and Reinforcing Bars Stiffened by Concrete\u201d, ACI Structural Journal, V. 91, No. 4, pp. 465-474. Chang, G.A. and Mander, J.B. (1994), \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I \u2013 Evaluation of Seismic Capacity\u201d, NCEER Technical Report No. NCEER-94-0006, State University of New York, Buffalo. Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, [http://peer.berkeley.edu/publications/peer_reports/reports_2015/webPEER-2015-12-kolozvari.pdf PEER Report No. 2015/12] Mander J.B., Priestley M.J.N., and Park R. (1988). \u201cTheoretical Stress-Strain Model for Confined Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 8, pp. 1804-1826. Orakcal K.(2004), \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. Tsai W.T. (1988), \u201cUniaxial Compressional Stress-Strain Relation of Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 9, pp. 2133-2136.","title":""},{"location":"libraries/modeling/uniaxial/PyTzQz/","text":"SimplePyTzQz","title":"SimplePyTzQz\n"},{"location":"libraries/modeling/uniaxial/PyTzQz/PySimple/","text":"PY Simple1 This command is used to construct a PySimple1 uniaxial material object: uniaxialMaterial PySimple1 $matTag $soilType $pult $Y50 $Cd < $c > Parameter Description matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult . c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects Notes In general the HHT algorithm is preferred over a Newmark algorithm when using this material. This is due to the numerical oscillations that can develop with viscous damping forces under transient loading with certain solution algorithms and damping ratios. EQUATIONS and EXAMPLE RESPONSES The equations describing PySimple1 behavior are described in [1] Only minor changes have been made in its implementation for OpenSees. The nonlinear \\(p-y\\) behavior is conceptualized as consisting of elastic ( \\(p-y^e\\) ), plastic ( \\(p-y^p\\) ), and gap \\((p-y^g)\\) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component \\((p-y^e)\\) of the displacement rate. The gap component consists of a nonlinear closure spring ( \\(p^c-y^g\\) ) in parallel with a nonlinear drag spring \\((p^d-y^g)\\) . Note that \\(y = y^e + y^p + y^g\\) , and that \\(p = p^d + p^c\\) . The plastic component has an initial range of rigid behavior between \\(-C_r p_\\text{ult} < p < C_r p_\\text{ult}\\) where \\(C_r\\) is the ratio of \\(p/p_\\text{ult}\\) when plastic yielding first occurs in virgin loading. The rigid range of \\(p\\) , which is initially \\(2 C_r p_\\text{ult}\\) , translates with plastic yielding (kinematic hardening). The rigid range of \\(p\\) can be constrained to maintain a minimum size on both the positive and negative loading sides (e.g., 25% of \\(p\\text{ult}\\) ), and this is accomplished by allowing the rigid range to expand or contract as necessary. Beyond the rigid range, loading of the plastic \\((p-y^p)\\) component is described by: \\[p = p_{\\text{ult}} - (p_{\\text{ult}} - p_o) \\left [\\frac{c y_{50}}{c y_{50} + | z_p - z^p_0|} \\right ]^n \\] where \\(p_\\text{ult}\\) is the ultimate resistance of the \\(p-y\\) material in the current loading direction, \\(p_o = p\\) at the start of the current plastic loading cycle, \\(y^p_o = y_p\\) at the start of the current plastic loading cycle, \\(c\\) = constant to control the tangent modulus at the start of plastic yielding, and n = an exponent to control sharpness of the \\(p-y^p\\) curve. The closure \\((p^c-y^g)\\) spring is described by: \\[p^c = 1.8 p_{\\text{ult}} \\left [\\frac{y_{50}}{y_{50} + 50(y_o^\\text{+} - y^g)} - \\frac{y_{50}}{y_{50} + 50(y_o^\\text{-} - y^g)} \\right ] \\] where \\(y_o^+\\) is the memory term for the positive side of the gap, \\(y_o^-\\) = memory term for the negative side of the gap. The initial values of \\(y_o^+\\) and \\(y_o^-\\) were set as \\(y_{50}/100\\) and \\(- y_{50}/100\\) , respectively. The factor of 1.8 brings \\(p^c\\) up to \\(p_\\text{ult}\\) during virgin loading to \\(y_o^+\\) (or \\(y_o^-\\) ). Gap enlargement follows logic similar to that of Matlock et al. (1978). The gap grows on the positive side when the plastic deformation occurs on the negative loading side. Consequently, the \\(y_o^+\\) value equals the opposite value of the largest past negative value of, \\(y^p + y^g + 1.5 y_{50}\\) where the \\(1.5y_{50}\\) represents some rebounding of the gap. Similarly, the \\(y_o^-\\) value equals the opposite value of the largest past positive value of \\(y^p+y^g-1.5y_{50}\\) . This closure spring allows for a smooth transition in the load displacement behavior as the gap opens or closes. The nonlinear drag \\((p^d-y^g)\\) spring is described by: \\[p^d = C_d p_{\\text{ult}} - (C_d p_{\\text{ult}} - p^d_o) \\left [\\frac{y_{50}}{y_{50} + 2| y^g - y^g_o|} \\right ]^n\\] where \\(C_d\\) is the ratio of the maximum drag force to the ultimate resistance of the p-y material, \\(d^p_o =p^d\\) at the start of the current loading cycle, and \\(y^g_o = y^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different p-y backbone relations. Matlock\u2019s (1970) recommended backbone for soft clay is closely approximated using \\(c = 10\\) , \\(n = 5\\) , and \\(C_r = 0.35\\) . API\u2019s (1993) recommended backbone for drained sand is closely approximated using \\(c = 0.5\\) , \\(n = 2\\) , and \\(C_r = 0.2\\) . PySimple1 is currently implemented to allow use of these two default sets of values. Values of \\(p_\\text{ult}\\) , \\(y_{50}\\) , and \\(C_d\\) must then be specified to define the \\(p-y\\) material behavior. Viscous damping on the far-field (elastic) component of the p-y material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap. In addition, the total force across the p-y material is restricted to pult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like PySimple1. [1]: Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759.","title":"PY Simple1\n"},{"location":"libraries/modeling/uniaxial/ScottHysteretic/","text":"ScottHysteretic uniaxialMaterial OOHysteretic tag ? bkbn+? unlRul+? stfDeg+? strDeg+? <bkbn-? unlRul-? stfDeg-? strDeg-?> <pinchX? pinchY?> HystereticBackbone hystereticBackbone type? tag? hystereticBackbone ReeseSoftClay tag? pu? y50? n? hystereticBackbone ReeseSand tag? kx? ym? pm? yu? pu? hystereticBackbone ReeseStiffClayBelowWS tag? Esi? y50? As? Pc? hystereticBackbone Raynor tag? Es? fy? fsu? Epsilonsh? Epsilonsm? C1? Ey? hystereticBackbone Capped tag? hystereticBackboneTag? capTag? hystereticBackbone LinearCapped tag? backboneTag? eCap? E? sRes? hystereticBackbone Material tag? matTag?\" << endln; hystereticBackbone Bilinear void *theBB = OPS_BilinearBackbone(rt); hystereticBackbone Trilinear void *theBB = OPS_TrilinearBackbone(rt); hystereticBackbone Multilinear void *theBB = OPS_MultilinearBackbone(rt); hystereticBackbone Arctangent void *theBB = OPS_ArctangentBackbone(rt); hystereticBackbone Mander void *theBB = OPS_ManderBackbone(rt); UnloadingRule unloadingRule type? tag? StiffnessDegradation StrengthDegradation strengthDegradation type? tag? Class Interface","title":"ScottHysteretic\n"},{"location":"libraries/numerics/","text":"Numeric Libraries Linear Equation Solvers The following methods provide the solution of the linear system of equations \\(Ku = P\\) . Each solver is tailored to a specific matrix topology. Profile SPD \u2013 Direct profile solver for symmetric positive definite matrices Band General \u2013 Direct solver for banded unsymmetric matrices Band SPD \u2013 Direct solver for banded symmetric positive definite matrices Sparse General \u2013 Direct solver for unsymmetric sparse matrices Sparse Symmetric \u2013 Direct solver for symmetric sparse matrices UmfPack General \u2013 Direct UmfPack solver for unsymmetric matrices Full General \u2013 Direct solver for unsymmetric dense matrices Conjugate Gradient \u2013 Iterative solver using the preconditioned conjugate gradient method Eigenvalue Solvers The following methods provide the solution of the generalized eigenvalue problem \\(Kv = MvL\\) Symmetric Arpack \u2013 Arpack solver for symmetric matrices Band Arpack \u2013 Arpack solver for banded matrices DOF Numberers The numbering of the degrees of freedom in the domain is done by the following methods Plain \u2013 Uses the numbering provided by the user RCM \u2013 Renumbers the DOF to minimize the matrix band-width using the Reverse Cuthill-McKee algorithm","title":"Numeric Libraries\n"},{"location":"libraries/numerics/EigenDecomp/ArpackSolver/","text":"ArpackSolver This is the solver that works on the ArpackSOE. It uses the LinearSOE in the SOE to perform the solve() operation if required. It uses the ARPACK library to perform the eigenvalue analysis. ARPACK is an eigen analysis package which was developed by R.B.Lehoucq, D.C.Sorensen and C.Yang at Rice University. ARPACK is a collection of FORTRAN77 subroutines designed to solve large scale eigen problems. ARPACK is capable of solving large scale non-Hermitian standard and generalized eigen problems. When the matrix K is symmetric, the method is a variant of the Lanczos process called Implicitly Restarted Lanczos Method (IRLM). It is based on previous work of Jun Peng(Stanford) Written: fmk Created: 05.09","title":"ArpackSolver\n"},{"location":"libraries/numerics/LinearSolve/110-Cusp/","text":"Cusp CuSPSolver is a linear sparse system solver based on CUSP Sparse library for OpenSEES. All the algorithms and the preconditioners supported by CUSP can be used in this solver. It can be invoked by a simple statement, which means it is very easy to use. Due to it\u2019s hardware and softawre requirements it is not built into the main OpenSees executable. Hardware Requirements: GPU: NVIDIA\u2019s GPU\u2019s with the CUDA\u2122 architecture. The list of CUDA-supported GPUs\uff1ahttps://developer.nvidia.com/cuda-gpus Software\uff1a OS: Windows XP 32/64-bit or later CUDA 5.5 Production Release CuSP 0.4.0 CuSPSolver package` Installation Process: Download the CUDA Toolkit 5.5 package from the official website of NVIDIA (choose the package which is consistent with your OS ), and install it. NOTE currently we are using CUDA 5.5, even though CUDA is now at release 6.0 (we will upgrade once CuSP upgrades to 6.0) https://developer.nvidia.com/cuda-toolkit-55-archive Install the CuSP library download\uff1ahttps://github.com/cusplibrary/cusplibrary Download one of the .dll\u2019s we provide based on either your <a href=\u201c http://opensees.berkeley.edu/OpenSees/code/cusp/32/CuSPSolver.dll\u201d> ; 32</a> or <a href=\u201c http://opensees.berkeley.edu/OpenSees/code/cusp/64/CuSPSolver.dll\u201d> ; 64 version of windows. system CuSP -rTol $RTOL -mInt $MINT -pre $PRE -solver $SOLVER \\(RTOL</strong></p></td> <td><p>Set the relative tolerance.</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) MINT Set the maximum number of iterations. \\(PRE</strong></p></td> <td><p>Set the preconditioner. can be none, diagonal, and ainv</p></td> </tr> <tr class=\"even\"> <td><p><strong>\\) SOLVER Set the iterative solver. can be bicg, bicgstab, cg, and gmres.","title":"Cusp\n"},{"location":"libraries/numerics/LinearSolve/274-FullGeneral/","text":"FullGeneral This command is used to construct a Full General linear system of equation object. As the name implies, the class utilizes NO space saving techniques to cut down on the amount of memory used. If the matrix is of size, nxn, then storage for an nxn array is sought from memory when the program runs. When a solution is required, the Lapack routines DGESV and DGETRS are used. The following command is used to construct such a system: system FullGeneral NOTES: This type of system should almost never be used! This is because it requires a lot more memory than every other solver and takes more time in the actal solving operation than any other solver. It is required if the user is interested in looking at the global system matrix. Code Developed by: fmk","title":"FullGeneral\n"},{"location":"libraries/numerics/LinearSolve/35-BandGeneral%20SOE/","text":"BandGeneral SOE This command is used to construct a BandGeneralSOE linear system of equation object. As the name implies, this class is used for matrix systems which have a banded profile. The matrix is stored as shown below in a 1dimensional array of size equal to the bandwidth times the number of unknowns. When a solution is required, the Lapack routines DGBSV and SGBTRS are used. The following command is used to construct such a system: system BandGeneral NOTES: THEORY: An n &times; n matrix A =( a <sub> i,j </sub>) is a band matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k <sub>1</sub> and k <sub>2</sub>: \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j&lt;i-k_1 \\quad\\mbox{ or }\\quad j&gt;i+k_2; \\quad k_1, k_2 \\ge 0.\\,\\] The quantities k <sub>1</sub> and k <sub>2</sub> are the left and right half-bandwidth , respectively. The bandwidth of the matrix is k <sub>1</sub>&nbsp;+&nbsp; k <sub>2</sub>&nbsp;+&nbsp;1 (in other words, the smallest number of adjacent diagonals to which the non-zero elements are confined). and matrices are usually stored by storing the diagonals in the band; the rest is implicitly zero. For example, 6-by-6 a matrix with bandwidth 3: <math> \\[\\begin{bmatrix} B_{11} &amp; B_{12} &amp; 0 &amp; \\cdots &amp; \\cdots &amp; 0 \\\\ B_{21} &amp; B_{22} &amp; B_{23} &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; B_{32} &amp; B_{33} &amp; B_{34} &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; \\ddots &amp; B_{43} &amp; B_{44} &amp; B_{45} &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; B_{54} &amp; B_{55} &amp; B_{56} \\\\ 0 &amp; \\cdots &amp; \\cdots &amp; 0 &amp; B_{65} &amp; B_{66} \\end{bmatrix}\\] </math> is stored as the 6-by-3 matrix <math> \\[\\begin{bmatrix} 0 &amp; B_{11} &amp; B_{12}\\\\ B_{21} &amp; B_{22} &amp; B_{23} \\\\ B_{32} &amp; B_{33} &amp; B_{34} \\\\ B_{43} &amp; B_{44} &amp; B_{45} \\\\ B_{54} &amp; B_{55} &amp; B_{56} \\\\ B_{65} &amp; B_{66} &amp; 0 \\end{bmatrix}\\] . </math> Code Developed by: fmk","title":"BandGeneral SOE\n"},{"location":"libraries/numerics/LinearSolve/36-BandSPD%20SOE/","text":"BandSPD SOE This command is used to construct a BandSPDSOE linear system of equation object. As the name implies, this class is used for symmetric positive definite matrix systems which have a banded profile. The matrix is stored as shown below in a 1 dimensional array of size equal to the (bandwidth/2) times the number of unknowns. When a solution is required, the Lapack routines DPBSV and DPBTRS are used. The following command is used to construct such a system: system BandSPD NOTES: THEORY: An n &times; n matrix A =( a <sub> i,j </sub>) is a symmmetric banded matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k : \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j&lt;i-k \\quad\\mbox{ or }\\quad j&gt;i+k; \\quad k \\ge 0.\\,\\] \\[a_{i,j} = a_{j,i}\\,\\] <math> y^T A y != 0 ,</math> for all non-zero vectors y with real entries (<math>y ^n</math>), The bandwidth of the matrix is k &nbsp;+&nbsp; k &nbsp;+&nbsp;1. For example, a symmetric 6-by-6 matrix with a right bandwidth of 2: <math> \\[\\begin{bmatrix} A_{11} &amp; A_{12} &amp; A_{13} &amp; 0 &amp; \\cdots &amp; 0 \\\\ &amp; A_{22} &amp; A_{23} &amp; A_{24} &amp; \\ddots &amp; \\vdots \\\\ &amp; &amp; A_{33} &amp; A_{34} &amp; A_{35} &amp; 0 \\\\ &amp; &amp; &amp; A_{44} &amp; A_{45} &amp; A_{46} \\\\ &amp; sym &amp; &amp; &amp; A_{55} &amp; A_{56} \\\\ &amp; &amp; &amp; &amp; &amp; A_{66} \\end{bmatrix}\\] . </math> This matrix is stored as the 6-by-3 matrix: <math> \\[\\begin{bmatrix} A_{11} &amp; A_{12} &amp; A_{13} \\\\ A_{22} &amp; A_{23} &amp; A_{24} \\\\ A_{33} &amp; A_{34} &amp; A_{35} \\\\ A_{44} &amp; A_{45} &amp; A_{46} \\\\ A_{55} &amp; A_{56} &amp; 0 \\\\ A_{66} &amp; 0 &amp; 0 \\end{bmatrix}\\] . </math> Code Developed by: fmk","title":"BandSPD SOE\n"},{"location":"libraries/numerics/LinearSolve/546-ProfileSPD%20SOE/","text":"ProfileSPD SOE This command is used to construct a profileSPDSOE linear system of equation object. As the name implies, this class is used for symmetric positive definite matrix systems. The matrix is stored as shown below in a 1 dimensional array with only those values below the first non-zero row in any column being stored. This is sometimes also referred to as a skyline storage scheme. The following command is used to construct such a system: system ProfileSPD THEORY: An n &times; n matrix A =( a <sub> i,j </sub>) is a symmmetric postive definite matrix if: \\[a_{i,j} = a_{j,i}\\,\\] <math> y^T A y != 0 ,</math> for all non-zero vectors y with real entries (<math>y ^n</math>). In the skyline or profile storage scheme only the entries below the first no-zero row entry in any column are stored if storing by rows: The reason for this is that as no reordering of the rows is required in gaussian eleimination because the matrix is SPD, no non-zero entries will ocur in the elimination process outside the area stored. For example, a symmetric 6-by-6 matrix with a structura as shown below: <math> \\[\\begin{bmatrix} A_{11} &amp; A_{12} &amp; 0 &amp; 0 &amp; 0 \\\\ &amp; A_{22} &amp; A_{23} &amp; 0 &amp; A_{25} \\\\ &amp; &amp; A_{33} &amp; 0 &amp; 0 \\\\ &amp; &amp; &amp; A_{44} &amp; A_{45} \\\\ &amp; sym &amp; &amp; &amp; A_{55} \\end{bmatrix}\\] . </math> The matrix is stored as 1-d array <math> \\[\\begin{bmatrix} A_{11} &amp; A_{12} &amp; A_{22} &amp; A_{23} &amp; A_{33} &amp; A_{44} &amp; A_{25} &amp; 0 &amp; A_{45} &amp; A_{55} \\end{bmatrix}\\] . </math> with a further array containing indices of diagonal elements: <math> \\[\\begin{bmatrix} 1 &amp; 3 &amp; 5 &amp; 6 &amp; 10 \\end{bmatrix}\\] . </math> Code Developed by: fmk","title":"ProfileSPD SOE\n"},{"location":"libraries/numerics/LinearSolve/660-SparseSPD%20SOE/","text":"SparseSPD SOE","title":"SparseSPD SOE\n"},{"location":"libraries/numerics/LinearSolve/661-SparseSYM%20SOE/","text":"SparseSYM SOE This command is used to construct a sparse symmetric system of equations which uses a row-oriented solution method in the solution phase. The following command is used to construct such a system: system SparseSYM NOTES: versions upto and including 2.2.0 use SparseSPD instead of SparseSYM as the option to the system command. For backward compatability this old option continues to work. REFERENCES: Kincho H. Law and David R. McKay, \u201cA Parallel Row-Oriented Sparse Solution Method for Finite Element Structural Analysis,\u201d International Journal for Numerical Methods in Engineering, 36:2895-2919, 1993. Code Developed by: Jun Peng, Stanford and now GOOGLE","title":"SparseSYM SOE\n"},{"location":"libraries/numerics/LinearSolve/672-SuperLU%20SOE/","text":"SuperLU SOE This command is used to construct a SparseGEN linear system of equation object. As the name implies, this class is used for sparse matrix systems. The solution of the sparse matrix is carried out using SuperLU . To following command is used to construct such a system: system SparseGEN REFERENCES: James W. Demmel and Stanley C. Eisenstat and John R. Gilbert and Xiaoye S. Li and Joseph W. H. Liu, \u201cA supernodal approach to sparse partial pivoting\u201d, SIAM J. Matrix Analysis and Applications, 20(3), 720-755, 1999. Code Developed by: fmk","title":"SuperLU SOE\n"},{"location":"libraries/numerics/LinearSolve/674-System%20Command/","text":"System Command This command is used to construct the LinearSOE and LinearSolver objects to store and solve the system of equations in the analysis. system systemType? arg1? ... The type of LinearSOE created and the additional arguments required depends on the systemType? provided in the command. The following contain information about systemType? and the args required for each of the available aystem types: BandGeneral SOE BandSPD SOE ProfileSPD SOE SuperLU SOE UmfPack SOE FullGeneral SparseSYM SOE Mumps Cusp","title":"System Command\n"},{"location":"libraries/numerics/LinearSolve/731-UmfPack%20SOE/","text":"UmfPack SOE This command is used to construct a sparse system of equations which uses the UmfPack solver. The following command is used to construct such a system: system UmfPack &lt;-lvalueFact $LVALUE &gt; (LVALUE*the number of nonzero entries) is the amount of additional memory set aside for fill in during the matrix solution, by default the LVALUE factor is 10. You only need to experiment with this if you get error messages back about LVALUE being too small. REFERENCES: A column pre-ordering strategy for the unsymmetric-pattern multifrontal method, T. A. Davis, ACM Transactions on Mathematical Software, vol 30, no. 2, June 2004, pp. 165-195. Algorithm 832: UMFPACK, an unsymmetric-pattern multifrontal method, T. A. Davis, ACM Transactions on Mathematical Software, vol 30, no. 2, June 2004, pp. 196-199. A combined unifrontal/multifrontal method for unsymmetric sparse matrices, T. A. Davis and I. S. Duff, ACM Transactions on Mathematical Software, vol. 25, no. 1, pp. 1-19, March 1999. An unsymmetric-pattern multifrontal method for sparse LU factorization, T. A. Davis and I. S. Duff, SIAM Journal on Matrix Analysis and Applications, vol 18, no. 1, pp. 140-158, Jan. 1997. Code Developed by: fmk","title":"UmfPack SOE\n"},{"location":"libraries/numerics/LinearSolve/BandGenLapack/","text":"BandGenLinLapackSolver This command is used to construct a BandGeneralSOE linear system of equation object. As the name implies, this class is used for matrix systems which have a banded profile. The matrix is stored as shown below in a one-dimensional array of size equal to the bandwidth times the number of unknowns. When a solution is required, the Lapack routines DGBSV and SGBTRS are used. Theory An \\(n\\timesn\\) matrix A =( a i,j ) is a band matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k 1 and k 2 : \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j<i-k_1 \\quad\\mbox{ or }\\quad j>i+k_2; \\quad k_1, k_2 \\ge 0.\\,\\] The quantities k 1 and k 2 are the left and right half-bandwidth , respectively. The bandwidth of the matrix is k 1 + k 2 + 1 (in other words, the smallest number of adjacent diagonals to which the non-zero elements are confined). and matrices are usually stored by storing the diagonals in the band; the rest is implicitly zero. For example, 6-by-6 a matrix with bandwidth 3: \\[\\begin{bmatrix} B_{11} & B_{12} & 0 & \\cdots & \\cdots & 0 \\\\ B_{21} & B_{22} & B_{23} & \\ddots & \\ddots & \\vdots \\\\ 0 & B_{32} & B_{33} & B_{34} & \\ddots & \\vdots \\\\ \\vdots & \\ddots & B_{43} & B_{44} & B_{45} & 0 \\\\ \\vdots & \\ddots & \\ddots & B_{54} & B_{55} & B_{56} \\\\ 0 & \\cdots & \\cdots & 0 & B_{65} & B_{66} \\end{bmatrix}\\] is stored as the 6-by-3 matrix \\[\\begin{bmatrix} 0 & B_{11} & B_{12}\\\\ B_{21} & B_{22} & B_{23} \\\\ B_{32} & B_{33} & B_{34} \\\\ B_{43} & B_{44} & B_{45} \\\\ B_{54} & B_{55} & B_{56} \\\\ B_{65} & B_{66} & 0 \\end{bmatrix}.\\] C++ Interface #include <system_of_eqn/linearSOE/bandGEN/BandGenLinLapackSolver.h> class BandGenLinLapackSolver : public BandGenLinSolver MovableObject Solver LinearSOESolver A BandGenLinLapackSolver object can be constructed to solve a BandGenLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the BandGenLinSOE class (see <BandGenLinSOE.h> ). Constructor ### Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the BandGenLinSolver constructor. Sets the size of iPiv to \\(0\\) , iPiv being an integer array needed by the LAPACK routines. Invokes delete on iPiv to free the memory allocated to store the array. The solver first copies the B vector into X and then solves the BandGenLinSOE system by calling the LAPACK routines dgbsv() , if the system is marked as not having been factored, and dgbtrs() if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is used to construct a 1d integer array, iPiv that is needed by the LAPACK solvers. It checks to see if current size of iPiv is large enough, if not it deletes the cold and creates a larger array. Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for this new array. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Code Developed by: fmk","title":"BandGenLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/BandSPDLapack/","text":"BandSPDLinLapackSolver system BandSPD This command is used to construct a BandSPDSOE linear system of equation object. As the name implies, this class is used for symmetric positive definite matrix systems which have a banded profile. The matrix is stored as shown below in a one dimensional array of size equal to the ( bandwidth /2) times the number of unknowns. When a solution is required, the Lapack routines DPBSV and DPBTRS are used. Theory An n \u00d7 n matrix A =( a i,j ) is a symmmetric banded matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k : \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j<i-k \\quad\\mbox{ or }\\quad j>i+k; \\quad k \\ge 0.\\,\\] \\[a_{i,j} = a_{j,i}\\,\\] \\[y^T A y != 0 \\,\\] for all non-zero vectors y with real entries ( \\(y \\in \\mathbb{R}^n\\) ), The bandwidth of the matrix is k + k + 1. For example, a symmetric 6-by-6 matrix with a right bandwidth of 2: \\[\\begin{bmatrix} A_{11} & A_{12} & A_{13} & 0 & \\cdots & 0 \\\\ & A_{22} & A_{23} & A_{24} & \\ddots & \\vdots \\\\ & & A_{33} & A_{34} & A_{35} & 0 \\\\ & & & A_{44} & A_{45} & A_{46} \\\\ & sym & & & A_{55} & A_{56} \\\\ & & & & & A_{66} \\end{bmatrix}.\\] This matrix is stored as the 6-by-3 matrix: \\[\\begin{bmatrix} A_{11} & A_{12} & A_{13} \\\\ A_{22} & A_{23} & A_{24} \\\\ A_{33} & A_{34} & A_{35} \\\\ A_{44} & A_{45} & A_{46} \\\\ A_{55} & A_{56} & 0 \\\\ A_{66} & 0 & 0 \\end{bmatrix}.\\] Code Developed by: fmk C++ #include <system_of_eqn/linearSOE/bandSPD/BandSPDLinLapackSolver.h> class BandSPDLinLapackSolver : public BandSPDLinSolver MovableObject Solver LinearSOESolver A BandSPDLinLapackSolver object can be constructed to solve a BandSPDLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the BandSPDLinSOE class. Constructor Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the BandSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X and then solves the BandSPDLinSOE system by calling the LAPACK routines dpbsv() , if the system is marked as not having been factored, and dpbtrs() if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"BandSPDLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/FullGenLapack/","text":"FullGenLinLapackSolver #include <~/system_of_eqn/linearSOE/fullGEN/FullGenLinLapackSolver.h> class FullGenLinLapackSolver : public FullGenLinSolver MovableObject Solver LinearSOESolver A FullGenLinLapackSolver object can be constructed to solve a FullGenLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the FullGenLinSOE class (see FullGenLinSOE ). Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the FullGenLinSolver constructor. Sets the size of iPiv to \\(0\\) , iPiv being an integer array needed by the LAPACK routines. Invokes delete on iPiv to free the memory it was allocated. First copies \\(B\\) into \\(X\\) and then solves the FullGenLinSOE system it is associated with (pointer kept by parent class) by calling the LAPACK routines dgesv() , if the system is marked as not having been factored, or dgetrs() , if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is used to construct a 1d integer array, iPiv that is needed by the LAPACK solvers. It checks to see if current size of iPiv is large enough, if not it deletes the cold and creates a larger array. Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for this new array. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"FullGenLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/ITPACK/","text":"ITPACK Introduction For several years, we have been involved with the development and use of research-oriented programs using iterative algorithms for solving large sparse linear systems \\(Au = b\\) with positive diagonal elements. One solves for the N component unknown vector \\(u\\) given the \\({\\bf N \\times N}\\) nonsingular coefficient matrix \\(A\\) and the N component right-hand side vector \\(b\\) . The current ITPACK software package of subroutines, version 2C, provides for the use of seven alternative iterative procedures. While these subroutines are not designed as production software, they should successfully handle industrial problems of moderate size, that is, ones that fit in high-speed memory. This package is written in standard FORTRAN-66 code. It has been tested over a wide variety of computer systems using various FORTRAN compilers, including one which is FORTRAN-77 compatible (see Acknowledgements). The seven iterative solution modules are based on several basic iterative procedures, such as the Jacobi method, the Successive Overrelaxation (SOR) method, the Symmetric SOR (SSOR) method, and the RS method for the reduced system. With the exception of SOR, the convergence of these basic methods are accelerated by Chebyshev (Semi-Iteration, SI) or Conjugate Gradient (CG) acceleration. All methods are available with adaptive parameter estimation and automatic stopping tests. When using the RS method it is required that the linear system be reordered into a \u201cred-black\" 1 system [@6; @12] . A switch to compute, if possible, the red-black indexing, permute the linear system, and permute associated vectors is provided. The successful convergence of iterative methods may be dependent on conditions that are difficult to determine in advance. For example, determining whether the coefficient matrix is positive definite can be as costly to check as solving the system. On the other hand, some conditions affecting convergence, such as positive diagonal elements, diagonal dominance, and symmetry are relatively easy to verify. For some applications, the theory may not exist to guarantee the convergence of an iterative method. The algorithms in ITPACK have been tested most extensively for linear systems arising from elliptic partial differential equations. The routines can be applied, formally, to any linear system which fits in high-speed memory. However, rapid convergence, and indeed convergence itself cannot be guaranteed unless the matrix of the system is symmetric and positive definite. Success can be expected, though not guaranteed, for mildly nonsymmetric systems. In other words, iterative methods may not converge when applied to systems with coefficient matrices which are completely general with no special properties. This article discusses the usage of ITPACK and gives a few test results. The description of the iterative methods is given in [@4] . The underlying theory on which the iterative algorithms are based is described in [@6] . A survey of the iterative methods in ITPACK is presented in [@11] . Throughout this paper, we adopt notation such as SOR() when referring to a subroutine and A(*) for a single-dimensioned array. The residual vector is \\(b-Au^{(n)}\\) for the linear system \\(Au=b\\) and the pseudo-residual vector is \\(Gu^{(n)}+k-u^{(n)}\\) for a basic iterative method of the form \\(u^{(n+1)}=Gu^{(n)}+k\\) . The smallest and largest eigenvalues of the iteration matrix \\(G\\) are denoted \\(m(G)\\) and \\(M(G)\\) , respectively. Sparse Matrix Storage The sparse storage scheme used in ITPACK is a common one. It is a row-wise representation of the nonzero entries in the coefficient matrix of the linear system. For a nonsymmetric coefficient matrix, all of the nonzero values in each row are stored in a contiguous block of data in a real-valued array A(*) . If the matrix is symmetric, computer memory can be saved by storing only the nonzero entries in each row on and above the main diagonal. For either nonsymmetric or symmetric sparse storage, associated column numbers are stored in an integer-valued array JA(*) such that \\({\\bf JA(K)}\\) is the column number for the value \\({\\bf A(K)}\\) . A mapping vector IA(*) is used to denote the starting locations of each of the contiguous blocks. The beginning of the linear block for row \\(I\\) is given by \\({\\bf IA(I)}\\) , the end by \\({\\bf IA(I+1)-1}\\) , and its length by \\({\\bf IA(I+1)-IA(I)}\\) . Thus, IA(*) will contain \\({\\bf N+1}\\) elements to accommodate a linear system of order N . The entries for each row may be stored in any order in the contiguous block for that row. For example, the coefficient matrix \\[ \\left[\\begin{array}{ccccc} 11. & 0. & 0. & 14. & 15. \\\\ 0. & 22. & 0. & 0. & 0. \\\\ 0. & 0. & 33. & 0. & 0. \\\\ 14. & 0. & 0. & 44. & 45. \\\\ 15. & 0. & 0. & 45. & 55. \\end{array} \\right] \\] would be represented in nonsymmetric sparse storage as \\[\\begin{aligned} {\\bf A(*)} & = & [11.,14.,15.,22.,33.,14.,44.,45.,15.,45.,55.] \\\\ {\\bf JA(*)} & = & [1,4,5,2,3,1,4,5,1,4,5] \\\\ {\\bf IA(*)} & = & [1,4,5,6,9,12] \\end{aligned}\\] and in symmetric sparse storage as \\[\\begin{aligned} {\\bf A(*)} & = & [11.,14.,15.,22.,33.,44.,45.,55.] \\\\ {\\bf JA(*)} & = & [1, 4, 5, 2, 3, 4, 5, 5] \\\\ {\\bf IA(*)} & = & [1, 4, 5, 6, 8, 9]\\end{aligned}\\] Usage The user is expected to provide the coefficient matrix and the right-hand side of the linear system to be solved. The data structure for the matrix of the system is either the symmetric or nonsymmetric sparse storage format described in Section 2 . An initial guess for the solution should be provided, if one is known; otherwise, it can be set to all zero values. A series of approximations for the solution are generated iteratively until the convergence criteria is satisfied. The algorithms are performed in two work space arrays and some control over the algorithmic procedure can be obtained from switches in two parameter arrays. There are seven main subroutines in ITPACK, each corresponding to an iterative method. They are: Subroutine Method JCG() Jacobi Conjugate Gradient JSI() Jacobi Semi-Iteration SOR() Successive Overrelaxation SSORCG() Symmetric SOR Conjugate Gradient SSORSI() Symmetric SOR Semi-Iteration RSCG() Reduced System Conjugate Gradient RSSI() Reduced System Semi-Iteration and the calling sequence is: CALL \\(\\langle\\) method \\(\\rangle\\) (N, IA, JA, A, RHS, U, IWKSP, NW, WKSP, IPARM, RPARM, IER) where the parameters are defined in the following. Here \u201cinput\" means that the subroutine expects the user to provide the necessary input data and\u201doutput\" means that the routine passes back information in the variable or array indicated. All parameters are linear arrays except variables N , NW , and IER . Moreover, all parameters may be altered by the subroutine call except variables N and NW . (See Section 7 for additional details.) N is the order of the linear system. [integer; input] IA(*) is a vector of length \\({\\bf N+1}\\) used in the sparse matrix storage format. It contains the row pointers into JA(*) and A(*) . [integer array; input] JA(*) is a vector of length NZ (defined in A(*) below) used in the sparse matrix storage format. It contains the column numbers for the corresponding entries in A(*) . [integer array; input] A(*) is a vector of length NZ used in the sparse matrix storage format. It contains the nonzero entries of the coefficient matrix with positive diagonal elements. ( NZ is the number of nonzero entries in the upper triangular part of the coefficient matrix when symmetric storage is used and is the total number of nonzeros when nonsymmetric storage is used.) [real array; input] RHS(*) is a vector of length N containing the right-hand side of the linear system. [real array; input] U(*) is a vector of length N containing the initial guess to the solution of the linear system on input and the latest approximate solution on output. [real array; input/output] IWKSP(*) is a vector of length \\({\\bf 3*N}\\) used for integer workspace. When reindexing for red-black ordering, the first N locations contain on output the permutation vector for the red-black indexing, the next N locations contain its inverse, and the last N are used for integer workspace. 2 [integer array; output] NW is a scalar. On input, NW is the available length for WKSP(*) . On output, IPARM(8) is the actual amount used (or needed). [integer; input] WKSP(*) is a vector used for real working space whose length depends on the iterative method being used. It must be at least NW entries long. (See the table near the end of this section for the required amount of workspace for each method.) [real array] IPARM(*) is a vector of length 12 used to initialize various integer and logical parameters. Default values may be set by calling subroutine DFAULT() described below. On output, IPARM(*) contains the values of the parameters that were changed. (Further details are given later in this section.) [integer array; input/output] RPARM(*) is a vector of length 12 used to initialize various real parameters on input. Default values may be set by calling subroutine DFAULT() described below. On output, RPARM(*) contains the final values of the parameters that were changed. (Further details are given later in this section.) [real array; input/output] IER is the error flag which is set to zero for normal convergence and to a nonzero integer when an error condition is present. (See the table at the end of this section for the meaning of nonzero values.) [integer; output] The user may supply nondefault values for selected quantities in IPARM(*) and by first executing CALL DFAULT (IPARM, RPARM) and then assigning the appropriate nondefault values before calling a solution module of ITPACK. The iterative algorithms used in ITPACK are quite complicated and some knowledge of iterative methods is necessary to completely understand them. The interested reader should consult the technical report [@4] and the book [@6] for details. Important variables in this package which may change adaptively are CME (estimate of \\(M(B)\\) , the largest eigenvalue of the Jacobi matrix), SME (estimate of \\(m(B)\\) , the smallest eigenvalue of the Jacobi matrix), OMEGA (overrelaxation parameter \\(\\omega\\) for the SOR and SSOR methods), SPECR (estimated spectral radius of the SSOR matrix), BETAB (estimate for the spectral radius of the matrix \\(LU\\) where \\(L\\) and \\(U\\) are strictly lower and upper triangular matrices, respectively, such that the Jacobi matrix \\(B=L+U\\) ). The integer array IPARM(*) and real array RPARM(*) allow the user to control certain parameters which affect the performance of the iterative algorithms. Furthermore, these arrays allow the updated parameters from the automatic adaptive procedures to be communicated back to the user. The entries in IPARM(*) and RPARM(*) are: DIGIT1 is determined from the actual stopping test computed on the final iteration, whereas DIGIT2 is based on the computed residual vector using the final approximate solution after the algorithm has converged. If these values differ greatly, then either the stopping test has not worked successfully or the original system is ill-conditioned. (See [@6] for additional details.) For storage of certain intermediate results, the solution modules require a real vector WKSP(*) and a corresponding variable NW indicating the available space. The length of the workspace array varies with each solution module and the maximum amount needed is given in the following table. Solution Module Maximum Length of WKSP(*) JCG() \\({\\bf 4*N + NCG}\\) JSI() \\({\\bf 2*N}\\) SOR() \\({\\bf N}\\) SSORCG() \\({\\bf 6*N + NCG}\\) SSORSI() \\({\\bf 5*N}\\) RSCG() \\({\\bf N + 3*NB + NCG}\\) RSSI() \\({\\bf N + NB}\\) The value of NCG is \\({\\bf 2*IPARM(1)}\\) for symmetric sparse storage and \\({\\bf 4*IPARM(1)}\\) for nonsymmetric sparse storage. It should be noted that the actual amount of workspace used may be somewhat less than these upper limits since some of the latter are dependent on the maximum number of iterations allowed, ITMAX , stored in IPARM(1) . Clearly, the array WKSP(*) must be dimensioned to at least the value of NW . Nonzero integer values of the error flag IER indicate that an error condition was detected. These values are listed below according to their numerical value and to the name of the routine in which the flag was set. Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , Normal convergence was obtained. \\(=\\) \\(1+{\\rm Mth}\\) , Invalid order of the system, N . \\(=\\) \\(2+{\\rm Mth}\\) , Workspace array WKSP(*) is not large enough. IPARM(8) is set to the amount of required workspace, NW . \\(=\\) \\(3+{\\rm Mth}\\) , Failure to converge in IPARM(1) iterations. RPARM(1) is reset to the last stopping value computed. \\(=\\) \\(4+{\\rm Mth}\\) , Invalid order of the black subsystem, NB . \\(=\\) \\(101\\) , A diagonal element is not positive. \\(=\\) \\(102\\) , No diagonal element in a row. \\(=\\) \\(201\\) , Red-black indexing is not possible. \\(=\\) \\(301\\) , No entry in a row of the original matrix. \\(=\\) \\(302\\) , No entry in a row of the permuted matrix. \\(=\\) \\(303\\) , Sorting error in a row of the permuted matrix. \\(=\\) \\(401\\) , A diagonal element is not positive. \\(=\\) \\(402\\) , No diagonal element in a row. \\(=\\) \\(501\\) , Failure to converge in ITMAX function evaluations. \\(=\\) \\(502\\) , Function does not change sign at the endpoints. \\(=\\) \\(601\\) , Successive iterates are not monotone increasing. JCG() , JSI() , SOR() , SSORCG() , SSORSI() , RSCG() , RSSI() assign values to Mth of 10,20,30,40,50,60,70, respectively. SBELM() , PRBNDX() , PERMAT() , SCAL() , ZBRENT() , EQRT1S() are subroutines with error flags in the 100\u2019s, 200\u2019s, 300\u2019s, 400\u2019s, 500\u2019s, 600\u2019s, respectively. These routines perform the following functions: SBELM() removes rows and columns, PRBNDX() determines the red-black indexing, SCAL() scales the system, ZBRENT() is a modified IMSL routine for computing a zero of a function which changes sign in a given interval, EQRT1S() is a modified IMSL routine for computing the largest eigenvalue of a symmetric tridiagonal matrix. 3 User-Oriented Modules The array U(*) should contain an initial approximation to the solution of the linear system before any ITPACK module is called. If the user has no information for making such a guess, then the zero vector may be used as the starting vector. The subroutine VFILL() can be used to fill a vector with a constant: CALL VFILL (N, U, VAL) fills the array U(*) of length N with the value VAL in each entry. To aid the user in using the iterative methods of ITPACK, four modules for constructing the sparse matrix storage arrays are included. The modules are: SBINI() is called at the beginning to initialize the arrays IA(*) , JA(*) , A(*) , and IWORK(*) ; SBSIJ() is called repeatedly to set the individual entries in the matrix and build a link list representation of the matrix structure; SBEND() is called at the end to restructure the link list into final sparse storage form; SBAGN() is called to return again to the link list representation if SBEND() has been called but additional elements are to be added or modified. These modules are described below. (a) Initialization: CALL SBINI (N,NZ,IA,JA,A,IWORK) Initializes IA(*) , JA(*) , A(*) , and IWORK(*) for a system of order N . IA(*) , JA(*) , and IWORK(*) are integer arrays of length at least \\({\\bf N+1}\\) , NZ , and NZ , respectively. A(*) is a real array of length at least NZ . (b) Set individual entries: CALL SBSIJ (N,NZ,IA,JA,A,IWORK,I,J,VAL,MODE,LEVEL,NOUT,IER) Inserts the value, VAL , of the (I,J) entry of the user\u2019s matrix into the link list representation for that matrix. When using symmetric sparse storage, J must be greater than or equal to I . If the (I,J) entry has already been set then MODE specifies the way in which the entry is to be treated: \\({\\bf MODE}<0\\) , Current entry value is left as is; \\(=0\\) , Current entry value is reset to VAL ; \\(>0\\) , VAL is added to the current entry value. If LEVEL is less than \\(0\\) , SBSIJ() causes no printing. If LEVEL is \\(0\\) , fatal errors messages are written to output unit number NOUT ; and if LEVEL is \\(1\\) or greater, a message is printed when SBSIJ() encounters a value it has already set with the value being reset according to the value of MODE . IER is an error parameter and returns values of Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , New (I,J) entry is established. \\(=\\) \\(700\\) , (I,J) entry is already set\u2014reset according to MODE . \\(=\\) \\(701\\) , Improper values for either I or J . \\(=\\) \\(702\\) , NZ is too small\u2014no room for the new entry. (c) Finalization: CALL SBEND (N,NZ,IA,JA,A,IWORK) Restructures the link list data structure built by SBINI() and SBSIJ() into the final data structure required by ITPACK. (d) Undo Finalization: CALL SBAGN (N,NZ,IA,JA,A,IWORK,LEVEL,NOUT,IER) Returns to link list representation for modification or addition of elements to the system. Repeated calls to SBSIJ() can then be made followed by a single call to SBEND() to close-out the sparse matrix representation. If LEVEL is less than \\(0\\) , no printing is done and if LEVEL is \\(0\\) or greater, fatal error information is written to the output unit number NOUT . IER is an error flag indicating: Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , Successful completion. \\(=\\) \\(703\\) , NZ is too small\u2014no room for the new entry. Note that SBINI() should not be called after SBAGN() is called since it would destroy the previous data. Examples Given a linear system \\(Au=b\\) with \\[A = \\left[\\begin{array}{rrrr} 4 & -1 & -1 & 0 \\\\ -1 & 4 & 0 & -1 \\\\ -1 & 0 & 4 & -1 \\\\ 0 & -1 & -1 & 4 \\end{array} \\right], \\hspace{0.3in} b = \\left[\\begin{array}{c} 6 \\\\ 0 \\\\ 0 \\\\ 6 \\end{array} \\right],\\] a program to solve this problem with an initial guess of \\(u^T = (0, 0, 0, 0)\\) using JCG() with symmetric sparse storage and printing the final approximate solution vector follows. INTEGER IA(5), JA(8), IPARM(12), IWKSP(12) REAL A(8), RHS(4), u(4), WKSP(24), RPARM(12) DATA A(1),A(2),A(3),A(4) / 4.0,-1.0,-1.0,4.0 / DATA A(5),A(6),A(7),A(8) / -1.0,4.0,-1.0,4.0 / DATA JA(1),JA(2),JA(3),JA(4) / 1,2,3,2 / DATA JA(5),JA(6),JA(7),JA(8) / 4,3,4,4 / DATA IA(1),IA(2),IA(3),IA(4),IA(5) / 1,4,6,8,9 / DATA RHS(1),RHS(2),RHS(3),RHS(4) / 6.0,0.0,0.0,6.0 / DATA N /4/, NW /24/, ITMAX /4/, LEVEL/1/, IDGTS/2/ C CALL DFAULT (IPARM, RPARM) IPARM(1) = ITMAX IPARM(2) = LEVEL IPARM(12) = IDGTS CALL VFILL (N, U, 0.E0) CALL JCG (N,IA,JA,A,RHS,U,IWKSP,NW,WKSP,IPARM,RPARM,IER) STOP END The output for this run would be BEGINNING OF ITPACK SOLUTION MODULE JCG JCG HAS CONVERGED IN 2 ITERATIONS. APPROX. NO. OF DIGITS (EST. REL. ERROR) = 14.6 (DIGIT1) APPROX. NO. OF DIGITS (EST. REL. RESIDUAL) = 14.3 (DIGIT2) SOLUTION VECTOR. 1 2 3 4 ------------------------------------------------------------- 2.00000E+00 1.00000E+00 1.00000E+00 2.00000E+00 Textbook methods such as the Jacobi (J), Gauss-Seidel (GS), Successive Overrelaxation (SOR\u2014fixed relaxation factor omega), Symmetric Successive Overrelaxation (SSOR\u2014fixed relaxation factor omega), and the RS method can be obtained from this package by resetting appropriate parameters after the subroutine DFAULT() is called but before ITPACK routines are called. Method Use Parameters J JSI() \\({\\bf IPARM(6)=0, IPARM(7)=2}\\) GS SOR() \\({\\bf IPARM(6)=0}\\) SOR\u2014fixed omega SOR() \\({\\bf IPARM(6)=0, RPARM(5)=OMEGA}\\) SSOR\u2014fixed omega SSORSI() \\({\\bf IPARM(6)=0, RPARM(5)=OMEGA}\\) RS RSSI() \\({\\bf IPARM(6)=0}\\) These methods were not included as separate routines because they are usually slower than the accelerated methods included in this package. On the black unknowns, the Cyclic Chebyshev Semi-Iterative (CCSI) method of Golub and Varga [@2] gives the same result as the RSSI method. The CCSI and RSSI methods converge at the same rate, and each of them converges twice as fast as the JSI method. This is a theoretical result [@6] and does not count the time involved in establishing the red-black indexing and the red-black partitioned system. Similarly, the Cyclic Conjugate Gradient (CCG) method with respect to the black unknowns, considered by Reid [@16] (see also Hageman and Young [@6] ), gives the same results as the RSCG method. Also, the CCG and the RSCG methods converge at the same rate, and each of them converges, theoretically, exactly twice as fast as the JCG method. Hence, the accelerated RS methods are preferable to the accelerated J methods when using a red-black indexing. Numerical Results The iterative algorithms in ITPACK have been tested over a wide class of matrix problems arising from elliptic partial differential equations with Dirichlet, Neumann, and mixed boundary conditions on arbitrary two-dimensional regions (including cracks and holes) and on rectangular three-dimensional regions [@1] . Both finite-difference and finite-element procedures have been employed to obtain the linear systems. The two sample problems presented here, while simple to pose, are representative of the behavior of the ITPACK routines for more complex problems. The iterative algorithms make no use of the constant coefficients in these two problems or of the particular structure of the resulting linear system. Because the ITPACK code is not tailored to any particular class of partial differential equations or discretization procedure, but rather to sparse linear systems, it is felt that the package can be used to solve a wider class of problems. We now consider two simple partial differential equations which when discretized by finite-difference methods give rise to large sparse linear systems. We obtain the solution of each of these systems by the seven algorithms in ITPACK 2C. These numerical results should aid the user of ITPACK in determining the amount of time required when solving more complicated sparse systems. However, one should not interpret these execution times as conclusive by themselves. Variances introduced by different compilers, computer systems, and timing functions can sometimes be significant. Moreover, the number of iterations required by an iterative method is dependent on the problem being solved, the initial estimate for the solution, the parameter estimates used, and the relative accuracy requested in the stopping criterion RPARM(1) . These tests were run on the CDC Cyber 170/750 at the University of Texas with the FTN 4.8 compiler (OPT=2). To obtain representative sparse linear systems, we discretize the following two self-adjoint elliptic partial differential equations in a region with prescribed conditions on the boundary. Here \\(u_{xx}\\) , \\(u_{yy}\\) , \\(u_{zz}\\) are partial derivatives and \\(du/dn\\) is the derivative in the normal direction. \\[\\begin{aligned} u_{xx} + 2u_{yy} = 0, && \\mbox{$(x,y)$ in $S=(0,1)\\times (0,1)$} \\\\ u = 1 + xy, && \\mbox{$(x,y)$ on the boundary of $S$} \\nonumber\\end{aligned}\\] Using the standard 5-point symmetric finite-difference operator with \\(h=\\frac{1}{20}\\) , we obtain a sparse linear system with \\(1729\\) nonzero elements and \\(361\\) unknowns. \\[\\begin{aligned} u_{xx}+2u_{yy}+3u_{zz}=0, && \\mbox{$(x,y,z)$ in $C=(0,1)\\times (0,1)\\times (0,1)$} \\nonumber \\\\ \\mbox{On the boundary of C:} && \\\\ u=1, && \\mbox{$(0,y,z)$, $(x,0,z)$, or $(x,y,0)$} \\nonumber \\\\ du/dn = yz(1 + yz), && (1,y,z) \\nonumber \\\\ du/dn = xz(1 + xz), && (x,1,z) \\nonumber \\\\ du/dn = xy(1 + xy), && (x,y,1) \\nonumber \\end{aligned}\\] Using the standard 7-point symmetric finite difference operator with \\(h=\\frac{1}{7}\\) , we obtain a sparse linear system with \\(1296\\) nonzero elements and \\(216\\) unknowns. Tables 1 and 2 display the number of iterations and execution times (in seconds) for the seven methods in ITPACK 2C for the linear systems corresponding to problems (1) and (2), respectively, using symmetric sparse storage. Both the time for the iteration algorithm and the total time for the subroutine call are given. The stopping criterion was set to \\(5\\times 10^{-6}\\) . To illustrate how effective the adaptive procedures are, we have included in these tables the number of iterations and the time when the optimum iteration parameters were used with no adaptive procedures. Routine Ordering Iterations Iteration time Total time JCG() Natural 61 (61) .250 (.247) .281 (.271) Red-black 61 (61) .232 (.246) .402 (.413) JSI() Natural 108 (95) .408 (.344) .439 (.375) Red-black 108 (95) .393 (.332) .569 (.498) SOR() Natural 72 (54) .356 (.280) .368 (.307) Red-black 65 (47) .311 (.224) .469 (.411) SSORCG() Natural 17 (13) .232 (.173) .264 (.185) SSORSI() Natural 23 (22) .242 (.213) .273 (.244) RSCG() Red-black 31 (31) .104 (.117) .269 (.297) RSSI() Red-black 60 (48) .207 (.166) .358 (.344) Number of Iterations and Execution Times for Problem (1) Using Adaptive and Nonadaptive Procedures (Nonadaptive Data in Parentheses) Routine Ordering Iterations Iteration time Total time JCG() Natural 28 (28) .092 (.090) .107 (.090) Red-black 28 (28) .079 (.074) .191 (.202) JSI() Natural 64 (54) .166 (.136) .196 (.152) Red-black 64 (54) .160 (.130) .268 (.266) SOR() Natural 42 (29) .139 (.095) .150 (.110) Red-black 38 (29) .124 (.097) .236 (.231) SSORCG() Natural 15 (11) .136 (.097) .167 (.111) SSORSI() Natural 19 (15) .138 (.101) .153 (.117) RSCG() Red-black 15 (15) .032 (.051) .150 (.169) RSSI() Red-black 31 (27) .075 (.064) .186 (.196) Number of Iterations and Execution Times for Problem (2) Using Adaptive and Nonadaptive Procedures (Nonadaptive Data in Parentheses) Values corresponding to the red-black ordering with the SSOR methods are omitted from the tables since it is known that these methods are ineffective with this ordering. Since the RS methods are defined for only the red-black ordering, the table entries for these methods with the natural ordering are not included. Notes on Use Before an iterative algorithm is called to solve a linear system, the values in the array A(*) are permuted and scaled. Afterwards, these values are unpermuted and unscaled. Consequently, the values in arrays A(*) and RHS(*) may change slightly due to roundoff errors in the computer arithmetic. Moreover, since entries in each row of the linear system may be stored in any order within a contiguous block of data, the locations of elements of A(*) and of corresponding ones in JA(*) may change from those given before the permuting and unpermuting was done. The same linear system is defined by the arrays A(*) , JA(*) , and IA(*) whether or not corresponding elements in A(*) and JA(*) have changed locations within contiguous blocks. Scaling of the linear system is done as follows to reduce the number of arithmetic operations. The diagonal entries of the linear system are checked for positivity and are moved to the first N locations of the array A(*) . The nonzero off-diagonal entries of the linear system \\(Au=b\\) are scaled. The scaling involves the diagonal matrix \\(D^{\\frac{1}{2}}\\) of square roots of the diagonal entries of the linear system, that is, \\[(D^{-\\frac{1}{2}}AD^{-\\frac{1}{2}})(D^{\\frac{1}{2}}u) = (D^{-\\frac{1}{2}}b).\\] The algorithms iterate until convergence is reached based on the relative accuracy requested via the stopping criterion set in RPARM(1) for the scaled solution vector \\((D^{\\frac{1}{2}}u)\\) . Unscaling solves for \\(u\\) and returns the linear system to its original form subject to roundoff errors in the arithmetic and to possible movement of entries within contiguous blocks of data. When requested, a red-black permutation of the data will be done before and after the iterative algorithm is called. Otherwise, the linear system is used in the order it is given which we call the \u201cnatural ordering.\" The Successive Overrelaxation (SOR) method has been shown to be more effective with the red-black ordering than with the natural ordering for some problems [@18] . In the SOR algorithm, the first iteration uses \\(\\omega= 1\\) and the stopping criterion is set to a large value so that at least one Gauss-Seidel iteration is performed before an approximate value for the optimum relaxation parameter is computed. Optional features of this package are red-black ordering, effective removal of rows and columns when the diagonal entry is extremely large, and error analysis. In the event that one is not using some of these options and needs additional memory space for a very large linear system, the relevant subroutines which can be replaced with dummy subroutines are as follows: red-black ordering [ PRBNDX() , PERMAT() , PERVEC() , QSORT() ], removal of rows [ SBELM() ], error analysis [ PERROR() ]. The timing routine TIMER() should call a routine which returns the run time in seconds. The value of the machine relative precision is contained in the variable SRELPR which is set in the subroutine DFAULT() and in the test program. This and other default values may be permanently changed when the code is installed by changing their values in the subroutine DFAULT() . SRELPR must be changed when moving the code to another computer. If the installer of this package does not know its value, an approximate value can be determined from a simple FORTRAN program given in the comment statements of subroutine DFAULT() . Since the amount of precision may change from computer to computer, the relative accuracy requested in the stopping criterion ZETA must not be less than about \\(500\\) times the machine relative precision SRELPR . If a value of ZETA is requested that is too small then the code resets it to this value. The current default value for ZETA , \\(5 \\times 10^{-6}\\) , is set by the routine DFAULT() into RPARM(1) . The distribution tape contains the ITPACK 2C software package of \\(71\\) subprograms and a testing program MAIN() together with its \\(27\\) subprograms. The routines DFAULT() and TIMER() in ITPACK and the program MAIN() are the only ones requiring editing by the installer of the package. ITPACK can be made into a compiled program library although not all of it would normally be used in a particular application. ITPACK History The 2C version of the ITPACK codes described here is the result of several years of research and development. The development of ITPACK began in the early 1970\u2019s when Professor Garrett Birkhoff suggested that general purpose software for solving linear systems should be developed for iterative methods as well as for direct methods. Initially, prototype programs were written based on preliminary iterative algorithms involving adaptive selection of parameters and automatic stopping procedures. These programs were tested on a large set of elliptic partial differential equations over domains compatible with the subroutine REGION() [@8] which superimposed a square grid over the domain. These routines were designed for solving self-adjoint elliptic partial differential equations. Next a preliminary version of ITPACK was coded in standard FORTRAN. The ITPACK routines used iterative algorithms which were refined from the prototype programs. However, these routines were designed to solve large sparse linear systems of algebraic equations instead of partial differential equations. The use of three interchangeable symmetric sparse storage modes in ITPACK 1.0 [@3] allowed for great flexibility and made it possible to solve a wider class of problems than the prototype programs and to study different storage modes for iterative methods. The next version, ITPACK 2.0 [@4] , was significantly faster than its predecessor since it was restricted to allow only one sparse symmetric storage format. Most of the iterative algorithms utilized in the 2.0 version of this package assume that the coefficient matrix of the linear system is symmetric positive definite. As with many packages, the need to handle a slightly larger class of problems, namely, nearly symmetric systems, soon became evident. This required adapting the routines to allow a switch for either a symmetric or nonsymmetric storage mode in ITPACK 2A [@5] . Moreover, a modification of the Conjugate Gradient algorithms was developed to handle nearly symmetric systems [@12] . ITPACK has been improved in the 2B version [@14] by (a) writing more efficient versions of several key subroutines, (b) incorporating Basic Linear Algebra Subprograms, BLAS [@15] , and (c) improving the user interface with better printing and documentation. Some additional improvements and corrections were made in the 2C version. The algorithms in ITPACK are not guaranteed to converge for all linear systems but have been shown to work successfully for a large number of symmetric and nonsymmetric systems which arise from solving elliptic partial differential equations [@1; @13] . The numerical algorithms in ITPACK 2C correspond to those described in the appendix of technical report [@5] and outlined in the book [@7] . In particular, the SOR code is based on an algorithm suggested to us by L. Hageman. Various other algorithms exist for iterative methods. For example, S. Eisenstat has an implementation of the Symmetric Successive Overrelaxation preconditioned Conjugate Gradient procedure. 4 Modules based on the seven iterative routines in ITPACK have been incorporated into the elliptic partial differential equation solving package ELLPACK [@17] together with all the necessary translation routines needed. The user-oriented modules described in Section 4 are not in ELLPACK. Moreover, if the ELLPACK system is not being used to generate the linear system for ITPACK, it is recommended that ITPACK be used as a stand-alone package apart from ELLPACK. Acknowledgements The authors wish to thank the referee for carefully going through the code and documentation for several different versions. Test runs were made on a variety of computer systems and helpful suggestions were made by R. Boisvert, W. Coughran, J. Dongarra, W. Dyksen, S. Eisenstat, S. Fillebrown, P. Gaffney, W. Gordon, R. Hanson, R. Lynch, J. Rice, B. Ward, and others. These suggestions and comments together with those of the referee have resulted in an improved software package. ITPACK has been tested on the following computing machines: CDC 6400, 6500, 6600, 7600, Cyber 170/750, 203, 205; Cray 1; DEC 10, 20, PDP 10, VAX 11/750, 11/780; IBM 195, 370/158, 3033; PRIME 400, 750; and others. 99 S. Eisenstat, A. George, R. Grimes, D. Kincaid, and A. Sherman. \u201cSome Comparisons of Software Packages for Large Sparse Linear Systems,\" in Advances in Computer Methods for Partial Differential Equations III , (R. Vichnevetsky and R. Stepleman, eds.), Publ. IMACS, Department of Computer Science, Rutgers University, New Brunswick, New Jersey, 08903, 1979, pp. 98-106. G. Golub and R. Varga. \u201cChebyshev Semi-Iterative Methods, Successive Overrelaxation Iterative Methods, and Second-Order Richardson Iterative Methods,\" Parts I & II, Numerische Mathematik , Vol. 3, 1961, pp. 147-168. R. Grimes, D. Kincaid, W. Macgregor, and D. Young. \u201cITPACK Report: Adaptive Iterative Algorithms Using Symmetric Sparse Storage,\" CNA-139, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1978. R. Grimes, D. Kincaid, and D. Young. \u201cITPACK 2.0 User\u2019s Guide,\" CNA-150, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1979. R. Grimes, D. Kincaid, and D. Young. \u201cITPACK 2A: A FORTRAN Implementation of Adaptive Accelerated Iterative Methods for Solving Large Sparse Linear Systems,\" CNA-164, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, October 1980. L. Hageman and D. Young. Applied Iterative Methods , Academic Press, New York, 1981. L. Hayes and D. Young. \u201cThe Accelerated SSOR Method for Solving Large Linear Systems: Preliminary Report,\" CNA-123, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, May 1977. D. Kincaid and R. Grimes. \u201cNumerical Studies of Several Adaptive Iterative Algorithms,\" CNA-126, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1977. D. Kincaid, R. Grimes, W. Macgregor, and D. Young. \u201cITPACK\u2014Adaptive Iterative Algorithms Using Symmetric Sparse Storage,\" in Symposium on Reservoir Simulation , Society of Petroleum Engineers of AIME, 6200 North Central Expressway, Dallas, Texas, 75206, February 1979, pp. 151-160. D. Kincaid, R. Grimes, and D. Young. \u201cThe Use of Iterative Methods for Solving Large Sparse PDE-Related Linear Systems,\" Mathematics and Computers in Simulation XXI , North-Holland Publishing Company, New York, 1979, pp. 368-375. D. Kincaid and D. Young. \u201cSurvey of Iterative Methods,\" in Encyclopedia of Computer Sciences and Technology , Vol. 13 (J. Belzer, A. Holzman, and A. Kent, eds.), Marcel Dekker, Inc., New York, 1979, pp. 354-391. D. Kincaid and D. Young. \u201cAdapting Iterative Algorithms Developed for Symmetric Systems to Nonsymmetric Systems,\" in Elliptic Problem Solvers , (M. Schultz, ed.), Academic Press, New York, 1981, p. 353-359. D. Kincaid. \u201cAcceleration Parameters for a Symmetric Successive Overrelaxation Conjugate Gradient Method for Nonsymmetric Systems,\" in Advances in Computer Methods for Partial Differential Equations IV , (R. Vichnevetsky and R. Stepleman, eds.), Publ. IMACS, Department of Computer Science, Rutgers University, New Brunswick, New Jersey, 08903, 1981, pp. 294-299. D. Kincaid, R. Grimes, J. Respess, and D. Young. \u201cITPACK 2B: A FORTRAN Implementation of Adaptive Accelerated Iterative Methods for Solving Large Sparse Linear Systems,\" CNA-173, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, September 1981. C. Lawson, R. Hanson, D. Kincaid, and F. Krogh. \u201cBasic Linear Algebra Subprograms for FORTRAN Usage,\" ACM Transactions on Mathematical Software , Vol. 5., No. 3, September 1979, pp. 308-323. J. Reid. \u201cThe Use of Conjugate Gradients for Systems of Linear Equations Possessing Property A,\" SIAM Journal of Numerical Analysis , Vol. 9, 1972, pp. 325-332. J. Rice and R. Boisvert. Solving Elliptic Problems Using ELLPACK . New York: Springer-Verlag, 1985. D. Young. Iterative Solution of Large Linear Systems , Academic Press, New York, 1971. D. Young and D. Kincaid. \u201cThe ITPACK Package for Large Sparse Linear Systems,\" in Elliptic Problem Solvers , (M. Schultz, ed.), Academic Press, New York, 1981, pp. 163-185. In this ordering, the components of the unknown vector \\(u\\) are considered as either \u201cred\" or\u201dblack\". A \u201cred-black ordering\" is any ordering such that every black unknown follows all of the red unknowns. This ordering of unknowns leads to a \\(2\\times 2\\) \u201dred-black partitioning\" of the coefficient matrix, that is, a matrix of the form \\[\\left[\\begin{array}{cc} D_R & H \\\\ K & D_B \\end{array} \\right]\\] with diagonal submatrices \\(D_R\\) and \\(D_B\\) . The original linear system may require rearrangement in order to arrive at this form. \u21a9\ufe0e For the red-black ordering, the I th entry of a permutation array P(*) indicates the position J into which the I th unknown of the original system is being mapped, that is, if \\({\\bf P(I)=J}\\) then unknown I is mapped into position J . The J th entry of an inverse permutation array IP(*) indicates the position I into which the J th unknown of the permuted system must be mapped to regain the original ordering, that is, \\({\\bf IP(J)=I}\\) . \u21a9\ufe0e IMSL (International Mathematical and Statistical Libraries, Inc.), Sixth Floor NBC Bldg., 7500 Bellaire Blvd., Houston, TX, 77036. \u21a9\ufe0e Private communication. \u21a9\ufe0e","title":"ITPACK\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectBlock/","text":"ProfileSPDDirectBlockSolver UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectBlockSolver.h> class ProfileSPDLinDirectBlockSolver : public LinearSOESolver\\ MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectBlockSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one block row at a time using a right-looking approach. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDDirectBlockSolver\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectSkypack/","text":"ProfileSPDDirectSkypack #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSkypackSolver.h> class ProfileSPDLinDirectSkypackSolver : public LinearSOESolver MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectSkypackSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means using the routines supplied in the SKYPACK library, a library which uses the BLAS levels 1,2 and 3 for the factorization and substitution. The routines in SKYPACK require a number of work areas: int block[3] and double invD[size] . In addition, to allow the use of the BLAS 2 and 3, work areas double rw[mRows x mCols] , double tw[mRows x mRows] and int index[max(mCols,mRows)] are created. Constructors Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Sets mCols and mRows equal to \\(0\\) and does not try and allocate any memory for the work arrays. A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Sets mCols and mRows and allocates space in memory for the work arrays rw , tw and index . If not enough memory is available in memory, mCols and mRows is set equal to \\(0\\) and an error message is printed. Invokes delete on any work areas that have been constructed. The solver first copies the B vector into X and then solves the BandSPDLinSOE system. If the matrix has not been factored, the matrix is first factored using the SKYPACK routine skysf2() , if mCols and mRows equal \\(0\\) , or skypf2() . skysf2() is a routine which uses the BLAS level 1 routines, skypf2() is a routine which uses BLAS levels 2 and 3. If skypf2() has been called, invD is set up. Once the matrix has been factored, skyss() is called. If the solution is successfully obtained, i.e. the skyss() routine returns \\(0\\) in the INFO argument, \\(0\\) is returned, otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is responsible for setting the block information required by the SKYPACK routines (block[0]=1; block[1]=size, block[2]=1) and for creating space for the invD work array. Returns \\(0\\) if successful, otherwise a warning message is printed and a \\(-1\\) is returned. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDDirectSkypack\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectThread/","text":"ProfileSPDLinDirectThread UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectThreadSolver.h> class ProfileSPDLinDirectThreadSolver : public LinearSOESolver MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectThreadSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this in parallel using threads by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one row block at a time using a left-looking approach. Within a row block the factorization is performed by \\(NP\\) threads. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDLinDirectThread\n"},{"location":"libraries/numerics/LinearSolve/SparseGenCol/","text":"SparseGenColLinSolver #include <system_of_eqn/linearSOE/SparseGen/SparseGenColLinSolver.h> class SparseGenColLinSolver : public LinearSOESolver MovableObject Solver SparseGenColLinSolver is an abstract class. The SparseGenColLinSolver class provides access for each subclass to the SparseGenColLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. Sets the link to the SparseGenColLinSOE object theSOE . This is the object on which the solver will perform the numerical computations.","title":"SparseGenColLinSolver\n"},{"location":"libraries/numerics/Numberer/PlainNumberer/","text":"PlainNumberer #include <analysis/numberer/PlainNumberer.h> class PlainNumberer : public DOF_Numberer MovableObject DOF_Numberer The PlainNumberer class is a DOF_Numberer. An object of this class assigns the equation numbers to thee DOF_Groups based on the order in which they are obtained from the DOF_GroupIter object obtained from the AnalyisModel. The class is useful for situations where the SystemOfEqn or Solver objects will impose a renumbering on the equations, which makes performing a complex numbering of the degrees-of-freedom a waste of computational effort. Constructor ### Destructor // Public Methods The integer NUMBERER_TAG_PlainNumberer is passed to the DOF_Numberer classes constructor. Does nothing. The PlainNumberer will twice obtain the DOF_GroupIter from the AnalysisModel. It iterates twice through the DOF_Groups first assigning the dofs with eqn numbers assigned -2 a number and then on the next pass the dofs assigned -3. The PlainNumberer then invokes setID() on each FE_Element in the AnalysisModel. Finally it invokes setEqnNum(numEqn) on the AnalyisModel. Returns a positive integer equal to the last equation number set if successful, a negative number if not; the value of which depends on the type of the PlainNumberer. A PlainNumberer will not use the lastDOF_Group integer, if one is supplied a warning message is printed. The method is identical to that outlined above. A PlainNumberer will not use the lastDOF_Groups ID, if this method is invoked a warning message is printed. Returns \\(0\\) . Returns \\(0\\) .","title":"PlainNumberer\n"},{"location":"libraries/numerics/Numberer/RCM/","text":"RCM #include <graph/numberer/RCM.h> class RCM: public GraphNumberer; MovableObject GraphNumberer RCM is a subclass of GraphNumberer which performs the numbering using the reverse Cuthill-McKee numbering algorithm. Constructor ### Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. The flag GPS is used to mark whether the Gibbs-Poole-Stodlmyer algorithm is used to determine a starting vertex when no starting vertex is given. Invokes the destructor on any ID object created when number() is invoked. If the present ID used for the result is not of size equal to the number of Vertices in theGraph , it deletes the old and constructs a new ID. Starts by iterating through the Vertices of the graph setting the tmp variable of each to \\(-1\\) . The Vertices are then numbered using a depth first sort of the Graph, with each unmarked Vertex in the Graph at a distance \\(d\\) from starting Vertex being placed in the d\u2019th level set. As this is RCM, the Vertices in level set \\(n\\) are assigned a higher number than those in level set \\(n+1\\) with the tmp variable of the starting Vertex being assigned numVertices \\(-1\\) . The tags of the Vertices are placed into the ID at location given by their tmp variable. These are replaced with the ref variable of each Vertex, which is returned on successful completion. The Vertex chosen as the starting Vertex is the one whose tag is given by lastVertex . If this is \\(-1\\) or the Vertex corresponding to lastVertex does not exist then another Vertex is chosen. If the GPS flag in constructor is false the first Vertex from the Graphs VertexIter is used; if true a RCM numbering using the first Vertex from the VertexIter is performed and the Vertices in the last level set are then used to create an ID lastVertices with which number(theGraph, lastVertices) can be invoked to determine the numbering. This method is invoked to determine the best starting Vertex for a RCM using a Vertex whose tag is in lastVertices . To do a RCM numbering is performed using each of the Vertices in startVertices as the Vertex in level set \\(0\\) . The Vertex which results in the numbering with the smallest profile is chosen as the starting Vertex. The RCM algorithm outlined above is then called with this starting Vertex. int sendSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Returns \\(0\\) . int recvSelf(Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) .","title":"RCM\n"},{"location":"libraries/numerics/Partitioner/Metis/","text":"Metis #include <graph/partitioner/Metis.h> class GraphPartitioner: GraphPartitioner Metis is a GraphPartitioner. The Metis graph partitioner calls procedures defined in the METIS library to partition the graph. METIS is currently being developed by G. Karypis and V. Kumar at the University of Minnesota. At the present time the Graph to be partitioned MUST have the vertices labeled \\(0\\) through \\(numVertex-1\\) . The METIS library uses two integer arrays to represent the graph, xadj and adjncy . \\(xadj(i)\\) stores the location in adjncy of the start of the \\(i\\) \u2019th Vertices adjacent Vertices. adjncy contains the tags of all the adjacent vertices. For example, the graph which is represented by the following matrix \\(A\\) : \\[A = \\left[ \\begin{array}{ccccc} 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 0 & 1 \\end{array} \\right]\\] is represented by: \\[xadj = \\left[ \\begin{array}{cccccccccccccc} 0 & 2 & 3 & 4 & 5 & 7 \\end{array} \\right]\\] and \\[adjncy = \\left[ \\begin{array}{cccccccccccccc} 2 & 3 & 0 & 1 & 4 & 0 & 1 \\end{array} \\right]\\] note that there is no space allocated for the diagonal components. Constructors ### Destructor // Public Methods // Private Method To construct a Metis object which will use the default settings when partitioning. To construct a Metis object which will use the setting passed into the constructor as options to metis\u2019s PMETIS() routine. checkOptions() is invoked to ensure the settings are valid. This is the method invoked to partition the graph into numPart partitions. On completion of the routine each vertex will be assigned a color \\(1\\) through numPart , the color assigned indicating the partition to which the vertex belongs. To partition a number of integer arrays are created, options[5] , partition[numVertex+1] , xadj[numVertex+1] and adjncy[2*numEdge] (CURRENTLY ASSUMING GRAPH IS SYMMETRIC - THIS MAY CHANGE & xadj and partition 1 LARGER THAN REQUIRED). If not enough memory is available for the arrays, a warning message is printed and \\(-2\\) is returned. The data for xadj and adjncy are determined from the Vertices of the Graph by iterating over each Vertex from \\(0\\) through numVertex \\(-1\\) . If default options are specified options[0] is set to \\(0\\) , otherwise \\(1\\) with options[1:4] = coarsenTo, mType, ipType, rType . if pType equals \\(1\\) PMETIS is called, otherwise KMETIS is called. Both are called with the following arguments: numVertex, xadj,adjncy, 0, 0, &weightFlag, options, numPart, &numbering, &edgecut, partition The colors of the partitions are then set equal to the color indicated in partition . The integer arrays are destroyed and \\(0\\) returned. Sets the default options. Sets the options for the partitioning to those passed as arguments. Then invokes checkOptions() to see if the options are valid. HOW ABOUT REFERRINGR TO MANUAL TO SEE WHAT OPTIONS MEAN. If options are not valid sets the default options. EXPAND ON VALID OPTIONS OR REFER TO METIS MANUAL.","title":"Metis\n"},{"location":"reference/ast/","text":"AST Reference","title":"AST Reference\n"},{"location":"reference/core/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } lib Node (name, crd, mass, **kwds) name Tag crd [x,y,z] x Num y Num z Num mass = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0] [x,y,z,x,y,z] x Num y Num z Num x Num y Num z Num LinearTransform (name, vecxz, joint_offsets, **kwds) name Tag Tag used to identify the transform object. vecxz [vecxz1,vecxz2,vecxz3] vecxz1 Num vecxz2 Num vecxz3 Num joint_offsets [[None1,None2,None3],[None1,None2,None3]] [None1,None2,None3] = [0.0, 0.0, 0.0] Grp None1 Num None2 Num None3 Num [None1,None2,None3] = [0.0, 0.0, 0.0] Grp None1 Num None2 Num None3 Num","title":"lib\n"},{"location":"reference/framework/","text":"Framework","title":"Framework\n"},{"location":"reference/modeling/constraint/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } constraint RigidBeamLink (name, nodes, **kwds) name Tag nodes [nodes1,nodes2] nodes1 Ref(uniaxial) nodes2 Ref(uniaxial)","title":"constraint\n"},{"location":"reference/modeling/element/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } element ZeroLength (name, nodes, materials, dofs, orientation, do_rayleigh, **kwds) name Tag nodes [iNode,jNode] iNode Ref(Node) jNode Ref(Node) materials [materials1,materials2,materials3,materials4,materials5,materials6] materials1 Ref(uniaxial) materials2 Ref(uniaxial) materials3 Ref(uniaxial) materials4 Ref(uniaxial) materials5 Ref(uniaxial) materials6 Ref(uniaxial) dofs = [\u2018 \\(dx', '\\) dy\u2019, \u2018 \\(dz', '\\) rx\u2019, \u2018 \\(ry', '\\) rz\u2019] [dofs1,dofs2,dofs3,dofs4,dofs5,dofs6] dofs1 Int dofs2 Int dofs3 Int dofs4 Int dofs5 Int dofs6 Int orientation [[x1,x2,x3],[yp1,yp2,yp3]] x [x1,x2,x3] x1 Num x2 Num x3 Num yp [yp1,yp2,yp3] yp1 Num yp2 Num yp3 Num do_rayleigh Int ZeroLength3D (name, nodes, materials, dofs, orientation, do_rayleigh, **kwds) name Tag nodes [iNode,jNode] iNode Ref(Node) jNode Ref(Node) materials [materials1,materials2,materials3,materials4,materials5,materials6] materials1 Ref(uniaxial) materials2 Ref(uniaxial) materials3 Ref(uniaxial) materials4 Ref(uniaxial) materials5 Ref(uniaxial) materials6 Ref(uniaxial) dofs = [\u2018 \\(dx', '\\) dy\u2019, \u2018 \\(dz', '\\) rx\u2019, \u2018 \\(ry', '\\) rz\u2019] [dofs1,dofs2,dofs3,dofs4,dofs5,dofs6] dofs1 Int dofs2 Int dofs3 Int dofs4 Int dofs5 Int dofs6 Int orientation [[x1,x2,x3],[yp1,yp2,yp3]] x [x1,x2,x3] x1 Num x2 Num x3 Num yp [yp1,yp2,yp3] yp1 Num yp2 Num yp3 Num do_rayleigh Int forceBeamColumn (name, \u2003\u2003\u2003nodes, \u2003\u2003\u2003transform, \u2003\u2003\u2003integration, \u2003\u2003\u2003consistent_mass, \u2003\u2003\u2003mass_density, \u2003\u2003\u2003**kwds) name Tag nodes [iNode,jNode] iNode Ref(Node) jNode Ref(Node) geom Ref(geomTransf) integration BeamInt cMass Flg Flag indicating whether to use consistent mass matrix. mass Num element mass per unit length DisplBeamColumn (name, \u2003\u2003\u2003nodes, \u2003\u2003\u2003transform, \u2003\u2003\u2003integration, \u2003\u2003\u2003consistent_mass, \u2003\u2003\u2003mass_density, \u2003\u2003\u2003**kwds) name Tag nodes [iNode,jNode] iNode Ref(Node) jNode Ref(Node) geom Ref(geomTransf)","title":"element\n"},{"location":"reference/modeling/layer/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } layer line (material, divs, fiber_area, vertices, **kwds) material Ref(Material) Reference to previously created material ( UniaxialMaterial for a FiberSection or NDMaterial for use in an NDFiberSection ) divs Int number of fibers along line area Num area of each fiber vertices [[y,z],[y,z]] start [y,z] \\(y\\) and \\(z\\) -coordinates of first fiber in line (local coordinate system) y Num z Num end [y,z] \\(y\\) and \\(z\\) -coordinates of last fiber in line (local coordinate system) y Num z Num","title":"layer\n"},{"location":"reference/modeling/patch/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } patch A patch is used to generate a number of fibers over a cross-sectional area. Currently there are three types of patches that fibers can be generated over: quadrilateral, rectangular and circular. All patches have the following attributes: area Total area of the patch. moic Second moment of area matrix of the patch about its centroidal axis ixc Second moment of inertia of the patch about its \\(x\\) axis iyc Second moment of inertia of the patch about its \\(y\\) axis fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tagfor a FiberSection and NDMaterial tag for use in an NDFiberSection). Fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tagfor a FiberSection and NDMaterial tag for use in an NDFiberSection). rect (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num quad (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num circ (material, \u2003\u2003\u2003divs, \u2003\u2003\u2003center, \u2003\u2003\u2003intRad, \u2003\u2003\u2003extRad, \u2003\u2003\u2003startAng, \u2003\u2003\u2003endAng, \u2003\u2003\u2003**kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [circ,rad] circ Int number of subdivisions (fibers) in the circumferential direction (number of wedges) rad Int number of subdivisions (fibers) in the radial direction (number of rings) center = [0.0, 0.0] [y,z] \\(y\\) & \\(z\\) -coordinates of the center of the circle y Num z Num intRad Num internal radius extRad Num external radius startAng Num starting angle endAng = 6.283185307179586 Num ending angle line (material, divs, fiber_area, vertices, **kwds) material Ref(Material) Reference to previously created material ( UniaxialMaterial for a FiberSection or NDMaterial for use in an NDFiberSection ) divs Int number of fibers along line area Num area of each fiber vertices [[y,z],[y,z]] start [y,z] \\(y\\) and \\(z\\) -coordinates of first fiber in line (local coordinate system) y Num z Num end [y,z] \\(y\\) and \\(z\\) -coordinates of last fiber in line (local coordinate system) y Num z Num","title":"patch\n"},{"location":"reference/modeling/section/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } section This module provides constructors for SectionForceDeformation objects which represent force-deformation (or resultant stress-strain) relationships at beam-column and plate sample points. FiberSection (name, torsional_stiffness, areas, **kwds) name Tag GJ Num linear-elastic torsional stiffness assigned to the section (optional, default = no torsional stiffness) areas [] SectionAggregator (name, materials, section, **kwds) name Tag materials {dof : material \u2026} the force-deformation quantity to be modeled by this section object. dof Flg material Ref(uniaxial) tags of previously-defined UniaxialMaterial objects section Ref(section) tag of previously-defined Section object to which the UniaxialMaterial objects are aggregated as additional force-deformation relationships","title":"section\n"},{"location":"reference/modeling/uniaxial/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } uniaxial UniaxialMaterial object library. A UniaxialMaterial object typically represents a pair of work conjugate scalars such as axial stress/strain, moment/cuvature, or force/deformation. ElasticSpring (name, \u2003\u2003\u2003elastic_modulus, \u2003\u2003\u2003damp_tangent, \u2003\u2003\u2003negative_modulus, \u2003\u2003\u2003shear_modulus, \u2003\u2003\u2003**kwds) name Tag E Num Young\u2019s modulus of elasticity eta Num damping tangent Eneg Num G Num ElasticPP (name, elastic_modulus, epsyP, epsyN, eps0, **kwds) name Tag E Num Young\u2019s modulus of elasticity epsyP Num strain or deformation at which material reaches plastic state in tension epsyN Num strain or deformation at which material reaches plastic state in compression. (optional, default is tension value) eps0 Num initial strain (optional, default: zero) Steel02 (name, Fy, E0, b, R0, cR1, cR2, a, sigInit, **kwds) name Tag Fy Num yield strength E0 Num initial elastic tangent b Num strain-hardening ratio (ratio between post-yield tangent and initial elastic tangent R0 Num cR1 = 0.925 Num cR2 = 0.15 Num a [a1,a2,a3,a4] isotropic hardening parameters a1 Num increase of compression yield envelope as proportion of yield strength after a plastic strain of a2\u2217(Fy/E0) a2 = 1.0 Num see explanation under a1 . a3 Num increase of tension yield envelope as proportion of yield strength after a plastic strain of a4\u2217(Fy/E0) a4 = 1.0 Num see explanation under a3 . sigInit Num initial stress Concrete02 (name, fpc, epsc0, fpcu, epsU, lamda, ft, Ets, **kwds) name Tag integer tag identifying material fpc Num concrete compressive strength at 28 days (compression is negative) epsc0 Num concrete strain at maximum strength fpcu Num concrete crushing strength epsU Num concrete strain at crushing strength lamda Num ratio between unloading slope at epscu and initial slope ft Num tensile strength Ets Num tension softening stiffness (absolute value) (slope of the linear tension softening branch) Concrete04 (name, fc, ec, ecu, Ec, tension, beta, **kwds) name Tag fc Num floating point values defining concrete compressive strength at 28 days (compression is negative)* ec Num floating point values defining concrete strain at maximum strength* ecu Num floating point values defining concrete strain at crushing strength* Ec Num floating point values defining initial stiffness** tension [fct,et] fct Num floating point value defining the maximum tensile strength of concrete et Num floating point value defining ultimate tensile strain of concrete beta Num floating point value defining the exponential curve parameter to define the residual stress (as a factor of $ft) at $etu Concrete02IS (name, E0, fpc, epsc0, fpcu, epscu, tension, **kwds) name Tag E0 Num fpc Num epsc0 Num fpcu Num epscu Num tension [rat,ft,Ets] rat Num ft Num Ets Num","title":"uniaxial\n"},{"location":"reference/pattern/Plain/","text":"Plain Pattern","title":"Plain Pattern\n"},{"location":"reference/pattern/UniformExcitation/","text":"UniformExcitation #include <domain/pattern/UniformExcitation.h> class UniformExcitation : public EarthquakeLoad TaggedObject MovableObject DomainComponent LoadPattern EarthquakePattern A UniformExcitation is an object which adds the loads imposed by a single ground excitation to the model. For a UniformExcitation this means that the R matrix at each node will have \\(1\\) column and all entries but those corresponding to the degree of freedom direction will be set to \\(0\\) , the value for the degree of freedom direction will be set to \\(1\\) .","title":"UniformExcitation\n"},{"location":"reference/runtime/MomentCurvature/","text":"","title":""},{"location":"reference/utilities/quadrature/","text":"Quadrature","title":"Quadrature\n"},{"location":"reference/utilities/torsion/","text":"Torsion","title":"Torsion\n"},{"location":"reference/utilities/units/","text":"units meter [\u2018m\u2019] milimeter [\u2018mm\u2019] inch [\u2018inch\u2019, \u2018in\u2019] international_foot [\u2018foot\u2019, \u2018ft\u2019] us_survey_foot [\u2018s_foot\u2019, \u2018s_ft\u2019] international_yard [\u2018yard\u2019, \u2018yd\u2019] kilogram [\u2018kg\u2019] pound_mass [\u2018lb\u2019] newton [\u2018N\u2019] pound_force [\u2018lbf\u2019] kip [\u2018kip\u2019] hertz [\u2018Hz\u2019] radian [\u2018radian\u2019, \u2018rad\u2019] arc_degree [\u2018deg\u2019]","title":"units\n"}]}