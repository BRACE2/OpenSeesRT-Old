{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".home-feature { justify-content: space-between !important; align-items: center !important; display: flex !important; margin-top: 3rem !important; margin-bottom: 3rem !important; } anabel anabel Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Get Started Guides View guides that explain the concepts and components of anabel . API Documentation Peruse a comprehensive list of functions provided by anabel , with detailed explanations of their interfaces. Gallery Walk through some examples of the various analysis procedures that anabel provides. Inelasticity Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Partial Differential Equations Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Reliability Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.","title":""},{"location":"developer/","text":"Developer Documentation Welcome to the OpenSeesRT developer documentation. Architecture Compiling Extending Contributing","title":"Developer Documentation\n"},{"location":"developer/architecture/","text":"Architecture An OpenSees application can be decomposed into the following parts: The core framework, as originally presented in @mckenna1997 ( link ). This defines the core components and interfaces. Component libraries and community-contributions; these are concrete objects such as elements, materials and solvers. These implement the interfaces described in class_interface . Most of the documentation for these is in the user-space side of things. Runtime ( OpenSeesRT , OpenSees.exe , OpenSeesPy ). A runtime is responsible for providing a mechanism to users for conducting an analysis. Runtimes have been implemented using various communication mechanisms. The classic OpenSees Tcl interpreters generally invoke class methods directly to perform analysis procedures, meanwhile OpenSeesPy leverages the interpreter framework introduced in @mckenna2010 The OpenSeesRT distribution implements a new runtime and aims to achieve the following goals: Idempotence Reliability In order to prevent the exensability of the framework from impacting its reliability , modularity must be separated from the core framework. Architecture: libG3 - Core OpenSees framework libOpenSeesRT - Tcl package linking libG3 with OpenSees component libraries. libOpenSeesPyRT - Python bindings. Exposes direct interface to model objects like Element , UniaxialMaterial , etc.","title":"Architecture\n"},{"location":"developer/architecture/api/","text":"G3 API Model Building Domain * G3_getDomain ( G3_Runtime * ); Materials UniaxialMaterial * G3_getUniaxialMaterialInstance ( G3_Runtime * , int ); int G3_addUniaxialMaterial ( G3_Runtime * , UniaxialMaterial * ); Loading int G3_addTimeSeries ( G3_Runtime * , TimeSeries * ); TimeSeries * G3_getTimeSeries ( G3_Runtime * , int ); StaticAnalysis * G3_getStaticAnalysis ( G3_Runtime * ); int G3_setStaticAnalysis ( G3_Runtime * , StaticAnalysis * ); StaticIntegrator * G3_getStaticIntegrator ( G3_Runtime * ); int G3_setStaticIntegrator ( G3_Runtime * , StaticIntegrator * ); TclSafeBuilder * G3_getSafeBuilder ( G3_Runtime * );","title":"G3 API\n"},{"location":"developer/architecture/api/analysis/","text":"Analysis API Static Analysis G3_setStaticAnalysis ( G3_Runtime * rt , StaticAnalysis * analysios ) Transient Analysis G3_setTransientAnalysis ( G3_Runtime * rt , DirectIntegrationAnalysis * analysis ); Systems of Equations G3_setLinearSoe ( G3_Runtime * rt , LinearSOE * soe ); Point the runtime, rt , to the LinearSOE pointer, soe . If the runtime is aware of a StaticAnalysis or [ DirectIntegrationAnalysis ], their respective setLinearSOE() methods will be called. LinearSOE ** G3_getLinearSoePtr ( G3_Runtime * rt ); Get the current system of equations. LinearSOE * G3_getDefaultLinearSoe ( G3_Runtime * rt , int flags ); flags is unused right now but could be useful for ensuring properties about the SOE, like forcing fullGen.","title":"Analysis API\n"},{"location":"developer/architecture/api/element_api/","text":"C API 2 Model Building Domain * OPS_GetDomain ( void ); eleObj* OPS_GetElement(int* eleTag); matObj* OPS_GetMaterialType(char* type, int sizeType); eleObj* OPS_GetElementType(char* type, int sizeType); int OPS_AllocateElement(eleObject * theEle, int* matTags, int* matType); int OPS_AllocateMaterial(matObject * theMat); limCrvObj* OPS_GetLimitCurveType(char* type, int sizeType); int OPS_AllocateLimitCurve(limCrvObject * theLimCrv); Coordinate Transformations CrdTransf * OPS_GetCrdTransf ( int crdTag ); Materials UniaxialMaterial * OPS_GetUniaxialMaterial ( int matTag ); NDMaterial * OPS_GetNDMaterial ( int matTag ); matObj * OPS_GetMaterial ( int * matTag , int * matType ); int addPlasticMaterial ( PlasticHardeningMaterial & theMaterial ) = 0 ; PlasticHardeningMaterial * getPlasticMaterial ( int tag ) = 0 ; Sections SectionForceDeformation * OPS_GetSectionForceDeformation ( int secTag ); FrictionModel * OPS_GetFrictionModel ( int frnTag ); LimitCurve * OPS_GetLimitCurve ( int LimCrvTag ); int addSection ( SectionForceDeformation & theSection ) = 0 ; SectionForceDeformation * getSection ( int tag ) = 0 ; int addSectionRepres ( SectionRepres & theSectionRepres ) = 0 ; SectionRepres * getSectionRepres ( int tag ) = 0 ; Other Yield Surface int addYieldSurface_BC ( YieldSurface_BC & theYS ) = 0 YieldSurface_BC * getYieldSurface_BC ( int tag ) = 0 ; int addYS_EvolutionModel ( YS_Evolution & theModel ) = 0 ; YS_Evolution * getYS_EvolutionModel ( int tag ) = 0 ; Cyclic Models int addCyclicModel ( CyclicModel & theModel ); CyclicModel * getCyclicModel ( int tag ); Damage models int addDamageModel ( DamageModel & theModel ); DamageModel * getDamageModel ( int tag ); Friction models int addFrictionModel ( FrictionModel & theFrnMdl ); FrictionModel * getFrictionModel ( int tag ); Runtime int OPS_GetNDF (); int OPS_GetNDM (); extern FE_Datastore * OPS_GetFEDatastore (); extern \"C\" const char * OPS_GetInterpPWD (); AnalysisModel ** OPS_GetAnalysisModel ( void ); EquiSolnAlgo ** OPS_GetAlgorithm ( void ); ConstraintHandler ** OPS_GetHandler ( void ); DOF_Numberer ** OPS_GetNumberer ( void ); LinearSOE ** OPS_GetSOE ( G3_Runtime * ); EigenSOE ** OPS_GetEigenSOE ( void ); StaticAnalysis ** OPS_GetStaticAnalysis ( void ); DirectIntegrationAnalysis ** OPS_GetTransientAnalysis ( void ); VTDI_Analysis ** OPS_GetVTDI_Analysis ( void ); // VTDI_Analysis** OPS_GetVariableTimeStepTransientAnalysis(void); StaticIntegrator ** OPS_GetStaticIntegrator ( void ); TransientIntegrator ** OPS_GetTransientIntegrator ( void ); ConvergenceTest ** OPS_GetTest ( void ); bool * OPS_builtModel ( void ); Conducting Analysis int * OPS_GetNumEigen ( void ); int OPS_InvokeMaterial ( eleObject * , int * , modelState * , double * , double * , double * , int * ); int OPS_InvokeMaterialDirectly ( matObject ** , modelState * , double * , double * , double * , int * ); int OPS_InvokeMaterialDirectly2 ( matObject * , modelState * , double * , double * , double * , int * ); int OPS_GetNodeDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeVel ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeAccel ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeIncrDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeIncrDeltaDisp ( int * nodeTag , int * sizeData , double * data ); int OPS_GetNodeCrd ( int * nodeTag , int * sizeData , double * data ); int OPS_numIter ( void ); IO int OPS_GetNumRemainingInputArgs (); int OPS_ResetCurrentInputArg ( int cArg ); int OPS_GetIntInput ( int * numData , int * data ); int OPS_SetIntOutput ( int * numData , int * data , bool scalar ); int OPS_GetDoubleInput ( int * numData , double * data ); int OPS_SetDoubleOutput ( int * numData , double * data , bool scalar ); const char * OPS_GetString (); // does a strcpy const char * OPS_GetStringFromAll ( char * buffer , int len ); // does a strcpy int OPS_SetString ( const char * str ); int OPS_GetStringCopy ( char ** cArray ); // returns a new copy int OPS_ResetInput ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , TCL_Char * * argv , Domain * domain , TclModelBuilder * builder ); int OPS_ResetInputNoBuilder ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , TCL_Char * * argv , Domain * domain ); int OPS_GetString ( char * cArray , int sizeArray ); // does a strcpy void OPS_GetMaterialPtr ( int * matTag , matObj * theRes );","title":"C API 2\n"},{"location":"developer/architecture/api/element_api_c/","text":"C API IO API int OPS_GetIntInput(int* numData, int* data); int OPS_GetDoubleInput(int* numData, double* data); int OPS_GetString(char* cArray, int sizeArray); int OPS_Error(char*, int length); Model Building API matObj* OPS_GetMaterial(int* matTag, int* matType); void OPS_GetMaterialPtr(int*, matObj*); eleObj* OPS_GetElement(int*); matObj* OPS_GetMaterialType(char* type, int sizeType); eleObj* OPS_GetElementType(char*, int); int OPS_AllocateElement(eleObj*, int* matTags, int* maType); int OPS_AllocateMaterial(matObj*); limCrv* OPS_GetLimitCurveType(char* type, int sizeType);//**MRL int OPS_AllocateLimitCurve(limCrvObj*);//**MRL int OPS_InvokeMaterial(struct eleObj*, int*, modelState*, double*, double*, double*, int*); int OPS_InvokeMaterialDirectly(matObj**, modelState*, double*, double*, double*, int*); int OPS_InvokeMaterialDirectly2(matObj*, modelState*, double*, double*, double*, int*); int OPS_GetNodeCrd(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeDisp(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeVel(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeAcc(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeIncrDisp(int* nodeTag, int* sizeData, double* data); int OPS_GetNodeIncrDeltaDisp(int* nodeTag, int* sizeData, double* data); Runtime API int OPS_GetNDF (); int OPS_GetNDM (); AnalysisModel ** OPS_GetAnalysisModel ( void ); EquiSolnAlgo ** OPS_GetAlgorithm ( void ); ConstraintHandler ** OPS_GetHandler ( void ); DOF_Numberer ** OPS_GetNumberer ( void ); LinearSOE ** OPS_GetSOE ( void ); EigenSOE ** OPS_GetEigenSOE ( void ); StaticAnalysis ** OPS_GetStaticAnalysis ( void ); DirectIntegrationAnalysis ** OPS_GetTransientAnalysis ( void ); VariableTimeStepDirectIntegrationAnalysis ** OPS_GetVariableTimeStepTransientAnalysis ( void ); int * OPS_GetNumEigen ( void ); StaticIntegrator ** OPS_GetStaticIntegrator ( void ); TransientIntegrator ** OPS_GetTransientIntegrator ( void ); ConvergenceTest ** OPS_GetTest ( void ); bool * OPS_builtModel ( void ); #define ISW_INIT 0 #define ISW_COMMIT 1 #define ISW_REVERT 2 #define ISW_FORM_TANG_AND_RESID 3 #define ISW_FORM_MASS 4 #define ISW_REVERT_TO_START 5 #define ISW_DELETE 6 #define ISW_SET_RESPONSE 7 #define ISW_GET_RESPONSE 8 #define OPS_UNIAXIAL_MATERIAL_TYPE 1 #define OPS_SECTION2D_TYPE 2 #define OPS_SECTION3D_TYPE 3 #define OPS_PLANESTRESS_TYPE 4 #define OPS_PLANESTRAIN_TYPE 5 #define OPS_THREEDIMENSIONAL_TYPE 6 #define OPS_SECTION_TYPE 7 typedef struct modState modelState ; typedef void ( * matFunct )( struct matObject * , modelState * , double * strain , double * tang , double * stress , int * isw , int * error ); typedef struct limCrvObject limCrvObj ; typedef void ( * eleFunct )( struct eleObject * , modelState * , double * tang , double * resid , int * isw , int * error ); typedef struct eleObject eleObj ; typedef struct matObject matObj ; typedef void ( * limCrvFunct )( struct limCrvObject * , modelState * , double * strain , double * tang , double * stress , int * isw , int * error ); struct modState { double time ; double dt ; }; struct matObject { int tag ; int matType ; int nParam ; int nState ; double * theParam ; double * cState ; double * tState ; matFunct matFunctPtr ; void * matObjectPtr ; }; struct limCrvObject { int tag ; int nParam ; int nState ; double * theParam ; double * cState ; double * tState ; limCrvFunct limCrvFunctPtr ; void * limCrvObjectPtr ; }; struct eleObject { int tag ; int nNode ; int nDOF ; int nParam ; int nState ; int nMat ; int * node ; double * param ; double * cState ; double * tState ; matObj ** mats ; eleFunct eleFunctPtr ; };","title":"C API\n"},{"location":"developer/architecture/api/ops_api/","text":"Runtime API OPS_GetNDF(void) OPS_GetNDM(void) OPS_InvokeMaterialObject(struct matObject theMat, modelState theModel, OPS_Error(char errorMessage, int length) OPS_GetMaterial(int matTag, int matType) OPS_GetElement(int eleTag) OPS_GetElementType(char type, int sizeType) OPS_GetMaterialType(char type, int sizeType) OPS_GetLimitCurveType(char type, int sizeType) OPS_AllocateLimitCurve(limCrvObject theLimCrv) OPS_AllocateMaterial(matObject theMat) OPS_AllocateElement(eleObject theEle, int matTags, int matType) OPS_GetNodeCrd(int nodeTag, int sizeCrd, double data) OPS_GetNodeDisp(int nodeTag, int sizeData, double data) OPS_GetNodeVel(int nodeTag, int sizeData, double data) OPS_GetNodeAccel(int nodeTag, int sizeData, double data) OPS_GetNodeIncrDisp(int nodeTag, int sizeData, double data) OPS_GetNodeIncrDeltaDisp(int nodeTag, int sizeData, double data) OPS_InvokeMaterial(eleObject theEle, int mat, modelState *model, OPS_InvokeMaterialDirectly(matObject **theMat, modelState model, OPS_InvokeMaterialDirectly2(matObject theMat, modelState *model, OPS_GetUniaxialMaterial(int matTag) OPS_GetNDMaterial(int matTag) OPS_GetSectionForceDeformation(int secTag) OPS_GetCrdTransf(int crdTag) OPS_GetFrictionModel(int frnTag) OPS_GetFEDatastore() OPS_GetInterpPWD() OPS_GetDomain(void) OPS_GetLimitCurve(int LimCrvTag) OPS_GetAnalysisModel(void) OPS_GetAlgorithm(void) OPS_GetHandler(void) OPS_GetNumberer(void) OPS_GetSOE(void) OPS_GetEigenSOE(void) OPS_GetStaticAnalysis(void) OPS_GetTransientAnalysis(void) OPS_GetVariableTimeStepTransientAnalysis(void) OPS_GetNumEigen(void) OPS_GetStaticIntegrator(void) OPS_GetTransientIntegrator(void) OPS_GetTest(void) OPS_builtModel(void) OPS_numIter() Parsing API OPS_GetString ( void ) OPS_GetStringFromAll ( char * buffer , int len ) OPS_SetString ( const char * str ) OPS_GetStringCopy ( char ** arrayData ) OPS_GetNumRemainingInputArgs () OPS_ResetCurrentInputArg ( int cArg ) OPS_ResetInput ( ClientData clientData , Tcl_Interp * interp , int cArg , int mArg , OPS_ResetInputNoBuilder ( ClientData clientData , Tcl_Interp * interp , int cArg , OPS_GetIntInput ( int * numData , int * data ) OPS_SetIntOutput ( int * numData , int * data , bool scalar ) OPS_GetDoubleInput ( int * numData , double * data ) OPS_SetDoubleOutput ( int * numData , double * data , bool scalar )","title":""},{"location":"developer/architecture/class_interface/","text":"Class Interface Specification Classes may be categorized as follows: Domain : These classes describe the finite element model and store the results of an analysis on the model. The classes include Domain , Element , Node , Load, SP_Constraint , MP_Constraint , and their subclasses. Analysis : These classes perform the analysis of the finite element model. The classes include the Analysis , ConstraintHandler , DOF_Numberer , SolutionAlgorithm , Integrator , FE_Element , DOF_Group and AnalysisModel classes, and their subclasses. Computational Classes : These classes allow for composing efficient computational strategies that take advantage of prolem features such as sparsity , symmetry , and parallelism . More specifically these include: System of Equation These include the abstract SystemOfEquation and Solver classes, and subclasses of these classes. These classes are provided for the solving of large scale systems of linear and eigenvalue equations. Graph These are classes used to provide information about nodal and elemental connectivity and sparsity of systems of equations. The classes include Graph , Vertex , GraphNumberer , GraphPartitioner , and their subclasses. There is no Edge class provided at present. In current design each Vertex stores in an ID the tag of all it\u2019s adjacent Vertices. For graph numbering and partitioning this has proved sufficient. Parallel Classes These facilitate the development of parallel object-oriented finite element programs, classes are provided for parallel programming. The classes in the framework support the aggregate programming model. The classes include Actor , Shadow , Message , MachineBroker , FEM_ObjectBroker , Channel , and their subclasses. Runtime Classes: These include the ModelNamespace and G3_Runtime classes. An analyst will interact with a ModelBuilder object, to create the Element, Node, Load and Constraint objects that define the model. Other/Utility Classes Matrix Classes: These include the classes Matrix, Vector and ID (integer array). These classes are used in the framework for passing information between objects in a safe manner, and for small scale numerical calculations in element formulation. Data Storage These are classes used to store data. There are two abstract classes TaggedObjectStorage and FE_Datastore . Objects of type TaggedObjectStorage are used as containers to store and provide access to the TaggedObjects in memory during program execution. FE_Datastore objects are used to store/retrieve information from databases, containers which can permanently hold program data. Visualization Classes These are classes used to generate images of the model for the analyst. These classes include Renderer , ColorMap , and their subclasses. This design allows for contributions in the fields of: Element and material modeling. Solution algorithms, integration procedures and constraint handling techniques. Model generation. Numerical analysis for solution of linear and eigenvalue problems. Graph theory for numbering and partitioning graphs. Data structures for container classes and database. Graphics. Message passing systems and load balancing in parallel environments. Frank McKenna and Gregory L. Fenves December 20, 1999","title":"Class Interface Specification\n"},{"location":"developer/architecture/class_interface/Parallel/","text":"Parallel Classes To facilitate the development of parallel object-oriented finite element programs, a new framework is presented in this section. The classes in the framework support the aggregate programming model. The new classes are: Shadow - A Shadow object represents a remote actor object in the local actor process. Actor - An Actor object is a local object in the remote actor process. It performs the operations requested of it by the Shadow object. The actor objects in an aggregation collectively perform the analysis operations by communicating between themselves. Channel - The Shadow and Actor objects communicate with each other through Channel objects. A Channel object represents a point in a local actor process through which a local object can send and receive information. Address - An Address object represents the location of a Channel object in the machine space. Channel objects send information to other Channel objects, whose locations are given by an Address object. Channel objects also receive information from other Channel objects, whose locations are given by an Address object. MovableObject - A MovableObject is an object which can send its state from one actor process to another. ObjectBroker - An ObjectBroker is an object in a local actor process for creating new objects. MachineBroker - A MachineBroker is an object in a local actor process that is responsible for creating remote actor processes at the request of Shadow objects in the same local process. Frank McKenna and Gregory L. Fenves Version 0.1 - Preliminary Draft December 20, 1999 PEER, University of California at Berkeley","title":"Parallel Classes\n"},{"location":"developer/architecture/class_interface/Parallel/actor/","text":"Actor Shadow Channel TCP_Socket MPI_Channel MovableObject Message FEM_ObjectBroker MachineBroker","title":""},{"location":"developer/architecture/class_interface/Parallel/actor/actor/Actor/","text":"Actor #include <actor/actor/Actor.h> class Actor Actor is meant as an abstract class, i.e. no instances of Actor should exist. An actor is associated with a shadow object. The shadow acts like a normal object in the users address space, data and processing that is done by the shadow may be stored and processed in a remote process, the actor resides in this remote address space. The actor and the shadow both have a channel, a communication port. This allows the two to communicate with each other. Constructor ### Destructor // Public Methods for Processing Functions // Public Methods for Sending/Receiving Objects This is called by the remote process upon initialization to construct the local actor object. It is used to create an Actor object in that remote address space which will communicate with objects in other processes through a channel object, theChannel and which uses theBroker to receive movable objects sent from other processes. The subclass will be able to add numMethods actor methods using addMethod() call. The base classes constructor invokes setUpActor() on theChannel object. It then sets the Address of the remote shadow object which created the actor process by invoking getLastSendersAddress() on theChannel . Provided so subclass destructor will be called. A method to add as a function to the actor object the function fp , this function is identified by the tag value. This function will be invoked by the actor on invocation of processMethod() with tag as the argument. The object checks to see that the tag has not been used previously. If it has not and the number of functions so far added is less than numActorMethods the function is added and \\(0\\) is returned, otherwise a \\(-1\\) (if tag was already used) or \\(-2\\) (if numActorMethods already added) or a \\(-3\\) (if running out of space) is returned to indicate the function was not added. virtual int getMethod (); A method which returns the next integer value sitting in the actors channel. This int value corresponds to the tag of the next method that the shadow object wants the actor to perform. If an error occurs \\(-1\\) will be returned. virtual int processMethod ( int tag ); This causes the actor object to invoke the function that was added to the actor with the tag identifier. If no method with tag exists a \\(-1\\) is returned. virtual int sendObject(MovableObject &theObject, ChannelAddress *theAddress =0); A method which will send theObject through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendObj(0, theObject,theBroker,theAddress) on the actors channel object if an address is specified, otherwise the result of invoking sendObj(theMessage,theBroker,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvObject(MovableObject &theObject, ChannelAddress *theAddress =0); A method which will receive theObject from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvObj(0, theObject,theBroker,theAddress) on the actors channel object if an address is specified, otherwise the result of invoking recvObj(theMessage,theBroker,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendMessage(Message &theMessage, ChannelAddress *theAddress =0); A method which will send the data in the message theMessage through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendMsg ( 0 , 0 , theMessage , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendMsg ( theMessage , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. virtual int recvMessage ( Message & theMessage ); A method which will receive the data in the message theMessage from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvMsg ( 0 , 0 , theMessage , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvMsg(0,0,theMessage,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendMatrix(Matrix &theMatrix, ChannelAddress *theAddress =0); A method which will send theMatrix through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendMatrix ( 0 , 0 , theMatrix , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendMatrix(0,0,theMatrix,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvMatrix ( Matrix & theMatrix ); A method which will receive theMatrix from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvMatrix ( 0 , 0 , theMatrix , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvMatrix(0,0,theMatrix,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendVector(Vector &theVector, ChannelAddress *theAddress =0); A method which will send theVector through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendVector ( 0 , 0 , theVector , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendVector(0,0,theVector,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int recvVector ( Vector & theVector ); A method which will receive theVector from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvVector ( 0 , 0 , theVector , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvVector(0,0,theVector,this->getShadowAdressPtr()) on the actors channel object is returned. virtual int sendID ( ID & theID , ChannelAddress \\ * theAddress = 0 ); A method which will send theID through the actors channel either to the address given by theAddress or to the address of the shadow object that created the actor if no address is specified. Returns the result of invoking sendID ( 0 , 0 , theID , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking sendID ( 0 , 0 , theID , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. virtual int recvID ( ID & theID ); A method which will receive theID from the actors channel either from the address given by theAddress or from the address of the shadow object that created the actor if no address is specified. Returns the result of invoking recvID ( 0 , 0 , theID , theAddress ) on the actors channel object if an address is specified, otherwise the result of invoking recvID ( 0 , 0 , theID , this - \\ > getShadowAdressPtr ()) on the actors channel object is returned. void Channel \\ * getChannelPtr ( void ) const ; A method which returns a pointer to the channel passed in the constructor. void FEM_ObjectBroker \\ * getObjectBrokerPtr ( void ) const ; A method which returns a pointer to the FEM_ObjectBroker passed in the constructor. void ChannelAddress \\ * getChannelAddressPtr ( void ) const ; A method which returns a pointer to the channel address for the shadow object that created the actor.","title":"Actor\n"},{"location":"developer/architecture/class_interface/Parallel/actor/actor/MovableObject/","text":"MovableObject #include </actor/actor/MovableObject.h> class MovableObject MovableObject is an abstract class, i.e. no instances of MovableObject should exist. MovableObjects are objects which are able to send/receive themselves to/from Channel objects. With each movable object is associated a unique class identifier, it is this id which will allow object brokers in remote processes to create an object of the correct type. In addition when databases are being used, each MovableObject will have a unique database tag, it is this integer which will allow the objects to retrieve their own data from the database. Constructor Destructor // Public Methods The constructor sets the objects class identifier to classTag : this is a unique id for each class of instantiable movable objects. The identifier will allow an object broker to recognize the object type to be instantiated. Sets the objects database tag to dbTag : this is a unique id for identifying the object in a database. The constructor sets the objects class identifier to classTag and sets the objects database tag to 0 . A method which returns the class id, classTag , provided in the constructor. int getDbTag ( void ) const ; A method which returns the database tag, dbTag , provided in the constructor or last set in setDbTag() . void setDbTag ( int dbTag ); A method to set the database tag to be equal to dbTag . virtual int sendSelf ( int commitTag , Channel & theChannel ) = 0 ; This is a pure virtual method, one must be written for each instantiable subclass of MovableObject. Each object has to send the data needed to be able to reproduce that object in a remote process. The object uses the methods provided by theChannel object to send the data to another channel at the remote actor, the address of the channel is set before this method is called. An object of similar type at the remote actor is invoked with a receiveSelf() to receive the data. Returns \\(0\\) if successful (successful in that the data got to the channel), or a \\(-1\\) if no data was sent. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker) =0; This is a pure virtual method, one must be written for each instantiable subclass of MovableObject. Each object has to receive the data needed to be able to recreate itself in the new process after it has been sent through theChannel . If the object is an aggregation containing other objects, new objects of the correct type can be constructed using theBroker . To return \\(0\\) if successful or a \\(-1\\) if not.","title":"MovableObject\n"},{"location":"developer/architecture/class_interface/Parallel/actor/message/Message/","text":"Message #include <actor/message/Message.h> class Message Messages are objects that can be sent between Channels. They are provided to allow data of arbitrary length and type, e.g. structs, to be sent between processes running on similar machine architectures. WARNING Sending Messages between machines with different architectures can result in erroniuos data being received. Each Message object keeps a pointer to the data it represents and an integer outlining the data size. There is no copy of the data kept by the Message. Constructors Destructor // Public Member Functions ; To construct an empty message. To construct a message for sending/receiving an array containing num doubles. To construct a message for sending/receiving an array containing num ints. To construct a message for sending/receiving a string of num characters or a struct. Does nothing. ; A method which will put the data given by the character pointer theData of size endLoc -startLoc into the data array pointed to by the Message starting at location \\(startLoc\\) in this array. Returns \\(0\\) if successful; an error message is printed and a \\(-1\\) is returned if not. The routine bcopy() is used to copy the data. virtual const char \\ * getData ( void ); A method which returns a const char * pointer to the messages data. virtual int getSize ( void ); A method to get the size of the array. The unit of size is that of a character.","title":"Message\n"},{"location":"developer/architecture/class_interface/Parallel/actor/objectBroker/FEM_ObjectBroker/","text":"FEM_ObjectBroker #include <actor/objectBroker/FEM_ObjectBroker.h> class FEM_ObjectBroker FEM_ObjectBrokers is an object used to create a new blank of a certain type in a process. The explicit type of object created depends on the method invoked and the integer classTag passed as an argument to the method. Once the object has been created, recvSelf() can be invoked on the object to instantiate the object with it\u2019s data. Constructor ### Destructor // Public Methods to get new Domain objects // Public Methods to get New Matrix,Vector and ID objects - NOT USED // Public Methods to get new Analysis objects - NOT NEEDED SEQUENTIAL // Public Methods for Parallel Model Generation Does nothing. Does nothing.","title":"FEM_ObjectBroker\n"},{"location":"developer/architecture/class_interface/Parallel/actor/objectBroker/ObjectBroker/","text":"ObjectBroker #include <ObjectBroker.h> class ObjectBroker ObjectBroker is an abstract class, i.e. no instances of ObjectBroker should exist. ObjectBrokers are objects in remote processes which create new objects in the remote process. It has one method virtual MovableObject \\ * getNewObject ( Channel & channel ) = 0 ; This method returns a pointer to an object of the type whose class type is given by the integer class ID value that is waiting at the Channel. The method must first instantiate the correct type of object, it then can invoke recv(channel) on this object. To get from a pointer of MovableObject to one of its descendents type casting must be used.","title":"ObjectBroker\n"},{"location":"developer/architecture/class_interface/Parallel/channel/Channel/","text":"Channel #include <actor/channel/Channel.h> class Channel Channel is an abstract class, i.e. no instances of Channel should exist. A Channel is a point of communication in a program, a mailbox to/from which data enters/leaves a program. Channels are objects through which the objects in the current processes address space can interact with objects in another processes address space. A channel in one process space is associated with a channel in the address space of another process space. The interaction is in the form of data sent between the two processes along the connection line. ### Constructor ### Destructor // Public Methods Does nothing. Does nothing. Provided so that a subclasses destructor will be invoked. When creating remote actors the channels created in the actor space need to know how to contact the shadows channels. This information is provided in the string returned from this method. It is used by the machine broker when starting the remote process. It places this information as the last arguments to the program. A method invoked in the local address space by a shadow object. The method is to be invoked concurrently with a setUpShadow() invocation on a channel object in all the remote actor processes. virtual int setUpActor ( void ) = 0 ; A method invoked in the remote address space by the actor. The method is invoked concurrently with a corresponding setUpShadow() invocation on a channel in a local actor process by the shadow object that created the running actor process. If the method fails returns a negative number. For actors with only one Channel this should cause the termination of the actor. virtual int setNextAddress ( ChannelAddress & theNextAddress ) = 0 ; A method invoked to set specify the next address that the next messages to be sent if sendMessage() or received if recvMessage() is invoked with a null pointer. To return the next available database tag, must be an integer value greater than \\(0\\) , \\(0\\) is used my the objects to check if they have yet been assigned a database tag. The method defined for the Channel base class always returns \\(0\\) , only database channel objects need worry about assigning unique integer values. To send the object theObject and the commit tag commitTag to a remote Channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. To receive the object theObject with the commit tag commitTag from a remote Channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel receives from the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method which is invoked to send the data in the Message object theMessage to another Channel object. The object will obtain the data and size of the data to be sent by invoking getData() and getSize() on theMessage . The channel object is then responsible for sending that data to the remote channel address given by theAddress . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method which is invoked to send the data in the Message object theMessage to another Channel object. The object will obtain the the size of the data that is being received by invoking getSize() on theMessage . The channel object is then responsible for receiving that amount of data from the channel whose address is given by theAddress . If theAddress is \\(0\\) , the Channel receives from the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a Matrix theMatrix to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a Matrix theMatrix from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a Vector theVector to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a Vector theVector from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for sending a ID theID to a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel sends to the Channel with the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not. A method for receiving a ID theID from a remote Channel, whose address is given by theAddress , with the integer identifiers dbTag and commitTag . If theAddress is \\(0\\) , the Channel receives from the Channel at the address last set in a send..() , recv..() , or setNextAddress() operation. To return \\(0\\) if successful, a negative number if not.","title":"Channel\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/LoadBalancer/","text":"LoadBalancer #include <domain/loadBalancer/LoadBalancer.h> class LoadBalancer A LoadBalancer is an object used to balance a PartitionedDomain. The LoadBalancer does this by invoking methods in the DomainPartitioner object with which it is associated. Constructor ### Destructor // Public Methods // Public Methods Sets the pointer to the associated PartitionedDomain to be \\(0\\) . Does nothing. Provided so the subclasses destructor will be called. Sets the pointer to the DomainPartitioner object associated with the LoadBalancer to point to thePartitioner . virtual int balance ( Graph & theWeightedGraph ) = 0 ; Each subclass must provide an implementation of this method. This method is invoked to balance the PartitionedDomain. The Graph theWeightedGraph is a weighted graph in which the vertices represent the Subdomains, the edges Subdomains sharing common boundary nodes and the weight the cost of the previous Subdomain calculations (determined by invoking getCost() on the Subdomains). Returns a pointer to the DomainPartitioner. If no DomainPartitioner has been set, a warning message is printed and \\(0\\) returned.","title":"LoadBalancer\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/ReleaseHeavierToLighterNeighbours/","text":"#include <domain/loadBalancer/ReleaseHeavierToLighterNeighbours.h> clas ReleaseHeavierToLighterNeighbours: public LoadBalancer LoadBalancer A ReleaseHeavierToLighterNeighbours is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. For numRelease times the Vertices of theWeightedGraph are iterated through. For each Vertex, \\(i\\) , releaseBoundary(i, theWeightedGraph, true, factorGreater) is invoked on the DomainPartitioner. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or releaseBoundary() returns a negative number.","title":""},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/ShedHeaviest/","text":"ShedHeaviest #include <domain/loadBalancer/ShedHeaviest.h> class ShedHeaviest: public LoadBalancer LoadBalancer A ShedHeaviest is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. The heaviest loaded partition, max , is first determined by iterating through the Graph theWeightedGraph looking at the vertex weights. Then releaseBoundary(max, theWieightedGraph, true, factorGreater) is invoked on the DomainPartitioner numRelease times. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or releaseBoundary() returns a negative number.","title":"ShedHeaviest\n"},{"location":"developer/architecture/class_interface/Parallel/loadBalancer/SwapHeavierToLighterNeighbours/","text":"SwapHeavierToLighterNeighbours #include <domain/loadBalancer/SwapHeavierToLighterNeighbours.h> class SwapHeavierToLighterNeighbours : public LoadBalancer LoadBalancer A SwapHeavierToLighterNeighbours is an object used to balance a PartitionedDomain. It does this by shedding the boundary vertices on the heaviest loaded partition (subdomain). Constructors Destructor // Public Methods Sets numRealeases to \\(1\\) and factorGreater to \\(1.0\\) . These are the paramemeters used in the balance() method. Sets the parameters used in the balance() method. Does nothing. For numRelease times the Vertices of theWeightedGraph are iterated through. For each Vertex, \\(i\\) , the weight of the Vertex is compared to those of it\u2019s adjacent Vertices, \\(other\\) , (this is done by looping through the adjacency ID of the Vertex), if the vertex weight is factorGreater times greater than the other Vertices load then swapBoundary(i, other) is invoked on the DomainPartitioner. Returns \\(0\\) if successful, otherwise a negative number and a warning message are returned if either no link has been set to the DomainPartitioner or swapBoundary() returns a negative number.","title":"SwapHeavierToLighterNeighbours\n"},{"location":"developer/architecture/class_interface/Parallel/machineBroker/MachineBroker/","text":"MachineBroker #include <actor/machineBroker/MachineBroker.h> class MachineBroker MachineBrokers are objects that are used to start remote processes running on the parallel machine. Constructor ### Destructor // Public Member Functions Does nothing. Invoked to start the program, actorProgram , on the parallel machine. The remote actor process uses information supplied by theChannel to allow the remote process to connect to the local process. The integer compDemand provides an indication of the computational demands of the remote process in a heterogeneous environment.","title":"MachineBroker\n"},{"location":"developer/architecture/class_interface/Parallel/shadow/Shadow/","text":"Shadow #include <actor/shadow/Shadow.h> class Shadow Shadow is meant as an abstract class, i.e. no instances of Shadow should exist. A Shadow object is associated with an Actor object which may exist in another process. The Shadow acts like a normal object in the users address space, data and processing that is done by the Shadow may be stored and processed in a remote process, the Actor object resides in this remote address space. The Actor and the Shadow both have a Channel, a communication port. This allows the two to communicate with each other. Constructors Destructor // Protected Methods for Sending Objects to Remote Actor This constructor is used when the actor process is already up and running. The constructor sets its channel to be theChannel , its associated object broker to be theBroker , and the address to which it will send data to be thaActorsAddress . This constructor is used to get an actor process up and running. If startShadow is true , the constructor invokes startActor(program,theChannel,compDemand) on theMachineBroker object. It then invokes setUpShadow() on theChannel and getLastSendersAddress() on theChannel to set up store the address of the actors channel, theActorsAddress ; this is done in case multiple shadow objects use a single channel. If an error occurs an error message is printed and the program terminated. Does nothing. A method which will send the MovableObject theObject to the actor object through the shadows channel. It returns the result of invoking sendObj(0,0,theObject, theBroker, theActorsAddress) on the shadow\u2019s associated channel theChannel . virtual void recvObject ( MovableObject & theObject ); A method which will cause the object to read the MovableObject theObject from the channel. It will return the result of invoking recvObj(0,0,theObject, theBroker, theActorsAddress) on the shadows associated channel theChannel . A method which will send the message theMessage to the actor object through the shadows channel. It will return the result of invoking sendMsg(0,0,theMessage, theActorsAddress) on the shadows associated channel theChannel . virtual void recvMessage ( Message & theMessage ); A method which will cause the object to read the message theMessage from the channel. It will return the result of invoking recvMsg(0,0,theMessage, theActorsAddress) on the shadows associated channel theChannel . A method which will send the Matrix theMatrix to the actor object through the shadows channel. It will return the result of invoking sendMatrix(0,0,theMatrix, theActorsAddress) on the shadows associated channel theChannel . virtual void recvMatrix ( Matrix & theMatrix ); A method which will cause the object to read the Matrix theMatrix from the channel. It will return the result of invoking recvMatrix(0,0,theMatrix, theActorsAddress) on the shadows associated channel theChannel . A method which will send the Vector theVector to the actor object through the shadows channel. It will return the result of invoking sendVector(0,0,theVector, theActorsAddress) on the shadows associated channel theChannel . virtual void recvVector ( Vector & theVector ); A method which will cause the object to read the Vector theVector from the channel. It will return the result of invoking recvVector(0,0,theVector, theActorsAddress) on the shadows associated channel theChannel . A method which will send the ID theID to the actor object through the shadows channel. It will return the result of invoking sendID(0,0,theID, theActorsAddress) on the shadows associated channel theChannel . virtual void recvID ( ID & theID ); A method which will cause the object to read the ID theID from the channel. It will return the result of invoking recvID(0,0,theID, theActorsAddress) on the shadows associated channel theChannel . void Channel \\ * getChannelPtr ( void ) const ; A method which returns a pointer to the channel currently set. void FEM_ObjectBroker \\ * getObjectBrokerPtr ( void ) const ; A method which returns a pointer to the FEM_ObjectBroker passed in the constructor. void ObjectBroker \\ * getActorAddressPtr ( void ) const ; A method which returns a pointer to the channel in the actors address space.","title":"Shadow\n"},{"location":"developer/architecture/class_interface/analysis/","text":"Analysis Classes The Analysis object is an aggregation of objects of the following types: SolnAlgorithm : The solution algorithm object is responsible for orchestrating the steps performed in the analysis. AnalysisModel : The AnalysisModel object is a container class for storing and providing access to the following types of objects: DOF_Group : The DOF_Group objects represent the degrees-of-freedom at the Node s or new degrees-of-freedom introduced into the analysis to enforce the constraints. FE_Element : The FE_Element objects represent the Elements in the Domain or they are introduced to add stiffness and/or load to the system of equations in order to enforce the constraints. Integrator : The Integrator object is responsible for defining the contributions of the FE_Element s and DOF_Group s to the system of equations and for updating the response quantities at the DOF_Group s with the appropriate values given the solution to the system of equations. ConstraintHandler : The ConstraintHandler object is responsible for handling the constraints. It does this by creating FE_Element s and DOF_Group s of the correct type. DOF_Numberer : The DOF_Numberer object is responsible for mapping equation numbers in the system of equations to the degrees-of-freedom in the DOF_Group s.","title":"Analysis Classes\n"},{"location":"developer/architecture/class_interface/analysis/ConstraintHandler/","text":"ConstraintHandler #include <analysis/handler/ConstraintHandler.h> class ConstraintHandler : public MovableObject The ConstraintHandler class is an abstract base class. Its purpose is to define the interface common among all subclasses. A constraint handler is responsible for: creating the FE_Element and DOF_Group objects and adding them to the AnalysisModel. setting the initial dof equation numbers to \\(-1\\) , \\(-2\\) or \\(-3\\) . A \\(-1\\) indicates to the DOF_Numberer object that no equation number is to be allocated for this dof, a \\(-3\\) that this dof is to be among the last group of dof to be numbered. deleting the DOF_Group and FE_Element objects that it created. Constructor Destructor // Public Methods // Protected Methods The integer classTag is passed to the MovableObject constructor. Does nothing. Invoked to set the links that the ConstraintHandler will need. These include links to the Domain, theDomain , for which the ConstraintHandler object will apply the constraints and the AnalysisModel, theModel , to which the ConstraintHandler will add the FE_Element and DOF_Group objects. Invoked to handle the constraints imposed on the domain by the SP_Constraints and MP_Constraints. The ConstraintHandler object does this by instantiating the appropriate FE_Element and DOF_Group objects and adding them to the AnalysisModel. For all the dofs in each DOF_Group the ConstraintHandler sets initial equation numbers as either \\(-1\\) , \\(-2\\) or \\(-3\\) : A \\(-1\\) indicates to the DOF_Numberer object that no equation number is to be allocated for this dof, a \\(-2\\) that an equation number is to be given for the dof, and a \\(-3\\) that an equation number is to be allocated and that this dof is to be among the last group of dof to be numbered,i.e. all dof initially assigned a \\(-3\\) are to be given a higher equation number than those given a \\(-2\\) . Those dof with a \\(-3\\) should include all those dof associated with the nodes whose tags are in nodesToBeNumberedLast . Returns a positive number if successfully, a negative integer if not; the positive number is to be set at the number of dof assigned a value \\(-3\\) (this will be the number of external dof for a subdomain), the negative value of which depends on the type of ConstraintHandler. For subdomains the constraint handler is responsible for setting the FE_Element by calling setFE_elementPtr . virtual void clearAll ( void ) = 0 ; Invoked to inform the ConstraintHandler object that the FE_Elements and DOF_Groups it constructed are no longer part of the AnalysisModel. The ConstraintHandler can delete these objects if necessary; or the ConstraintHandler can store them and use them in subsequent calls to handle() . A const member function to return the Domain object associated with the ConstraintHandler, theDomain . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function to return the AnalysisModel object associated with the ConstraintHandler, theModel . Integrator \\ * getIntegratorPtr ( void ) const ; A const member function to return the Integrator object associated with the ConstraintHandler, theIntegrator .","title":"ConstraintHandler\n"},{"location":"developer/architecture/class_interface/analysis/DOF_Numberer/","text":"DOF_Numberer #include <analysis/numberer/DOF_Numberer.h> class DOF_Numberer : public MovableObject The DOF_Numberer class is a base class. Its purpose is to define the interface common among all subclasses. A DOF_Numberer object is responsible for assigning the equation numbers to the individual dofs in each of the DOF_Groups in the AnalysisModel. The base DOF_Numberer uses a GraphNumberer object to first number the DOF_Groups, based on the ordering of the DOF_Group objects, it assigns the equation numbers to the individual degrees-of-freedom. Subtypes may wish to implement the numbering in a more efficient manner by using the FE_Element and DOF_Group objects directly. Constructors ### Destructor // Public Methods // Protected Methods The integer NUMBERER_TAG_DOF_Numberer (defined in <classtags.h> ) is passed to the MovableObject classes constructor. Sets the GraphNumberer to be used in the numbering to theGraphNumberer() . Provided for subclasses. The integer classTag is passed to the MovableObject classes constructor. Provided for FEM_ObjectBroker. The integer NUMBERER_TAG_DOF_Numberer (defined in <classtags.h> ) is passed to the MovableObject classes constructor. Sets the GraphNumberer to be used in the numbering to be \\(0\\) , the GraphNumberer object is created and linked in a recvSelf() method invocation. Does nothing. Invoked to set a link to the AnalysisModel from which the DOF_Numberer will number (provide the equation number in the SystemOfEqn object) the degrees-of-freedoms in each DOF_Group objects. Invoked to assign the equation numbers to the dofs in the DOF_Groups and the FE_Elements, ensuring that the dof\u2019s in the DOF_Group whose tag is given by lastDOF_Group are numbered last in a \\(-2\\) or \\(-3\\) group. The initial values of these equation numbers have been set by the ConstraintHandler object to be \\(-1\\) , \\(-2\\) or \\(-3\\) , all dofs with a \\(-3\\) are to be assigned higher equation numbers than those assigned a \\(-2\\) . To set the numEqn in the AnalysisModel and to return the number of equations numEqn if successful, a negative number if not. This base class performs the ordering by getting an ID containing the ordered DOF_Group tags, obtained by invoking number(theModel- \\(>\\) getDOFGroupGraph(), lastDOF_Group) on the GraphNumberer, theGraphNumberer , passed in the constructor. The base class then makes two passes through the DOF_Group objects in the AnalysisModel by looping through this ID; in the first pass assigning the equation numbers incrementally to any degree-of-freedom marked with a \\(-2\\) and in the second pass assigning the equation numbers incrementally to any degree-of-freedom marked with a \\(-3\\) . It then iterates through the FE_Elements in the AnalsisModel invoking setID() on each object. Finally setNumEqn(numEqn) is invoked on the AnalysisModel. Return numEqn if successful, a warning message and a negative number is returned if an error occurs; \\(-1\\) is returned if setLinks() has not yet been invoked, \\(-2\\) if no GraphNumberer was passed in the constructor, \\(-3\\) if the number of DOF_Groups in AnalysisModel and size of ID returned are not the same, and a \\(-4\\) if there is no DOF_Group corresponding to one of the tags given in the ID. Invoked to assign the equation numbers to the dofs in the DOF_Groups and the FE_Elements, ensuring that the dof\u2019s in the DOF_Groups whose tag is given in lastDOF_Groups are numbered last in a \\(-2\\) or \\(-3\\) group. The initial values of these equation numbers have been set by the ConstraintHandler object to be \\(-1\\) , \\(-2\\) or \\(-3\\) , all dofs with a \\(-3\\) are to be assigned higher equation numbers than those assigned a \\(-2\\) . To set the numEqn in the AnalysisModel and to return the number of equations numEqn if successful, a negative number if not. This method in the base class is almost identical to the one just described. The only difference is that the ID identifying the order of the DOF_Groups is obtained by invoking number(theModel- \\(>\\) getDOFGroupGraph(), lastDOF_Groups) on the GraphNumberer. The DOF_Numberer sends the class identifier and database tag of the GraphNumberer in a ID to the channel, if no GraphNumberer is associated a \\(-1\\) is sent as the class tag. The object then invokes sendSelf() on the GraphNumberer. The DOF_Numberer receives the class identifier and database tag of the GraphNumberer in an ID from the channel, if no GraphNumberer is associated a \\(-1\\) is received. The DOF_Numberer will then ask theBroker for a GraphNumberer with that class identifier, it sets the database tag for the GraphNumberer and it then invokes recvSelf() on that GraphNumberer. A const member function to return the AnalysisModel object associated with the DOF_Numberer, theModel . A const member function to return the GraphNumberer object associated with the DOF_Numberer, theGraphNumberer .","title":"DOF_Numberer\n"},{"location":"developer/architecture/class_interface/analysis/algorithm/EquiSolnAlgo/","text":"EquiSolnAlgo #include <analysis/algorithm/equiSolnAlgo/EquiSolnAlgo.h> class EquiSolnAlg : public SolutionAlgo MovableObject SolutionAlgorithm The EquiSolnAlgo class is an abstract base class. Its purpose is to define the interface common among all subtypes. An EquiSolnAlgo object defines the sequence of operations performed by the the Integrator and the LinearSOE objects in solving the equilibrium equation \\(R(U) = 0\\) given the current state of the domain at each time step in a direct integration analysis or load increment in a static analysis. Constructor Destructor // Public Methods // Public Methods for Output // Public Methods for Pointers - not Protected for ConvergenceTest The integer classTag is passed to the SolutionAlgorithm classes constructor. Does nothing. Sets up the links needed by an object of this class, or a derived class, to an AnalysisMode, IncrementalIntegrator and LinearSOE object. Pointers to these objects can be obtained by subtypes using the protected methods defined below. A method implemented by each subclass which specifies the steps taken in order to get the system into an equilibrium state. It is a pure virtual function, i.e. all subclasses or their descendents must implement this routine. To return \\(0\\) if algorithm succeeds, a negative value otherwise. The Integrator is to send information to the stream based on the integer flag . A const member function which returns a pointer to the AnalysisModel associated with the EquiSolnAlgo object, theModel passed in setLinks() . \\(0\\) returned if one not yet associated. IncrementalIntegrator \\ * getIncrementalIntegratorPtr ( void ) const ; A const member function which returns a pointer to the StaticMethod associated with the StaticSolnAlgo object, theIntegrator passed in setLinks() . \\(0\\) returned if one not yet associated. LinSysOfEqn \\ * getLinearSOEptr ( void ) const ; A const member function which returns a pointer to the LinearSOE associated with the EquiSolnAlgo object, theLinearSOE passed in setLinks() . \\(0\\) returned if one not yet associated.","title":"EquiSolnAlgo\n"},{"location":"developer/architecture/class_interface/analysis/algorithm/SolutionAlgorithm/","text":"SolutionAlgorithm #include <analysis/algorithm/SolutionAlgorithm.h> class SolutionAlgorithm : public MovableObject The SolutionAlgorithm class is an abstract base class. Its purpose is to define the interface common among all its subclasses. A SolutionAlgorithm object performs the steps in the analysis by specifying the sequence of operations to be performed by members in the analysis aggregation. Constructor Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. Invokes the destructor on any recorder object added to the SolutionAlgorithm and releases memory used to hold pointers to the recorder objects. Is called by the Analysis if the domain changes. It is called after domainChange() has been called on the ConstraintHandler , DOF_Numberer and the Integrator and after setSize() has been called on the SystemOfEqn object. For base class nothing is done and \\(0\\) is returned. The subclasses can provide their own implementation of this method if anything needs to be done, e.g. memory allocation, To return \\(0\\) if successful, a negative number if not. To add a recorder object theRecorder to the SolutionAlgorithm. returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if not enough memory is available. To invoke record(track) on any Recorder objects which have been added to the SolutionAlgorithm . To invoke playback(track) on any Recorder objects which have been added to the SolutionAlgorithm .","title":"SolutionAlgorithm\n"},{"location":"developer/architecture/class_interface/analysis/analysis/Analysis/","text":"Analysis #include <analysis/analysis/Analysis.h> class Analysis ; The Analysis class is an abstract base class. Each Analysis object will be associated with a single Domain, the Domain upon which it will perform the analysis operations. The base Analysis class holds a pointer to this Domain and will return this pointer to subclasses. Constructors and Destructor Analysis ( theDomain & theDomain ); All analysis are associated with a single domain, this constructor sets up the link between the analysis and the domain. virtual ~ Analysis (); Does nothing. Provided so that the subclasses destructor will be invoked. Pure Virtual Public Member Functions virtual int domainChanged ( void ) = 0 ; Invoked to inform the analysis that the finite element model has changed, for example when new elements have been added. It is also a virtual function. To return \\(0\\) if successful, a negative number if not. Protected Method Domain * getDomainPtr ( void ); Returns a pointer to the domain that was passed in the constructor.","title":"Analysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DirectIntegrationAnalysis/","text":"DirectIntegrationAnalysis #include <analysis/analysis/DirectIntegrationAnalysis.h> class DirectIntegrationAnalysis : public TransientAnalysis ; Analysis TransientAnalysis DirectIntegrationAnalysis is a subclass of TransientAnalysis. It is used to perform a transient analysis using an incremental approach on the Domain. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors. TransientIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. EquiSolnAlgo - an algorithmic class specifying the sequence of operations to be performed in setting up and solving the finite element equation which can be represented by the equation K(U) U = P(U). Constructor ### Destructor // Public Methods // Public Methods to vary the type of Analysis tStart , tFinish and thDomain are passed to the TransientAnalysis class constructor. The constructor is responsible for setting up all links needed by the objects in the aggregation. It invokes setLinks(theDomain) on theModel , setLinks(theDomain,theModel,theIntegrator) on theHandler , setLinks(theModel) on theNumberer , setLinks ( theModel , theSOE ) on theIntegrator and setLinks(theModel,theAnalysis, theIntegrator, theSOE) on theSolnAlgo . Does nothing. clearAll() must be invoked if the destructor on the objects in the aggregation need to be invoked. Invoked to perform a transient analysis on the FE_Model. The method checks to see if the domain has changed before it performs the analysis. The DirectIntegrationAnalysis object performs the following: while \u0304 while w\u0304hile \u0304 double time = tStart; while (theDomain- \\(>\\) getCurrntTime() \\(<\\) tFinish) { if (theDomain- \\(>\\) hasDomainChanged() == true) this- \\(>\\) domainChanged(); theIntegrator- \\(>\\) newStep( \\(\\delta t\\) ); theAlgorithm- \\(>\\) solveCurrentStep(); theIntegrator- \\(>\\) commit(); } The type of analysis performed, depends on the type of the objects in the analysis aggregation. If any of the methods invoked returns a negative number, an error message is printed, revertToLastCommit() is invoked on the Domain, and a negative number is immediately returned. Returns a \\(0\\) if the algorithm is successful. void clearAll ( void ); Will invoke the destructor on all the objects in the aggregation. NOTE this means they must have been constructed using new() , otherwise a segmentation fault can occur. void domainChange ( void ); This is a method invoked by a domain which indicates to the analysis that the domain has changed. The method invokes the following: It invokes clearAll() on theModel which causes the AnalysisModel to clear out its list of FE_Elements and DOF_Groups, and clearAll() on theHandler . It then invokes handle() on theHandler . This causes the constraint handler to recreate the appropriate FE_Element and DOF_Groups to perform the analysis subject to the boundary conditions in the modified domain. It then invokes number() on theNumberer . This causes the DOF numberer to assign equation numbers to the individual dof\u2019s. Once the equation numbers have been set the numberer then invokes setID() on all the FE_Elements in the model. Finally the numberer invokes setNumEqn() on the model. It then invokes domainChanged() on theIntegrator and theAlgorithm to inform these objects that changes have occurred in the model. It invokes setSize ( theModel . getDOFGraph ()) on theSOE which causes the system of equation to determine its size based on the connectivity of the dofs in the analysis model. Finally it invokes domainChanged() on theIntegrator and theAlgorithm . Returns \\(0\\) if successful. At any stage above, if an error occurs the method is stopped, a warning message is printed and a negative number is returned. int setDeltaT ( double $ \\ delta t$ ); Sets the time increment used in the analyze() method to \\(\\delta t\\) . Returns \\(0\\) . To change the algorithm between analysis. It first invokes the destructor on the old SolutionAlgorithm object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new SolutionAlgorithm. Returns \\(0\\) if successful, a warning message and a negative number if not. To change the integration scheme between analysis. It first invokes the destructor on the old Integrator object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . It also invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new Integrator. Returns \\(0\\) if successful, a warning message and a negative number if not. To change the linear system of equation object between analysis. It first invokes the destructor on the old LinearSOE object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newSOE . links for this object by invoking setLinks() . It then invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes setSize() on the new LinearSOE. Returns \\(0\\) if successful, a warning message and a negative number if not.","title":"DirectIntegrationAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DomainDecompositionAnalysis/","text":"DomainDecompositionAnalysis UNDER CONSTRUCTION #include <analysis/analysis/DomainDecompositionAnalysis.h> class DomainDecompositionAnalysis : public Analysis , public MovableObject ; \\ Analysis \\ MovableObject \\ DomainDecompositionAnalysis is a subclass of Analysis, it is used when performing an analysis using the domain decomposition method to solve the equations. Its public member functions are all virtual to allow for the generalization of the class. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where A is a matrix, and x and b are vectors. IncrementalIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. DomainDecompositionAlgo - an algorithmic class specifying the sequence of operations to be performed in determining the response for the external dof and placing these in the system of equations. DomainSolver - an algorithmic class specifying the sequence of operations to be performed in performing the numerical operations. ### Destructor // Public Methods // Protected Member Functions The constructor sets all the links required by the objects in the aggregation. To do this it invokes setLinks(theDomain) on theModel , setLinks(theSubdomain,theModel,theIntegrator) on theHandler , setLinks(theModel) on theNumberer , it invokes setLinks(theModel, theSOE) on theIntegrator , and it invokes setLinks(theModel,theIntegrator, theSOE,theSolver,theSubdomain) on theSolnAlgo . Finally it invokes setAnalysis ( \\ * this ) on theSubdomain . A constructor that is used when creating a DomainDecompositionObject which is to receive itself afterwards. Sets the links to the Subdomain. It is essential that this object recvSelf() before DomainDecompositionAnalysis methods are invoked as their invocation will cause segmentation faults. Invokes setAnalysis(this) on the Subdomain. DomainDecompositionAnalysis ( int classTag , Subdomain & theDomain ); Provided for subclasses to use. Invokes setAnalysis(this) on the Subdomain. Causes an error message to be output and returns \\(-1\\) . virtual void domainChanged ( void ); Method used to inform the object that the domain has changed. The DomainDecompositionAnalysis object then performs the following: theAnalysisModel- \\(>\\) clearAll(), theConstraintHandler- \\(>\\) clearAll(); numExtEqn = theConstraintHandler- \\(>\\) handle(theSubdomain- \\(>\\) getExternalNodes()); theDOFnumberer- \\(>\\) number(theExternalDOFsDOFGrps); theLinSysOfEqn- \\(>\\) setSize(theAnalysisModel- \\(>\\) getDOFGraph); theIntegrator- \\(>\\) domainChanged(); theAlgorithm- \\(>\\) domainChanged(); Finally tangFormed is marked as false . int getNumExternalEqn ( void ); A method to return the number of external degrees-of-freedom on the Subdomain interface, this information is returned when handle() is invoked on theConstraintHandler . virtual int computeInternalResponse ( void ); A method which invokes solveCurrentStep() on theAlgorithm . virtual int formTangent ( void ); A method to form the condensed tangent matrix, given the current number of internal dof. It first checks to see if the Subdomain has changed, by invoking hasDomainChanged() on the Subdomain; if it has invokeChangeOnAnalysis() is invoked on the Subdomain . It then checks to see if counter is equal to \\(-1\\) or not; a \\(-1\\) indicating the tangent has already been formed in order that the residual could be determined. If this is not the case formTangent() is invoked on theIntegrator , condenseA() is invoked on theSolver object, a flag is set to indicate that the tangent has been formed, and the counter is incremented. Returns a \\(0\\) if successful, if either the formTangent() or condenseA() method returns a negative number this number is returned. virtual int formResidual ( void ); A method to form the condensed residual vector, given the current number of internal dof. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed it invokes formTangent() on itself and sets the counter to \\(-1\\) . To form the residual formUnbalance() is invoked on theIntegrator and condenseRHS(numInt) is invoked on theSolver . Returns \\(0\\) or the negative number that was returned if either formUnbalance() or condenseRHS() failed. int formTangVectProduct ( Vector & u ); A method to form the product of the condensed tangent matrix times the vector \\(u\\) . A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed it invokes formTangent() on itself and sets the counter to \\(-1\\) . Finally the result of invoking computeCondensedMatVect ( numInt , u ) on theSolver is returned. virtual Matrix & getTangent (); A method which returns the portion of A corresponding to internal equation numbers. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . If the tangent has not yet been formed formTangent() is invoked. The method returns the result of invoking getCondensedA() on theSolver() . virtual Vector & getResidual (); A method which returns the portion of the \\(b\\) corresponding to the external equation numbers. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain and formResidual() is called. The object returns the Vector obtained from invoking getCondensedRHS() on the solver. const Vector & getTangVectProduct (); Returns the result of invoking getCondensedMatVect() on the solver. A check to see if the Subdomain has changed is first made, this is done by invoking hasDomainChanged() on the Subdomain; if it has been modified invokeChangeOnAnalysis() is invoked on the Subdomain . The object returns the Vector obtained from invoking getCondensedMatVect() on theSolver . int sendSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID and populates the ID with the class tags of the aggregates in the aggregation. This ID is sent and then sendSelf(theChannel,theBroker) is invoked on each of the aggregates. Returns 0. int recvSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID and receives data into it from theChannel . Based on the class tags in the ID theBroker is then asked to return pointers to new objects required in the aggregation. sendSelf ( theChannel , theBroker ) is invoked on each of these new aggregate objects. Finally setLinks is invoked on each of these objects with the correct arguments and setAnalysis(this) is invoked on the Subdomain . Returns 0. A const member function which returns a pointer to theSubdomain . ConstraintHandler \\ * getConstraintHandlerPtr ( void ) const ; A const member function which returns a pointer to theSubdomain . DOF_Numberer \\ * getDOF_NumbererPtr ( void ) const ; A const member function which returns a pointer to theNumberer . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function which returns a pointer to theModel . DomainDecompAlgo \\ * getDomainDecompAlgoPtr ( void ) const ; A const member function which returns a pointer to theAlgorithm . IncrementalIntegrator \\ * getIncrementalIntegratorPtr ( void ) const ; A const member function which returns a pointer to theIntegrator . LinearSOE \\ * getLinSOEPtr ( void ) const ; A const member function which returns a pointer to theSOE . A const member function which returns a pointer to theSolver . associated with the DomainDecompositionAnalysis object.","title":"DomainDecompositionAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/DomainUser/","text":"DomainUser #include <DomainUser.h> class DomainUser ; Analysis Design DomainDisplay The DomainUser class is an abstract base class. Its purpose is to define the interface common among all subclasses. A DomainUser is a user of the domain, example subtypes being Analysis and Design. The class defines the pure virtual function domainChange() : it is this method that is invoked by the domain on all domain users once the domain has changed, i.e. the connectivity has changed. All DomainUser are associated with a single domain, this constructor sets up the link between the DomainUser and the domain, setting its link with theDomain. The constructor invokes addDomainUser ( \\ * this ) on the domain. All DomainUser are associated with a single domain, the destructor removes the link in the domain by invoking removeDomainUser ( \\ * this ) on the domain. Invoked by the associated domain to inform the domainUser that the connectivity of the domain has changed. A const method which returns a pointer to the Domain object on which the DomainUser performs its DomainUser.","title":"DomainUser\n"},{"location":"developer/architecture/class_interface/analysis/analysis/StaticAnalysis/","text":"StaticAnalysis #include <analysis/analysis/StaticAnalysis.h> class StaticAnalysis : public Analysis ; Description StaticAnalysis is a subclass of Analysis , it is used to perform a static analysis on the Domain. The following are the aggregates of such an analysis type: AnalysisModel - a container class holding the FE_Element and DOF_Group objects created by the ConstraintHandler object. ConstraintHandler - a class which creates the DOF_Group and FE_Element objects, the type of objects created depending on how the specified constraints in the domain are to be handled. DOF_Numberer - a class responsible for providing equation numbers to the individual degrees of freedom in each DOF_Group object. LinearSOE - a numeric class responsible for the creation and subsequent solution of large systems of linear equations of the form \\(Ax = b\\) , where \\(A\\) is a matrix and \\(x\\) and \\(b\\) are vectors. StaticIntegrator - an algorithmic class which provides methods which are invoked by the FE_Element to determine their current tangent and residual matrices; that is this is the class that sets up the system of equations. It also provides the update() method which is invoked to set up the appropriate dof response values once the solution algorithm has formed and solved the system of equations. EquiSolnAlgo - an algorithmic class specifying the sequence of operations to be performed in setting up and solving the finite element equation which can be represented by the equation K(U) U = P(U). Class Interface Constructors StaticAnalysis ( Domain & theDomain , ConstraintHandler & theHandler , DOF_Numberer & theNumberer , AnalysisModel & theModel , EquiSolnAlgo & theSolnAlgo , LinearSOE & theSOE , StaticIntegrator & theIntegrator , int numIncrements = 1 ); The constructor is responsible for setting the links between the objects in the aggregation. To do this it invokes setLinks(theDomain) on theModel , setLinks ( theDomain , theModel , theIntegrator ) on theHandler , setLinks(theModel) on theNumberer , setLinks(theModel, theSOE) on theIntegrator , and setLinks(theModel,theAnalysis, theIntegrator, theSOE) on theSolnAlgo . The constructor also sets the number of analysis steps that will be performed to be numIncrements . Destructor Does nothing. clearAll() must be invoked if the destructor on the objects in the aggregation need to be invoked. Public Methods int analyze ( int numSteps ); Invoked to perform a static analysis on the FE_Model. The analysis The StaticAnalysis object performs the following: // while \u0304 while w\u0304hile \u0304 for ( int i = 0 ; i < numSteps ; i ++ ) { if ( theDomain -> hasDomainChanged () == true ) this -> domainChanged (); theIntegrator . newStep (); theSolnAlgo . solveCurrentStep (); theIntegrator . commit (); } The type of analysis performed, depends on the type of the objects in the analysis aggregation. If any of the methods invoked returns a negative number, an error message is printed, revertToLastCommit() is invoked on the Domain, and a negative number is immediately returned. Returns a \\(0\\) if the algorithm is successful. void clearAll ( void ); Will invoke the destructor on all the objects in the aggregation. NOTE this means they must have been constructed using new() , otherwise a segmentation fault can occur. int domainChange ( void ); This is a method invoked by the analysis during the analysis method if the Domain has changed. The method invokes the following: It invokes clearAll() on theModel which causes the AnalysisModel to clear out its list of FE_Elements and DOF_Groups , and clearAll() on theHandler . It then invokes handle() on theHandler . This causes the constraint handler to recreate the appropriate FE_Element and DOF_Groups to perform the analysis subject to the boundary conditions in the modified domain. It then invokes number() on theNumberer . This causes the DOF numberer to assign equation numbers to the individual dof\u2019s. Once the equation numbers have been set the numberer then invokes setID() on all the FE_Elements in the model. Finally the numberer invokes setNumEqn() on the model. It invokes setSize ( theModel . getDOFGraph ()) on theSOE which causes the system of equation to determine its size based on the connectivity of the dofs in the analysis model. Finally domainChanged() is invoked on both theIntegrator and theAlgorithm . Returns 0 if successful. At any stage above, if an error occurs the method is stopped, a warning message is printed and a negative number is returned. Public Methods to vary the type of Analysis int setNumIncrements ( int numIncrements ); To set the number of incremental steps in the analysis to be numIncrements . Returns \\(0\\) . int setAlgorithm ( EquiSolnAlgo & theAlgorithm ); To change the algorithm between analysis. It first invokes the destructor on the old SolutionAlgorithm object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new SolutionAlgorithm. Returns \\(0\\) if successful, a warning message and a negative number if not. int setIntegrator ( StaticIntegrator & theIntegrator ); To change the integration scheme between analysis. It first invokes the destructor on the old Integrator object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newAlgorithm and sets the links for this object by invoking setLinks() . It also invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes domainChanged() on the new Integrator. Returns \\(0\\) if successful, a warning message and a negative number if not. int setLinearSOE ( LinearSOE & theSOE ); To change the linear system of equation object between analysis. It first invokes the destructor on the old LinearSOE object associated with the analysis. It then sets the SolutionAlgorithm associated with the analysis to be newSOE . links for this object by invoking setLinks() . It then invokes setLinks() on the ConstraintHandler and SolutionAlgorithm objects. Checks then to see if the domain has changed, if true it invokes domainChanged() , otherwise it invokes setSize() on the new LinearSOE. Returns \\(0\\) if successful, a warning message and a negative number if not.","title":"StaticAnalysis"},{"location":"developer/architecture/class_interface/analysis/analysis/SubstructuringAnalysis/","text":"SubstructuringAnalysis #include </analysis/analysis/SubstructuringAnalysis.h> class SubstructuringAnalysis : public DomainDecompositionAnalysis ; MovableObject Analysis DomainDecompositionAnalysis SubstructuringAnalysis is a subclass of DomainDecompositionAnalysis. It is used when performing an analysis using the substructuring method. It differs from the DomainDecompositionAnalysis class only in that the constructor ensures that a SubstructuringSolver is given for the Solver. The constructor is responsible for ensuring a Substructuring solver is passed in as an argument. The base class does the rest. For this reason WE WILL FORGET THIS CLASS. Invokes removeDomainUser(this) on the domain object.","title":"SubstructuringAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/analysis/TransientAnalysis/","text":"TransientAnalysis #include <analysis/analysis/TransientAnalysis.h> class TransientAnalysis : public Analysis ; The TransientAnalysis class is an abstract class. Its purpose is to define the interface common among all subclasses. A TransientAnalysis object is responsible for performing a transient analysis on the domain. Constructor Destructor // Public Methods // Protected Data The Domain theDomain is passed to the Analysis classes constructor. Sets the starting time and finishing time for the transient analysis to tStart and tFinish . Does nothing. Invoked to perform a dynamic analysis on the model. The type of analysis performed, depends on the type of the objects in the analysis aggregation. Returns a \\(0\\) if successful, otherwise a negative number is returned; the value of which depends on the type of the analysis. virtual void setTimeStart ( double tStart ); To set the starting time of the TransientAnalysis to tStart . It invokes setCurrntTime(tStart) on the associated domain object. virtual void setTimeFinish ( double tFinish ); To set the finishing time of the TransientAnalysis to tFinish .","title":"TransientAnalysis\n"},{"location":"developer/architecture/class_interface/analysis/convergenceTest/ConvergenceTest/","text":"#include \\(<\\tilde{}\\) /convergenceTest/ConvergenceTest.h \\(>\\) class ConvergenceTest: public MovableObject MovableObject A ConvergenceTest object is an object which can be used in an algorithmic class to test if convergence has been achieved for an iteration. The ConvergenceTest class is an abstract class, defining the interface that all subclasses must provide. The integer classTag is passed to the MovableObject constructor. Does nothing. To set the corresponding EquiSolnAlgo class. To return a postive number if the convergence criteria defined for the object has been satisfied, the positibe number equal to the number of times since start that test() has been invoked. Otherwise a negative number is to be returned. A -2 is returned if the test fails to meet the criteria and no more tests are to be performed due to limits set, i.e. the maximum number of iterations, otherwise a -1 is to be returned. This is invoked at the start of each iteration. To return 0 if sucessfull, i.e that testing can proceed, a negative number if not.","title":""},{"location":"developer/architecture/class_interface/analysis/integrator/CentralDifference/","text":"CentralDifference #include <analysis/integrator/CentralDifference.h> class CentralDifference : public TransientIntegrator MovableObject Integrator IncrementalIntegrator CentralDifference is a subclass of TransientIntegrator which implements the CentralDifference method. In the CentralDifference method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , the equilibrium equation (expressed for the TransientIntegrator) is typically solved at time \\(t\\) for \\({\\bf U}_{t+\\Delta t}\\) , i.e. solve: \\[{\\bf R} ({\\bf U}_{t+ \\Delta t}) = {\\bf P}(t) - {\\bf F}_I(\\ddot{\\bf U}_{t}) - {\\bf F}_R(\\dot{\\bf U}_{t},{\\bf U}_{t})\\] where we use following to relate \\(\\dot{\\bf U}_{t}\\) and \\(\\ddot{\\bf U}_{t}\\) to \\({\\bf U}_{t}\\) and the displacement quantities at times \\(t\\) and \\(t - \\Delta t\\) : \\[\\dot {\\bf U}_{t} = \\frac{1}{2 \\Delta t} \\left( {\\bf U}_{t + \\Delta t} - {\\bf U}_{t - \\Delta t} \\right)\\] \\[\\ddot {\\bf U}_{t} = \\frac{1}{\\Delta t^2} \\left( {\\bf U}_{t + \\Delta t} - 2 {\\bf U}_t + {\\bf U}_{t - \\Delta t}\\right)\\] which results in the following \\[\\left[ \\frac{1}{\\Delta t^2} {\\bf M} + \\frac{1}{2 \\Delta t} {\\bf C} \\right] {\\bf U}_{t + \\Delta t} = {\\bf P}(t) - F_I \\left(\\ddot{\\bf U}_t^{(i-1)} \\right) -F_R\\left( \\dot{\\bf U}_t^{(i-1)}, {\\bf U}_t)\\right)\\] Constructors Destructor // Public Methods // Public Methods for Output Sets \\(\\gamma\\) to \\(1/2\\) and \\(\\beta\\) to \\(1/4\\) . Sets a flag indicating whether the incremental solution is done in terms of displacement, \\(\\Delta \\U\\) , if dispFlag is true , or acceleration, \\(\\Delta \\ddot \\U\\) , if dispFlag is false . Sets \\(\\gamma\\) to gamma and \\(\\beta\\) to beta . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag . Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 {\\bf K} + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1) theEle- \\(>\\) addCtoTang(c2) theEle- \\(>\\) addMtoTang(c3) int formNodTangent ( DOF_Group \\ * theDof ); The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() theDof- \\(>\\) addMtoTang(c3) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE- \\(>\\) getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\ Delta t$ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 depending on the flag indicating whether incremental displacements or accelerations are being solved for at each iteration. If dispFlag was true , c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta * deltaT)\\) and c3 to \\(1/ (\\beta * deltaT^2)\\) . If the flag is false c1 is set to \\(\\beta * deltaT^2\\) , c2 to \\(\\gamma * deltaT\\) and c3 to \\(1.0\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . Then the velocity and accelerations approximations at time \\(t + \\delta t\\) are set using the difference approximations if dispFlag was true . (displacement and velocity if false ). The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with new quantities for time \\(t + \\Delta t\\) . current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response at the DOF_Group objects are then updated by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\delta U\\) are of different sizes. int sendSelf(int commitTag, Channel &theChannel); Places the \\(\\beta\\) and \\(\\gamma\\) and dispFlag into a vector if size 3 and invokes sendVector on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 3 the values of \\(\\beta\\) , \\(\\gamma\\) and dispFlag . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\gamma\\) and \\(\\beta\\) .","title":"CentralDifference\n"},{"location":"developer/architecture/class_interface/analysis/integrator/DisplacementControl/","text":"DisplacementControl UNDER CONSTRUCTION. #include <analysis/integrator/DisplacementControl.h> class DisplacementControl : public StaticIntegrator MovableObject Integrator IncrementalIntegrator DisplacementControl is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the displacement control method. In the displacement control method the displacement at a specified degree-of-freedom Uc is specified for each iteration. The following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[Uc_n^{(i)} - Uc_{n-1} = \\delta Uc_n\\] where \\(\\delta Uc_n\\) depends on \\(\\delta Uc_{n-1}\\) , the displacement increment at the previous time step, \\(J_{n-1}\\) , the number of iterations required to achieve convergence in the previous load step, and \\(Jd\\) , the desired number of iteraions. \\(\\delta Uc_n\\) is bounded by \\(\\delta Uc_{min}\\) and \\(\\delta Uc_{max}\\) . \\[\\delta Ucn = max \\left( \\delta Uc{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta Uc{n-1}, \\delta Uc{max} \\right) \\right)\\] SOME THEORY. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_DisplacementControl (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. \\(\\delta Uc_1\\) is the load factor used in the first step. The arguments \\(Jd\\) , \\(\\delta Uc_{min}\\) , and \\(\\delta Uc_{max}\\) are used in the determination of the increment in the load factor at each step. Does nothing. int newStep ( void ); WHAT DO I DO? int update ( const Vector & $ \\ Delta U$ ); WHAT DO I DO? int sendSelf(int commitTag, Channel &theChannel); WHAT DO I DO? int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); WHAT DO I DO? int Print ( OPS_Stream & s , int flag = 0 ); WHAT DO I DO?","title":"DisplacementControl\n"},{"location":"developer/architecture/class_interface/analysis/integrator/IncrementalIntegrator/","text":"IncrementalIntegrator #include <analysis/integrator/IncrementalIntegrator.h> class IncrementalIntegrator: public Integrator MovableObject Integrator IncrementalIntegrator is an abstract class. A subclass of it is used when performing a static or transient analysis using an incremental displacement approach. Subclasses of IncrementalIntegrators provide methods informing the FE_Element and DOF_Group objects how to build the tangent and residual matrices and vectors. They also provide the method for updating the response quantities at the DOFs with appropriate values; these values being some function of the solution to the linear system of equations. Constructor ### Destructor // Public Methods // Public Method added for Domain Decomposition // Protected Methods The integer classTag is passed to the Integrator classes constructor. Pointers to the AnalysisModel and LinearSOE are set to \\(0\\) . Does nothing. Invoked by the Analysis object to set up the links the IncrementalIntegrator objects needs to perform its operations. Sets the pointers to the AnalysisModel and LinearSOE objects to point to theAnalaysisModel and theSOE . virtual int formTangent ( void ); Invoked to form the structure tangent matrix. The method first loops over all the FE_Elements in the AnalysisModel telling them to form their tangent and then it loops over the FE_Elements again adding the tangent to the LinearSOE objects A matrix. It performs the following: while \u0304 while w\u0304hile \u0304 FE_EleIter &theEles = theAnalysisModel.getFEs(); theSOE.zeroA(); while((elePtr = theEles1()) \\(\\neq\\) 0) if (theSOE.addA(elePtr- \\(>\\) getTangent(this), elePtr- \\(>\\) getID(), \\(1.0\\) ) \\(<\\) 0) return \\(-1\\) ; Returns \\(0\\) if successful, otherwise an error message is printed an a \\(-1\\) is returned if setLinks() has not been called, or \\(-2\\) if failure to add an FE_Elements tangent to the LinearSOE. The two loops are introduced to allow for efficient parallel programming. THIS MAY CHANGE TO REDUCE MEMORY DEMANDS. virtual int formUnbalance ( void ); Invoked to form the unbalance. The method fist zeros out the \\(B\\) vector of the LinearSOE object and then invokes formElementResidual() and formNodalUnbalance() on itself. while \u0304 while w\u0304hile \u0304 theSOE.zeroB(); this- \\(>\\) fromElementResidual(); this- \\(>\\) formNodalUnbalance() If an error occurs in either of these two methods or if setLinks() has not been called, an error message is printed and a negative number is returned. Returns \\(0\\) if successful. To inform the FE_Element how to build its tangent matrix for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int formEleResidual ( FE_Element \\ * theEle ) = 0 ; To inform the FE_Element how to build its residual vector for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int formNodTangent ( DOF_Group \\ * theDof ) = 0 ; To inform the DOF_Group how to build its tangent matrix for addition to the system of equations. The subclasses must provide the implementation of this method. This is required in transient analysis as th Node objects have mass. THIS MAY CHANGE. virtual int formNodUnbalance ( DOF_Group \\ * theDof ) = 0 ; To inform the DOF_Group how to build its residual vector for addition to the system of equations. The subclasses must provide the implementation of this method. virtual int update ( const Vector & $ \\ Delta U$ ) = 0 ; When invoked causes the integrator object to update the DOF_Group responses with the appropriate values based on the computed solution to the system of equation object. The subclasses must provide an implementation of this method. virtual int commit ( void ) = 0 ; Invoked by the SolutionAlgorithm to inform the Integrator that current state of domain is on solution path. Returns the result of invoking commitDomain() on the AnalysisModel object associated with the Integrator. Returns in result values for the last solution to the system of equation object whose location in the solution vector is given by id . For a location specified by a negative integer in id 0.0 will be returned in result . Returns a \\(0\\) if successful, a warning message and a negative number is returned if an error occurs. \\(-1\\) if setSize() has not been called and a \\(-2\\) if location in id is greater than \\(order-1\\) of \\(b\\) vector. A const member function which returns a pointer to the LinearSOE associated with the IncrementalIntegrator object, i.e. theSOE passed in setLinks() . AnalysisModel \\ * getAnalysisModelPtr ( void ) const ; A const member function which returns a pointer to the AnalysisModel associated with the IncrementalIntegrator object, i.e. theModel passed in setLinks() . virtual int formNodalUnbalance ( void ); The method first loops over all the DOF_Group objects telling them to form their unbalance and then adds this Vector to the \\(b\\) vector of the LinearSOE object, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 DOF_EleIter &theDofs = theAnalysisModel.getDOFs(); theSOE.zeroB(); while((dofPtr = theDofs()) \\(\\neq\\) 0) theSOE.addB(dofPtr- \\(>\\) getUnbalance(theIntegrator), dofPtr- \\(>\\) getID()) Returns \\(0\\) if successful, otherwise a negative number is returned and a warning message is printed if an error occurred. Note, no test is made to ensure setLinks() has been invoked. virtual int formElementResidual ( void ); Invoked to form residual vector (the C vector in theSOE). The method iterates twice over the FE_elements in the AnalysisModel, the first time telling the FE_Elements top form their residual and the second time to add this residual to the LinearSOE objects \\(b\\) vector, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 FE_EleIter &theEles = theAnalysisModel.getFEs(); while((elePtr = theEles()) \\(\\neq\\) 0) { theSOE.addA(elePtr- \\(>\\) getResidual(this), elePtr- \\(>\\) getID()) Returns \\(0\\) if successful, otherwise a warning message is printed and a negative number is returned if an error occurs. Note, no test is made to ensure setLinks() has been invoked.","title":"IncrementalIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/Integrator/","text":"Integrator #include <analysis/integrator/Integrator.h> class Integrator : public MovableObject ; MovableObject The Integrator class is an abstract base class. Its purpose is to define the interface common among all subclasses. An integrator method is responsible for defining how the system of equations are set up (this it does by specifying how the FE_Element and DOF_Group objects of the analysis model construct the vectors and matrices asked of them by the Analysis). It is also responsible for updating the response quantities at the DOFs with the appropriate values; the values are determined from the solution to the system of equations. Constructor Destructor // Public Methods // Public Method added for Domain Decomposition // Public Method added for Output classTag is passed to the MovableObject classes constructor. Does nothing. Provided so the subclass destructors will be invoked. Is called by the Analysis object. Refer to the Analysis classes to see when it is invoked. To return \\(0\\) if successful, a negative number if not. This base class returns \\(0\\) . Called upon to determine the FE_Element theEle s matrix contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the DOF_Group theDof s matrix contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the FE_Element theEle s vector contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. Called upon to determine the DOF_Group theDof s vector contribution to the SystemOfEqn object. To return \\(0\\) if successful, a negative number otherwise. virtual int getLastResponse ( Vector & result , const ID & id ) = 0 ; Called upon to get the result quantities for the components specified in the ID id and to place them in the Vector result . This is provided for domain decomposition methods. To return \\(0\\) if successful, a negative number otherwise. The Integrator is to send information to the stream based on the integer flag .","title":"Integrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/LoadControl/","text":"LoadControl #include <analysis/integrator/LoadControl.h> class LoadControl: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadControl is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the load control method. In the load control method, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = \\delta \\lambda_n\\] where \\(\\delta \\lambda_n\\) depends on \\(\\delta \\lambda_{n-1}\\) , the load increment at the previous time step, \\(J_{n-1}\\) , the number of iterations required to achieve convergence in the previous load step, and \\(Jd\\) , the desired number of iteraions. \\(\\delta \\lambda_n\\) is bounded by \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] Knowing \\(\\lambda_n^{(i)}\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor] , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadControl}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadControl (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. \\(\\delta \\lambda_1\\) is the load factor used in the first step. The arguments \\(Jd\\) , \\(\\delta \\lambda_{min}\\) , and \\(\\delta \\lambda_{max}\\) are used in the determination of the increment in the load factor at each step. Does nothing. int newStep ( void ); The object obtains the current value of \\(\\lambda\\) from the AnalysisModel object. It increments this by \\(\\delta \\lambda_n\\) . \\[\\delta \\lambda_n = max \\left( \\delta \\lambda_{min}, min \\left( \\frac{Jd}{J_{n-1}} \\delta \\lambda_{n-1}, \\delta \\lambda_{max} \\right) \\right)\\] It will then invoke applyLoadDomain ( 0.0 , $ \\lambda $ ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. Sets the value of the load increment in newStep() to be \\(\\delta \\lambda\\) . Returns \\(0\\) . int sendSelf(int commitTag, Channel &theChannel); Places in a vector if size 5 the value of \\(\\delta \\lambda_{n-1}\\) , \\(Jd\\) , \\(J_{n-1}\\) , \\(\\delta \\lambda_{min}\\) and \\(\\delta \\lambda_{max}\\) ) and then sends the Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 5 the data that was sent in sendSelf() . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"LoadControl\n"},{"location":"developer/architecture/class_interface/analysis/integrator/LoadPath/","text":"LoadPath #include <analysis/integrator/LoadPath.h> class LoadPath: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator LoadPath is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a user specified load path. The load path is specified in a Vector, path , to the objects constructor and at each step in the analysis: \\[\\lambda_n^{(i)} - \\lambda_{n-1} = path(n) - path(n-1)\\] Knowing \\(\\lambda_n^{(i)} = path(n)\\) prior to each iteration, the \\(N+1\\) unknowns in equation [staticFormTaylor] , is reduced to \\(N\\) unknowns and results in the following equation: \\[\\R({\\bf U}_{n}) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - {\\bf K}_n^{(i)} ({\\bf U}_{n} - {\\bf U}_{n}^{(i)}) \\label{staticFormLoadPath}\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. A vector object path is created which is a copy of loadPath and an index into this vector is set to \\(0\\) . The integer INTEGRATOR_TAGS_LoadPath (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. No vector object is created. Provided for the FEM_ObjectBroker to create a blank object, recvSelf() should be invoked on this object. Invokes the destructor on the vector path . The object obtains the current value of \\(\\lambda\\) from the path vector using the current index. The index is then incremented by \\(1\\) . If the index is greater than the size of path , \\(\\lambda\\) is set to \\(0\\) and an error message is printed. It will then invoke applyLoadDomain(0.0, \\(\\lambda\\) ) on the AnalysisModel object. Returns \\(0\\) if successful. A warning message is printed and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to first increment the DOF_Group displacements with \\(\\Delta U\\) , by invoking incrDisp( \\(\\Delta U)\\) on the AnalysisModel, and then to update the domain, by invoking updateDomain() on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a \\(-1\\) is returned if no AnalysisModel is associated with the object. int sendSelf(int commitTag, Channel &theChannel); Places the size if path and the index in an ID of size 2 and send this ID. Then sends the Vector path . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the ID or the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a ID of size 2 the size of the vector and current index. Creates a new Vector and receives the Vector from the Channel. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to receive the Vector or the ID. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) .","title":"LoadPath\n"},{"location":"developer/architecture/class_interface/analysis/integrator/MinUnbalDispNorm/","text":"MinUnbalDispNorm #include <analysis/integrator/MinUnbalDispNorm.h> UNDER CONSTRUCTION. class MinUnbalDispNorm: public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator MinUnbalDispNorm is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using the minimum unbalanced displacement norm method. In this method WHAT SOME THEORY. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_MinUnbalDispNorm (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. Does nothing. int newStep ( void ); WHAT DO I DO? int update ( const Vector & $ \\ Delta U$ ); WHAT DO I DO? int sendSelf(int commitTag, Channel &theChannel); WHAT DO I DO? int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); WHAT DO I DO? int Print ( OPS_Stream & s , int flag = 0 ); WHAT DO I DO?","title":"MinUnbalDispNorm\n"},{"location":"developer/architecture/class_interface/analysis/integrator/StaticIntegrator/","text":"StaticIntegrator #include <analysis/integrator/StaticIntegrator.h> class StaticIntegrator: public Integrator MovableObject Integrator IncrementalIntegrator LoadControl ArcLength DisplacementControl StaticIntegrator is an abstract class. It is a subclass of IncrementalIntegrator provided to implement the common methods among integrator classes used in performing a static analysis on the FE_Model. The StaticIntegrator class provides an implementation of the methods to form the FE_Element and DOF_Group contributions to the tangent and residual. A pure virtual method newStep() is also defined in the interface, this is the method first called at each iteration in a static analysis, see the StaticAnalysis class. In static nonlinear finite element problems we seek a solution ( \\(\\U\\) , \\(\\lambda\\) ) to the nonlinear vector function \\[\\R(\\U, \\lambda) = \\lambda {\\bf P} - {\\bf F}_R(\\U) = \\zero \\label{staticGenForm}\\] The most widely used technique for solving the non-linear finite element equation, equation [femGenForm] , is to use an incremental scheme. In the incremental formulation, a solution to the equation is sought at successive incremental steps. \\[\\R({\\bf U}_{n}, \\lambda_n) = \\lambda_n {\\bf P} - {\\bf F}_R({\\bf U}_{n}) \\label{staticIncForm}\\] The solution of this equation is typically obtained using an iterative procedure, in which a sequence of approximations ( \\({\\bf U}_{n}^{(i)}\\) , \\(\\lambda_n^{(i)}\\) ), \\(i=1,2, ..\\) is obtained which converges to the solution ( \\({\\bf U}_n\\) , \\(\\lambda_n)\\) . The most frequently used iterative schemes, such as Newton-Raphson, modified Newton, and quasi Newton schemes, are based on a Taylor expansion of equation [staticIncForm] about ( \\({\\bf U}_{n}\\) , \\(\\lambda_n\\) ): \\[\\R({\\bf U}_{n},\\lambda_n) = \\lambda_n^{(i)} {\\bf P} - {\\bf F}_{R}\\left({\\bf U}_{n}^{(i)} \\right) - \\left[ \\begin{array}{cc} {\\bf K}_n^{(i)} & -{\\bf P} \\\\ \\end{array} \\right] \\left\\{ \\begin{array}{c} {\\bf U}_{n} - {\\bf U}_{n}^{(i)} \\\\ \\lambda_n - \\lambda_n^{(i)} \\end{array} \\right\\} \\label{staticFormTaylor}\\] which a system of of \\(N\\) equations with ( \\(N+1\\) ) unknowns. Two solve this, an additional equation is required, the constraint equation. The constraint equation used depends on the static integration scheme, of which there are a number, for example load control, arc length, and displacement control. Constructors ### Destructor // Public Methods The integer classTag is passed to the IncrementalIntegrator classes constructor. Does nothing. Provided so that the subclasses destructors will be called. To form the tangent matrix of the FE_Element, theEle , is instructed to zero this matrix and then add it\u2019s \\(K\\) matrix to the tangent, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang() The method returns \\(0\\) . virtual int formEleResidual ( FE_Element \\ * theEle ); To form the residual vector of the FE_Element, theEle , is instructed to zero the vector and then add it\u2019s \\(R\\) vector to the residual, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theEle- \\(>\\) zeroResidual() theEle- \\(>\\) addRtoResid() The method returns \\(0\\) . virtual int formNodTangent ( DOF_Group \\ * theDof ); This should never be called in a static analysis. An error message is printed if it is. Returns -1. virtual int formNodUnbalance ( DOF_Group \\ * theDof ); To form the unbalance vector of the DOF_Group, theDof , is instructed to zero the vector and then add it\u2019s \\(P\\) vector to the unbalance, i.e. it performs the following: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() theDof- \\(>\\) addPtoUnbal() The method returns \\(0\\) .","title":"StaticIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/integrator/TransientIntegrator/","text":"TransientIntegrator #include <analysis/integrator/TransientIntegrator.h> class TransientIntegrator : public Integrator MovableObject Integrator IncrementalIntegrator Newmark HHT Wilson- \\(\\Theta\\) Generalized Alpha TransientIntegrator is an abstract subclass of IncrementalIntegrator . A subclass of it is used when performing a nonlinear transient analysis of the problem using a direct integration method. The TransientIntegrator class redefines the formTangent() method of the IncrementalIntegrator class and it defines a new method newStep() which is invoked by the DirectIntegrationAnalysis class at each new time step. In nonlinear transient finite element problems we seek a solution ( \\(\\U\\) , \\(\\dot \\U\\) , \\(\\ddot \\U\\) ) to the nonlinear vector function \\[{\\bf R}({\\bf U},\\Ud, \\Udd) = {\\bf P}(t) - {\\bf F}_I(\\Udd) - {\\bf F}_R(\\U, \\Ud) = \\zero \\] {#femGenForm} The most widely used technique for solving the transient non-linear finite element equation, equation [femGenForm] , is to use an incremental direct integration scheme. In the incremental formulation, a solution to the equation is sought at successive time steps \\(\\Delta t\\) apart. \\[\\R({\\bf U}_{n \\Delta t},\\dot{\\bf U}_{n \\Delta t}, \\ddot{\\bf U}_{n \\Delta t}) = {\\bf P}(n \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{n \\Delta t}) - {\\bf F}_R({\\bf U}_{n \\Delta t}, \\dot{\\bf U}_{n \\Delta t}) \\] {#fullTimeForm} For each time step, \\(t\\) , the integration schemes provide two operators, \\(\\operatorname{I}_1\\) and \\(\\operatorname{I}_2\\) , to relate the velocity and accelerations at the time step as a function of the displacement at the time step and the response at previous time steps: \\[\\dot {\\bf U}_{t} = {\\I}_1 ({\\bf U}_t, {\\bf U}_{t-\\Delta t}, \\dot {\\bf U}_{t-\\Delta t}, \\ddot {\\bf U}_{t - \\Delta t}, {\\bf U}_{t - 2\\Delta t}, \\dot {\\bf U}_{t - 2 \\Delta t}. ..., ) \\label{I1}\\] \\[\\ddot {\\bf U}_{t} = {\\I}_2 ({\\bf U}_t, {\\bf U}_{t-\\Delta t}, \\dot {\\bf U}_{t-\\Delta t}, \\ddot {\\bf U}_{t - \\Delta t}, {\\bf U}_{t - 2\\Delta t}, \\dot {\\bf U}_{t - 2 \\Delta t}. ..., ) \\label{I2}\\] These allow us to rewrite equation [fullTimeForm] , in terms of a single response quantity, typically the displacement: \\[\\R({\\bf U}_t) = {\\bf P}(t) - {\\bf F}_I(\\ddot{\\bf U}_t) - {\\bf F}_R({\\bf U}_t, \\dot{\\bf U}_t) \\label{genForm}\\] The solution of this equation is typically obtained using an iterative procedure, i.e. making an initial prediction for \\({\\bf U}_{t}\\) , denoted \\({\\bf U}_{t}^{(0)}\\) a sequence of approximations \\({\\bf U}_{t}^{(i)}\\) , \\(i=1,2, ..\\) is obtained which converges (we hope) to the solution \\({\\bf U}_{t}\\) . The most frequently used iterative schemes, such as Newton-Raphson, modified Newton, and quasi Newton schemes, are based on a Taylor expansion of equation [genForm] about \\({\\bf U}_{t}\\) : \\[\\R({\\bf U}_{t}) = \\R({\\bf U}_{t}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial {\\bf U}_t} \\vert}_{{\\bf U}_{t}^{(i)}}\\right] \\left( {\\bf U}_{t} - {\\bf U}_{t}^{(i)} \\right)\\] \\[ \\R({\\bf U}_{t}) = {\\bf P} (t) - {\\bf F}_{I} \\left( \\ddot {\\bf U}_{t}^{(i)} \\right) - {\\bf F}_{R} \\left( \\dot {\\bf U}_{t}^{(i)}, {\\bf U}_{t}^{(i)} \\right)- \\left[ {\\bf M}^{(i)} {\\I}_2' + {\\bf C}^{(i)} {\\I}_1' + {\\bf K}^{(i)} \\right] \\left( {\\bf U}_{t} - {\\bf U}_{t}^{(i)} \\right) \\label{femGenFormTaylor}\\] To start the iteration scheme, trial values for \\({\\bf U}_{t}\\) , \\(\\dot {\\bf U}_{t}\\) and \\(\\ddot {\\bf U}_{t}\\) are required. These are obtained by assuming \\({\\bf U}_{t}^{(0)} = {\\bf U}_{t-\\Delta t}\\) . The \\(\\dot {\\bf U}_{t}^{(0)}\\) and \\(\\ddot {\\bf U}_{t}^{(0)}\\) can then be obtained from the operators for the integration scheme. Subclasses of TransientIntegrators provide methods informing the FE_Element and DOF_Group objects how to build the tangent and residual matrices and vectors. They also provide the method for updating the response quantities at the DOFs with appropriate values; these values being some function of the solution to the linear system of equations. Constructor Destructor // Public Methods The integer classTag is passed to the IncrementalIntegrator classes constructor. Does nothing. Invoked to form the structure tangent matrix. The method is rewritten for this class to include inertia effects from the nodes. The method iterates over both the FE_Elements and DOF_Groups invoking methods to form their contributions to the \\(A\\) matrix of the LinearSOE and then adding these contributions to the \\(A\\) matrix. The method performs the following: // while \u0304 while w\u0304hile \u0304 theSysOfEqn . zeroA (); DOF_EleIter & theDofs = theAnalysisModel . getDOFs (); while (( dofPtr = theDofs ()) \\ neq 0 ) dofPtr -> formTangent ( theIntegrator ); theSOE . addA ( dofPtr -> getTangent ( this ), dofPtr -> getID ()) FE_EleIter & theEles = theAnalysisModel . getFEs (); while (( elePtr = theEles ()) \\ neq 0 ) theSOE . addA ( elePtr -> getTangent ( this ), elePtr -> getID (), 1.0 ) Returns \\(0\\) if successful, otherwise a \\(-1\\) if an error occurred while trying to add the stiffness. The two loops are introduced for the FE_Elements, to allow for efficient parallel programming when the FE_Elements are associated with a ShadowSubdomain. virtual int formEleResidual ( FE_Element * theEle ); Called upon by the FE_Element theEle to determine it\u2019s contribution to the rhs of the equation. The following are invoked before \\(0\\) is returned. // while \u0304 while w\u0304hile \u0304 theEle - $ > $zeroResidual () theEle - $ > $addRIncInertiaToResid () virtual int formNodUnbalance ( DOF_Group * theDof ); Called upon by the DOF_Group theDof to determine it\u2019s contribution to the rhs of the equation. The following are invoked before \\(0\\) is returned. // while \u0304 while w\u0304hile \u0304 theDof -> zeroUnbalance () theDof -> addPIncInertiaToUnbalance () virtual int newStep ( double deltaT ) = 0 ; Invoked to inform the integrator that the transient analysis is proceeding to the next time step. To return \\(0\\) if successful, a negative number if not.","title":"TransientIntegrator\n"},{"location":"developer/architecture/class_interface/analysis/model/","text":"Analysis Model The AnalysisModel object is a container class for storing and providing access to the following types of objects: 1. ** DOF_Group ** : The ** DOF_Group ** objects represent the degrees - of - freedom at the ** Node ** s or new degrees - of - freedom introduced into the analysis to enforce the constraints . 2. [ ` FE_Element ` ]( model / fe_ele ): The ` FE_Element ` objects represent the ` Elements ` in the ` Domain ` or they are introduced to add stiffness and / or load to the system of equations in order to enforce the constraints . The ` FE_Element ` s and ` DOF_Group ` s are important to the design because : 1. They remove from the ` Node ` and ` Element ` objects the need to worry about the mapping between degrees - of - freedoms and equation numbers . 2. They also remove from the ` Node ` and ` Element ` class interfaces methods for forming tangent and residual vectors , that are used to form the system of equations . 3. The subclasses of ` FE_Element ` and ` DOF_Group ` are responsible for handling the constraints . This removes from the rest of the objects the analysis aggregation the need to deal with the constraints .","title":"Analysis Model\n"},{"location":"developer/architecture/class_interface/analysis/model/AnalysisModel/","text":"AnalysisModel MODIFY INTERFACE TO OFFER USER DEFINED STORAGE TYPE. #include \"analysis/model/AnalysisModel.h\" class AnalysisModel : public MovableObject AnalysisModel is a container class. This class is responsible for holding and providing access to the FE_Element and DOF_Group objects that the ConstraintHandler creates. It is also responsible for updating the response quantities at the DOF_Groups and for triggering methods in the associated Domain. It provides operations for the following: Population : methods so that the ConstraintHandler can add the FE_Element and DOF_Group objects to the analysis model. Access : methods so that other classes in the analysis aggregation can access the components of the AnalysisModel. Connectivity : methods such that the SysOfEqn can determine the connectivity of the DOF, which is needed for storage, sparsity, etc. Update : methods for updating the individual DOFs with the response quantities given by the AnalysisMethod. Trigger : methods which trigger events in the domain. Each subclass of AnalysisModel must have its own subclasses of FE_ELEIter and DOF_GrpIter . NOTE at the moment FE_Element and DOF_Group objects are not TaggedObjects and for this reason TaggedObjectStorage classes cannot be used for storage. This may change to allow efficient storage classes to be used. Constructors Destructor // Public Methods - Population/Depopulation // Public Member Functions - Access // Public Member Functions - Connectivity // Public Member Functions - Update // Public Member Functions - Trigger // Public Methods for Output // Protected Member Functions Constructs an empty AnalysisModel. The constructor allocates space for two arrays of 256 pointers to FE_Elements and DOF_Groups. If not enough memory is available for these arrays, an error message is printed and the program is terminated. Note these arrays grow automatically if the problem needs it. Provided for subclasses to be used. The storage of the FE_Elements and DOF_Groups and iters to access them must be provided by the subclass. Is responsible for returning to memory the arrays used for storing pointers to the FE_Element and DOF_Groups which have been added to the AnalysisModel. It is not responsible for deleting the individual DOF_Group and FE_Element objects, that is the responsibility of the ConstraintHandler. If the Graphs have been requested their destructor is invoked. Adds the FE_Element pointed to by theElement to the domain and invokes setAnalysisModel(*this) on the FE_Element. If the array for the FE_Elements is large enough, it adds this pointer to the array and increments the number of FE_Elements in the array. If the array is not large enough, a new one double in size is constructed, all the old pointers are copied to this new array and the new pointer is then added. If not enough room is available for this array, an error message is printed and the program is terminated. Returns true , otherwise false if theElement is \\(0\\) or derived class used which does not implement the method. virtual bool addDOF_Group ( DOF_Group \\ * theGroup ); Adds the DOF_Group pointed to by theGroup to the domain. If the array for the DOF_Groups is large enough, it adds this pointer to the array and increments the number of DOF_Groups in the array. If the array is not large enough, a new one double in size is constructed, all the old pointers are copied to this new array and the new pointer is then added. If not enough room is available for this array, an error message is printed and the program is terminated. Returns true , otherwise false if theGroup is \\(0\\) or derived class used which does not implement the method. virtual void clearAll ( void ); Clears from the model all FE_Element and DOF_Group objects that have been added to the analysis model using the above two methods. It does this by setting the components in the two arrays of pointers equal to \\(0\\) and setting the number of components to \\(0\\) . If the Graphs have been created their destructor is invoked. Also sets numEqn to \\(0\\) . Returns the number of DOF_Group objects that have been added to the model. Returns a pointer to the DOF_Group object whose tag is given by tag . It first checks to see if the DOF_Group object is at the location in the array given by tag ; if not it searches through the array to find the DOF_Group object. Returns a pointer to the object if found, otherwise \\(0\\) is returned. Returns an FE_EleIter for the FE_Elements of the model. virtual ` DOF_Group ` getDOFs ( void ) = 0 ; Returns a DOF_GrpIter for the DOF_Groups of the model. Sets the value of the number of equations in the model. Invoked by the DOF_Numberer when it is numbering the dofs. Returns the number of DOFs in the model which have been assigned an equation number. Returns the value passed in setNumEqn() , if setNumEqn() was not invoked \\(0\\) is returned. virtual const Graph & getDOFGraph ( void ); Returns the DOF connectivity graph for the individual dofs in the model. This graph is used by the system of equation object to determine its size. If no graph has yet been constructed it creates a new DOF_Graph object using itself as the argument, otherwise it returns a pointer to this graph. THIS WILL CHANGE WHEN I REMOVE DOF_Graph CLASS - will go through and construct the Graph. virtual const Graph & getDOFGroupGraph ( void ); Returns the connectivity of the DOF_Group objects in the model. This graph is used by the DOF_Numberer to assign equation numbers to the dofs. If no graph has yet been constructed it creates a new DOF_GroupGraph object using itself as the argument, otherwise it returns a pointer to this graph. AGAIN WILL CHANGE. The model is responsible for invoking setDisp(disp) , setVel(vel) and setAccel(accel) on each DOF_Group in the model. It does this by iterating over the DOF_Group objects using the iter. virtual void setDisp ( const const Vector & disp ); The model is responsible for invoking setDisp(disp) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeDisp(disp) on each DOF_Group. virtual void setVel ( const const Vector & vel ); The model is responsible for invoking setVel(vel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeVel(vel) on each DOF_Group. virtual void setAccel ( const const Vector & accel ); The model is responsible for invoking setAccel(accel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking setNodeAccel(accel) on each DOF_Group. virtual void incrDisp ( const const Vector & disp ); The model is responsible for invoking incrNodeDisp(disp) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeDisp(disp) on each DOF_Group. virtual void incrVel ( const const Vector & vel ); The model is responsible for invoking incrNodeVel(vel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeVel(vel) on each DOF_Group. virtual void incrAccel ( const const Vector & accel ); The model is responsible for invoking incrNodeAccel(accel) on each DOF_Group in the model. It does this by getting an iter to the DOF_Group objects and iterating through them invoking incrNodeAccel(accel) on each DOF_Group. Method to set the link to the associated Domain. Invoked by during the construction of the Analysis object. virtual void applyLoadDomain(double timeStep = 0.0, double loadFactor = 1.0); Method which invokes applyLoad ( timeStep , loadFactor ) on the domain. This method causes the domain ask the loads in the currently set to apply themselves. If no Domain has been set nothing is done and an error message is printed. virtual int commitDomain ( void ); Method which invokes commit() on the domain: this is an operation which causes all nodes in the domain to take the current values of response quantities and copy them into the accepted values. Returns \\(0\\) if successful , a negative number if not: \\(-1\\) if no Domain has been set and \\(-2\\) if commit() fails on the Domain. virtual int revertDomainToLastCommit ( void ); Method which invokes revertToLastCommit() on the domain: this is an operation which causes all nodes in the domain to set the trial response quantities equal to the last committed response quantities. Returns \\(0\\) if successful , a negative number if not: \\(-1\\) if no Domain has been set and \\(-2\\) if revertToLastCommit () fails on the Domain. virtual void updateDomain ( void ); Method which invokes update() on the domain. If no Domain has been set nothing is done and an error message is printed. To get the current time in the Domain. If no Domain has been set a warning message is printed and \\(0.0\\) is returned, otherwise the result of invoking getCurrentTime() on the Domain is returned. To set the current time in the Domain to be newTime . If no Domain has been set a warning message is printed, otherwise setCurrentTime(newTime) is invoked on the Domain. To get the current load factor in the Domain. If no Domain has been set a warning message is printed and \\(0.0\\) is returned, otherwise the result of invoking getCurrentLoadFactor() on the Domain is returned. ; To set the current load factor in the Domain to be newFactor . If no Domain has been set a warning message is printed, otherwise setCurrentLoadFactor(newFactor) is invoked on the Domain. Returns \\(0\\) . Note the FE_Elements and DOF_Group objects are not sent as they are not MovableObjects. AnalysisModel objects are only sent when setting up a DomainDecompAnalysis on a remote process; only type info and whatever subclasses might need need to be sent. ; Returns \\(0\\) . Returns a pointer to the associated Domain, that is the Domain set when setLinks() was last invoked.","title":"AnalysisModel\n"},{"location":"developer/architecture/class_interface/analysis/model/dof_grp/DOF_Group/","text":"NEED A GETTANGFORCE() LIKE FE_Element FOR ELE_BY_ELE SOLVERS. KEEP A POINTER TO LAST INTEGRATOR. DOF_Group #include <analysis/dof_grp/DOF_Group.h> class DOF_Group; DOF_Group is a base class. An object of type DOF_Group represents an unconstrained node of the domain in the model. Each node in the domain is associated with one DOF_Group. DOF_Groups are called upon in the analysis to provide their contributions of unbalanced load to the system of equations. Subclasses are used by the constraint handler to to introduce new dofs into the analysis. The DOF_Group is responsible for providing operations to set and access the mapping betwwen equation numbers and DOFs, allowing the Integrator to from the tangent (if nodal masses in transient problem) and unbalanced load information, and for setting and obtaining the nodal trial response quantities. Constructors Destructor // Public Methods - Mapping // Public Methods - Tangent & Residual // Public Methods - Node Response Constructs a DOF_Group with an associated node given by theNode and a tag given by tag . During construction it determines the number of unknown dofs from the node, numDOF , and creates an Vector object to hold the unbalance information and an ID object to hold mapping between degrees-of-freedom and equation numbers. All values of the ID are set to \\(-2\\) initially. It creates a Vector to hold the unbalance loads and an ID to hold the mapping information, both of size equal to the number of unknowns. If the size of the Vector or the ID is \\(0\\) , i.e. ran out of memory, a warning message is orinted and numDOF set to \\(0\\) . DOF_Group ( int tag , int numDOF ); Provided for subclasses. Constructs a DOF_Group with the number of unknown dofs given by numDOF and a tag given by tag . No Node is associated with this DOF_Group. Creates a Vector of size numDOF to hold the unbalance information and an ID object to hold mapping between degrees-of-freedom and equation numbers. All values of the ID are set to \\(-2\\) initially. If the size of the Vector or the ID is \\(0\\) , i.e. ran out of memory, a warning message is orinted and numDOF set to \\(0\\) . Invokes the destructor on the Vector created to hold the unbalance. Operation to set the equation number of the dof\u2019th DOF in the DOF_Group to value . In this base class, if index is a valid location, \\(0 < index < numDOF-1\\) the operator (index) = value is invoked on the ID object created for the mapping, otherwise an error message is printed. virtual void setID ( const ID & values ); An operation to set the equation numbers of all the DOFs in the DOF_Group to be those given in the ID values . In this base class, the operator = values is invoked on the ID object created for the mapping. virtual const ID & getID ( void ) const ; A const member function which returns in an ID object the equation numbers associated with the degrees-of-freedom in the DOF_Group. The size of the ID object is equal to the number of degrees-of-freedom represented by the DOF_Group. This base class returns the ID created for the mapping. virtual int getTag ( void ) const ; A const member function which returns the integer identifier tag passed in the constructor. virtual int getNumDOF ( void ) const ; Returns the total number of DOFs in the DOF_Group. This base class returns numDOF . virtual int getNumFreeDOF ( void ) const ; Returns the total number of free DOFs in the DOF_Group, i.e. number of dof in the group who have not been assigned a negative equation number. Determines this by looping through the ID containing the mapping information. virtual int getNumConstrainedDOF ( void ) const ; Returns the total number of constrained DOFs in the DOF_Group, i.e. number of dof in the group who have been assigned a negative equation number. Determines this by looping through the ID containing the mapping information. Returns the current tangent matrix for the DOF_Group. If no tangent matrix has been created, one of size(numDOF,numDOF) is constructed. If not enough space is available for a new tangent matrix, an error message is printed and an error Matrix is returned.. To form the DOF_Groups tangent. Invokes formNodTangent(this) on The Integrator object theIntegrator . To zero the tangent. If a tangent matrix has been allocated, will invoke Zero() on the tangent matrix. To add fact times the nodal mass matrix to the tangent matrix. In this base class, if a Matrix to store the tangent has not yet been created, one of size (numDOF,numDOF) is now created; if construction of this matrix fails an error is printed and an error Matrix is returned. Invokes addMatrix ( theNode - $ > $ getMass , fact ) on the Matrix, printing a warining message if this method returns a \\(negative\\) value. If no Node is associated with the DOF_Group an error message is printed and nothing is done. To zero the unbalance vector. Invokes Zero() on the vector object used to store the unbalance information. virtual void formUnbalance(Integrator *theIntegrator); Causes the DOF_Group to form its contribution to the residual. Invokes formNodUnbalance(this) on theIntegrator . virtual const Vector &getUnbalance() const; Returns the vector holding the unbalance. virtual void addPtoUnbalance ( double fact = 1.0 ); Adds the product of the unbalanced load at the node and fact to the unbalance vector. A warning message is printed and nothing is done if no node is associated with the DOF_Group, otherwise addVector(theNode- \\(>\\) getUnbalancedLoad(),fact) is invoked on the unbalance vector and a warning message is printed if this method returns a negative value. virtual void addMtoTang ( const Vector & $ \\ ddot u$ , double fact ); Adds fact times the product of the associated nodes mass matrix and the Vector \\(\\ddot u\\) to the unbalance vector. A warning message is printed and nothing is done if no node is associated with the DOF_Group. To return the committed displacement at the node. Returns the result of invoking getDisp() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. To return the committed velocity at the node. Returns the result of invoking getVel() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. To return the committed velocity at the node. Returns result of invoking getAccel() on the Node. If there is no associated node object, an error message is printed and an error Vector is returned. This operation sets the value of the nodal trial displacement at the associated node. The vector u is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector u using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal displacement for the node. Creates a Vector to store the correct components of u , then invokes setTrialDisp() on the node object; if no node object an error message is printed. CURRENTLY THERE IS NO CHECK TO SEE IF myID(i) DOES NOT OVERFLOW ADMISSIBLE VALUES IN U - THIS NEEDS TO CHANGE virtual int setNodeVel ( const Vector & $u ^ {.} $ ); This operation sets the value of the nodal trial velocity at the associated node. The vector \\(u^{.}\\) is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector \\(u^{.}\\) using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal velocity for the node. Creates a Vector to store the correct components of u , then invokes setTrialVel() on the node object; if no node object an error message is printed. MUST CHANGE AS setNodeDisp virtual int setNodeAccel ( const Vector & $u ^ {..} $ ); This operation sets the value of the nodal trial acceleration at the associated node. The vector \\(u^{..}\\) is of size equal to the number of equations in the AnalysisModel (this is not checked by the DOF_Group). The DOF_Group object accesses the contents of the Vector \\(u^{..}\\) using its assigned equation numbers. If a \\(-1\\) exists for a DOF a \\(0\\) value is set as the corresponding nodal acceleration for the node. The return value is as outlined above for setNodeAccel(). Creates a Vector to store the correct components of u , then invokes setTrialAccel() on the node object; if no node object an error message is printed. MUST CHANGE AS setNodeDisp These methods are similar to those three just outlined, the only difference being that the trial response quantities at the nodes are incremented, not set, with the values now given; this is done by invoking incrTrialDisp() , incrTrialVel() , and incrTrialAccel() respectively on the nodes. MUST ALL CHANGE AS setNodeDisp","title":"`DOF_Group`\n"},{"location":"developer/architecture/class_interface/analysis/model/dof_grp/TransformationDOF_Group/","text":"TransformationDOF_Group #include <analysis/dof_grp/TransformationDOF_Group.h> UNDER CONSTRUCTION. class TransformationDOF_Group: public DOF_Group; DOF_Group TransformationDOF_Group is a subclass of DOF_Group. This object stores the transformation matrix \\(\\T\\) used by the TransformationFE objects when a node has been constrained with an MP or SP_Constraint. Constructors Destructor // Public Methods - dealing with the ID and Transformation matrix // Public Methods - Tangent & Residual // Public Methods - update trial response quantities","title":"TransformationDOF_Group\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/FE_Element/","text":"FE_Element #include <analysis/fe_ele/FE_Element.h> class FE_Element ; FE_Element is a base class, subtypes of which are used to enforce the constraints on the domain. An object of type FE_Element represents an element of the domain in the analysis. It enforces no constraints other than single point homogeneous boundary conditions, imposed on any of the elements nodes. It provides a similar interface to that of an Element but modified to provide features useful to an Analysis class. The FE_Element is responsible for: Holding information about the mapping between equation numbers and the degrees-of-freedom at the element ends, this mapping is determined from the DOF_Group objects associated with the elements Node objects. Providing methods to allow the integrator to combine the elements stiffness, mass and damping matrices into the elements contribution to the structure tangent matrix and the elements resisting force to the structure unbalance. Obtaining the stiffness, damping and mass matrices from the elements. Providing methods so other forces can be determined. While the FE_Element class is associated with an element in the domain, subclasses do not have to be. It is the subclasses that are used to implement the constraints imposed on the nodal displacements in the domain. // Constructors // Destructor // Public Methods - Mapping // Public Methods to form and obtain Tangent & Residual // Public Methods to allow Integrator to Build Tangent // Public Methods to allow Integrator to Build Residual // Public Methods to allow Element-by-Element strategies // Public Methods added for Domain Decomposition Constructs an empty FE_Element with an associated element given by theElement . During construction it determines the number of unknown dofs from the element. Constructs an ID for the mapping between dof\u2019s of the element and equation numbers in the system of equation and an ID to hold the tag of the DOF_Group objects associated with each Node of the element. If the result of invoking theElementPtr->isSubdomain() is true invokes setFE_Element(this) on the Subdomain; if false creates a Matrix for the tangent and a Vector for the residual to be stored. An error message is printed and the program is terminated if no Domain object is associated with the Element, a Node of the Element does not exist in the Domain, each Node has not yet been associated with a DOF_Group object, or there is not enough memory for the Vectors and Matrices required. FE_Element ( int numDOFGroup , int numDOF ); Provided for subclasses. Constructs an empty FE_Element with the number of unknown dofs given by numDOF and the number of associated DOF_Group objects given by numDOFGroup , two empty IDs are constructed to hold the mapping and the tags of the DOF_Groups. The subclass must fill in the ID for the tags of the DOF_Groups in order that setID() will work. No element is associated with this FE_Element. No space is allocated for the tangent and residual matrix and vector, this is the responsibility of the subclass. ~ FE_Element (); Deletes the IDs, Vectors and Matrices created by the constructor. Returns a const ID containing the unique tag number of the DOF_Group objects associated with that FE_Element. For this base class, these are obtained from the DOF_Groups associated with the Node objects that are associated with the Element object passed in the constructor. This ID is computed only once, during the creation of the object. virtual const ID & getID ( void ) const ; Returns a const ID containing the equation numbers associated with its matrices and vectors. This ID will contain \\(0\\) \u2019s unless the setID() method has been called. void setAnalysisModel ( AnalysisModel & theModel ); To set a link to the AnalysisModel in which the FE_Element resides; this link is needed in setID() . Is invoked by the AnalysisModel when the FE_element is added to the AnalysisModel. virtual void setID ( void ); Causes the FE_Element to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. The \\(i-1\\) component of the ID contains the equation number that is associated with \\(i\\) \u2019th degree-of-freedom (a consequence of C indexing for IDs). The method is to be invoked by the DOF_Numberer after the DOF_Groups have been assigned their equation numbers. The base class uses the ID containing the tags of the DOF_Group objects to determine this by looping over the DOF_Group objects (identified in the DOF_Group ID and obtained from the AnalysisModel) and getting their mapping by invoking getID() . Returns \\(0\\) if successful, a warning message and a negative number is returned if an error occurs: \\(-1\\) returned if no AnalysisModel link has been set, \\(-2\\) if a DOF_Group object does not exist in the AnalysisModel and a \\(-3\\) if there are more dof\u2019s in the DOF_Groups than dof\u2019s identified for the FE_Element. Causes the FE_Element to determine it\u2019s contribution to the tangent matrix and to return this matrix. If the Element is a Subdomain it invokes computeTangent() and getTang() on the Subdomain. Otherwise formEleTangent(this) is invoked on theIntegrator and the new tangent matrix is returned. Subclasses must provide their own implementation. If no Element is passed in the constructor, a warning message is printed and an error Matrix of size 1X1 is returned. Causes the FE_Element to determine it\u2019s contribution to the residual vector and to return this vector. If the Element is a Subdomain it invokes computeResidual() and getResistingForce() on the Subdomain. Otherwise formEleResidual(this) is invoked on theIntegrator and the resuting residual vector is returned. Subclasses must provide their own implementation. If no Element is passed in the constructor, a warning message and an error vector is returned. Zeros the tangent matrix. If the Element is not a Subdomain invokes Zero() on the tangent matrix. Subclasses must provide their own implementation. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKtToTang(double fact = 1.0); Adds the product of fact times the element\u2019s tangent stiffness matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getTangentStiff(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKsToTang(double fact = 1.0); Adds the product of fact times the element\u2019s secant stiffness matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getSecantStiff(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addCtoTang(double fact = 1.0); Adds the product of fact times the element\u2019s damping matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getDamp(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addMtoTang(double fact = 1.0); Adds the product of fact times the element\u2019s mass matrix to the tangent. If no element is associated with the FE_Element nothing is added, if the element is not a Subdomain addMatrix(theEle- \\(>\\) getMass(),fact is invoked on the tangent matrix. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. Zeros the residual vector. If the Element is not a Subdomain invokes Zero() on the residual vector. Subclasses must provide their own implementation. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addRtoResidual(double fact = 1.0); Adds to the residual vector the product of the elements residual load vector and fact . If no element is associated with the FE_Element nothing is added, if the associated element is not a Subdomain addVector(myEle- \\(>\\) getResistingForce(),fact) is invoked on the residual. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addRIncInertiaToResidual(double fact = 1.0); Adds to the residual vector the product of the elements residual load vector with inertia forces included and fact . If no element is associated with the FE_Element nothing is added, if the associated element is not a Subdomain addVector(myEle- \\(>\\) getResistingForceIncInertia(),fact) is invoked on the residual. Nothing is done and a warning message is printed if no Element was passed in the constructor or the Element passed was a Subdomain. virtual void addKtForce(const Vector &disp, double fact = 1.0); Adds to the residual the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addKsForce(const Vector &disp, double fact = 1.0); Adds to the residual the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addD_Force(const Vector &vel, double fcat = 1.0); Adds to the residual the product of elements current damping matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector vel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual void addM_Force(const Vector &accel, double fact = 1.0); Adds to the residual the product of elements current mass matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector accel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the Element is a Subdomain nothing is added and an warning message is printed. An error message is also printed if invoking addMatrixVector() on the residual vector returns \\(< 0\\) . virtual const Vector &getTangForce(const Vector &disp, double fact=1.0); Returns the product of FE_Elements current tangent matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If the element associated with the FE_Element is a subdomain, the tangent is obtained by invoking getTang() on the subdomain, otherwise the tangent is formed by invoking formEleTang(this) on the integrator object last used in a getTangent() or getResidual() . If no element is associated with the FE_Element a zero vector is returned and an error message is printed. An error message is also printed if invoking addMatrixVector() on the force vector returns \\(< 0\\) . virtual const Vector &getKtForce(const Vector &disp, double fact=1.0); Returns the product of elements current tangent stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain an error vector is returned and a warning message printed. virtual const Vector &getKsForce(const Vector &disp, double fact = 1.0); Returns the product of elements current secant stiffness matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector disp associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain an error vector is returned and a warning message printed. virtual const Vector & getD_Force ( const Vector & vel , double fact = 1.0 ); Returns the product of elements current damping matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector vel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain a warning message is printed and an error Vector is returned. virtual const Vector & getM_Force ( const Vector & accel , double fcat = 1.0 ); Returns the product of elements current mass matrix and a Vector whose values are obtained by taking the product of fact and those elements of the Vector accel associated with the FE_Elements equation numbers. If no element is associated with the FE_Element or the associated element is a Subdomain a warning message is printed and an error Vector is returned. Integrator * getLastIntegrator ( void ); Method which returns the last integrator supplied in a formTangent() or a formResidual() invocation. const Vector & getLastResponse ( void ); A method which invokes getLastResponse() on the Integrator object that was last passed as an argument to any of the routines. The FE_Element s ID and the force Vector object is passed as arguments. Returns the force Vector object if successful. If no element is associated with the FE_Element or no integrator has yet to be passed, a warning message is printed and an error Vector is returned.","title":"FE_Element\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/lagrange/LagrangeMP_FE/","text":"LagrangeMP_FE #include <analysis/fe_ele/lagrange/LagrangeMP_FE.h> class LagrangeMP_FE : public ` FE_Element ` ; LagrangeMP_FE is a subclass of FE_Element used to enforce a multi point constraint, of the form \\({\\bf U}_c = {\\bf C}_{cr} {\\bf U}_r\\) , where \\({\\bf U}_c\\) are the constrained degrees-of-freedom at the constrained node, \\({\\bf U}_r\\) are the retained degrees-of-freedom at the retained node and \\({\\bf C}_{cr}\\) a matrix defining the relationship between these degrees-of-freedom. To enforce the constraint the following are added to the tangent and the residual: \\[\\left[ \\begin{array}{cc} 0 & \\alpha{\\bf C}^t \\\\ \\alpha{\\bf C} & 0 \\end{array} \\right] , \\left\\{ \\begin{array}{c} 0 \\\\ 0 \\end{array} \\right\\}\\] at the locations corresponding to the constrained degree-of-freedoms specified by the MP_Constraint, i.e. \\([{\\bf U}_c\\) \\({\\bf U}_r]\\) , and the lagrange multiplier degrees-of-freedom introduced by the LagrangeConstraintHandler for this constraint, \\({\\bf C} = [-\\I\\) \\({\\bf C}_{cr}]\\) . Nothing is added to the residual. Constructor Destructor // Public Methods To construct a LagrangeMP_FE element to enforce the constraint specified by the MP_Constraint theMP using a default value for \\(\\alpha\\) of \\(alpha\\) . The FE_Element class constructor is called with the integers \\(3\\) and the two times the size of the retainedID plus the size of the constrainedID at the MP_Constraint theMP plus . A Matrix and a Vector object are created for adding the contributions to the tangent and the residual. The residual is zeroed. If the MP_Constraint is not time varying, then the contribution to the tangent is determined. Links are set to the retained and constrained nodes. The DOF_Group tag ID is set using the tag of the constrained Nodes DOF_Group, the tag of the retained Node DOF_Group and the tag of the LagrangeDOF_Group, theGroup . A warning message is printed and the program is terminated if either not enough memory is available for the Matrices and Vector or the constrained and retained Nodes of their DOF_Groups do not exist. Invokes delete on any Matrix or Vector objects created in the constructor that have not yet been destroyed. Causes the LagrangeMP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. This information is obtained by using the mapping information at the DOF_Group objects associated with the constrained and retained nodes and the LagrangeDOF_Group, theGroup . Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node (sets corresponding ID component to \\(-1\\) so nothing is added to the tangent) and \\(-4\\) if the ID in the DOF_Group is too small for the Node (again setting corresponding ID component to \\(-1\\) ). If the MP_Constraint is time-varying, from the MP_Constraint theMP it obtains the current \\(C_{cr}\\) matrix; it then adds the contribution to the tangent matrix. Returns this tangent Matrix. Returns the residual, a \\(\\zero\\) Vector. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); CURRENTLY just returns the \\(0\\) residual. THIS WILL NEED TO CHANGE FOR ELE-BY-ELE SOLVERS.","title":"LagrangeMP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/lagrange/LagrangeSP_FE/","text":"LagrangeSP_FE #include <analysis/fe_ele/lagrange/LagrangeSP_FE.h> class LagrangeSP_FE : public FE_Element LagrangeSP_FE is a subclass of FE_Element used to enforce a single point constraint. It does this by adding to the tangent and the residual: \\[\\left[ \\begin{array}{cc} 0 & \\alpha \\\\ \\alpha & 0 \\end{array} \\right] , \\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] at the locations corresponding to the constrained degree-of-freedom specified by the SP_Constraint and the lagrange multiplier degree-of-freedom introduced by the LagrangeConstraintHandler for this constraint, where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to the constraint. Constructor ### Destructor // Public Methods To construct a LagrangeSP_FE element to enforce the constraint specified by the SP_Constraint theSP using a value for \\(\\alpha\\) of alpha (which, if none is specified, defaults to \\(1.0\\) ). The FE_Element class constructor is called with the integers \\(2\\) and \\(2\\) . A Matrix and a Vector object of order \\(2\\) are created to return the tangent and residual contributions, with the tangent entries (0,1) and (1,0) set at \\(\\alpha\\) . A link to the Node in the Domain corresponding to the SP_Constraint is also set. A warning message is printed and program terminates if there is not enough memory or no Node associated with the SP_Constraint exists in the Domain, or DOF_Group is associated with the Node. Invokes the destructor on the Matrix and Vector objects created in the constructor. Causes the LagrangeSP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. From the Node object link, created in the constructor, the DOF_Group corresponding to the Node associated with the constraint is determined. From this DOF_Group object the mapping for the constrained degree of freedom is determined and the myID(0) in the base class is set. The myID(1) is determined from the Lagrange DOF_Group theGroup passed in the constructor. Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node and \\(-4\\) if the ID in the DOF_Group is too small for the Node. Returns the tangent Matrix created in the constructor. Sets the FE_Elements contribution to the residual: \\[\\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid. Returns this residual Vector. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); Sets the FE_Elements contribution to the residual: \\[\\left\\{ \\begin{array}{c} 0 \\\\ \\alpha(u_s - u_t) \\end{array} \\right\\}\\] where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement in disp corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid.","title":"LagrangeSP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/penalty/PenaltyMP_FE/","text":"PenaltyMP_FE #include <analysis/fe_ele/penalty/PenaltyMP_FE.h> class PenaltyMP_FE : public ` FE_Element ` ; PenaltyMP_FE is a subclass of FE_Element used to enforce a multi point constraint, of the form \\({\\bf U}_c = {\\bf C}_{cr} {\\bf U}_r\\) , where \\({\\bf U}_c\\) are the constrained degrees-of-freedom at the constrained node, \\({\\bf U}_r\\) are the retained degrees-of-freedom at the retained node and \\({\\bf C}_{cr}\\) a matrix defining the relationship between these degrees-of-freedom. To enforce the constraint a matrix \\(\\alpha {\\bf C}^T \\C\\) is added to the tangent for the degrees-of-freedom \\([{\\bf U}_c\\) \\({\\bf U}_r]\\) , where \\({\\bf C} = [-\\I\\) \\({\\bf C}_{cr}]\\) . Nothing is added to the residual. Constructor ### Destructor // Public Methods To construct a PenaltyMP_FE element to enforce the constraint specified by the MP_Constraint theMP using a default value for \\(\\alpha\\) of \\(alpha\\) . The FE_Element class constructor is called with the integers \\(2\\) and the size of the retainedID plus the size of the constrainedID at the MP_Constraint theMP . A Matrix and a Vector object are created for adding the contributions to the tangent and the residual. The residual is zeroed. A Matrix is created to store the \\(C\\) Matrix. If the MP_Constraint is not time varying, the components of this Matrix are determined, then the contribution to the tangent \\(\\alpha C^TC\\) is determined and finally the \\(C\\) matrix is destroyed. Links are set to the retained and constrained nodes. A warning message is printed and the program is terminated if either not enough memory is available for the Matrices and Vector or the constrained and retained Nodes do not exist in the Domain. Invokes delete on any Matrix or Vector objects created in the constructor that have not yet been destroyed. Causes the PenaltyMP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. This information is obtained by using the mapping information at the DOF_Group objects associated with the constrained and retained nodes to determine the mappings between the degrees-of-freedom identified in the constrainedID and the retainedID at the MP_Constraint theMP . Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group, \\(-3\\) if the constrained DOF specified is invalid for this Node (sets corresponding ID component to \\(-1\\) so nothing is added to the tangent) and \\(-4\\) if the ID in the DOF_Group is too small for the Node (again setting corresponding ID component to \\(-1\\) ). If the MP_Constraint is time-varying, from the MP_Constraint theMP it obtains the current \\(C_{cr}\\) matrix; it then forms the \\(C\\) matrix and finally it sets the tangent matrix to be \\(\\alpha C^TC\\) . Returns the tangent matrix. Returns the residual, a \\(\\zero\\) Vector. virtual const Vector &getTangForce(const Vector &disp, double fact = 1.0); CURRENTLY just returns the \\(0\\) residual. THIS WILL NEED TO CHANGE FOR ELE-BY-ELE SOLVERS.","title":"PenaltyMP_FE\n"},{"location":"developer/architecture/class_interface/analysis/model/fe_ele/penalty/PenaltySP_FE/","text":"PenaltySP_FE #include <analysis/fe_ele/penalty/PenaltySP_FE.h> class PenaltySP_FE : public FE_Element ; PenaltySP_FE is a subclass of FE_Element used to enforce a single point constraint. It does this by adding \\(\\alpha\\) to the tangent and \\(\\alpha * (U\\_s - U\\_t)\\) to the residual at the locations corresponding to the constrained degree-of-freedom specified by the SP_Constraint , where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to the constraint. Constructor Destructor // Public Methods To construct a PenaltySP_FE element to enforce the constraint specified by the SP_Constraint theSP using a value for \\(\\alpha\\) of alpha (which, if none is specified, defaults to \\(1.0e8\\) ). The FE_Element class constructor is called with the integers \\(1\\) and \\(1\\) . A Matrix and a Vector object of order \\(1\\) are created to return the tangent and residual contributions, with the tangent entry being set at \\(\\alpha\\) . A link to the Node in the Domain corresponding to the SP_Constraint is also set. A warning message is printed and program terminates if there is not enough memory or no Node associated with the SP_Constraint exists in the Domain. Invokes the destructor on the Matrix and Vector objects created in the constructor. Causes the PenaltySP_FE to determine the mapping between it\u2019s equation numbers and the degrees-of-freedom. From the Node object link, created in the constructor, the DOF_group corresponding to the Node associated with the constraint is determined. From this DOF_Group object the mapping for the constrained degree of freedom is determined and the ID in the base class is set. Returns \\(0\\) if successful. Prints a warning message and returns a negative number if an error occurs: \\(-2\\) if the Node has no associated DOF_Group , \\(-3\\) if the constrained DOF specified is invalid for this Node and \\(-4\\) if the ID in the DOF_Group is too small for the Node. Returns the tangent Matrix created in the constructor. Sets the FE_Elements contribution to the residual to be \\(\\alpha * (U_s - U_t)\\) , where \\(U_s\\) is the specified value of the constraint and \\(U_t\\) the current trial displacement at the node corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the specified constrained degree-of-freedom is invalid. Returns this residual Vector set. virtual const Vector & getTangForce ( const Vector & disp , double fact = 1.0 ); Sets the FE_Elements contribution to the residual to be \\(\\alpha * (U\\_s - disp\\_t)\\) , where \\(U\\_s\\) is the specified value of the constraint and \\(disp\\_t\\) the value in disp corresponding to constrained degree-of-freedom. Prints a warning message and sets this contribution to \\(0\\) if the mapping, determined in setID() , for the the specified constrained degree-of-freedom lies outside disp .","title":"PenaltySP_FE\n"},{"location":"developer/architecture/class_interface/database/","text":"Data Storage In this work there are two general types of data storage classes provided: Classes which can be used to store and provide access to the TaggedObjects during program execution. The abstract base class for these classes is TaggedObjectStorage . The concrete subclasses can implement the interface using the traditional CS data storage techniques, such as arrays, linked lists, hash tables, etc.. Classes which can be used to store and retrieve information from permanent data archives, i.e. databases. The abstract base class defining the interface for these classes is FE_Datastore .","title":"Data Storage\n"},{"location":"developer/architecture/class_interface/database/FE_Datastore/","text":"FE_Datastore #include <database/FE_Datastore.h> class FE_Datastore: public ModelBuilder, public Channel ModelBuilder Channel FE_Datastore is an abstract class. An FE_Datastore object is used in the program to store/restore the geometry and state information in the domain at particular instances. How, where and how the data is stored depends on the implementation provided by the concrete subclasses. // Constructor // Destructor // Public Methods // Protected Methods The Domain object theDomain is passed to the ModelBuilder constructor. A pointer is kept to theBroker object. Does nothing. To return a unique integer identifier at each call. This identifier will be used by the objects to store/retrieve their information to/from the database. Invoked to store the current state of the domain in the database. The integer commitTag is used to identify the state for subsequent calls to restore the information from the database. To return \\(0\\) if successful, a negative number if not. In the implementation for the FE_Datastore class, the object first invokes validateBaseRelationsWrite() on itself. If this method returns \\(0\\) , the object then loops over all the components of the Domain object invoking sendSelf ( commitTag , this ) on each of these objects. Returns \\(0\\) if successful, a negative number if not. For each domain component that could not send itself a warning message is printed. Invoked to restore the state of the domain from a database. The state of the domain at the end of this call is to be the same as the state of the domain when commitState(commitTag) was invoked. To return \\(0\\) if successful, a negative number if not. In the implementation for the FE_Datastore class, the object first invokes validateBaseRelationsRead() on itself. If this method returns \\(0\\) , the object then loops over all the components of the Domain object invoking recvSelf ( commitTag , this ) on each of these objects. Returns \\(0\\) if successful, a negative number if not. For each domain component that could not send itself a warning message is printed. This method is invoked before the information can be sent to the database. It is required to ensure that: Each Node, Element, SP_Constraint , MP_Constraint , NodalLoad and ElementalLoad which is to save information in the database has a database tag. That the information in the base tables is up to date so that a later call to validateBaseRelationsRead(commitTag) will be successful. To return \\(0\\) if the base relations are up to date, to return \\(1\\) if they are up to date and the component data has been sent to the database, and a negative number if the method fails. This method is invoked before the information can be extracted from the database. It is required to ensure that the Domain has the same type of DomainComponent objects and that each of these has the same database tag as when validateBaseRealationsWrie(commitTag) was invoked. To return \\(0\\) if the base relations are up to date, to return \\(1\\) if they are up to date and the component data has been received from the database, and a negative number if the method fails. Returns a pointer to theBroker object passed in the constructor.","title":"FE_Datastore\n"},{"location":"developer/architecture/class_interface/database/FileDatastore/","text":"FileDatastore #include <database/FileDatastore.h> class FileDatastore: public FE_Datastore ModelBuilder Channel FE_Datastore FileDatastore is a concrete class. An FileDatastore object is used in the program to store/restore the geometry and state information in the domain at particular instances. This information is stored in binary form in files. As no standard format is used for the storage of integers and double values, files used to store the data on one type of machine, may not be read by a FileDatastore object on another type of machine where the storage of integers and doubles is different. For each of the base relations, i.e. Domain, Nodes, Elements, SP_Constraints, MP_Constraints, NodalLoads and ElementalLoads, a separate file is used to store the information. Files are also used for each size of ID, Vector and Matrix stored. At present, Messages are not stored, only ID and Vector objects of size \\(<= 200\\) can be stored, the max \\(noRows * noCols\\) of Matrices that can be stored is \\(<= 2000\\) , and only a single relation is created for Matrices which have similar sizes but differing dimensions. The data is stored in the files following the schema outlined previously. // Constructor // Destructor // Public Methods inherited from the ModelBuilder Class // Public Methods inherited from the FE_Datastore Class // Public Methods inherited from the Channel Class Opens the files for the domain and base component relations, files have names name.relation , and stores the end of file locations. Creates three arrays of file pointers for the ID, Vector and Matrix files and then zeros these arrays. If the files could not be opened, or there is not enough memory for the arrays an error message is printed and the program is terminated. Each file that is opened is closed and the arrays of file pointers obtained from the heap in the constructor are returned to the heap. To build the finite element model from data in the database. It does this by invoking restor ( 0 ) on itself. Increments the integer containing the current dbTag and returns this integer. The object first checks to see if the Domain has already been committed to the database with a similar commitTag . If it has, a check is made to ensure that the current domain stamp and the one at the time of this last commit are the same. If they are different, an error message is printed and \\(-1\\) is returned. A check is then made to see if the component base relations have been updated for this current domain stamp. If they have not been the base relations are updated, and each domain component is asked to send its data to the database. Finally the Domain relation is updated with the current time, load factor and domain stamp. Returns \\(1\\) if the component base relations needed to be updated and the component information sent, \\(0\\) if just the Domain relation needed to be updated. A warning message and a negative number is printed if an error occurs. The object first obtains from the Domain relation the information for commitTag . If no information exists, an error message is printed and a \\(-1\\) is returned. A check is then made to see if the domain stamp for this entity and the Domain objects current stamp are the same. If different, clearAll() is invoked on the Domain, and from the component base relations new domain components are created, are asked to recvSelf() from this and these new components are added to the Domain. Finally the current time, domain stamp and load factor are set using the information in the entity. Returns \\(1\\) if the domain needed to be cleared and new component objects created, \\(0\\) if just the Domain object needed to be updated with current time and load factor. A warning message and a negative number is printed if an error occurs. Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns the result of invoking sendSelf ( commitTag , \\ * this ) on theObject . Returns the result of invoking recvSelf(commitTag, *this, theBroker) on theObject . Prints an error message and returns \\(-1\\) as not yet implemented. Prints an error message and returns \\(-1\\) as not yet implemented. First determines the size of the matrix, \\(noRows * noCols\\) . If a files for matrices of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a Matrix with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for Matrices of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if Matrix size is too large. First determines the size of the matrix, \\(noRows * noCols\\) . If a files for matrices of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a Matrix with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the Matrix is set. returns \\(0\\) if successful. If a file for Vectors of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a Vector with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for Vectors of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if Vector size is too large. If a file for Vectors of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a Vector with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the Vector is set. Returns \\(0\\) if successful. If a file for IDs of this size has not yet been created, one is created now and the cell in the array of file pointers is set. If file can not be created a warning message is printed and program is terminated. A sequential search is made in the file to see if information is already stored for a ID with this dbTag and commitTag . The data is then written at this location, or eof if no location was found. The end of file location for IDss of this size is updated. If successful \\(0\\) is returned. A warning message and a negative number is returned if the operation fails: \\(-1\\) if ID size is too large. If a file for IDs of this size has not yet been created, an error message is printed and \\(-1\\) is returned. A sequential search is made in the file to see if information is already stored for a ID with this dbTag and commitTag . If no information is stored a \\(-1\\) is returned. If information is stored, the information is retrieved and the data in the ID is set. Returns \\(0\\) if successful.","title":"FileDatastore\n"},{"location":"developer/architecture/class_interface/database/database/","text":"TaggedObject TaggedObjectStorage ArrayOfTaggedObjects MapOfTaggedObjects FE_Datastore FileDatastore Recorder MaxNodeDispRecorder FileNodeDispRecorder DatastoreRecorder","title":""},{"location":"developer/architecture/class_interface/domain/","text":"Domain Classes These are the classes that are used to describe the finite element model and to store the results of an analysis on this model. The classes provide include Domain , Element , Node , Load , Constraint and their subclasses. Typically, a Domain object is used as a container object to store and provide access to the Node , Element , Load and Constraint objects created by the ModelBuilder object. Component Constraint Domain Load loadBalancer Node Partitioner Pattern","title":"Domain Classes\n"},{"location":"developer/architecture/class_interface/domain/domain/","text":"DomainComponent Element Node Load NodalLoad ElementalLoad SP_Constraint MP_Constraint TimeSeries LinearSeries RectangularSeries PathSeries PathTimeSeries LoadPattern EarthquakePattern UniformExcitation Domain","title":""},{"location":"developer/architecture/class_interface/domain/component/DomainComponent/","text":"DomainComponent #include <domain/component/DomainComponent.h> class DomainComponent TaggedObject MovableObject Element Node NodalLoad ElementalLoad SP_Constraint MP_Constraint The DomainComponent class is an abstract class, example subclasses include Element, Node, SP_Constraint , MP_Constraint , NodalLoad, ElementalLoad. Each object of these types is a component of an enclosing Domain object. The DomainComponent class provides methods to set and retrieve a pointer to the enclosing Domain object. Constructor ### Destructor // Public Methods Constructs a DomainComponent with a tag given by tag , whose class tag is given by classTag . The tag of a component is some unique means of identifying the component among like components, i.e. the tag of a node would be its unique node number. The classTag is a means of identifying the class of the object. No domain is associated with the object. The integer tag is passed to the TaggedObject constructor and the integer classTag is passed to the MovableObject constructor. Does nothing. Provided so subclasses destructor\u2019s will always be called. Sets the encompassing domain of the component to that given by theDomain . This method is invoked by theDomain when the component is being added to the domain, in an addDomain.. invocation (see interface for Domain). Returns a pointer to the Domain to which the component was added, or \\(0\\) if the setDomain() command was never called on the object. To cause the object to display itself using theRenderer . The integer displayMode is used to indicate what is to be displayed and the float fact is used to factor the nodal displacements. To return \\(0\\) if successful, a negative number if not. This base class simply returns \\(0\\) . Its up to the subclasses to override this method if the objects are to be rendered.","title":"DomainComponent\n"},{"location":"developer/architecture/class_interface/domain/constraints/MP_Constraint/","text":"MP_Constraint #include <domain/constraints/MP_Constraint.h> class MP_Constraint : public DomainComponent TaggedObject MovableObject An MP_Constraint represents a multiple point constraint in the domain. A multiple point constraint imposes a relationship between the displacement for certain dof at two nodes in the model, typically called the retained node and the constrained node: \\(U_c = C_{cr} U_r\\) An MP_Constraint is responsible for providing information on the relationship between the dof, this is in the form of a constraint Matrix, \\(C_{cr}\\) , and two ID objects, retainedID and constrainedID indicating the dof\u2019s at the nodes represented by \\(C_{cr}\\) . For example, for the following constraint imposing a relationship between the displacements at node \\(1\\) , the constrained node, with the displacements at node \\(2\\) , the retained node in a problem where the x,y,z components are identified as the 0,1,2 degrees-of-freedom: \\[u_{1,x} = 2 u_{2,x} + u_{2,z}\\] \\[u_{1,y} = 3 u_{2,z}\\] the constraint matrix is: \\[C_{cr} = \\left[ \\begin{array}{cc} 2 & 1 \\\\ 0 & 3 \\\\ \\end{array} \\right]\\] constrainedID = \\([0\\) \\(1]\\) and retainedID \\(= [0\\) \\(2]\\) . Constructors ### Destructor // Public Methods // Public Methods for Output To construct a multiple point constraint where the constrained node is given by nodeConstr , the retained node by nodeRetain , the constrainedID by constrainedDOF , the retainedID by retainedDOF and \\(C_{cr}\\) by constraint . The integers tag and CNSTRNT_TAG_MP_Constraint are passed to the DomainComponent classes constructor. New Matrix and ID objects are created to hold the information. For the subclasses to use. The subclasses can vary the contents of the Matrix returned when getConstraint() is invoked. The integers tag classTag are passed to the DomainComponent classes constructor. New ID objects are created to hold the information. Provided for the FEM_ObjectBroker to construct a blank object. The data for the object is filled in when recvSelf() is invoked on the object. \\(0\\) and classTag are passed to the DomainComponent constructor. Invokes the destructor on both the ID and the Matrix object, if a Matrix object is passed in the constructor. Returns the value of nodeRetain passed in the constructor, i.e. the tag of the retained node. virtual int getNodeConstrained(void) const; Returns the value of nodeConstr passed in the constructor, i.e. the tag of the constrained node. virtual const ID &getConstrainedDOFs(void) const; Returns, as a const, the constrainedID formed in the constructor. virtual const ID &getRetainedDOFs(void) const; Returns, as a const, the retainedID formed in the constructor. virtual int applyConstraint(double timeStamp) A method to invoked to inform the MP_Constraint to determine \\(C_{cr}\\) , for the time timeStamp . The base class will do nothing, as Matrix is assumed to be constant. virtual const Matrix & getConstraint ( void ) const ; Returns the current constraint Matrix, that determined in the last call to applyConstraint() . For the MP_Constraint class, \\(C_{cr}\\) determined in the constructor is returned. virtual int sendSelf ( int commitTag , Channel & theChannel ); Creates a Vector, stores the MP_Constraints tag, nodeRetain, nodeConstrained and value in the Vector, and sends the Vector to the Channel using the objects own database tag and commitTag . It then sends the participatingDOF ID and the constraint Matrix, again using the objects database tag and commitTag . Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to send the data. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates a Vector, receives the Vector from the Channel using commitTag and the objects database tag, and sets theMP_Constraints tag, nodeRetain, nodeConstrained from the the Vector. Creates a Vector and a Matrix, and then receives the participatingDOF ID and the constraint Matrix into these objects. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to receive the data. virtual void Print ( OPS_Stream & s , int flag = 0 ); Prints out the MP_Constraints tag, then the tags of the constrained and retained nodes, then the two ID\u2019s and finally the constraint Matrix.","title":"MP_Constraint\n"},{"location":"developer/architecture/class_interface/domain/constraints/SP_Constraint/","text":"SP_Constraint #include <domain/constraints/SP_Constraint.h> class SP_Constraint : public DomainComponent TaggedObject MovableObject DomainComponent An SP_Constraint represents a single point constraint in the domain. A single point constraint specifies the response of a particular degree-of-freedom at a node. The declaration that all methods are virtual allows for time varying constraints to be introduced. Constructors SP_Constraint ( int classTag ); SP_Constraint ( int nodeTag , int ndof , int classTag ); SP_Constraint ( int nodeTag , int ndof , double value , bool isConstant ); Destructor Public Methods virtual int getNodeTag ( void ) const ; virtual int getDOF_Number ( void ) const ; virtual int applyConstraint ( double loadFactor ); virtual double getValue ( void ); virtual bool isHomogeneous ( void ) const ; virtual void setLoadPatternTag ( int loadPaternTag ); virtual int getLoadPatternTag ( void ) const ; Public Methods for Output virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag = 0 ); To construct a single point constraint to constrain the trial displacement of the ndof \u2019th dof at node node to the value given by value . The integer value tag is used to identify the SP_Constraint among all other SP_Constraints. If value is equal to \\(0.0\\) the method isHomogeneous() will always return true , otherwise false . Provided for subclasses to use. The subclasses can vary the value of the imposed displacement when getValue() is invoked. If this constructor is used the isHomogeneous() method will always return false . The integer value tag is used to identify the SP_Constraint among all other SP_Constraints. Provided for the FEM_ObjectBroker to be able to instantiate an object; the data for this object will be read from a Channel object when recvSelf() is invoked. \\(0\\) and classTag are passed to the DomainComponent constructor. Does nothing. Provided so that a subclasses destructor can be invoked. Returns the value of node passed in the constructor, this should be the tag of the node that is being constrained. virtual int getDOF_Number ( void ) const ; Returns the value of ndof that was passed in the constructor, this identifies the dof number corresponding to the constraint. To set the value of the constraint for the load factor given by loadFactor . The constraint is set equal to loadFactor * value if the constraint is not constant, or value if the constraint was identified as constant in the constructor. To return a boolean indicating whether or not the constraint is a homogeneous constraint. A homogeneous constraint is one where the value of the constraint, value , is always \\(0\\) . This information can be used by the ConstraintHandler to reduce the number of equations in the system. virtual double getValue ( void ) const ; To return the value of the constraint determined in the last call to applyConstraint() . This base class returns value passed in the constructor. To set the LoadPattern tag associated with the object to be loadPatternTag . To return the load pattern tag associated with the load. virtual int sendSelf ( int commitTag , Channel & theChannel ); Creates a Vector, and stores the SP_Constraints tag, nodeTag, ndof and value in the Vector. It then passes the Vector as an argument to theChannel objects sendVector() method, along with the objects database tag and commitTag . Subclasses must invoke this method in their implementation of sendSelf() , so that the node and ndof values in remote object can be set. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to send the data. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates a Vector, and receives the Vector from the channel object using the recvVector() method call and the objects own database tag and commitTag . Using the information contained in the Vector, the SP_Constraints tag, nodeTag, ndof and value are set. Subclasses must invoke this method in their implementation of recvSelf() , so that the node and ndof values can be set. Returns \\(0\\) if successful, a negative number if the Channel object, theChannel , failed to receive the data. virtual void Print ( OPS_Stream & s , int flag = 0 ) const ; Prints out the SP_Constraints tag, then node , ndof and value .","title":"SP_Constraint\n"},{"location":"developer/architecture/class_interface/domain/domain/Domain/","text":"Domain #include <domain/domain/Domain.h> class Domain Domain is container class for storing and providing access to the components of a domain, i.e. nodes, elements, boundary conditions, and load patterns. A Domain is a container class which contains the all elements, nodes, load cases, single point constraints and multiple point constraints that the model builder uses to create the model of the structure. It provides operations for the following: Population: Methods so that the DomainComponents can be addled to the Domain. Depopulation: Methods so that the DomainComponents can be removed from the Domain. Access: Methods so that other classes, i.e. analysis and design, can access the DomainComponents. Query: Methods for determining the state of the domain. Update: Methods for updating the state of the Domain Analysis: Methods added for the Analysis class. Output: Methods added for outputting information. The Domain class stores each type of object, i.e. Nodes, Elements, SP_Constraints, MP_Constraints, NodalLoads and ElementalLoads, in a container object. Currently these container objects are a subtype of TaggedObjectStorage (templates are not used as yet due to present difficulties in porting code which uses templates). Constructors Destructor // Public Methods to Populate the Domain // Public Methods to Populate the LoadPatterns // Public Methods to Depopulate the Domain // Public Methods to Access the Components of the Domain // Public Methods to Query the State of the Domain // Public Methods to Update the Domain // Public Methods for Output // Protected Member Functions Constructs an empty domain. The storage for the DomainComponents uses ArrayOfTaggedObjects objects for each type of object to be stored. The initial sizes specified for these objects are 4096 for the Elements and Nodes, 256 SP_Constraints and MP_Constraints, and 32 for the container for the LoadPatterns. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Constructs an empty Domain. The storage for the DomainComponents uses ArrayOfTaggedObjects objects for each type of object to be stored. The initial sizes specified for these objects are as given in the arguments for this constructor, i.e. numElements for the Elements and numNodes for the Nodes. A size of 32 is used for the LoadPatterns. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Constructs a Domain where the Nodes, Elements, MP_Constraints, SP_Constraint and LoadPattern objects will be stored in the storage objects provided. A check is made to ensure these container objects are empty is made; if not empty the warning() method of the global ErrorHandler is invoked and the objects are cleared. Constructs a Domain where the Nodes, Elements, MP_Constraints, SP_Constraint and LoadPattern objects will be stored in the storage objects obtained by invoking getEmptyCopy() on the theStorageType object. A check is made to ensure that memory is allocated for these objects, if not the fatal() method of the global ErrorHandler is invoked. Invokes delete on all the storage objects. This means that, if the two latter constructors have been called, the container objects must have been created using new and that at no other point in the program is the destructor invoked on these objects. It should be noted, that the objects in the Domain, i.e. the DomainComponents, are not destroyed. To clean up these objects clearAll() should be invoked before the destructor is called. To add the element pointed to by theElementPtr to the domain. If _DEBUG is defined the domain checks to see that: 1) that all external nodes for the element exists in the domain. and 2) that the sum of the dof at all the nodes equals the num of dof at the element. In addition the domain always checks to ensure that no other element with a similar tag exists in the domain. If the checks are successful, the element is added to the domain by the domain invoking addComponent(theElePtr) on the container for the elements. The domain then invokes setDomain(this) on the element and domainChange() on itself if the element is successfully added. The call returns true if the element is added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addNode ( Node \\ * theNodePtr = false ); To add the node pointed to by theNodePtr to the domain. The domain first checks that no other node with a similar tag, node number, has been previously added to the domain. The domain will then add the node to it\u2019s node container object, by invoking addComponent(theNodePtr) . If successful, the Domain invokes setDomain(this) on the node, domainChange() on itself, and checks the coordinates of the domain to see if they effect the box encompassing the Domain. The call returns true if the node was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addSP ( SP_Constraint \\ * theSPptr = false ); To add the single point constraint pointed to by theSPptr to the domain. If _DEBUG is defined the domain is responsible for checking to see that 1) the constrained node exists in the domain and 2) that the node has the dof that is to be constrained. In addition the domain always checks to ensure that no other constraint with a similar tag exists in the domain. If the checks are successful, the constraint is added to domain by the domain invoking addComponent(theSPptr) on the container for the SP_Constraints. The domain then invokes setDomain(this) on the constraint and domainChange() on itself. The call returns true if the constraint was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addMP ( MP_Constraint \\ * theMPptr = false ); To add the multiple point constraint pointed to by theMPptr, to the domain. If _DEBUG is defined the domain first checks to see that the retained and the constrained node both exist in the model and that the matrix is of proper dimensions (THIS LAST PART NOT YET IMPLEMENTED). In addition the domain always checks to ensure that no other MP_Constraint with a similar tag exists in the domain. If the checks are successful, the constraint is added to domain by the domain invoking addComponent(theMPptr) on the container for the MP_Constraints. The domain then invokes setDomain(this) on the constraint and domainChange() on itself. The call returns true if the constraint was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addLoadPattern ( LoadPattern \\ * thePattern ); To add the LoadPattern thePattern to the domain. The load is added to domain by the domain invoking addComponent(theLd) on the container for the LoadPatterns. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method of the global ErrorHandler is invoked and false is returned. virtual bool addNodalLoad ( NodalLoad \\ * theLd , int loadPatternTag ); To add the nodal load theld to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding node exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addNodalLoad(theLd) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. virtual bool addElementalLoad(ElementalLoad *theLd, int loadPatternTag); To add the elemental load theld to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding element exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addElementalLoad(theLd) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the load. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. virtual bool addSP_Constraint(SP_Constraint *theConstraint, int loadPatternTag); To add the elemental load theConstraint to the LoadPattern in the domain whose tag is given by loadPatternTag . If _DEBUG is defines, checks to see that corresponding node exists in the domain. A pointer to the LoadPattern is obtained from the LoadPattern container and the load is added to LoadPattern by invoking addSP_Constraint(theConstraint) on the LoadPattern object. The domain is responsible for invoking setDomain(this) on the constraint. The call returns true if the load was added, otherwise the warning() method on the global ErrorHandler is invoked and false is returned. To remove all the components from the model and invoke the destructor on these objects. First clearAll() is invoked on all the LoadPattern objects. Then the domain object invokes clearAll() on its container objects. In addition the destructor for each Recorder object that has been added to the domain is invoked. In addition the current time and load factor are set to \\(0\\) , and the box bounding the domain is set to the box enclosing the origin. To remove the element whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the elements. Returns \\(0\\) if no such element exists in the domain. Otherwise the domain invokes setDomain ( 0 ) on the element (using a cast to go from a TaggedObject to an Element, which is safe as only an Element objects are added to this container) and domainChange() on itself before a pointer to the element is returned. virtual Node \\ * removeNode ( int tag ); To remove the node whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the nodes. Returns \\(0\\) if no such node exists in the domain. If the node is to be removed the domain invokes setDomain ( 0 ) on the node and domainChange() on itself before a pointer to the Node is returned. virtual SP_Constraint \\ * removeSP_Constraint ( int tag ); To remove the SP_Constraint whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the single point constraints. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain(0) on the constraint and domainChange() on itself before a pointer to the constraint is returned. Note this will only remove SP_Constraints which have been added to the domain and not directly to LoadPatterns. virtual ` MP_Constraint ` \\ * removeMP_Constraint ( int tag ); To remove the MP_Constraint whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the multi point constraints. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and domainChange() on itself before a pointer to the constraint is returned. virtual LoadPattern \\ * removeLoadPattern ( int tag ); To remove the LoadPattern whose tag is given by tag from the domain. The domain achieves this by invoking removeComponent(tag) on the container for the load patterns. If the LoadPattern exists, the domain then iterates through the loads and constraints of the LoadPattern invoking setDomain ( 0 ) on these objects. Returns \\(0\\) if the load was not in the domain, otherwise returns a pointer to the load that was removed. Invokes setDomain ( 0 ) on the load case before it is returned. To return an iter for the Elements in the domain. It returns an ElementIter for the elements of the domain that were added using addElement() . virtual NodeIter & getNodes ( void ); It returns a NodeIter for the nodes which have been added to the domain. virtual SP_ConstraintIter & getSPs ( void ); To return an SP_ConstraintIter for the single point constraints which have been added to the domain. virtual MP_ConstraintIter & getMPs ( void ); To return an MP_ConstraintIter for the multiple point constraints which have been added to the domain. virtual LoadPatternIter & getLoadPatterns ( void ); To return an LoadPatternIter for the LoadPattern objects which have been added to the domain. virtual Element \\ * getElement ( int tag ); To return a pointer to the element tag . If no such element exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the element container and performing a cast to an element if the object exists. virtual Node \\ * getNode ( int tag ); To return a pointer to the node whose tag is given by tag . If no such node exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the node container and performing a cast to a node if the object exists. virtual SP_Constraint \\ * getSP_ConstraintPtr ( int tag ); To return a pointer to the SP_Constraint whose tag is given by tag . If no such SP_Constraint exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the single-point constraint container and performing a cast to an SP_Constraint if the object exists. virtual ` MP_Constraint ` \\ * getMP_ConstraintPtr ( int tag ); To return a pointer to the MP_Constraint whose tag is given by tag . If no such MP_Constraint exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the multi-point constraint container and performing a cast to an MP_Constraint if the object exists. virtual ElementalLoad \\ * getLoadPattern ( int tag ); To return a pointer to the LoadPattern whose tag is given by tag . If no such LoadPattern exists \\(0\\) is returned. It does this by invoking em getComponentPtr(tag) on the elemental load container and performing a cast to a LoadPattern if the object exists. To return the number of elements in the domain. It does this by invoking getNumComponents() on the container for the elements. virtual int getNumNodes ( void ) const ; To return the number of nodes in the domain. It does this by invoking getNumComponents() on the container for the nodes. virtual int getNumSPs ( void ) const ; To return the number of single point constraints in the domain. It does this by invoking getNumComponents() on the container for the single point constraints. virtual int getNumMPs ( void ) const ; To return the number of multi point constraints in the domain. It does this by invoking getNumComponents() on the container for the multi point constraints. virtual int getNumLoadPatterns ( void ) const ; To return the number of load patterns in the domain. It does this by invoking getNumComponents() on the container for the load patterns. virtual const Vector & getPhysicalBounds ( void ); To return the bounding rectangle for the Domain. The information is contained in a Vector of size 6 containing in the following order {xmin, ymin, zmin, xmax, ymax, zmax}. This information is built up as nodes are added to the domain, initially all are set to \\(0\\) in the constructor. virtual Graph & getElementGraph ( void ); Returns the current element graph (the connectivity of the elements in the domain). If the eleChangeFlag has been set to true the method will invoke buildEleGraph(theEleGraph) on itself before returning the graph. The vertices in the element graph are to be labeled \\(0\\) through \\(numEle-1\\) . The Vertices references contain the elemental tags. virtual Graph & getNodeGraph ( void ); Returns the current node graph (the connectivity of the nodes in the domain). If the nodeChangeFlag has been set to true the will invoke buildNodeGraph(theNodeGraph) on itself before returning the graph. The vertices in the node graph are to be labeled \\(0\\) through \\(numNode-1\\) . The Vertices references contain the nodal tags. To set the current commitTag to newTag . To set the current time to newTime . To set the committed time to newTime . To apply the loads for the given time pseudoTime . The domain first clears the current load at all nodes and elements, done by invoking zeroUnbalancedLoad() on each node and zeroLoad() on each element. The domain then invokes applyLoad(pseudoTime) on all LoadPatterns which have been added to the domain. The domain will then invoke applyConstraint(pseudoTime) on all the constraints in the single and multi point constraint containers. Finally the domain sets its current time to be pseudoTime . To set the loads in the LoadPatterns to be constant. The domain achieves this by invoking setLoadConstant() on all the LoadPatterns which have been added to the domain. Note that LoadPatterns added after this method has been invoked will not be constant until this method is invoked again. virtual void commit ( void ); To commit the state of the domain , that is to accept the current state as being ion the solution path. The domain invokes commit() on all nodes in the domain and then commit() on all elements of the domain. These are calls for the nodes and elements to set there committed state as given by their current state. The domain will then set its committed time variable to be equal to the current time and lastly increments its commit tag by \\(1\\) . virtual int revertToLastCommit ( void ); To return the domain to the state it was in at the last commit. The domain invokes revertToLastCommit() on all nodes and elements in the domain. The domain sets its current loadFactor and time stamp to be equal to the last committed values. The domain decrements the current commitTag by \\(1\\) . Finally it invokes applyLoad() on itself with the current time. virtual void update ( void ); Called by the AnalysisModel to update the state of the domain. Iterates over all the elements of the Domain and invokes update() . To set the domain stamp to be newStamp . Domain stamp is the integer returned by hasDomainChanged() . virtual int hasDomainChanged ( void ); To return an integer stamp indicating the state of the domain. Initially \\(0\\) , this integer is incremented by \\(1\\) if domainChange() has been invoked since the last invocation of the method. If the domain has changed it marks the element and node graph flags as not having been built. To add a recorder object theRecorder to the domain. record(commitTag) is invoked on each commit() . The pointers to the recorders are stored in an array which is resized on each invocation of this method. The domain will invoke playback(commitTag) on all recorder objects which have been added to the domain. To print the state of the domain. The domain invokes Print ( s , flag ) on all it\u2019s container objects. This function allows domain objects to be printed to streams. The function invokes \\(M.Print(s)\\) before returning \\(s\\) . Sets a flag indicating that the integer returned in the next call to hasDomainChanged() must be incremented by \\(1\\) . This method is invoked whenever a Node, Element or Constraint object is added to the domain. virtual int buildEleGraph(Graph &theEleGraph) A method which will cause the domain to discard the current element graph and build a new one based on the element connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr. virtual int buildNodeGraph(Graph &theNodeGraph) A method which will cause the domain to discard the current node graph and build a new one based on the node connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr.","title":"Domain\n"},{"location":"developer/architecture/class_interface/domain/domain/partitioned/PartitionedDomain/","text":"UNDER CONSTRUCTION #include </domain/domain/partitioned/PartitionedDomain.h> class PartitionedDomain: public Domain Domain PartitionedDomain is an extension of Domain. A partitioned domain is an aggregation of subdomains. All elements, nodes, loadcases are added to the PartitionedDomain. The components can be moved among subdomains (keeping in mind that subdomains are themselves subclasses of domain and therefore must obey the requirements for adding and removing elements specified in the interface for Domain) by invoking the remove..() and add...() methods on the subdomain. Constructors Destructor // Public Member Functions - which extend the Domain class // Public Member Functions - inherited from Domain but rewritten // Protected Methods virtual int buildEleGraph(Graph &theEleGraph) Constructs an empty PartitionedDomain. A link with the domain partitioner thePartitioner is set up. The thePartitioner is used by the domain to partition and load balance the partitioned domain. Constructs an empty PartitionedDomain, storage is allocated for the components that are to be added using the estimated number of components passed as arguments. A link with the domain partitioner thePartitioner is set up. The thePartitioner is used by the domain to partition and load balance the partitioned domain. Deletes the storage components. Method which first checks that subdomains with tags 1 through numPartitions exist in the PartitionedDomain. Then it invokes setPartitionedDomain(*this) on the DomainPartitioner and finally it returns the result of invoking partition(numPartitions on the DomainPartitioner, which will return 0 if successful, a negative number if not. virtual bool addSubdomain ( Subdomain \\ * theSubdomainPtr ); Adds the subdomain pointed to by theSubdomainPtr to the domain. The domain is responsible for checking that no other subdomain with a similar tag, has been previously added to the domain. If successful the domain is responsible for invoking setDomain(this) on the Subdomain. The domain is also responsible for invoking domainChange() . The call returns false if the subdomain was not added, otherwise true is returned. virtual int getNumSubdomains ( void ); Method which returns the number of Subdomains (partitions). virtual Subdomain \\ * getSubdomainPtr ( int tag ); Returns the Subdomain whose tag is given by tag . virtual SubdomainIter & getSubdomains ( void ); Returns an iter for the Subdomains of the PartitionedDomain. Node *removeExternalNode(int tag); A method to remove a Node whose tag is given by tag from the PartitionedDomain, but will not remove the Node from any Subdomains. Graph &getSubdomainGraph(void); This will create a new graph each time it is invoked; deleting the old graph. THIS WILL BE CHANGED. A vertex is created for each Subdomain, with an edge to each Subdomain the Subdomain is connected to, a tag equal to the Subdomain tag, and a weight equal to the result of invoking getCost() on the Subdomain. To add the element pointed to by theElementPtr to the domain. If check is true the domain is responsible for checking to see that: 1) no other element with a similar tag, element number, exists in any of the subdomains. If check is successful the partitioned domain attempts to add the element to the storage arrey. The call returns false if the element was not added, otherwise true is returned. virtual bool addNode ( Node \\ * theNodePtr , bool check = false ); Adds the node pointed to by theNodePtr to the domain. If check is true the domain is responsible for checking that no other node with a similar tag, node number, exists in any of the subdomains. If successful the partition domain attempts to add the node by invoking Domain::addNode . The call returns false if the node was not added, otherwise true is returned. virtual bool addSP_Constraint(SP_Constraint *theSPptr, bool check = false); Adds the single point constraint pointed to by theSPptr to the domain. The domain performs some checks is check is true. If successful the domain adds the constraint using Domain::addSP_Constraint() . The call returns false if the constraint was not added, otherwise true is returned. virtual bool addMP ( MP_Constraint \\ * theMPptr , bool check = false ); Adds the multiple point constraint pointed to by theMPptr, to the domain. The domain performs some checks is check is true. If successful the domain adds the constraint using Domain::addMP_Constraint() . The call returns false if the constraint was not added, otherwise true is returned. virtual bool addLoadCase ( LoadCase \\ * theLCptr ); It returns an PartionedDomEleIter for the elements of the domain. This is an iter which goes through all the subdomains, invoking getElements() on the subdomain to get an ElementIter. The PartitionedDomEleIter uses this iter to go through the elements of the subdomain until it begins returning \\(0\\) ; at which point it goes on to the next subdomain. virtual Element \\ * getElement ( int tag ) const ; Returns a pointer to the element whose tag is given by tag . If no such element exists \\(0\\) is returned. This is done by invoking getElement(tag) on the subdomains until the element is found or no more subdomains exist; in which case a \\(0\\) is returned. virtual Node \\ * getNode ( int tag ) const ; Returns a pointer to the node whose tag is given by tag . If no such node exists \\(0\\) is returned. This is done by invoking getNode(tag) on the subdomains until the element is found or no more subdomains exist; in which case a \\(0\\) is returned. virtual LoadCase \\ * getLoadCasePtr ( int tag ) const ; Returns a pointer to the element whose tag is given by tag . If no such load case exists \\(0\\) is returned. Sets the current load case of the domain to be that whose tag is given by LCtag. It iterates through all the subdomains invoking the same operation on them. Returns false if no such load case exists, otherwise returns true . Sets the current load case of the domain to be that whose tag is given by newTime . It iterates through all the subdomains invoking the same operation on them. virtual void applyLoad ( double time = 0.0 , double loadFactor = 1.0 ); The partitioned domain iterates through all the subdomains invoking applyLoad(double timeStamp) on them. virtual void linearize ( void ); The partitioned domain iterates through all the subdomains invoking linearize() on them. virtual void commit ( void ); The partitioned domain iterates through all the subdomains invoking commit() on them. Returns the tag of the current load case set for the domain. If no load case is set \\(-1\\) is returned. Returns the currentTime set for the domain. If no load case is set \\(0\\) is returned. Returns the number of elements in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumNodes ( void ) const = 0 ; Returns the number of nodes in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumSPs ( void ) const ; Returns the number of SP_Constraints in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumMPs ( void ) const ; Returns the number of MP_Constraints in the domain. This number is obtained by summing the contributions from each subdomain. virtual int getNumLCs ( void ) const ; Returns the number of LoadCases in the domain. This number is obtained by summing the contributions from each subdomain. virtual Domain \\ * getEmptyDomainCopy ( void ); Returns an empty copy of the actual domain. virtual Element \\ * removeElement ( int tag ); To remove the element whose tag is given by tag from the domain. The method Returns \\(0\\) if no such element exists in the domain. Otherwise the domain invokes setDomain ( 0 ) on the element and setDomainChange(true,true,false) on itself before a pointer to the element is returned. virtual Node \\ * removeNode ( int tag , bool checkNeeded = true ); To remove the node whose tag is given by tag from the domain. Returns \\(0\\) if no such node exists in the domain. Otherwise if the checkNeeded is true before the node is removed a check is made to see that the node is not referenced by any element, constraint or load. If it is referenced the Node will not be removed and \\(0\\) is returned. If the node is to be removed the domain invokes setDomain ( 0 ) on the node and setDomainChange(true,false,true) on itself before a pointer to the Node is returned. virtual LoadCase \\ * removeLoadCase ( int tag ); To remove the load case whose tag is given by tag from the domain. Returns \\(0\\) if the load case was not in the domain, otherwise returns a pointer to the load case that was removed. Invokes setDomain ( 0 ) on the load case before it is returned. virtual SP_Constraint \\ * removeSP_Constraint ( int tag ); To remove the SP_Constraint whose tag is given by tag from the domain. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and setDomainChange(true,false,false) on itself before a pointer to the constraint is returned. virtual ` MP_Constraint ` \\ * removeMP_Constraint ( int tag ); To remove the MP_Constraint whose tag is given by tag from the domain. Returns \\(0\\) if the constraint was not in the domain, otherwise the domain invokes setDomain ( 0 ) on the constraint and setDomainChange(true,false,false) on itself before a pointer to the constraint is returned. Will return a pointer to the DomainPartitioner object associated with the PartitionedDomain. virtual int buildEleGraph(Graph &theEleGraph) A method which will cause the domain to discard the current element graph and build a new one based on the element connectivity. Returns \\(0\\) if successful otherwise \\(-1\\) is returned along with an error message to opserr.","title":""},{"location":"developer/architecture/class_interface/domain/load/Load/","text":"Load #include <domain/load/Load.h> class Load: public DomainComponent TaggedObject MovableObject DomainComponent Load is an abstract base class. A Load object is used to add load to the domain. The Load class defines one method in its interface applyLoad() , a method all subclasses must implement. Constructor ### Destructor // Public Methods Constructs a load with a tag given by tag and a class tag is given by classTag . These are passed to the DomainComponent constructor. The load object is to add loadFactor times the load to the corresponding residual value at its associated element(s) or node(s). To set the tag of the enclosing load pattern for the load to be loadPatternTag . To return the current load pattern tag associated with the load. If no load pattern tag has been set \\(-1\\) is returned.","title":"Load\n"},{"location":"developer/architecture/class_interface/domain/node/DummyNode/","text":"DummyNode #include <DummyNode.h> class DummyNode : public DomainComponent DomainComponent DummyNodes are a type of node created and used by Subdomains for their exterior nodes. They reference a real node and most methods invoked on them are in turn invoked by the dummy node on the real node. The calls asking the real node to change its current state are ignored. The calls involving DOF_Group are handled by the dummy node. To construct a dummy node which is associated with the node pointed to by theRealNode . Each DummyNode, when involved with a StaticCondensationAnalysis analysis, will be associated with a DOF_Group object. It is the DOF_Group that contains the ID of equation numbers. When invoked this method sets that link for the DummyNode object. virtual ` DOF_Group ` \\ * getDOF_GroupPtr ( void ); Method which returns a pointer to the DOF_Group object that was set using setDOF_GroupPtr . If no pointer has been set a \\(0\\) is returned. virtual int getNumberDOF ( void ) const ; Returns the result of invoking getNumberDOF() on its associated Node object. virtual Vector & getMass ( void ) const ; Returns the result of invoking getMass() on its associated Node object. virtual void setMass ( Vector & mass ); Invokes getNumberDOF() on its associated Node object. virtual const Vector & getCrds ( void ) const ; Returns the result of invoking getCrds() on its associated Node object. virtual const Vector & getDisp ( void ) const ; Returns the result of invoking getDisp() on its associated Node object. virtual const Vector & getVel ( void ) const ; Returns the result of invoking getVel() on its associated Node object. virtual const Vector & getAccel ( void ) const ; Returns the result of invoking getAccel() on its associated Node object. virtual const Vector & getTrialDisp ( void ) const ; Returns the result of invoking getTrialDisp() on its associated Node object. virtual const Vector & getTrialVel ( void ) const ; Returns the result of invoking getTrialVel() on its associated Node object. virtual const Vector & getTrialAccel ( void ) const ; Returns the result of invoking getTrialAccel() on its associated Node object. void addUnbalancedLoad ( const Vector & additionalLoad ); Returns the result of invoking addUnbalancedLoad() on its associated Node object. virtual const Vector & getUnbalancedLoad ( void ) const ; Returns the result of invoking getUnbalancedLoad() on its associated Node object. The following commands do nothing, they just return.","title":"DummyNode\n"},{"location":"developer/architecture/class_interface/domain/node/NodalLoad/","text":"NodalLoad #include <domain/node/NodalLoad.h> class NodalLoad: public Load TaggedObject MovableObject DomainComponent Load NodalLoads are loads acting on Nodes. The public methods are all declared as virtual to allow subclasses to be introduced for the provision of time varying loads. Each NodalLoad object is associated with a single Node object and has a Vector object corresponding to the load acting on this Node object as a result of the NodalLoad. Constructors ### Destructor // Public Methods // Public Methods for Output To create a NodalLoad object with tag tag acting on Node node with a reference load given by load . tag and LOAD_TAG_NodalLoad (defined in <classTags.h> )are passed to the Load constructor. A new vector object is created using the vector load as the argument. (THIS MAY CHANGE - may associate the load Vector with load , allowing identical loads on diff nodes to be created without the need for each to have its own vector) If no enough memory is available an error message is printed and the program terminates. The boolean isLoadConstant is used to indicate whether the value of the load applies to the Node is independent of the load factor. Provided for subclasses, which may which to provide the abstraction of time varying nodal loads. The integers tag and classTag are passed to the Load constructor. Provided so that a FEM_ObjectBroker can construct an object. \\(0\\) and classTag are passed to the Load classes constructor. The data for the object is filled in when recvSelf() is invoked on the object. If a Vector for the load was constructed, the destructor invokes delete on this Vector object. To set the associated Domain object. First checks to ensure that a Node object with the tag exists in the Domain. It sets the pointer for it\u2019s associated Node object to point to this object, and then invokes the DomainComponent classes setDomain() method. If the Node does not exist in the Domain a warning message and setDomain() is not invoked. Returns the integer node passed in the constructor. To it\u2019s associated Node it invokes addUnbalancedLoad() with it\u2019s copy of the Vector object load and a factor of loadFactor if isLoadConstant was specified as false in the constructor or \\(1\\) if it was specified as true . Warning messages are printed, if no Domain has been associated with the NodalLoad object or no Node with a tag node exists in the Domain. For efficiency reasons, the NodalLoad object keeps a pointer to it\u2019s associated Node object. The time timeStep has no influence on the load added. Determines its database tag. The object then sends it\u2019s tag, node and size of load Vector to the Channel in an ID object. Then, if load is not NULL, it sends it\u2019s copy of the load Vector. Returns \\(0\\) if successful, a negative number if the Channel failed to send the data. The object first determines its database tag. It then invokes receives an ID object from the Channel containing it\u2019s tag, node and size of load Vector. If size of load is not \\(0\\) it then receives it\u2019s copy of the load Vector. Returns \\(0\\) if successful, a negative number if the Channel failed to receive the data. Prints it\u2019s node and then prints the load Vector.","title":"NodalLoad\n"},{"location":"developer/architecture/class_interface/domain/node/Node/","text":"Node NEW METHOD POSSIBLY NEEDED TO SPECIFY THE NUMBER OF PREVIOUSLY COMMITTED RESPONSES TO KEEP .. NEEDED FOR EXPLICIT DYNAMIC INTEGRATORS #include </domain/node/Node.h> class Node : public DomainComponent TaggedObject MovableObject Nodes are points in space connected by the elements. Nodes have original position, trial displacement, velocity and acceleration, and committed displacement, velocity and acceleration (the last committed trial quantities). Nodes also store information about any load acting on the node, nodal mass and the nodal participation matrix. In addition, each Node object keeps track of it\u2019s associated DOF_Group object. The Node interface provides methods to set and retrieve these quantities. Constructors Destructor // Public Methods dealing with DOF at the Node // Public Method for obtaining nodal coordinates // Public Method for obtaining committed and trial responses // Public Method for updating trial responses // Public Method for setting and obtaining unbalanced load // Public Method for setting state // Public Method for dynamic and modal analysis // Public Method for Output To construct a node which has no data, other than the classTag identifier; \\(0\\) and classTag are passed to the DomainComponent constructor. This is the constructor called by an FEM_ObjectBroker. The data must be filled in subsequently by a call to recvSelf() . To construct a node whose unique integer among nodes in the domain is given by tag and whose classTag is given by classTag . This constructor can be used by subclasses who wish to handle their own data management. To construct a node for 1d problems whose unique integer among nodes in the domain is given by tag and whose original position in 1d space is given by (Crd1). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node (defined in classTags.h). A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node for 2d problems whose unique integer among nodes in the domain is given by tag and whose original position in 2d space is given by (Crd1,Crd2). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node. A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node for 3d problems whose unique integer among nodes in the domain is given by tag and whose original position in 3d space is given by (Crd1,Crd2,Crd3). With the node is associated ndof number of degrees of freedom. The class tag is NOD_TAG_Node. A Vector object is created to hold the coordinates. No storage objects are created to hold the trial and committed response quantities, mass, load quantities; these are created as needed to reduce the memory demands on the system in certain situations. To construct a node which is an exact copy of theCopy . Invokes the destructor on all the storage objects created to hold the coordinates, response quantities, mass and load quantities. Returns the number of degrees-of-freedom, ndof , associated with the node. Each node, when involved with an analysis, will be associated with a DOF_Group object. It is the DOF_Group that contains the ID of equation numbers. When invoked this method sets the pointer to that DOF_Group object. virtual ` DOF_Group ` \\ * getDOF_GroupPtr ( void ); Method which returns a pointer to the DOF_Group object that was set using setDOF_GroupPtr . If no pointer has been set a \\(0\\) is returned. virtual const Vector & getCrds ( void ) const ; Returns the original coordinates in a Vector. The size of the vector is 2 if node object was created for a 2d problem and the size is 3 if created for a 3d problem. virtual const Vector & getDisp ( void ) ; Returns the last committed displacement as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getVel ( void ) ; Returns the last committed velocity as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getAccel ( void ) ; Returns the last committed acceleration as a Vector, the vector of size ndof . If no Vector has yet been allocated, two Vector objects are created to store the committed and trial response quantities created; if not enough space is available an error message is printed and program terminated. virtual const Vector & getTrialDisp ( void ) ; Returns the current trial displacements as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getTrialVel ( void ) ; Returns the current trial velocities as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getTrialAccel ( void ) ; Returns the current trial accelerations as a Vector, the vector of size ndof . If no Vector has yet been allocated, a new Vector is created and returned; if not enough space is available an error message is printed and the program is terminated. virtual const Vector & getIncrDisp ( void ) ; Returns the incremental displacement as a Vector. The incremental displacement is equal to the difference between the current trial displacement and committed displacement (trial - committed). If no Vector has yet been allocated, three Vector objects are created to store the committed, trial and incremental response quantities; if not enough space is available an error message is printed and program terminated. virtual int setTrialDisp ( const Vector & newTrialDisp ); Sets the current trial displacement to be that given by newTrialDisp . Sets th incremental displacement to be trial \\(-\\) committtd. If no space has yet been allocated for the trial displacements, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialDisp is not of size ndof . virtual int setTrialVel ( const Vector & newTrialVel ); Sets the current trial velocity to be that given by newTrialVel . If no space has yet been allocated for the trial velocities, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialVel is not of size ndof . virtual int setTrialAccel ( const Vector & newTrialAccel ); Sets the current trial acceleration to be that given by newTrialAccel . If no space has yet been allocated for the trial accelerations, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if newTrialAccel is not of size ndof . virtual int incrTrialDisp ( const Vector & trialIncrDisp ); Sets the current trial displacement to be that given by the addition of the last trial displacement, assumed \\(0\\) if not yet set, and trialIncrDisp . Increments the incremental displacement by trialIncrDisp . If no space has yet been allocated for the displacements, three Vector objects are now created to store the trial, committed and incremental response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrDisp is not of size ndof . virtual int incrTrialVel ( const Vector & trialIncrVel ); Sets the current trial velocity to be that given by the addition of the last trial velocity, assumed \\(0\\) if not yet set, and trialIncrVel . If no space has yet been allocated for the trial velocities, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrVel is not of size ndof . virtual int incrTrialAccel ( const Vector & trialIncrAccel ); Sets the current trial Acceleration to be that given by the addition of the last trial Acceleration, assumed \\(0\\) if not yet set, and trialIncrAccel . If no space has yet been allocated for the trial accelerations, two Vector objects are now created to store the trial and committed response quantities; if not enough memory is available on the heap to create these new Vectors an error message is printed and the program is terminated. Returns \\(0\\) if successful, an error message is printed and a \\(-2\\) is returned if trialIncrAccel is not of size ndof . virtual void zeroUnbalancedLoad ( void ); Causes the node to zero out its unbalanced load vector. virtual int addUnbalancedLoad(const Vector &additionalLoad, double fact); The Node is responsible for adding fact times additionalLoad to the current unbalanced load at the Node. If additionalLoad is not of size ndof no load is added, an error message is printed and a \\(-1\\) is returned. If no space has yet been allocated for the unbalanced load a new Vector is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. Returns \\(0\\) if successful. To add minus fact times the product \\(M * R * accel\\) to the current unbalanced load. Nothing is done if no mass or R matrix have been set. Prints a warning and returns a \\(-1\\) if the size of accel and the number of columns in \\(R\\) are not the same. If no space has yet been allocated for the unbalanced load a new Vector is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. Returns \\(0\\) if successful. virtual const Vector & getUnbalancedLoad ( void ); Returns the current unbalanced load. If no space has yet been allocated for the unbalanced load a new Vector of size numDOF is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. virtual const Vector & getUnbalancedLoadIncInertia ( void ); Returns the current unbalanced load Vector, as defined above, MINUS the product of the nodes mass matrix and the trial nodal accelerations. The result is saved in another vector which is returned. If no space has yet been allocated for this new Vector, a Vector of size numDOF is now created; if not enough space is available for this Vector an error message is printed and the program is terminated. virtual int commitState ( void ); Causes the node to set the committed model displacements, velocities and accelerations to be equal to the current trial displacements, velocities and accelerations. The incremental displacement is set to \\(0\\) . No assignment is done for any of the quantities for which no memory has been allocated. Returns \\(0\\) . virtual int revertToLastCommit ( void ); Causes the node to set the trial nodal displacements, velocities and accelerations to be equal to the current committed displacements, velocities and accelerations. The incremental displacement is set to \\(0\\) . No assignment is done for any of the trial quantities for which no memory has been allocated. Returns \\(0\\) . virtual int revertToStart ( void ); Causes the node to set the trial and committed nodal displacements, velocities and accelerations to zero. No assignment is done for any of the trial quantities for which no memory has been allocated. Returns \\(0\\) . virtual const Matrix & getMass ( void ) ; Returns the mass matrix set for the node, which is a matrix of size ndof,ndof . This matrix is equal to that set in setMass() or zero if setMass() has not been called. If no storage space has been allocated for the mass, a matrix is now created. An error message is printed and the program terminated if no space is available on the heap for this matrix. virtual int setMass ( const Matrix & mass ); Sets the value of the mass at the node. A check is made to ensure that the mass has the same dimensions of the mass matrix associated with the Node; if incompatible size an error message is printed and -1 returned. If no mass matrix yet allocated, one is created; if no space is available an error message is printed and the program terminated. Returns 0 if successful. Creates a Matrix to store the R matrix. The matrix is of dimension ndof and numCol . If not enough space is available for this matrix an error message is printed and the program is terminated. Zeros the matrix R and returns \\(0\\) if successful. Sets the \\(row,col\\) entry of R to be equal to Value . If no matrix R has been specified or the position in R is out of range a warning message is printed and a \\(-1\\) is returned. Returns \\(0\\) if successful. This is a method provided for Element objects, the Node object returns the product of the matrix \\(R\\) and the vector \\(V\\) . If the matrix and vector are of inappropriate size a warning message is printed and a zero vector is returned. virtual int sendSelf ( int commitTag , Channel & theChannel ); Causes the Node object to send the data needed to init itself on a remote machine to the Channel object theChannel . The data sent includes the tag, number of dof, coordinates, committed response quantities, unbalanced load, mass and participation matrix. To do this the Node creates an ID object into which it stores its tag, the ndof and a flag indicating whether any additional information, i.e. mass, response quantities also need to be sent. In addition four database tags are also included in this ID object. The database tags, if not already obtained, are requested from the Channel object (these are needed as each object can only store a single object of a particular size using it\u2019s own database tags \u2013 additional tags are needed when multiple objects of the same size are needed. The objects that have been created are then sent. virtual int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Invoked on a remote machine to read its data that was sent by a node object in another actor when sendSelf() was invoked. As in sendSelf() , the Node object creates an ID object. It asks the Channel object to fill this object with data. Based on the data it creates Matrix and Vector objects to store the Nodes data and asks the Channel object to fill these with data. The data placed here by the Channel object correspond to the data put there by the sending Node object. void Print ( OPS_Stream & s , int flag = 0 ); Causes the Node to print out its tag, mass matrix, and committed response quantities. Causes the Node to display itself. If flag is \\(1\\) the Node will cause its tag to be printed to the display.","title":"Node\n"},{"location":"developer/architecture/class_interface/domain/partitioner/DomainPartitioner/","text":"UNDER CONSTRUCTION DomainPartitioner #include <domain/partitioner/DomainPartitioner.h> class DomainPartitioner A DomainPartitioner is an object used to partition and load balance a PartitionedDomain. The DomainPartitioner uses the element graph of the domain to partition and load balance. Derived types can use the node graph of the domain. The partitioner uses a GraphPartitioner and a LoadBalancingAlgo to partition and load balance the domain. Constructors Destructor // Public Methods // Public Methods Used by the LoadBalancer Constructs a DomainPartitioner which will use theGraphPartitioner to initially partition the PartitionedDomain using the element graph and the theLoadBalancer to load balance the PartitionedDomain. The max number of subdomains that the Domain can be partitioned is currently set at 8. Constructs a DomainPartitioner which will use theGraphPartitioner to initially partition the PartitionedDomain. The max number of subdomains that the Domain can be partitioned is currently set at 8. Sets the link with the PartitionedDomain that is to be partitioned. virtual int partition ( int numParts ); Method invoked to partition the Domain. It first checks to see that the PartitionedDomain has at least numParts Subdomains, with tags 1 through numParts ; if not prints an error message and returns -1. It then asks the domain for the element graph. This graph is then partitioned using the GraphPartitioner into numParts ; if partitioning fails an error message is printed and \\(-10 +\\) number returned from GraphPartitioner is returned. If successful the domain is partitioned according to the following rules: All nodes which are internal to a partition are added using the addNode() method of the Subdomain. These nodes are removed from the PartionedDomain using removeNode() . External nodes (these are nodes shared across partitions as a result of element connectivity or MP_Constraints are added to those Subdomains whose elements reference them. They are added using the addExternalNode() command. SP_Constraints whose node is interior to a Subdomain are removed from the PartitionedDomain and added to the Subdomain. MP_Constraints whose two nodes are interior to a Subdomain are removed from the PartitionedDomain and added to the Subdomain. The elements are sent to the partition whose tag is given by the color of the vertex in the partitioned (colored) element graph. The elements are removed from the PartitionedDomain using removeElement() and added to the Subdomain using addElement() . For the loads, a check is made to ensure that each Subdomain has a LoadCase with a tag equal to the tags in the LoadCases that have been added to the PartitionedDomain; if not new LoadCases are created and added to the Subdomain. It then iterates through all the NodalLoads in the LoadCases in the PartionedDomain, if the corresponding node is external the NodalLoad is removed and added to the corresponding LoadCase in the Subdomain. ELEMENTAL LOADS are not yet dealt with. The DomainPartitioner invokes hasDomainChanged() on each Subdomain; if the Subdomain has changed invokeChangeOnAnalysis() . Finally hasDomainChanged() is invoked on the PartitionedDomain; if it has changed invokeChangeOnAnalysis() . partitionFlag is set to true. virtual void balance(Graph &theWeightedGraph) Checks first to see that the partitionFlag has been set; if it hasn\u2019nt an error message is printed and a \\(-1\\) is returned. If a LoadBalancer was passed in the constructor balance() is invoked on this object; if no LoadBalancer was passed nothing is done and method returns \\(0\\) . If balancing is performed, the DomainPartitioner invokes hasDomainChanged() on each Subdomain; if the Subdomain has changed invokeChangeOnAnalysis() . Finally hasDomainChanged() is invoked on the PartitionedDomain; if it has changed invokeChangeOnAnalysis() . partitionFlag is set to true. Method which invokes setPartitioner(this) on the LoadBalancingAlgo. It then invokes balance(load) on this object, where load is vector of size numParts containing the load of each subdomain. Returns the number of partitions in the PartitionedDomain. Method which returns the partition graph. This is a graph with a vertex for every partition and an edge between partitions if there exists an element in one partition which is connected to an element in the other partition. virtual Graph &getColoredGraph(void); A method which returns the current colored graph representing the partitioning of the elements in the subdomains. Does this by invoking getElementGraph() on the PartitionedDomain. Note that this is the same graph that was colored by the DomainPartitioner in partitioning the PartitionedDomain. virtual void swapVertex(int from, int to, int vertexTag, bool notAdjacentOther = true); Method which will take the element given by vertex reference of the vertex whose tag is given by vertexTag from subdomain from and place it in subdomain to . If notAdjacentOther is true a check is made to ensure that the vertex to be swapped is not adjacent to a vertex in any other partition. Returns \\(0\\) if successful, returns an error message and \\(-1\\) if PartitionedDomain has not been partitioned, \\(-2\\) if from Subdomain does not exist, \\(-3\\) if to Subdomain does not exist, \\(-4\\) if a vertex given by tag does not exist, returns \\(-5\\) if notAdjacentOther was true and the vertex was adjacent to a vertex in another partition, and returns \\(-6\\) if no Element with a tag similar to tag exists (this should not happen if element graph is built correctly). The Element, Nodes, NodalLoads, SP_Constraints and MP_Constraints that need to be moved between the two Subdomains, or between the PartitionedDomain and Subdomains are also moved. NO ELEMENTAL LOADS are moved yet. virtual void swapBoundary(int from, int to, bool notAdjacentOther = true); Method which when invoked will take all the boundary elements in subdomain from that are connected to elements in subdomain to and place them in subdomain to . If adjacentVertexOther is true no Elements which are connected to elements in subdomains other than to and from are moved. Returns \\(0\\) if successful, returns an error message and \\(-1\\) if PartitionedDomain has not been partitioned, \\(-2\\) if from Subdomain does not exist, \\(-3\\) if to Subdomain does not exist. The Elements, Nodes, NodalLoads, SP_Constraints and MP_Constraints that need to be moved between the two Subdomains, or between the PartitionedDomain and Subdomains are also moved. NO ELEMENTAL LOADS are moved yet. It performs the operation by creating an ID of vertices and then using code similar to that used in swapVertex() ; swapVErtex() is not called repeatedly as this was found to be too slow. virtual int releaseVertex(int from, int vertexTag, Graph &theWeightedPartitionGraph, double factorGreater, bool adjacentVertexOonly); Method which when invoked will take the element given by vertex reference of the vertex whose tag is given by vertexTag from subdomain from and place it in the subdomain to which it is most attracted (to which it is most connected). If it is equally attracted to two subdomains it is sent to the one with the lightest load (the loads on the subdomains are given in the theWeightedPartitionGraph . If the mustReleaseToLighter is true a check is first made to see if the load on the intended subdomain is lighter than the load in from and that the ratio in load between from and the new domain is greater than factorGreater ; if this is the case the element is swapped, if not the element is not swapped. An additional requirement that the vertex that is to be swapped is not adjacent to any other partition can also be set. The method determines which partition the vertex is to be sent to and then returns the result of invoking swapVertex() on itself, with this partition used as the to argument in the arguments. virtual int releaseBoundary(int from, Graph &theWeightedPartitionGraph, double factorGreater, bool adjacentVertexOonly); Method which when invoked will release all the elements on the boundary of subdomain from . It performs the operation by creating an ID of all the vertices on the boundary of the from Subdomain. Then releaseBoundary() is invoked on all these vertices.","title":"DomainPartitioner\n"},{"location":"developer/architecture/class_interface/domain/pattern/EarthquakePattern/","text":"EarthquakePattern #include <domain/pattern/EarthquakePattern.h> NEEDS MODIFICATION TO ALLOW MULTIPLE EARTHQUAKE PATTERNS, SO DON\u201dT HAVE TO SET R IN NODES EACH APPLYLOAD. class EarthquakePattern: public LoadPattern TaggedObject MovableObject DomainComponent LoadPattern The EarthquakePattern class is an abstract class. An EarthquakePattern is an object which adds earthquake loads to models. This abstract class keeps track of the GroundMotion objects and implements the applyLoad() method. It is up to the concrete subclasses to set the appropriate values of R at each node in the model. Constructor ### Destructor // Public Methods // Protected Methods The integers tag and classTag are passed to the LoadPattern classes constructor. Invokes the destructor on all GroundMotions added to the Earthquakepattern. It then invokes the destructor on the array holding pointers to the GroundMotion objects. Obtains from each GroundMotion, the velocity and acceleration for the time specified. These values are placed in two Vectors of size equal to the number of GroundMotion objects. For each node in the Domain addInertiaLoadToUnbalance() is invoked with the acceleration Vector objects. SIMILAR OPERATION WITH VEL and ACCEL NEEDS TO BE INVOKED ON ELEMENTS .. NEED TO MODIFY ELEMENT INTERFACE Adds the GroundMotion, theMotion to the list of GroundMotion objects.","title":"EarthquakePattern\n"},{"location":"developer/architecture/class_interface/domain/pattern/LoadPattern/","text":"LoadPattern #include <domain/pattern/LoadPattern.h> class LoadPattern : public DomainComponent TaggedObject MovableObject DomainComponent The LoadPattern class is a concrete base class. A LoadPattern is a container class for Load and SP_Constraint objects. Each LoadPattern object is associated with a TimeSeries object which, for a given pseudo time, will return the appropriate load factor to be applied to the load in the LoadPattern. // Constructors // Destructor // Public Methods The integer tag is passed to the DomainComponent classes constructor. Creates three ArrayOftaggedObjects objects to store pointers to the NodalLoad, ElementalLoad and SP_Constraints and three iters. If not enough memory is available for these objects an error message is printed and the program is terminated. This is the constructor provided for subclasses to use. The integers tag and classTag are passed to the DomainComponent classes constructor. Invokes the destructor on the TimeSeries object. Also invokes the destructor on any objects created in the constructor for storage of the pointers and for iters. It does not invoke the destructor on these objects, the Domain object is responsible for doing this. If a TimeSeries object is associated with the pattern, the destructor is invoked on that TimeSeries object. It then sets the TimeSeries object associated with the LoadPattern to theSeries . If any loads or constraint objects exist in the LoadPattern, the LoadPattern will invoke setDomain() on those objects. Finally invokes the DomainComponent classes setDomain() method. Adds the NodalLoad object pointed to by theLoad to the LoadPattern. If the LoadPattern could add the pointer to its storage object for nodal loads, it will invoke setDomain() and setLoadPattern() on the load object if a Domain has been set. Adds the ElementalLoad pointed to by theLoad to the LoadPattern. If the LoadPattern could add the pointer to its storage object for elemental loads, it will invoke setDomain() and setLoadPattern() on the load object if a Domain has been set. Adds the SP_Constraint pointed to by theSp to the LoadPattern. If the LoadPattern could add the pointer to its storage object for single-point constraints, it will invoke setDomain() and setLoadPattern() on the constraint object if a Domain has been set. Returns an iter to the nodal loads in the LoadPattern. Returns an iter to the elemental loads in the LoadPattern. Returns an iter to the single-point constraints in the LoadPattern. To remove the nodal load whose identifier is given by tag from the LoadPattern and sets the loads associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To remove the elemental load whose identifier is given by tag from the LoadPattern and set the loads associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To remove the single-point constraint whose identifier is given by tag from the LoadPattern and st its associated Domain object to 0 . Returns a pointer to the load if successfully removed, otherwise 0 is returned. To apply the load for the pseudo time pseudoTime . From the associated TimeSeries object the LoadPattern will obtain a current load factor for the pseudo time. It will then invoke applyLoad ( load factor ) on the loads and applyConstraint ( load factor ) on the single-point constraints in the LoadPattern. If setLoadConstant() has been invoked, the saved load factor is used and no call is made to the TimeSeries object. If no TimeSeries is associated with the object a load factor of 0.0 is used. Marks the LoadPattern as being constant. Subsequent calls to applyLoad() will use the current load factor. Creates a vector of size 4 into which it places the current load factor, the mark indicating whether LoadPattern is constant, and the database tag and class tag of the TimeSeris object. Invokes sendVector() on the Channel object and sendSelf() on the TimeSeries object. Does the mirror image of sendSelf() . Invokes Print ( s , flag ) on the TimeSeries, NodalLoads, ElementalLoads and SP_Constraints.","title":"LoadPattern\n"},{"location":"developer/architecture/class_interface/domain/pattern/TimeSeries/","text":"TimeSeries #include <domain/pattern/TimeSeries.h> class TimeSeries : public DomainComponent MovableObject The TimeSeries class is an abstract base class. A TimeSeries object is used in a LoadPattern to determine the current load factor to be applied to the loads and constraints for the time specified. Constructor ### Destructor // Pure Virtual Public Methods The integer classTag is passed to the MovableObject classes constructor. Does nothing. To return the current load factor for the given value of pseudoTime to be applied to the loads and single-point constraints in a LoadPattern based on the value of pseudoTime . To print to the stream s output based on the value of flag .","title":"TimeSeries\n"},{"location":"developer/architecture/class_interface/element/Element/","text":"Element NEED TO ADD ADD_INERTIA_LOAD TO INTERFACE .. SEE EARTHQUAKE_PATTERN CLASS. #include <element/Element.h> class Element : public DomainComponent TaggedObject MovableObject Element is an abstract class, i.e. no instances of Element will exist. The element class provides the interface that all element writers must provide when introducing new element classes. Constructor & Destructor To construct an element whose unique integer among elements in the domain is given by tag , and whose class identifier is given by classTag . Both of these integers are passed to the DomainComponent constructor. The destructor. Declared as virtual to allow subclass destructors to be invoked. Public Methods dealing with Nodes and dof Public Methods dealing with State Public Methods for obtaining Linearized Stiffness, Mass and Damping Matrices Public Methods for obtaining Resisting Forces methods for obtaining information specific to an element To return the number of external nodes associated with the element. To return an ID containing the tags of the external nodes for the element. To return the number of dof associated with the element. This should equal the sum of the dofs at each of the external nodes. To ensure this, each subclass can overwrite the DomainComponent classes setDomain() method. virtual int commitState ( void ) = 0 ; The element is to commit its current state. To return \\(0\\) if successful, a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; The element is to set it\u2019s current state to the last committed state. To return \\(0\\) if successful, a negative number if not. virtual int revertToStart ( void ) = 0 ; The element is to set it\u2019s current state to the state it was at before the analysis started. To return \\(0\\) if successful, a negative number if not. virtual int update ( void ); This method is invoked after the response quantities have been updated in the Domain, but not necessarily committed, e.g. during a non-linear Newton-Raphson solution algorithm. To return \\(0\\) if successful, a negative number if not. This base class implementation returns \\(0\\) . virtual bool isSubdomain ( void ); The element is to return true if the element is of type (or subtype) Subdomain, else the element should return false. This base class implementation returns \\(false\\) . virtual Matrix & getTangentStiff ( void ) = 0 ; To return the tangent stiffness matrix. The element is to compute its stiffness matrix based on the original location of the nodes and the current trial displacement at the nodes. \\[{\\bf K}_e = {\\frac{\\partial {\\bf F}_{R_i}}{\\partial \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual Matrix & getSecantStiff ( void ) = 0 ; To return the elements secant stiffness matrix. The element is to compute its stiffness matrix based on the original location of the nodes and the current trial displacement at the nodes. THIS SECANT MAY BE REMOVED. virtual Matrix & getDamp ( void ) = 0 ; To return the damping matrix. The element is to compute its damping matrix based on the original location of the nodes and the current trial response quantities at the nodes. \\[{\\bf C}_e = {\\frac{\\partial {\\bf F}_{R_i}}{\\partial \\dot \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual Matrix & getMass ( void ) = 0 ; To return the mass matrix. The element is to compute its mass matrix based on the original location of the nodes and the current trial response quantities at the nodes. \\[{\\bf M}_e = {\\frac{\\partial {\\bf F}_{I_i}}{\\partial \\ddot \\U} \\vert}_{{\\bf U}_{trial}}\\] virtual void zeroLoad ( void ) = 0 ; This is a method invoked to zero the element load contributions to the residual, i.e. \\({\\bf P}_e = \\zero\\) virtual Vector & getResistingForce ( void ) = 0 ; Returns the resisting force vector for the element. This is equal to the applied load due to element loads minus the loads at the nodes due to internal stresses in the element due to the current trial displacement, i.e. \\[{\\bf R}_e = {\\bf P}_{e} - {\\bf F}_{R_e}({\\bf U}_{trial})\\] virtual Vector & getResistingForceIncInertia ( void ) = 0 ; Returns the resisting force vector for the element with inertia forces included. This is equal to the applied load due to element loads (loads set using addLoad() , minus the loads at the nodes due to internal stresses in the element due to the current trial response quantities, i.e. \\[{\\bf R}_e = {\\bf P}_e - {\\bf F}_{I_e} (\\ddot {\\bf U}_{trial}) - {\\bf F}_{R_e}(\\dot {\\bf U}_{trial}, {\\bf U}_{trial})\\] setResponse() is a method invoked to determine if the element will respond to a request for a certain of information. The information requested of the element is passed in the array of char pointers argv of length em argc. If the element does not respond to the request a \\(-1\\) is returned. If it does respond, an integer value greater than or equal to \\(0\\) is returned. This is the responseID passed in the getResponse() method. In addition the Element object is responsible for setting the Information object eleInformation with the type of the return, i.e. IntType, DoubleType, MatrixType, VectorType, IDType , and for creating a Matrix, Vector or ID object for the Information object, if the information to be returned is of any of these types. The information object is responsible for invoking the destructor on these objects. The base class responds to no requests and will always return \\(-1\\) . getResponse is a method invoked to obtain information from an analysis. The method is invoked with the integer argument returned and the Information object that was prepared in a successful setResponse() method invocation. To return \\(0\\) if successful, a negative number if not. The base class implementation will always return \\(-1\\) .","title":"Element\n"},{"location":"developer/architecture/class_interface/element/ElementalLoad/","text":"ElementalLoad #include <element/ElementalLoad.h> class ElementalLoad: public Load TaggedObject MovableObject DomainComponent Load ElementalLoad is an abstract class, i.e. no instances of ElementalLoad will exist. The ElementalLoad class provides the interface that all ElementalLoad writers must provide when introducing new ElementalLoad classes. // Constructors // Destructor // Public Methods Provided to allow subclasses to construct an ElementalLoad object associated with the Element whose unique identifier in the Domain will be elementTag . The integers tag and and classTags are passed to the Load constructor. Provided so that a FEM_ObjectBroker can construct an object. \\(0\\) and classTag are passed to the Load classes constructor. The data for the object is filled in when recvSelf() is invoked on the object. Does nothing. Provided so that the ElementalLoad subclasses destructor will be called. Returns the integer elementTag passed in the constructor.","title":"ElementalLoad\n"},{"location":"developer/architecture/class_interface/element/beamWithHinges/BeamWithHinges2D/","text":"NEED TO ADD ADD_INERTIA_LOAD TO INTERFACE .. SEE EARTHQUAKE_PATTERN CLASS. BeamWithHinges2D #include <element/BeamWithHinges2D.h> class BeamWithHinges2D : public DomainComponent \\ TaggedObject \\ MovableObject \\ DomainComponent \\ Element \\ BeamWithHinges2D is a beam-column element which uses the force based formulation for its state determination. This element has material non-linear hinges at both ends and exhibits linear elastic behavior through its interior region, including linear elastic shear effects. Constructors ### Destructor // Public Methods dealing with Nodes and dof // Public Methods dealing with State // Public Methods for obtaining Linearized Stiffness, Mass and Damping Matrices // Public Methods for obtaining Resisting Forces Constructs a BeamWithHinges2D object with tag tag , unique among all elements in the domain. The end nodes of the element are set to be those with tags nodeI and nodeJ . The elastic properties of the interior beam region are set to be E , the modulus of elasticity; I , the second moment of area of the beam cross-section; A , the beam cross-sectional area; G , the shear modulus; and alpha , the cross-section shape factor for elastic shear effects. Element hinges are created by obtaining copies of sectionI and sectionJ . The hinge lengths are specified as ratios of the total element length, ratioI and ratioJ . The element distributed load (reference value) is set to be distrLoad , and the element mass density per unit length is massDens . Constructs a BeamWithHinges2D object with tag tag , unique among all elements in the domain. The end nodes of the element are set to be those with tags nodeI and nodeJ . The elastic properties of the interior beam region are set to be E , the modulus of elasticity; I , the second moment of area of the beam cross-section; A , the beam cross-sectional area; G , the shear modulus; and alpha , the cross-section shape factor for elastic shear effects. Element hinges are created by obtaining copies of sectionI and sectionJ . The hinge lengths are specified as ratios of the total element length, ratioI and ratioJ . The element mass density per unit length is massDens . Constructs a blank BeamWithHinges2D object. Invokes the section destructors. Returns 2, the number of external nodes for this element. Returns an ID containing the tags of the two external nodes for this element. Returns 6, the number of degrees of freedom for this element. int commitState ( void ); Invokes commitState() on each section and returns the sum of the result of these invocations. int revertToLastCommit ( void ); Invokes revertToLastCommit() on each section and returns the sum of the result of these invocations. int revertToStart ( void ); Invokes revertToStart() on each section and returns the sum of the result of these invocations. const Matrix & getTangentStiff ( void ); Computes the element flexibility matrix, then returns its inverse, the element stiffness matrix. The element flexibility is the sum of the hinge flexibilities, \\(\\mathbf{f}_I\\) and \\(\\mathbf{f}_J\\) , and the elastic flexibility of the beam interior, \\(\\mathbf{f}_{mid}\\) . \\[\\label{eq:fele} \\fbas := \\int_{0}^{L}{\\bint^T \\fsec \\bint \\: dx} = \\mathbf{f}_I + \\mathbf{f}_{mid} + \\mathbf{f}_J\\] The flexibility of the beam interior is obtained in closed form, \\[\\mathbf{f}_{mid} = \\int_{l_I}^{L-l_J}{\\bint^T \\fsec_{mid} \\bint \\: dx}\\] where \\(\\bint\\) is the force interpolation matrix, \\[\\bint := \\left[ \\begin{array}{c c c} 1 & 0 & 0 \\\\ 0 & \\frac{x}{L} & \\frac{x}{L} - 1 \\\\ 0 & \\frac{1}{L} & \\frac{1}{L} \\end{array} \\right]\\] and \\(\\fsec\\) is the elastic section flexibility of the beam interior. \\[\\fsec_{mid} = \\left[ \\begin{array}{c c c} \\frac{1}{EA} & 0 & 0 \\\\ 0 & \\frac{1}{EI} & 0 \\\\ 0 & 0 & \\frac{1}{\\alpha GA} \\end{array} \\right]\\] The hinge flexibilities, \\(\\mathbf{f}_I\\) and \\(\\mathbf{f}_J\\) , are obtained by the midpoint integration rule, \\[{\\mathbf{f}}_i = \\bint(x_i)^T \\fsec_i \\bint(x_i) * l_i, \\:\\: i=I,J\\] where \\(x_i\\) is the midpoint of hinge \\(i\\) , measured along the length of the beam, and is the point at which the force interpolation matrix, \\(\\bint\\) is evaluated. The flexiblity, \\(\\fsec_i\\) , is obtained from the constitutive relation for section \\(i\\) . The element stiffness is then obtained by inversion of the element flexibility, given by Equation [eq:fele] . \\[\\label{eq:kele} \\kbas = \\fbas^{-1}\\] The element then obtains the matrix, \\(\\mathbf{A}\\) , which transforms the element basic stiffness from its corotating frame to the global frame of reference. The transformed stiffness matrix, \\(\\kele\\) , is then assembled into the structural system of equations. \\[\\kele = \\mathbf{A}^T \\kbas \\mathbf{A}\\] const Matrix & getSecantStiff ( void ); To return the elements secant stiffness matrix. THIS SECANT MAY BE REMOVED. const Matrix & getDamp ( void ); To return the damping matrix. const Matrix & getMass ( void ); Returns the element lumped mass matrix, \\(\\mele\\) . It is assumed that the mass density per unit length, \\(\\rho\\) , is constant along the entire element, including the hinge regions. \\[\\label{eq:mele} \\mele = \\left[ \\begin{array}{c c c c c c} \\frac{\\rho L}{2} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{\\rho L}{2} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{\\rho L}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{\\rho L}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\end{array} \\right]\\] void zeroLoad ( void ); This is a method invoked to zero the element load contributions to the residual. const Vector & getResistingForce ( void ); Returns the element resisting force vector. The basic element force vector is obtained as the product of the basic element stiffness, \\(\\kbas\\) , given by Equation [eq:kele] , and the basic element deformations, \\(\\vbas\\) . \\[\\qbas = \\kbas \\vbas\\] The basic element force vector is then transformed from the corotating frame to the global frame of reference. The transformed force vector is then assembled into the structural system of equations. \\[\\label{eq:qele} \\qele = \\mathbf{A}^T \\qbas\\] const Vector & getResistingForceIncInertia ( void ); Returns the element resisting force vector, \\(\\tilde{\\qele}\\) with inertia forces included, \\[\\tilde{\\qele} = \\qele - \\mele \\ddot{\\mathbf u}\\] where \\(\\qele\\) and \\(\\mele\\) are obtained from Equations [eq:qele] and [eq:mele] , respectively, and \\(\\ddot{\\mathbf u}\\) is the vector of trial nodal accelerations for the element.","title":"BeamWithHinges2D\n"},{"location":"developer/architecture/class_interface/element/zeroLength/ZeroLength/","text":"ZeroLength #include <element/ZeroLength.h> class ZeroLength: public Element TaggedObject MovableObject DomainComponent Element The ZeroLength class represents an element defined by two nodes at the same geometric location, hence it has zero length. The nodes are connected by of uniaxial materials to represent the force-deformation relationship for the element. ZeroLength elements are constructed with a tag in a domain of dimension 1, 2, or 3, connected by nodes Nd1 and Nd2 . The vector x defines the local x-axis for the element and the vector yprime lies in the local x-y plane for the element. The local z-axis is the cross product between x and yprime , and the local y-axis is the cross product between the local z-axis and x . Constructors ### Destructor // public methods to obtain information about dof & connectivity // public methods to set the state of the element // public methods to obtain stiffness, mass, damping and residual information // public methods for element output Construct a ZeroLength element with tag . The force-deformation relationship for the element is given by a pointer theMaterial to a UniaxialMaterial model acting in local direction . The local direction is 1, 2, 3, for translation in the local x, y, z axes or 4, 5, 6 for rotation about the local x, y, z axes. Construct a ZeroLength element with tag . The force-deformation relationship is given by the n1dMat pointers theMaterial to UniaxialMaterial models. direction is an ID of length n1dMat that gives the local direction for each corresponding entry in the array theMaterial The local direction is 1, 2, 3, for translation in the local x, y, z axes or 4, 5, 6 for rotation about the local x, y, z axes. This is the constructor invoked by an FEM_ObjectBroker object. It constructs an empty ZeroLength element with two nodes. The recvSelf() method is invoked on the object for it to set the internal data. Element destructor deletes memory for storing material model pointers. Returns 2. Return ID of size \\(2\\) with the node tags defining the element. Return the number of DOF for the element, which depends on the dimension of the problem and the number of DOF associated with each node. Initialize element and define data structures. Commit state of element by committing state of materials. Return 0 if successful, !0 otherwise. Revert state of element to last commit by reverting to last committed state of materials. Return 0 if successful, !0 otherwise. Revert state of element to initial state by reverting to initial state of materials. Return 0 if successful, !0 otherwise. Return tangent stiffness matrix for element. Return secant stiffness matrix of element. The secant stiffness is defined by the secant for the materials. Return a zero damping matrix. Return a zero mass matrix. The element has no loads, so this operation has no effect. The element has no loads, so this operation has no effect and returns 0. The element has no mass, so this operation has no effect and returns 0. Return resisting force vector. Return resisting force vector with inertia included. Send information about element over a channel. Receive information about element over a channel. Display element. Print information about element. Set response quantities as \"force\", \"deformation\", \"material\", or \"stiff\". Return response ID or -1 if error. Currently, only the one uniaxial material can be set. Get response information for responseID . Return 0 if successful, -1 otherwise.","title":"ZeroLength\n"},{"location":"developer/architecture/class_interface/element/zeroLength/ZeroLengthSection/","text":"ZeroLengthSection #include <element/zeroLength/ZeroLengthSection.h> class ZeroLengthSection : public Element TaggedObject MovableObject DomainComponent Element The ZeroLengthSection class represents an element defined by two nodes at the same geometric location, hence it has zero length. The nodes are connected by a SectionForceDeformation object which represents the force-deformation relationship for the element. ZeroLengthSection elements are constructed with a tag in a domain of dimension 2 or 3, connected by nodes Nd1 and Nd2 . The vector x defines the local x-axis for the element and the vector yprime lies in the local x-y plane for the element. The local z-axis is the cross product between x and yprime , and the local y-axis is the cross product between the local z-axis and x . Constructors Destructor // public methods to obtain information about dof & connectivity // public methods to set the state of the element // public methods to obtain stiffness, mass, damping and residual information // public methods for element output Construct a ZeroLengthSection element with tag . The force-deformation relationship for the element is obtained by invoking getCopy() on the SectionForceDeformation pointer theSection . The section model acts in the local space defined by the x and yprime vectors. The section axial force-deformation acts along the element local x-axis and the section y-z axes directly corresponsd to the local element y-z axes. This is the constructor invoked by an FEM_ObjectBroker object. It constructs an empty ZeroLengthSection element with two nodes. The recvSelf() method is invoked on the object for it to set the internal data. Element destructor deletes memory for storing the section model pointer. Returns 2. Return ID of size \\(2\\) with the node tags defining the element. Return the number of DOF for the element, which depends on the dimension of the problem and the number of DOF associated with each node. Initialize element and define data structures. Sets up the element transformation matrix, \\(A\\) , which defines the kinematic relationship between nodal displacements and section deformations. Commit state of element by committing state of the section. Return 0 if successful, !0 otherwise. Revert state of element to last commit by reverting to last committed state of the section. Return 0 if successful, !0 otherwise. Revert state of element to initial state by reverting to initial state of the section. Return 0 if successful, !0 otherwise. Return tangent stiffness matrix for element. The element tangent is computed from the section tangent matrix, \\(k_b\\) , as \\(K_e = A^T k_b A\\) . The section tangent is obtained by calling getSectionTangent() . Returns the tangent stiffness matrix for the element as the secant stiffness is not defined for SectionForceDeformation objects. Return a zero damping matrix. Return a zero mass matrix. The element has no loads, so this operation has no effect. The element has no loads, so this operation has no effect and returns 0. The element has no mass, so this operation has no effect and returns 0. Return resisting force vector for element. The element resisting force is computed from the section stress resultants, \\(s\\) , as \\(P_e = A^T s\\) . The section stress resulant is obtained by calling getStressResultant() . Returns the result of getResistingForce() as there is no element mass. Send information about element and the section over a channel. Receive information about element and section from a channel. Display element. Prints the element node tags and section model to the stream em s. Currently returns -1. Currently returns -1.","title":"ZeroLengthSection\n"},{"location":"developer/architecture/class_interface/graph/","text":"Graph Classes In this work Graphs are used for three purposes: to provide information on the sparsity of the system of equation to the SystemofEqn object, to provide the connectivity of the DOF_Group objects for determining a good mapping between degrees-of-freedom and equation numbers. to provide information on the connectivity both the Elements and Nodes in the Domain, which can be useful for example in partitioning. The classes provided include Graph, Vertex, GraphNumberer and GraphPartitioner. There is no Edge class provided at present. In current design each Vertex stores in an ID the tag of all it\u2019s adjacent Vertices, this may change. For graph numbering and partitioning this has to date proved sufficient. Graph Vertex GraphNumberer RCM GraphPartitioner Metis","title":"Graph Classes\n"},{"location":"developer/architecture/class_interface/graph/graph/ArrayGraph/","text":"UNDER CONSTRUCTION - removeVertex & printSpecial NEED TO BE ADDED. ArrayGraph #include <graph/graph/ArrayGraph.h> class ArrayGraph: public Graph Graph ArrayGraph is a subtype of Graph. The vertices for this type of graph are held in a simple array data structure whose initial size is specified at construction. This size can increase if needed. The array storage scheme is more efficient than a List storage scheme in terms of accessing the vertices; in very large problems where memory is limited this type of scheme may have problems getting enough contiguous meory in which case a List might be a better choice. There is a question as to whether or not the public methods should be declared as virtual. Good OOP programming would have all methods declared as virtual, however as subclasses cannot gain access to the private member data there does not seem to be much point in declaring them, except for the destructor, virtual in this instance. Constructors ### Destructor // Public Methods // Protected Methods To construct an empty ArrayGraph. Creates a Vertex ** array, theVertices of size arraySize and sets the number of vertices, numVertex , and number of edges numEdge to \\(0\\) . If it fails to get an array of appropriate size it sets its arraySize to \\(0\\) ; subclasses can check if successfull construction by invoking the protected member function getArraySize() . Goes through theVertices and anywhere it finds a non-zero pointer, invokes the vertex destructor on that pointer. It then invokes the destructor on theVertices array. Method to add a vertex to the graph. If the adjacency list of the vertex is not empty the graph will first check to see all vertices in the the the vertices adjacency list exist in the graph before the vertex is added. It then checks if it neeeds a new array and if so creates one, i.e. if the arraySize \\(=\\) numVertex it creates a new array, whose size is double the original and copies the pointers to the vertices, before invoking delete() on the old array. It now tries to add the vertex in the array at location vertexTag . If this fails it adds at the first empty location it comes to. Returns a 0 if successfull addition, a \\(-1\\) otherwise and a message to opserr explaining the problem. virtual int addEdge(int vertexTag, int otherVertexTag); Causes the Graph to add an edge ( vertexTag , otherVertexTag ) to the Graph. A check is first made to see if vertices with tags given by vertexTag and otherVertexTag exist in the graph. If they do not exist a \\(-1\\) is returned, otherwise the method invokes addEdge() on each of the corresponding vertices in the graph. Returns \\(0\\) or a positive integer if sucessfull (positive if edge has already been added), a negative number if not. virtual Vertex \\ * getVertexPtr ( int vertexTag ); A method which returns a pointer to the vertex whose tag is given by vertexTag . The method first looks at location vertexTag for the vertex, otherwise it must search through the array until it finds the vertex it is looking for. If no such vertex exists in the graph \\(0\\) is returned. virtual VertexIter & getVertices ( void ); A method which first invokes reset() on the graphs ArrayVertexIter and then returns a reference to this iter. virtual int getNumVertex ( void ) const ; A method to return the number of vertices in the graph, returns numVertex. virtual int getNumEdge ( void ) const ; A method to return the number of edges in the graph, returns numEdge. virtual void Print ( OPS_Stream & s ) const = 0 ; A method to print the graph. It first prints out numVertex and numEdge and then on each newline prints the vertexTag and the edges for that vertex. It does this by going through theVertices array and invoking Print() on each non-zero pointer. A method to return the size of the graphs array.","title":"ArrayGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/DOFGraph/","text":"DOFGraph #include <DOFGraph.h> class DOFGraph : public ArrayGraph Graph ArrayGraph DOFGraph is a type of Graph. It is a graph of the DOF connectivity of the analysis model. It is utilised by a SystemOfEqn object to determine the sparsity of the system. It is a subtype of ArrayGraph, though it could just as easily be a subtype of any other type of Graph subclass that fully implements the graph interface. The constructor is responsible for constructing the graph given theModel . It creates the vertices of the graph, one for every DOF in the model and adds all edges based on the FE_Element connectivity. For this reason the model must be fully populated with the DOF_Group and FE_Element objects before the constructor is called. The superclass ArrayGraph is responsible for destroying the vertices.","title":"DOFGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/DOF_GroupGraph/","text":"DOF_GroupGraph #include <DOF_GroupGraph.h> class DOF_GroupGraph : public ArrayGraph Graph ArrayGraph DOF_GroupGraph is a type of Graph. It is a graph of the DOF_Group connectivity of the analysis model. It is utilised by the DOF_Numberer to assign equation numbers to the individual DOFs in the DOF_Groups of the model. It is a subtype of ArrayGraph, though it could just as easily be a subtype of any other type of Graph subclass that fully implements the graph interface. The constructor is responsible for constructing the graph given theModel . It creates the vertices of the graph, one for every equation (each DOF that has not been constrained out by the constraint handler) in the model and adds all edges based on the FE_Element connectivity. For this reason the model must be fully populated with the DOF_Group_Group and FE_Element objects before the constructor is called. The superclass ArrayGraph is responsible for destroying the vertices.","title":"DOF_GroupGraph\n"},{"location":"developer/architecture/class_interface/graph/graph/Graph/","text":"Graph #include <graph/graph/Graph.h> class Graph: Graph is a base class. A Graph is a container class responsible for holding the vertex set and edge set. The class is responsible for: providing methods to add vertices and edges. accessing the vertices and edges. All the methods for the class are declared as virtual to allow subclasses to be introduced. Constructors ### Destructor // Public Methods To create an empty Graph. Creates an ArrayOfTagged object of initial size \\(32\\) in which to store the Vertices. The ArrayOfTagged object is used to store the Vertices. To create an empty Graph. Creates an ArrayOfTagged object of initial size numVertices in which to store the Vertices. The ArrayOfTagged object is used to store the Vertices. To create an empty Graph. The theVerticesStorage object is used to store the Vertices. clearAll() is invoked on this object to ensure it is empty. Invokes clearAll() on the storage object used to store the Vertices. It then invokes delete on the storage object used, which was either passed or created in the constructor. Causes the graph to add a vertex to the graph. If checkAdjacency is true , a check is made to ensure that all the Vertices in the adjacency list of the Vertex are in the Graph. If a vertex in the adjacency is not in the Graph the vertex is not added, a warning message is printed and false is returned. If successful, returns the result of invoking addComponent() on the TaggedStorage object used to store the Vertices. virtual int addEdge(int vertexTag, int otherVertexTag); Causes the Graph to add an edge ( vertexTag , otherVertexTag ) to the Graph. A check is first made to see if vertices with tags given by vertexTag and otherVertexTag exist in the graph. If they do not exist a \\(-1\\) is returned, otherwise the method invokes addEdge() on each of the corresponding vertices in the graph. Increments numEdge by \\(1\\) and returns \\(0\\) if sucessfull, a \\(1\\) if the edge already existed, and a \\(-2\\) if one addEdge() was successful, but the other was not. virtual Vertex \\ * getVertexPtr ( int vertexTag ); A method which returns a pointer to the vertex whose tag is given by vertexTag . If no such vertex exists in the graph \\(0\\) is returned. Invokes getComponentPtr(vertexTag) on the vertex storage object and casts this to a Vertex * if not null. virtual VertexIter & getVertices ( void ); A method which returns a reference to the graphs VertexIter. This iter can be used for iterating through the vertices of the graph. virtual int getNumVertex ( void ) const ; A method to return the number of vertices in the graph. Invokes getNumComponents() on the Vertex storage object. virtual int getNumEdge ( void ) const ; A method to return the number of edges in the graph, returns numEdge . To remove the Vertex from the Graph whose tag is equal to vertexTag . If removeEdgeFlag is true will also remove the Vertex from the remaining Vertices adjacency lists. returns a pointer to the removed Vertex if successful, \\(0\\) if the Vertex was not in the Graph. Invokes removeComponent(vertexTag) on the vertex storage object and casts this to a Vertex * if not null. DOES NOT YET DEAL WITH removeEdgeFlag . virtual void Print ( OPS_Stream & s , int flag = 0 ); A method to print the graph. Invokes Print ( s , flag ) on the vertex storage object. Invokes Print() on the Graph G .","title":"Graph\n"},{"location":"developer/architecture/class_interface/graph/graph/Vertex/","text":"Vertex #include <graph/graph/Vertex.h> class Vertex : public TaggedObject ; Vertex is the abstraction of a vertex in a graph. It has a color, weight and a temporary integer value associated with it. Also associated with it is an integer reference, which can be used to identify an object of some type the vertex is representing and in integer temporary variable for algorithms which work with graphs. // Constructor // Destructor // Public Methods . Construct a Vertex whose tag, reference, weight and color are as given by the arguments. The degree of the vertex is set to \\(0\\) . The integer *tag* is passed to the TaggedObject classes constructor. Does nothing. To set the weight of the vertex to *newWeight* virtual void setColor ( int newColor ); To set the color of the vertex to *newColor* virtual void setTmp ( int newTmp ); To set the temporary variable of the vertex to *newTmp* virtual int getTag ( void ) const ; . Returns the vertices tag. virtual int getRef ( void ) const ; Returns the vertices integer reference. virtual double getWeight ( void ) const ; Returns the vertices weight. virtual int getColor ( void ) const ; Returns the vertices color. virtual int getTmp ( void ) const ; Returns the vertices temporary variable. virtual int addEdge ( int otherTag ); If the adjacency list for that vertex does not already contain otherTag , otherTag is added to the adjacency list and the degree of the vertex is incremented by \\(1\\) . Returns a \\(0\\) if sucessfull, a \\(1\\) if edge already existed and a negative number if not. Note that no check is done by the vertex to see that a vertex with otherTag exists in the graph. The adjacency list for a Vertex is stored in an ID object containing the adjacent Vertices tags. A check is made to see if otherTag is in this ID using getLocation() , if it needs to be added the * \\[degree\\] * operator is invoked on the ID. virtual int getDegree ( void ) const ; Returns the vertices degree. virtual const ID & getAdjacency ( void ) const ; Returns the vertices adjacency list, this is returned as an ID whose components are tags for vertices which have been successfully added. virtual void Print ( OPS_Stream & s , int flag = 0 ); Prints the vertex. If the flag = 0 only the vertex tag and adjacency list is printed. If the flag =1 the vertex tag, weight and adjacency are printed. If the flag =2 the vertex tag, color and adjacency are printed. If the flag =3 the vertex tag, weight, color and adjacency are printed.","title":"Vertex\n"},{"location":"developer/architecture/class_interface/graph/numberer/GraphNumberer/","text":"GraphNumberer #include <graph/numberer/GraphNumberer.h> class GraphNumberer : public MovableObject ; RCM MinDegree GraphNumberer is an abstract class. The GraphNumberer class defines the interface that all programmers must provide when introducing new GraphNumberer subclasses. A GraphNumberer is an algorithmic class for numbering the Vertices of a Graph; that is assigning a unique integer value ( \\(0\\) through numVertex \\(-1\\) ) to each Vertex (uses tmp variable of Vertex) of the Graph. Constructor Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. Does nothing. This is the method invoked to perform the graph numbering, that is to assign a unique integer \\(1\\) through numVertex , to each Vertex in the Graph. Returns an ordered ID containing the vertex references in the order of the numbering, i.e. \\(ID(0)\\) contains the integer reference for the vertex assigned the number 1, \\(ID(1)\\) contains the integer reference for the vertex assigned the number 2 and so on. A side effect of the numbering is that the Tmp variable of each vertex is set to the number assigned to that vertex. If lastVertex is not \\(-1\\) the Vertex whose tag is given by lastVertex should be numbered last (it does not have to be though THIS MAY CHANGE). This is the method invoked to perform the graph numbering, that is to assign a unique integer \\(1\\) through numVertex , to each Vertex in the Graph. Returns an ordered ID containing the vertex references in the order of the numbering, i.e. \\(ID(0)\\) contains the integer reference for the vertex assigned the number 1, \\(ID(1)\\) contains the integer reference for the vertex assigned the number 2 and so on. A side effect of the numbering is that the Tmp variable of each vertex is set to the number assigned to that vertex. lastVertices is used as a hint to indicate that these Vertices should be numbered last (they do not have to be though THIS MAY CHANGE).","title":"GraphNumberer\n"},{"location":"developer/architecture/class_interface/graph/partitioner/GraphPartitioner/","text":"GraphPartitioner #include <graph/partitioner/GraphPartitioner.h> class GraphPartitioner ; Metis GraphPartitioner is an abstract class. The GraphPartitioner class defines the interface that all programmers must provide when introducing new GraphPartitioner subclasses. A GraphPartitioner is an algorithm for partitioning (coloring) the vertices of a graph; that is assigning a color (1 through the number of partitions) to each vertex of the graph. Constructor Destructor // Public Methods To construct a GraphPartitioner. This is the method invoked to partition the graph into numPart partitions. On completion of the routine each vertex will be assigned a color \\(1\\) through numPart , the color assigned indicating the partition to which the vertex belongs. Returns a \\(0\\) if successful, a negative number if not; the value depending on the subclass.","title":"GraphPartitioner\n"},{"location":"developer/architecture/class_interface/material/","text":"Material Classes Material classes are used to provide information to the Elements about the material. There is one main class MaterialModel. The Element objects query the MaterialModel objects to obtain the current value of stress and the tangent defining the stress-strain relationship for the current value of strain at the point in the domain represented by the MaterialModel object.","title":"Material Classes\n"},{"location":"developer/architecture/class_interface/material/ElasticIsotropicMaterial/","text":"ElasticIsotropicMaterial #include <material/nD/ElasticIsotropicMaterial.h> class ElasticIsotropicMaterial : public NDMaterial \\ TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial is an abstract class. It provides the interface to which all elastic isotropic material implementations must conform. It also serves as a prototype for all elastic isotropic material implementations, as described by the Prototype pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods To construct an ElasticIsotropicMaterial whose unique integer tag among NDMaterials in the domain is given by tag , and whose class tag is given by classTag . These tags are passed to the NDMaterial class constructor. Does nothing. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Outputs an error indicating this method is a subclass responsibility. Returns a specific implementation of an ElasticIsotropicMaterial by switching on type . Outputs an error if type is not valid. This is the prototype method.","title":"ElasticIsotropicMaterial\n"},{"location":"developer/architecture/class_interface/material/HystereticBackbone/","text":"HystereticBackbone // Description: This file contains the interface for HystereticBackbone, // which represents a backbone curve for hysteretic models. // // Written: MHS // Created: Aug 2000 // extern bool OPS_addHystereticBackbone ( HystereticBackbone * newComponent ); extern HystereticBackbone * OPS_getHystereticBackbone ( int tag ); extern void OPS_clearAllHystereticBackbone ( void ); class HystereticBackbone : public TaggedObject , public MovableObject { public : HystereticBackbone ( int tag , int classTag ); virtual ~ HystereticBackbone (); virtual double getStress ( double strain ) = 0 ; virtual double getTangent ( double strain ) = 0 ; virtual double getEnergy ( double strain ) = 0 ; virtual double getYieldStrain ( void ) = 0 ; virtual HystereticBackbone * getCopy ( void ) = 0 ; virtual int setVariable ( char * argv ); virtual int getVariable ( int varID , double & theValue ); virtual int setParameter ( char ** argv , int argc , Information & eleInformation ); virtual int updateParameter ( int responseID , Information & eleInformation ); protected : private : };","title":"HystereticBackbone\n"},{"location":"developer/architecture/class_interface/material/Material/","text":"PRESENTLY LITTLE IN THE INTERFACE .. THIS MAY CHANGE IF MAKE GENERAL i.e 1D, 2D and 3d PROBLEMS RETURN MATRICES AND VECTORS .. IF CHANGE, INTERFACE FOR UniaxialMaterial MAY THEN CHANGE. Material #include <material/Material.h> class Material: public TaggedObject, public MovableObject TaggedObject MovableObject Material is an abstract class. The Material class provides the interface that all Material writers must provide when introducing new Material subclasses. A Material object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. // Constructor // Destructor To construct a Material whose unique integer among Materials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the TaggedObject and MovableObject class constructors.","title":"Material\n"},{"location":"developer/architecture/class_interface/material/NDMaterial/","text":"INTERFACE MAY CHANGE IF MAKE MATERIAL MORE GENERAL. NDMaterial #include <material/nD/NDMaterial.h> class NDMaterial : public Material TaggedObject MovableObject Material NDMaterial is an abstract class. The NDMaterial class provides the interface that all NDMaterial writers must provide when introducing new NDMaterial subclasses. An NDMaterial object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. Constructor ### Destructor // Public Methods To construct a NDMaterial whose unique integer among NDMaterials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. Does nothing. Sets the value of the trial strain vector, that value used by getStress() and getTangent() , to be strain . To return \\(0\\) if successful and a negative number if not. To return the material stress vector at the current trial strain. To return the material tangent stiffness matrix at the current trial strain. To accept the current value of the trial strain vector as being on the solution path. To return \\(0\\) if successful, a negative number if not. To cause the material to revert to its last committed state. To return \\(0\\) if successful, a negative number if not. Invoked to cause the material to revert to its original state in its undeformed configuration. To return \\(0\\) if successful, a negative number if not. Returns a pointer to a new NDMaterial, which is an exact copy of this instance. It is up to the caller to ensure that the destructor is invoked.","title":"NDMaterial\n"},{"location":"developer/architecture/class_interface/material/UniaxialMaterial/","text":"UniaxialMaterial #include <material/UniaxialMaterial.h> class UniaxialMaterial : public Material TaggedObject MovableObject Material UniaxialMaterial is an abstract class. The UniaxialMaterial class provides the interface that all UniaxialMaterial writers must provide when introducing new UniaxialMaterial subclasses. A UniaxialMaterial object is responsible for keeping track of stress, strain and the constitution for a particular point in the domain. Constructor and Destructor UniaxialMaterial ( int tag , int classTag ); To construct a UniaxialMaterial whose unique integer among UniaxialMaterials in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. ~ UniaxialMaterial () Does nothing. Public Methods virtual int setTrialStrain ( double strain ) = 0 ; virtual int setTrialStrain ( double strain , double strainRate = 0 ) = 0 ; virtual int setTrialStrain ( double strain , double temperature , double strainRate ); virtual int setTrial ( double strain , double & stress , double & tangent , double strainRate = 0.0 ); virtual int setTrial ( double strain , double temperature , double & stress , double & tangent , double & thermalElongation , double strainRate = 0.0 ); Sets the value of the trial strain, that value used by getStress() and getTangent() , to be strain . Return \\(0\\) if successful, a negative number if not. virtual double getStress ( void ) = 0 ; To return the current value of stress for the trial strain. virtual double getTangent ( void ) = 0 ; To return the current value of the tangent for the trial strain. virtual double getInitialTangent ( void ) = 0 ; Return the initial tangent. virtual int commitState ( void ) = 0 ; To accept the current value of the trial strain as being on the solution path. To return \\(0\\) if successful, a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; To cause the material to revert to the state at the last commit. To return \\(0\\) if successful, a negative number if not. virtual int revertToStart ( void ) = 0 ; Invoked to cause the material to revert to its original state in its undeformed configuration. To return \\(0\\) if successful, a negative number if not. virtual UniaxialMaterial * getCopy ( void ) = 0 ; To return an exact copy of the material.","title":"UniaxialMaterial\n"},{"location":"developer/architecture/class_interface/material/mdMaterial/","text":"MaterialModel UniaxialMaterial ElasticMaterial ElasticPPMaterial ParallelMaterial Concrete01 Steel01 NDMaterial SectionForceDeformation GenericSection1D GenericSectionND ElasticSection2D ElasticSection3D FiberSection2D FiberSection3D","title":""},{"location":"developer/architecture/class_interface/material/section/ElasticSection3D/","text":"ElasticSection3D #include <material/section/ElasticSection3D.h> class ElasticSection3D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation ElasticSection3D provides the implementation of a section which exhibits uncoupled elastic behavior in axial, moment, shear, and torsion response. Constructor Destructor // Public Methods // Public Methods for Output To construct an ElasticSection3D with an integer identifier tag , an elastic modulus of \\(E\\) , a second moment of area about the local z-axis, \\(I_z\\) , a second moment of area about the local y-axis, \\(I_y\\) , a polar moment of intertia of \\(J\\) , a section area of \\(A\\) , an elastic shear modulus of \\(G\\) , and a shape factor of \\(\\alpha\\) . The integers tag and MAT_TAG_ElasticSection3D, defined in <classTags.h> , are passed to the SectionForceDeformation class constructor. Constructs a blank ElasticSection3D object. Does nothing. Sets the value of the section deformation vector, \\(\\esec\\) to be def . The section deformation vector, \\(\\esec\\) , is defined by \\[\\esec := \\left[ \\begin{array}{c} \\epsilon_a \\\\ \\kappa_z \\\\ \\kappa_y \\\\ \\gamma_y \\\\ \\gamma_z \\\\ \\phi \\end{array} \\right]\\] where \\(\\epsilon_a\\) is the axial strain, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\kappa_z\\) is the curvature about the local z-axis, \\(\\gamma_y\\) is the shear strain along the local y-axis, \\(\\gamma_z\\) is the shear strain along the local z-axis, and \\(\\phi\\) is the angle of twist. Returns \\(0\\) . Returns the current value of the section deformation vector, \\(\\esec\\) . Returns the section stress resultants, \\(\\ssec\\) , the product of the section stiffness matrix, \\(\\ksec\\) , and the section deformation vector, \\(\\esec\\) , \\[\\ssec = \\ksec \\esec = \\left[ \\begin{array}{c} P \\\\ M_z \\\\ M_z \\\\ V_y \\\\ V_y \\\\ T \\end{array} \\right]\\] where \\(P\\) is the axial force, \\(M_z\\) is the bending moment about the local z-axis, \\(M_y\\) is the bending moment about the local y-axis, \\(V_y\\) is the shear force along the local y-axis, \\(V_z\\) is the shear force along the local z-axis, and \\(T\\) is the torque. Returns the value of \\(\\ssec\\) calculated at the previous state determination. Returns the section stiffness matrix, \\(\\ksec\\) , where \\[\\ksec = \\left[ \\begin{array}{cccccc} EA & 0 & 0 & 0 & 0 & 0 \\\\ 0 & EI_z & 0 & 0 & 0 & 0 \\\\ 0 & 0 & EI_y & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\alpha GA & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\alpha GA & 0 \\\\ 0 & 0 & 0 & 0 & 0 & GJ \\end{array} \\right]\\] Returns the section stiffness matrix, \\(\\ksec\\) . Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) , where \\[\\fsec = \\left[ \\begin{array}{cccccc} \\frac{1}{EA} & 0 & 0 & 0 & 0 & 0 \\\\ 0 & \\frac{1}{EI_z} & 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{1}{EI_y} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\frac{1}{\\alpha GA} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\frac{1}{GJ} \\end{array} \\right]\\] Overrides the base class implementation and returns the section flexibility matrix, \\(\\fsec\\) . Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticSection3D object, constructed using the same values of tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the ordering of section response quantities. For this section, axial response is the first quantity, bending about the local z-axis is the second, bending about the local y-axis is the third, shear along the local y-axis is the fourth, shear along the local z-axis is the fifth, and torsion is the sixth. \\[code := \\left[ \\begin{array}{c} 2 \\\\ 1 \\\\ 4 \\\\ 3 \\\\ 5 \\\\ 6 \\end{array} \\right]\\] Returns 6. Creates a Vector of size \\(8\\) into which it places tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Invokes sendVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Returns \\(0\\) if successful, a warning message and a negative number are returned if the Channel object fails to send the Vector. Creates a Vector of size \\(8\\) . Invokes recvVector() on theChannel using the ElasticSection3D objects dbTag , the integer commitTag and the Vector as arguments. Using the data in the Vector to set its tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed and a negative number is returned if the Channel object fails to receive the Vector. Prints to the stream s the object\u2019s tag , \\(E\\) , \\(A\\) , \\(I_z\\) , \\(I_y\\) , \\(J\\) , \\(G\\) , and \\(\\alpha\\) values.","title":"ElasticSection3D\n"},{"location":"developer/architecture/class_interface/material/section/FiberSection/","text":"FiberSection This file contains the class definition for FiberSection.h. FiberSection provides the abstraction of a section discretized by fibers. The section stiffness and stress resultants are obtained by summing fiber contributions. class FiberSection : public SectionForceDeformation { public : FiberSection (); FiberSection ( int tag , int estNumFibers = 8 ); FiberSection ( int tag , int numFibers , Fiber ** fibers ); ~ FiberSection (); int setTrialSectionDeformation ( const Vector & deforms ); const Vector & getSectionDeformation ( void ); const Vector & getStressResultant ( void ); const Matrix & getSectionTangent ( void ); const Matrix & getInitialTangent ( void ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); SectionForceDeformation * getCopy ( void ); const ID & getType ( void ); int getOrder ( void ) const ; int sendSelf ( int cTag , Channel & theChannel ); int recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( const char ** argv , int argc , OPS_Stream & s ); int getResponse ( int responseID , Information & info ); int addFiber ( Fiber & theFiber ); protected : private : int numFibers ; // number of fibers in the section Fiber ** theFibers ; // array of pointers to fibers // that form the section int sizeFibers ; // size of the fibers array int order ; ID * code ; Vector * e ; // section trial deformations Vector * eCommit ; Vector * s ; // section resisting forces (axial force, bending moment) Matrix * ks ; // section stiffness int otherDbTag ; };","title":"FiberSection\n"},{"location":"developer/architecture/class_interface/material/section/SectionForceDeformation/","text":"SectionForceDeformation #include <material/section/SectionForceDeformation.h> class SectionForceDeformation : public Material TaggedObject MovableObject Material SectionForceDeformation provides the interface which all SectionForceDeformation models must implement. Constructor and Destructor SectionForceDeformation ( int tag , int classTag ); To construct a SectionForceDeformation object whose unique integer tag among SectionForceDeformation objects in the domain is given by tag , and whose class identifier is given by classTag . These integers are passed to the Material class constructor. ~ SectionForceDeformation () Does nothing. Public Methods virtual int setTrialSectionDeformation ( const Vector & def ) = 0 ; To set the value of the trial section deformation vector, \\(\\esec\\) to be def . To return \\(0\\) if successful, a negative number if not. virtual const Vector & getSectionDeformation ( void ) = 0 ; To return the trial section deformation vector, \\(\\esec\\) . virtual const Vector & getStressResultant ( void ) = 0 ; To return the section resisting forces, \\(\\ssec\\) , at the current trial state. virtual const Vector & getPrevStressResultant ( void ) = 0 ; To return the section resisting forces, \\(\\ssec\\) , from the previous trial state. virtual const Matrix & getSectionTangent ( void ) = 0 ; To return the section tangent stiffness matrix, \\(\\ksec\\) , at the current trial state. virtual const Matrix & getPrevSectionTangent ( void ) = 0 ; To return the section tangent stiffness matrix, \\(\\ksec\\) , from the previous trialstate. virtual const Matrix & getSectionFlexibility ( void ); Obtains the section tangent stiffness matrix, \\(\\ksec\\) , and returns its inverse, the section flexibility matrix, \\(\\fsec\\) , via an explicit matrix inversion. NOTE: The explicit matrix inversion provides default behavior and may be overridden in subclasses to suit specific SectionForceDeformation implementations. virtual const Matrix & getPrevSectionFlexibility ( void ); Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. NOTE: This function provides default behavior and may be overridden in subclasses to suit specific SectionForceDeformation implementations. virtual int commitState ( void ) = 0 ; To commit the section state. Returns \\(0\\) if successful and a negative number if not. virtual int revertToLastCommit ( void ) = 0 ; To revert the section to its last committed state. Returns \\(0\\) if successful and a negative number if not. virtual int revertToStart ( void ) = 0 ; To revert the section to its initial state. Returns \\(0\\) if successful and a negative number if not. virtual SectionForceDeformation * getCopy ( void ) = 0 ; To return a pointer to a new SectionForceDeformation object, which is a copy of this instance. It is up to the caller to ensure that the destructor is invoked. virtual const ID & getType ( void ) = 0 ; To return the section ID code that indicates the ordering and type of response quantities returned by the section. Lets the calling object (e.g. an Element) know how to interpret the quantites returned by this SectionForceDeformation model. virtual int getOrder ( void ) = 0 ; To return the number of response quantities provided by the section. Output int sendSelf ( int commitTag , Channel & theChannel ); FILL IN. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); FILL IN. void Print ( OPS_Stream & s , int flag = 0 ) = 0 ; To print section information to the stream s based on the value of flag .","title":"SectionForceDeformation\n"},{"location":"developer/architecture/class_interface/recorder/DatastoreRecorder/","text":"DatastoreRecorder #include <recorder/DatastoreRecorder.h> class DatastoreRecorder: public Recorder Recorder A DatastoreRecorder object is used in the program to invoke commitState() on an FE_Datastore object when commit() is invoked on a Domain. The class is included in the framework so that the Domain class does not have to be modified for FE_Datastore objects. // Constructor // Destructor // Public Methods Saves a pointer to the object theDatastore . Does nothing. Returns the result of invoking commitState(commitTag) on theDatastore object. Returns the result of invoking restoreState(commitTag) on theDatastore object. Does nothing.","title":"DatastoreRecorder\n"},{"location":"developer/architecture/class_interface/recorder/MaxNodeDispRecorder/","text":"MaxNodeDispRecorder #include <recorder/MaxNodeDispRecorder.h> class MaxNodeDispRecorder: public Recorder Recorder The MaxNodeDispRecorder class is used to store information about the absolute maximum nodal displacement at a number of specified Nodes for a specified degree of freedom during an analysis. // Constructor // Destructor // Public Methods Creates a \\(0\\) Vector object of size equal to the size of nodeTags to store the maximum nodal displacements and creates an ID object equal to nodeTags to store the Node tags. Does nothing. For each node in nodeTags the value of the dof \u2019th committed displacement is obtained. If the absolute value of this is greater than the value currently stored in the Vector of max displacements, the value in the Vector is updated. If no Node exists in theDomain with the tag or the Node does not have a dof \u2019th degree-of-freedom associated with it \\(0\\) is entered in the Vector. Returns \\(0\\) . Prints to opserr the Vector containing the maximum absolute nodal displacements. Note, at the end of the analysis, what is printed is independent of commitTag . Returns \\(0\\) . Zeros the Vector of maximum nodal displacements.","title":"MaxNodeDispRecorder\n"},{"location":"developer/architecture/class_interface/recorder/Recorder/","text":"Recorder #include <recorder/Recorder.h> class Recorder The Recorder class is an abstract class which is introduced to allow information to be saved during the analysis. The interface defines two pure virtual methods record() and playback() . record() is a method which is called by the Domain object during a commit() . The playback() method can be called by the analyst after the analysis has been performed. Public Methods virtual int record ( int commitTag , double timeStamp ) = 0 ; This is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. More specifically, the method is invoked by the Domain object after commit() has been invoked on all the domain component objects. What the Recorder records depends on the concrete subtype. virtual int setDomain(Domain &theDomain); This is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. virtual int domainChanged ( void ); this is a method called when something major has happened in the Domain, eg. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it\u2019s pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it will have been deleted and it\u2019s old pointer information will no longer be valid.) virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); These methods are called in parallel applications. When invoked the recorders send/recv information about what they are recording. virtual int restart ( void ); Invoked by the Domain object when revertToStart() is invoked on the Domain object. What the Recorder does depends on the concrete subtype. virtual double getRecordedValue ( int clmnId , int rowOffset , bool reset ) { return 0 ; } //added by SAJalali","title":"Recorder\n"},{"location":"developer/architecture/class_interface/system_of_eqn/","text":"Linear Algebra Linear algebraic operations","title":"Linear Algebra\n"},{"location":"developer/architecture/class_interface/system_of_eqn/Solver/","text":"Solver #include <system_of_eqn/Solver.h> class Solver: public MovableObject MovableObject Solver is an abstract class. A Solver object is responsible for performing the numerical operations on its associated SystemOfEqn object. The integer classTag is passed to the MovableObject classes constructor. Does nothing. Provided so the subclasses destructor will be called. Causes the solver to solve the system of equations. Returns \\(0\\) if successful , negative number if not; the actual value depending on the type of Solver.","title":"Solver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/SystemOfEqn/","text":"SystemOfEqn #include <system_of_eqn/SystemOfEqn.h> class SystemOfEqn : public MovableObject MovableObject LinearSOE EigenSOE SystemOfEqn is an abstract class. A SystemOfEqn object is responsible for storing the system of equations it represents. A Solver object, which is associated with the SystemOfEqn object, is responsible for performing the numerical operations to solve for the system of equations. The integer classTag is provided to the constructor for the MovableObject. Does nothing. Declared to allow the subclass destructor to be called. Invoked to cause the system of equation object to solve itself. To return \\(0\\) if successful, negative number if not.","title":"SystemOfEqn\n"},{"location":"developer/architecture/class_interface/system_of_eqn/eigenSOE/","text":"Eigen Equation Systems BandArpack SymArpack SymBandEigenSolver - Solve the GEP of a symmetric banded matrix using the LAPACK subroutine dsbevx . FullGenEigenSolver - Solve the GEP of a general banded matrix using the LAPACK subroutine dggev","title":"Eigen Equation Systems\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/","text":"Linear Equation Systems Linear Systems ( LinearSOE ) FullGenLinSOE BandGenLinSOE BandSPDLinSOE ProfileSPDLinSOE SparseGenColLinSOE SparseGenRowLinSOE UmfpackGenLinSOE SymSparseLinSOE Linear Solvers LinearSOESolver fullGEN FullGenLinSolver FullGenLinLapackSolver bandGEN BandGenLinSolver BandGenLinLapackSolver bandSPD BandSPDLinSolver BandSPDLinLapackSolver BandSPDLinThreadSolver profileSPD ProfileSPDLinSolver ProfileSPDLinDirectSolver ProfileSPDLinDirectBlockSolver ProfileSPDLinDirectThreadSolver ProfileSPDLinDirectSkypackSolver sparseGEN SparseGenColLinSolver SuperLU ThreadedSuperLU SparseGenRowLinSolver UmfpackGenLinSolver SymSparseLinSolver sparseSYM diagonal itpack umfGEN petsc cg","title":"Linear Equation Systems\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/DomainSolver/","text":"DomainSolver #include <system_of_eqn/linearSOE/DomainSolver.h> class DomainSolver: public LinearSOESolver MovableObject Solver LinearSOESolver DomainSolver is an abstract class. DomainSolver objects are responsible for performing the numerical operations required for the domain decomposition methods. Constructor ### Destructor // Public Methods classTag is needed by the LinearSOESolver objects constructor. Causes the condenser to form \\(A_{ee}^* = A_{ee} -A_{ei} A_{ii}^{-1} A_{ie}\\) , where \\(A_{ii}\\) is the first numInt rows of the \\(A\\) matrix. The original \\(A\\) is changed as a result. \\(A_{ee}^*\\) is to be stored in \\(A_{ee}\\) . virtual int condenseRHS ( int numInt ) = 0 ; Causes the condenser to form \\(B_e^* = B_e - A_{ei} A_{ii}^{-1} B_i\\) , where \\(A_{ii}\\) is the first numInt rows of \\(A\\) . The original \\(B\\) is changed as a result. \\(B_e^*\\) is to be stored in \\(B_e\\) . virtual int computeCondensedMatVect ( Vector & u , int numInt ) = 0 ; Causes the condenser to form \\(A_{ee} u\\) . virtual Matrix & getCondensedA ( void ) = 0 ; Returns the contents of \\(A_{ee}\\) as a matrix. virtual Vector & getCondensedRHS ( void ) = 0 ; Returns the contents of \\(B_e\\) as a Vector. virtual Vector & getCondensedMatVect ( void ) = 0 ; Returns the contents of the last call to computeCondensedMatVect() . virtual int setComputedXext ( const Vector & u ) = 0 ; Sets the computed value of the unknowns in \\(X_e\\) corresponding to the external equations to u . The number of external equations is given by the size of vector \\(u\\) . virtual int solveXint ( void ) = 0 ; To compute the internal equation numbers \\(X_i\\) given the value set for the external equations in the last call to setComputedXext() .","title":"DomainSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/LinearSOE/","text":"LinearSOE #include <system_of_eqn/linearSOE/LinearSOE.h> class LinearSOE : public SystmOfEqn MovableObject LinearSOE is an abstract class. A LinearSOE object provides an abstraction of a system of linear equations. A linear system of equation of order \\(n\\) : \\[\\begin{array}{ccccccccc} a_{0,0}x_0 & + & a_{0,1}x_1 & + & ... & + & a_{0,n-1}x_{n-1} & = & b_0 \\\\ a_{1,0}x_0 & + & a_{1,1}x_1 & + & ... & + & a_{1,n-1}x_{n-1} & = & b_1 \\\\ ... & & ... & & & & ... & & ... \\\\ a_{n-1,0}x_0 & + & a_{n-1,1}x_1 & + & ... & + & a_{n-1,n-1}x_{n-1} & = & b_{n-1} \\\\ \\end{array}\\] can be expressed by the matrix equation \\(Ax=b\\) , where \\(A\\) is a matrix of order \\(n\\) X \\(n\\) and \\(b\\) and \\(x\\) are vectors or order \\(n\\) . A LinearSOE object is responsible for storing these equations and for providing methods at the interface to set up and obtain the equations. Each LinearSOE object will be associated with a LinearSOESolver object. It is the LinearSOESolver objects that is responsible for solving the linear system of equations. The integer classTag is passed to the constructor for the SystemOfEqn . The constructor sets sets the pointer for the currently associated LinearSOESolver object to point to theSolver . Does nothing. Causes the SystemOfEqn object to invoke solve() on the currently associated LinearSOESolver object. Returns a \\(0\\) if successful, negative number if not; the actual value depending on the LinearSOESolver. To solve a linear system of equations means to find \\(x\\) such that the equation \\(Ax=b\\) is satisfied. A method which returns the number of equations in the system, i.e. the number of unknowns. Invoked to allow the LinearSOE object to determine the size and sparsity of the matrix \\(A\\) and vectors \\(x\\) and \\(b\\) . This information can be deduced from the number of vertices and the connectivity between the vertices in the Graph object G . To return \\(0\\) if successful, a negative number if not. The LinearSOE object assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += M(i,j)\\) . Numbering in \\(A\\) starts at \\((0,0)\\) , i.e. C style. If a location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . To return \\(0\\) if successful, a negative number if not. virtual int addB(const Vector & theVector, const ID & loc, double fact = 1.0) =0; The LinearSOE object assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . To return \\(0\\) if successful, a negative number if not. virtual int setB ( const Vector & theVector , double fact = 1.0 ) = 0 ; The LinearSOE object sets the vector b to be fact times the Vector V . To return \\(0\\) if successful, a negative number if not. virtual void zeroA ( void ) = 0 ; To zero the matrix \\(A\\) , i.e. set all the components of \\(A\\) to \\(0\\) . virtual void zeroB ( void ) = 0 ; To zero the vector \\(b\\) , i.e. set all the components of \\(b\\) to \\(0\\) . virtual const Vector & getX ( void ) = 0 ; To return, as a Vector object, the vector \\(x\\) . A const reference is returned, meaning the Vector that is returned cannot be modified, i.e. no non-const method can be invoked on the Vector. virtual const Vector & getB ( void ) = 0 ; To return as a Vector object the vector \\(b\\) . A const reference is returned, meaning the Vector that is returned cannot be modified, i.e. no non-const method can be invoked on the Vector. virtual double normRHS ( void ) = 0 ; To return the 2-norm of the vector \\(x\\) . virtual void setX ( int loc , double value ) = 0 ; The LinearSOE object is responsible for setting \\(x(loc) = value\\) . This is needed in domain decomposition methods and could be useful in iterative solution strategies when an initial approximation is known. This is invoked to set the currently associated LinearSOESolver object to be newSolver . Each subclass will provide it\u2019s own variation of setSolver() method (needed so subclasses can verify type of Solver object passed). the subclasses in their variation of the setSolver() method (unless they wish to implement their own solve() method) invoke this method. Returns \\(0\\) . Returns a pointer to the associated LinearSOESolver object.","title":"LinearSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/LinearSOESolver/","text":"LinearSOESolver #include <system_of_eqn/linearSOE/LinearSOESolver.h> class LinearSOESolver: public Solver MovableObject Solver LinearSOESolver is an abstract class. A LinearSOESolver object is responsible for solving the LinearSOE object that it is associated with. That is, to find \\(x\\) such that the matrix equation \\(Ax=b\\) is satisfied. The integer classTag is passed to the Solver. Does nothing. Provided so the subclasses destructor will be called. Causes the LinearSOESolver to solve the system of equations \\(Ax=b\\) for \\(x\\) . Returns \\(0\\) if successful , negative number if not; the actual value depending on the type of LinearSOESolver. The result of the solve are to be stored in the \\(x\\) vector of the LinearSOE by the object. This is invoked by the LinearSOE object when setSize() has been invoked on it. Solvers may sometimes need to store additional data that needs to be updated if the size of the system of equation changes.","title":"LinearSOESolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandGEN/BandGenLinSOE/","text":"BandGenLinSOE #include <system_of_eqn/linearSOE/bandGEN/BandGenLinSOE.h> class BandGenLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE BandGenLinSOE is class which is used to store a banded unsymmetric system with kl subdiagonals and ku superdiagonals. The \\(A\\) matrix is stored in a 1d double array with \\((kl+ku+1)*n\\) elements, where n is the size of the system. \\(A_{i,j}\\) is stored at location \\((ku+1+i-j) + j*(ku+1+kl)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example when \\(n=5\\) , \\(kl = 2\\) and \\(ku=1\\) : \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & 0 & 0 & 0 \\\\ a_{1,0} & a_{1,1} & a_{1,2} & 0 & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & 0 \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{ccccccccccccccccccccc} * & a_{0,0} & a_{1,0} & a_{2,0} & a_{0,1} & a_{1,1} & a_{2,1} & a_{3,1} & a_{1,2} & a_{2,2} & a_{3,2} & a_{4,2} & a_{2,3} & a_{3,3} & a_{4,3} & * & a_{3,4} & a_{4,4} & * & * \\\\ \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(N\\) . To allow the solvers access to this data, the solvers that use this class are all declared as friend classes. The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the theSolver . No memory is allocated for the 3 1d arrays. BandGenLinSOE ( int N , int numSuperDiagonals , int numSubDiagonal , BandGenLinSolver & theSolver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. Sets the size of the system to \\(N\\) , the number of superdiagonals to numSuperDiagonals and number of subdiagonals to numSubDiagonals . Allocates memory for the arrays; if not enough memory is available a warning message is printed and the system size is set to \\(0\\) . Sets the solver to be called when solving the equations to theSolver . Invokes setLinearSOE ( \\ * this ) and setSize() on the theSolver . Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first setting kl and ku equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in kl or ku being increased. Knowing kl , ku and the size of the system (the number of Vertices in G ), a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Prints a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"BandGenLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandGEN/BandGenLinSolver/","text":"BandGenLinSolver #include <~/system_of_eqn/linearSOE/bandGEN/BandGenLinSolver.h> class BandGenLinSolver : public LinearSOESolver MovableObject Solver BandGenLinSolver is an abstract class. The BandGenLinSolver class provides access for each subclass to the BandGenLinSOE object through the pointer theSOE , which is a protected pointer. Constructor Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. virtual int setLinearSOE ( BandGenLinSOE & theSOE ); The method sets up the link between the BandGenLinSOE object and the BandGenLinSolver, that it is sets the pointer the subclasses use.","title":"BandGenLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandSPD/BandSPDLinSOE/","text":"BandSPDLinSOE #include <system_of_eqn/linearSOE/bandSPD/BandSPDLinSOE.h> class BandSPDLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE BandSPDLinSOE is class which is used to store a banded symmetric system with ku superdiagonals. The \\(A\\) matrix is stored in a 1d double array with \\((ku+1)n\\) elements, where \\(n\\) is the size of the system. \\(A_{i,j}\\) is stored at location \\((ku+1+i-j) + j*(ku+1)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example when \\(n=5\\) , \\(ku = 2\\) : \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & a_{0,1} & 0 & 0 \\\\ a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{cccccccccccccccccccc} * & * & a_{0,0} & * & a_{0,1} & a_{1,1} & a_{0,2} & a_{1,2} & a_{2,2} & a_{1,3} & a_{2,3} & a_{3,3} & a_{2,4} & a_{3,4} & a_{4,4}\\\\ \\end{array} \\right]\\] The \\(X\\) and \\(B\\) vectors are stored in 1d double arrays of length \\(N\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. BandSPDLinSOE ( int N , int ku , BandSPDLinSolver & theSolver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. Sets the size of the system to \\(N\\) , the number of superdiagonals to ku . Allocates memory for the arrays; if not enough memory is available a warning message is printed and the system size is set to \\(0\\) . Sets the solver to be called when solving the equations to theSolver . Invokes setLinearSOE ( \\ * this ) and setSize() on the theSolver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor. Calls delete on any arrays created. int setBandSPDSolver ( BandSPDLinSolver & newSolver ); Invokes setLinearSOE (* this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. int getNumEqn ( void ) = 0 ; A method which returns the current size of the system. int setSize ( const Graph & G ); The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first setting ku equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in ku being increased. Knowing ku and the size of the system (the number of Vertices in G , a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Prints a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. int addA ( const Matrix & M , const ID & loc , doublefact = 1.0 ) = 0 ; First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += \\texttt{fact} * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector \\(b\\) to be fact times the Vector \\(V\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . int sendSelf ( int commitTag , Channel & theChannel ); Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. ```cpp int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"BandSPDLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/bandSPD/BandSPDLinSolver/","text":"BandSPDLinSolver #include <~/system_of_eqn/linearSOE/bandSPD/BandSPDLinSolver.h> class BandSPDLinSolver : public LinearSOESolver MovableObject Solver BandSPDLinSolver is an abstract class. The BandSPDLinSolver class provides access for each subclass to the BandSPDLinSOE object through the pointer theSOE , which is a protected pointer. Constructor Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing. Provided so the subclasses destructor will be called. The method sets up the link between the BandSPDLinSOE object and the BandSPDLinSolver, that it is sets the pointer the subclasses use.","title":"BandSPDLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/fullGEN/FullGenLinSOE/","text":"FullGenLinSOE #include <~/system_of_eqn/linearSOE/fullGEN/FullGenLinSOE.h> class FullGenLinSOE : public LinearSOE MovableObject SystemOfEqn FullGenLinSOE is class which is used to store a full general system. The \\(A\\) matrix is stored in a 1d double array with \\(n*n\\) elements, where \\(n\\) is the size of the system. \\(A_{i,j}\\) is stored at location \\((i + j*(n)\\) , where \\(i\\) and \\(j\\) range from \\(0\\) to \\(n-1\\) , i.e. C notation. For example, when \\(n=3\\) : \\[\\left[ \\begin{array}{ccc} a_{0,0} & a_{0,1} & a_{0,2} \\\\ a_{1,0} & a_{1,1} & a_{1,2} \\\\ a_{2,0} & a_{2,1} & a_{2,2} \\\\ \\end{array} \\right]\\] is stored as: \\[\\left[ \\begin{array}{cccccccccccccccccccc} a_{0,0} & a_{1,0} & a_{2,0} & a_{0,1} & a_{1,1} & a_{2,1} & a_{0,2} & a_{1,2} & a_{2,2} \\\\ \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(n\\) . To allow the solvers access to this data, the solvers that use this class are all declared as friend classes. The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. FullGenLinSOE ( int N , FullGenLinSolver & solver ); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) and the matrix \\(A\\) is marked as not having been factored. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) and \\(b\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . Invokes setLinearSOE ( \\ * this ) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor. Destructor ~ FullGenLinSOE (); Calls delete on any arrays created. Methods int setFullGEnSolver ( FullGenLinSolver & newSolver ); Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning \\(-1\\) if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. int getNumEqn ( void ) = 0 ; A method which returns the current size of the system. int setSize ( const Graph & theGraph ); The size of the system is determined by invoking getNumVertex() on theGraph . If the old space allocated for the 1d arrays is not big enough, it the old space is returned to the heap and new space is allocated from the heap. Prints a warning message, sets size to \\(0\\) and returns a \\(-1\\) , if not enough memory is available on the heap for the 1d arrays. If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. int addA ( const Matrix & M , const ID & loc , doublefact = 1.0 ) = 0 ; First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\[a_{loc(i),loc(j)} += \\texttt{fact} * M(i,j)\\] . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corresponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(\\texttt{loc}) = \\texttt{value}\\) . int sendSelf ( int commitTag , Channel & theChannel ); Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the framework design. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the framework\u2019s design.","title":"FullGenLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/fullGEN/FullGenLinSolver/","text":"#include \\(<\\tilde{ }\\) /system_of_eqn/linearSOE/fullGEN/FullGenLinSolver.h \\(>\\) class FullGenLinSolver: public LinearSOESolver MovableObject Solver LinearSOESolver FullGenLinSolver is an abstract class. The FullGEnLinSolver class provides access for each subclass to the FullGenLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. Sets the link to the FullGEnLinSOE object theSOE . This is the object on which the solver will perform the numerical computations.","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSolver/","text":"UNDER CONSTRUCTION # ProfileSPDLinDirectSolver #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSolver.h> class ProfileSPDLinDirectSolver : public LinearSOESolver MovableObject\\ Solver\\ LinearSOESolver\\ ProfileSPDLinSolver\\ A ProfileSPDLinDirectSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one column at a time using a left-looking approach. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSOE/","text":"ProfileSPDLinSOE #include \"ProfileSPDLinSOE.h\" class ProfileSPDLinSOE : public LinearSOE MovableObject SystemOfEqn LinearSOE ProfileSPDLinSOE is class which is used to store a symmetric system of equations using a profile storage scheme. The upper triangular part of \\(A\\) is stored in a 1d double array with the diagonals of \\(A\\) located at positions given by an integer array \\(iLoc\\) . For example when \\(n=5\\) and \\(A\\) as shown below: \\[\\left[ \\begin{array}{ccccc} a_{0,0} & a_{0,1} & 0 & 0 & a_{0,4} \\\\ a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} & 0 \\\\ a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} \\\\ 0 & a_{3,1} & a_{3,2} & a_{3,3} & a_{3,4} \\\\ 0 & 0 & a_{4,2} & a_{4,3} & a_{4,4} \\\\ \\end{array} \\right]\\] this is stored using: \\[A = \\left[ \\begin{array}{cccccccccccccccccccc} a_{0,0} & a_{0,1} & a_{1,1} & a_{1,2} & a_{2,2} & a_{1,3} & a_{2,3} & a_{3,3} & a_{0,4} & 0 & a_{2,4} & a_{3,4} & a_{4,4}\\\\ \\end{array} \\right]\\] and \\[iLoc = \\left[ \\begin{array}{cccccccccccccccccccc} 1 & 3 & 5 & 8 & 13 \\\\ \\end{array} \\right]\\] Note \\(iLoc\\) stores the diagonal locations using Fortran indexing. This is to facilitate calls to Fortran libraries, e.g. Digital\u2019s DXML. The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(N\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 1d arrays. ProfileSPDLinSOE(int N, int *newIloc, ProfileSPDLinSolver &theSolver); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) and the matrix \\(A\\) is marked as not having been factored or condensed. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) , \\(b\\) and \\(iLoc\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . The size of \\(A\\) is given by \\(newIloc(N-1)\\) , if this is not a valid address in newIloc a segmentation fault or erronious results will result. The contents of \\(iLoc\\) are set equal to those of newIloc . Invokes setLinearSOE(*this) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning the returned value if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined by looking at the adjacency ID of each Vertex in the Graph object G . This is done by first determining the column height for each Vertex \\(i\\) in G , done by setting \\(iLoc(i)\\) equal to \\(0\\) and then checking for each Vertex in G , whether any of the vertex tags in the Vertices adjacency ID results in \\(iLoc(i)\\) being increased. Knowing the col height of each column, the values of iLoc can be determined. Knowing iLoc and the size of the system (the number of Vertices in G , a check to see if the previously allocated 1d arrays for \\(A\\) , \\(x\\) and \\(b\\) are large enough. If the memory portions allocated for the 1d arrays are not big enough, the old space is returned to the heap and new space is allocated from the heap. Printins a warning message if not enough memory is available on the heap for the 1d arrays and returns a \\(-1\\) . If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corrseponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":"ProfileSPDLinSOE\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSolver/","text":"ProfileSPDLinSolver #include $<\\tilde{ }$ProfileSPDLinSolver.h$>$\\ class ProfileSPDLinSolver : public LinearSOESolver Solver LinearSOESolver ProfileSPDLinSolver is an abstract class. The ProfileSPDLinSolver class provides access for each subclass to the ProfileSPDLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. The method sets up the link between the ProfileSPDLinSOE object and the ProfileSPDLinSolver, that it is sets the pointer the subclasses use.","title":"ProfileSPDLinSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSubstrSolver/","text":"ProfileSPDLinSubstrSolver UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinSubstrSolver.h> class ProfileSPDLinSubstrSolver : public DomainSolver , public ProfileSPDLinSubstrSolver \\ MovableObject Solver LinearSOESolver DomainSolver ProfileSPDLinDirectSolver A ProfileSPDLinSubstrSolver object will perform the numerical substructuring operations on a ProfileSPDLinSOE object. EXPAND. Constructor ### Destructor // Public Methods Causes the condenser to form \\(A_{ee}^* = A_{ee} -A_{ei} A_{ii}^{-1} A_{ie}\\) , where \\(A_{ii}\\) is the first numInt rows of the \\(A\\) matrix. The original \\(A\\) is changed as a result. \\(A_{ee}^*\\) is to be stored in \\(A_{ee}\\) . int condenseRHS ( int numInt ); Causes the condenser to form \\(B_e^* = B_e - A_{ei} A_{ii}^{-1} B_i\\) , where \\(A_{ii}\\) is the first numInt rows of \\(A\\) . The original \\(B\\) is changed as a result. \\(B_e^*\\) is to be stored in \\(B_e\\) . int computeCondensedMatVect ( Vector & u , int numInt ); Causes the condenser to form \\(A_{ee} u\\) . Matrix & getCondensedA ( void ); Returns the contents of \\(A_{ee}\\) as a matrix. Vector & getCondensedRHS ( void ); Returns the contents of \\(B_e\\) as a Vector. Vector & getCondensedMatVect ( void ); Returns the contents of the last call to computeCondensedMatVect() . int setComputedXext ( const Vector & u ); Sets the computed value of the unknowns in \\(X_e\\) corresponding to the external equations to u . The number of external equations is given by the size of vector \\(u\\) . int solveXint ( void ); To compute the internal equation numbers \\(X_i\\) given the value set for the external equations in the last call to setComputedXext() .","title":"ProfileSPDLinSubstrSolver\n"},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/sparseGEN/SparseGenColLinSOE/","text":"#include \\(<\\tilde{ }\\) /system_of_eqn/linearSOE/sparseGen/SparseGenColLinSOE.h \\(>\\) class SparseGenColLinSOE: public LinearSOE MovableObject SystemOfEqn LinearSOE SparseGenColLinSOE is class which is used to store the matrix equation \\(Ax=b\\) of order \\(size\\) using a sparse column-compacted storage scheme for \\(A\\) . The \\(A\\) matrix is stored in a 1d double array with \\(nnz\\) elements, where \\(nnz\\) is the number of non-zeroes in the matrix \\(A\\) . Two additional 1d integer arrays \\(rowA\\) and \\(colStartA\\) are used to store information about the location of the coefficients, with \\(colStartA(i)\\) storing the location in the 1d double array of the start of column \\(i\\) and \\(rowA(j)\\) identifying the row in \\(A\\) to which the \\(j'th\\) component in the 1d double array. \\(colStartA\\) is of dimension \\(size+1\\) and \\(rowA\\) of dimension \\(nnz\\) . For example \\[\\left[ \\begin{array}{ccccc} a_{0,0} & 0 & a_{0,2} & a_{0,3} & 0 \\\\ a_{1,0} & a_{1,1} & 0 & 0 & 0 \\\\ 0 & a_{2,1} & a_{2,2} & 0 & 0 \\\\ 0 & 0 & 0 & a_{3,3} & a_{3,4} \\\\ a_{4,0} & a_{4,1} & 0 & 0 & a_{4,4} \\end{array} \\right]\\] is stored in: \\[\\left[ \\begin{array}{cccccccccccccc} a_{0,0} & a_{1,0} & a_{4,0} & a_{1,1} & a_{2,1} & a_{4,1} & a_{0,2} & a_{2,2} & a_{0,3} & a_{3,3} & a_{3,4} & a_{4,4} \\\\ \\end{array} \\right]\\] with \\[colStartA = \\left[ \\begin{array}{cccccccccccccc} 0 & 3 & 6 & 8 & 10 & 12 \\end{array} \\right]\\] and \\[rowA = \\left[ \\begin{array}{cccccccccccccc} 0 & 1 & 4 & 1 & 2 & 4 & 0 & 2 & 0 & 3 & 3 & 4 \\end{array} \\right]\\] The \\(x\\) and \\(b\\) vectors are stored in 1d double arrays of length \\(n\\) . The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(0\\) and the matrix \\(A\\) is marked as not having been factored. Invokes setLinearSOE(*this) on the solver . No memory is allocated for the 3 1d arrays. SparseGenColLinSOE(int N, int NNZ, int *colStartA, int *rowA, SparseGenColLinSolver &theSolver); The solver and a unique class tag (defined in <classTags.h> ) are passed to the LinearSOE constructor. The system size is set to \\(N\\) , the number of non-zeros is set to \\(NNZ\\) and the matrix \\(A\\) is marked as not having been factored. Obtains memory from the heap for the 1d arrays storing the data for \\(A\\) , \\(x\\) and \\(b\\) and stores the size of these arrays. If not enough memory is available for these arrays a warning message is printed and the system size is set to \\(0\\) . Invokes setLinearSOE(*this) and setSize() on solver , printing a warning message if setSize() returns a negative number. Also creates Vector objects for \\(x\\) and \\(b\\) using the ( double \\ *, int ) Vector constructor. It is up to the user to ensure that colStartA and rowA are of the correct size and contain the correct data. Calls delete on any arrays created. Invokes setLinearSOE ( \\ * this ) on newSolver . If the system size is not equal to \\(0\\) , it also invokes setSize() on newSolver , printing a warning and returning \\(-1\\) if this method returns a number less than \\(0\\) . Finally it returns the result of invoking the LinearSOE classes setSolver() method. A method which returns the current size of the system. The size of the system is determined from the Graph object theGraph , which must contain size vertices labelled \\(0\\) through \\(size-1\\) , the adjacency list for each vertex containing the associated vertices in a column of the matrix \\(A\\) . The size is determined by invoking getNumVertex() on theGraph and the number of non-zeros is determined by looking at the size of the adjacenecy list of each vertex in the graph, allowing space for the diagonal term. If the old space allocated for the 1d arrays is not big enough, it the old space is returned to the heap and new space is allocated from the heap. Prints a warning message, sets size to \\(0\\) and returns a \\(-1\\) , if not enough memory is available on the heap for the 1d arrays. If memory is available, the components of the arrays are zeroed and \\(A\\) is marked as being unfactored. If the system size has increased, new Vector objects for \\(x\\) and \\(b\\) using the (double *,int) Vector constructor are created. The \\(colStartA\\) and \\(rowA\\) are then determined by looping through the vertices, setting \\(colStartA(i) = colStartA(i-1) + 1 +\\) the size of Vertices \\(i\\) adjacency list and placing the contents of \\(i\\) and the adjacency list into \\(rowA\\) in ascending order. Finally, the result of invoking setSize() on the associated Solver object is returned. First tests that loc and M are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Matrix M into the matrix \\(A\\) . The Matrix is assembled into \\(A\\) at the locations given by the ID object loc , i.e. \\(a_{loc(i),loc(j)} += fact * M(i,j)\\) . If the location specified is outside the range, i.e. \\((-1,-1)\\) the corrseponding entry in M is not added to \\(A\\) . If fact is equal to \\(0.0\\) or \\(1.0\\) , more efficient steps are performed. Returns \\(0\\) . int addB ( const Vector & V , const ID & loc , double fact = 1.0 ) = 0 ; First tests that loc and V are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then assembles fact times the Vector V into the vector \\(b\\) . The Vector is assembled into \\(b\\) at the locations given by the ID object loc , i.e. \\(b_{loc(i)} += fact * V(i)\\) . If a location specified is outside the range, e.g. \\(-1\\) , the corresponding entry in V is not added to \\(b\\) . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . int setB ( const Vector & V , double fact = 1.0 ) = 0 ; First tests that V and the size of the system are of compatible sizes; if not a warning message is printed and a \\(-1\\) is returned. The LinearSOE object then sets the vector b to be fact times the Vector V . If fact is equal to \\(0.0\\) , \\(1.0\\) or \\(-1.0\\) , more efficient steps are performed. Returns \\(0\\) . void zeroA ( void ) = 0 ; Zeros the entries in the 1d array for \\(A\\) and marks the system as not having been factored. void zeroB ( void ) = 0 ; Zeros the entries in the 1d array for \\(b\\) . const Vector & getX ( void ) = 0 ; Returns the Vector object created for \\(x\\) . const Vector & getB ( void ) = 0 ; Returns the Vector object created for \\(b\\) . double normRHS ( void ) = 0 ; Returns the 2-norm of the vector \\(x\\) . void setX ( int loc , double value ) = 0 ; If loc is within the range of \\(x\\) , sets \\(x(loc) = value\\) . Returns \\(0\\) . The object does not send any data or connectivity information as this is not needed in the finite element design. Returns \\(0\\) . The object does not receive any data or connectivity information as this is not needed in the finite element design.","title":""},{"location":"developer/architecture/class_interface/system_of_eqn/linearSOE/sparseGEN/SuperLU/","text":"SuperLU #include <system_of_eqn/linearSOE/fullGEN/SuperLU.h> class SuperLU : public SparseGenColLinSolver \\ MovableObject Solver LinearSOESolver SparseGenColLinSolver A SuperLU object can be constructed to solve a SparseGenColLinSOE object. It obtains the solution by making calls on the the SuperLU library developed at UC Berkeley by Prof. James Demmel, Xiaoye S. Li and John R. Gilbert. The SuperLU library contains a set of subroutines to solve a sparse linear system \\(AX=B\\) . It uses Gaussian elimination with partial pivoting (GEPP). The columns of A may be preordered before factorization; the preordering for sparsity is completely separate from the factorization and a number of ordering schemes are provided. Constructor ### Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the SparseGenColLinSolver constructor. Saves the values for the arguments permSpec , panelSize , relax and thresh that will be used when calling the SuperLU routines in solve() and setSize() . permSpec defines the ordering routine used in defining the column permutations permC : \\(0\\) uses the original ordering supplied, \\(1\\) defines a min-degree ordering based on \\(A^TA\\) and \\(2\\) a min-degree ordering based on \\(A^T + A\\) . relax defines the min number of columns in a subtree for the subtree to be considered a single supernode. thresh defines the pivoting threshold: at step j of the Gaussian elimination if (abs \\((A_{jj}) \\ge\\) thresh (max \\(i \\ge j\\) abs( \\(A_{ij}\\) )). A value for thresh of \\(0.0\\) definines no pivoting, a value of \\(1.0\\) classical partial pivoting. panelSize defines the number of consecutive columns used as a panel in the elimination. For more information on these values see the SuperLU manual. Invokes delete on permR , permC and etree arrays. First copies \\(B\\) into \\(X\\) and then solves the FullGenLinSOE system it is associated with (pointer kept by parent class) by calling the SeuperLU routine dgstrf() , if the system is marked as not having been factored, or dgstrs() , if system is marked as having been factored. If the solution is successfully obtained, i.e. the SuperLU routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) and sets the char rafact to Y . Obtains the size of the system from it\u2019s associaed SparseGenColLinSOE object. With this information it creates space for the integer arrays permR , permC and etree . It then creates the a SuperMatrix for A by calling the SuperLU routine dCreate_CompCol_Matrix() , sets the column permutation permR by calling the SuperLU routine get_perm_c(permSpec, A, permC) , applies this permutation and determines the elimination tree etree by calling the SuperLU routine sp_preorder() . It then creates a SuperMatrix for X by calling the SuperLU routine dCreate_Dense_Matrix() . Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for the arrays. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"SuperLU\n"},{"location":"developer/architecture/class_interface/utility/","text":"Algebraic Classes Numerical classes are used to pass numerical information between objects and to handle the numerical operations in the solution procedure. The container classes provided include Matrix , Vector , and ID . The abstractions provided by the Matrix and Vector classes should be apparent. The ID class provides the abstraction of an integer array. SysOfEqn provides abstractions for performing linear algebraic operations. Matrix Vector ID SysOfEqn","title":"Algebraic Classes\n"},{"location":"developer/architecture/class_interface/utility/ID/","text":"ID #include <matrix/ID.h> class ID : The ID class provides the abstraction for an integer Vector. The class is introduced in addition to the Vector class, to save memory and casting when integer arrays are required. An ID of order size is an ordered 1d array of size integer values. For example an ID id of order 5: \\(id = [id_0\\) \\(id_1\\) \\(id_2\\) \\(id_3\\) \\(id_4]\\) In the ID class, the data is stored in a 1d integer array of length equal to arraySize, where order <= arraySize. Creating an ID with storage capacity greater than that required allows the ID object to grow without the need to deallocate and allocate more memory. At present time none of the methods are declared as being virtual. THIS MAY CHANGE. To construct an ID of size \\(0\\) . No memory is allocated for the storage of the data. To construct a ID of size idSize . The constructor creates an integer array of size idSize to store the data and zeroes this array by invoking Zero() on itself. If not enough memory is available an error message is printed and an ID of size \\(0\\) is returned. To construct a ID of size idSize . The constructor creates an integer array of size arraySize to store the data and zeroes this array. If arraySize is less than idSize , the new arraySize is set equal to idSize . If not enough memory is available an error message is printed and the program is terminated. This constructor is provided to allow an ID to grow. To construct an ID using another ID M . The new ID will be identical to the ID \\(M\\) , same order and same size of array to hold the integer values. If not enough memory is available a warning message is printed and both the order and arraySize of the ID are set to \\(0\\) . Will invoke delete on the integer array used to store the components. Returns the order of the ID. Zeros out the ID, i.e. sets all the components of the ID to \\(0\\) . This is accomplished by zeroing the first this.Size() components of the array. Will return the location the first location in the ID of the integer x . If x is not in the ID a \\(-1\\) is returned. Will return the last location in the ID of the integer x . If x is not in the ID a \\(-1\\) is returned. All the integer components x are removed from the ID and the length of the ID is reduced by the number of the removed components. The arraySize remains unchanged. Returns the data at location x in the ID. Assumes ( x ) is a valid location in the ID, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the ID. Assumes ( x ) is a valid location in the ID, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the ID. If x is outside the order of the ID the ID is order of the ID is enlarged to x+1 . When increasing the order, a check is first made to see if the current array is large enough; if it is the components between the old end and the new component are set to \\(0\\) and the order of the ID is set to x+1 , if not a new array is created. The size of this array is max( \\(2*\\) old array size, x). A copy of the components of the old array into the new array is made, with any new components set to \\(0\\) . If not enough space is available or x is less than \\(0\\) , a warning message is printed and the contents of ID_ERROR returned. Sets the current ID to be equal to the ID given by M . If the IDs are of different sizes, the current data is deallocated and more space allocated before the contents are copied. If not enough memory is available, the order and arraySize of the current ID is set to \\(0\\) and the ID is returned without copying the components. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const ID & id ); A function to print out the contents of the ID id to the output stream s . Prints out the components into the stream and then sends a newline character. friend istream & operator $ >> $ ( istream & s , const ID & id ); A function to read the contents of the ID id from the input stream s . Sets the components of id equal to the next id.Size() entries in the stream.","title":"ID\n"},{"location":"developer/architecture/class_interface/utility/Matrix/","text":"Matrix #include <matrix/Matrix.h> class Matrix : The Matrix class provides the matrix abstraction. A matrix of order numRows X numCols is an ordered 2d array of numbers arranged in numRows rows and numCols columns. For example, a matrix \\(A\\) of order 2 X 3: $$A = $$ The Matrix class provides the implementation of a general unsymmetric matrix. The data for the matrix is stored in a 1d double array of size numRows*numCols with the data for \\(a_{i,j}\\) located at j*numRows + i in the 1d array. This is similar to the ordering of a Fortran 2d array and will permit calls to numerical Fortran libraries, e.g. BLAS, for certain method calls at a future stage. At present no subclassing is permitted (THIS MAY CHANGE), the reason for this is that the Matrix objects are envisioned to be small scale matrices primarily used for the passing of data between objects in the system. To allow subclassing could reduce the efficiency of the program due to the manner in which virtual functions are implemented. To construct a Matrix with numRows = \\(0\\) , and numCols = \\(0\\) . No memory is allocated to store the data. To construct a Matrix with numRows = nrows , and numCols = ncols and all coefficients equal to \\(0\\) . Allocates memory for the storage of the data. If numRows \\(<\\) \\(0\\) , numCols \\(<\\) \\(0\\) or not enough memory is available available, an error message is printed and a Matrix with numRows = \\(0\\) and numCols = \\(0\\) is returned. Before the Matrix is returned, Zero() is called on the Matrix. To construct a Matrix with numRows = nrows , and numCols = ncols and all coefficients equal to \\(0\\) . The memory for storage of the data is found at the location pointed to by data . Note that this memory must have been previously allocated and it must be of appropriate size, erroneous results and segmentation faults can occur otherwise. No additional memory is allocated for the storage of the data. To construct a Matrix using another Matrix. The new Matrix will be a general matrix that is identical to the Matrix M , i.e. same size and identical components. If not enough memory is available, an error message is printed and a Matrix with numRows = \\(0\\) and numCols = \\(0\\) is returned. The constructor tests for the type of \\(M\\) to see whether the performance can be improved, by avoiding having to call \\(M\\) \u2019s overloaded (i,j) operators if \\(M\\) is of type genMatrix. Free\u2019s up any memory allocated in the constructor. Note that if the third constructor had been invoked, the memory passed is not released back to the system (this must be done later by the user of this constructor). Returns the number of rows, numRows, of the Matrix. The method is declared inline for the compiler to produce faster code which does not require a method call. Returns the number of columns, numCols, of the Matrix. Zero\u2019s out the Matrix, i.e. sets all the components of the matrix to \\(0\\) . The method tests for the type of Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators if the Matrix is of type genMatrix. Assembles into the current Matrix the Matrix M . The contents of the current matrix at location ( rows(i),cols(j) ) is set equal to the current value plus fact times the value of the matrix M at location ( i,j ). A warning is printed for every rows ( i ), cols ( j ) specified which is outside the bounds of the matrix. Will solve the equation \\(Ax=V\\) for the Vector x , which is returned. At the moment the current matrix is assumed to be symmetric positive definite. THIS IS TO CHANGE. A Vector is created using V . If this Vector is not of the correct size or if an error occurs during factorization a warning message is printed and the Vector x is returned. To add a factor fact times the Matrix other to the current Matrix. The size of the other Matrix is first checked to see sizes are compatible; if size are not compatible nothing is done and a warning message is printed. The method tests for the type of other , to see whether the performance can be improved by avoiding having to call other \u2019s overloaded (i,j) operators, if other is of type genMatrix. Returns the data at location( row,col ) in the Matrix. Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( row,col ) in the Matrix. Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Returns a new Matrix of dimension ( rows.Size() , cols.Size() ). The contents of the new matrix are given by the contents of the current matrix at the locations given by the rows and cols objects. For example the contents of the new matrix at location ( i,j ) are equal to the contents of the current matrix at location ( rows(i),cols(j) ). Assumes ( row,col ) is a valid location in the Matrix, a segmentation fault or erroneous results can occur if this is not the case. Sets the current Matrix to be equal to the Matrix given by M . If the Matrices are of different sizes, the current data is deallocated and additional space allocated before the contents are copied. If not enough space can be allocated for the new data, an error message is printed and a Matrix of size \\(0\\) x \\(0\\) is returned. The method tests for the type of M , to see whether the performance can be improved by avoiding having to call \\(M\\) \u2019s overloaded (i,j) operators, if \\(M\\) is of type genMatrix. This method must be implemented by each subclass. A method to add fact to each component of the current Matrix. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to subtract fact from each component of the current Matrix. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to multiply each component of the current Matrix by fact . The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method which will divide each component of the current Matrix by fact . If fact is equal to zero, an error message is printed and the contents of the Matrix are set to MATRIX_VERY_LARGE_VALUE (defined in <Matrix.h> ). The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Matrix, whose components are equal to the components of the current Matrix plus the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The += operator is then invoked on this Matrix with fact as the argument, and the new Matrix is then returned. A method to return a new Matrix, whose components are equal to the components of the current Matrix minus the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The -= operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Matrix, whose components are equal to the components of the current Matrix times the value fact . A new Matrix object is constructed, using the current Matrix as the argument to the constructor. The = operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Matrix whose components are equal to the components of the current Matrix divided the value fact . A new Matrix object is constructed by using the current Matrix as the argument to the constructor. The /= operator is then invoked on this Matrix with fact as the argument, and this new Matrix is then returned. A method to return a new Vector, of size numRows, whose components are equal to the product of the current Matrix times the Vector V . If the current Matrix and Vector V are not compatible, i.e. V.Size() is not equal to numCols, an error message is printed and a zero Vector of size equal to the number of rows in the current Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Vector, of size numCols, whose components are equal to the product of the transpose of the current Matrix times the Vector V . If the current Matrix and Vector V are not compatible, i.e. V.Size() is not equal to numRows, an error message is printed and a zero Vector of size equal to the number of columns in the current Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if the current Matrix is of type genMatrix. A method to return a new Matrix equal to the sum of the current Matrix and the Matrix M . It does this by creating a new matrix passing itself as an argument to the constructor. The addMatrix() method is then invoked on this new Matrix with \\(M\\) and \\(-1\\) as the arguments. The new Matrix is then returned. A method to return a new Matrix equal to the the current Matrix minus the Matrix M . It does this by creating a new matrix passing itself as an argument to the constructor. The addMatrix() method is then invoked on this new Matrix with \\(M\\) and \\(-1\\) as the arguments. The new Matrix is then returned. A method to return a new Matrix equal to the product of the current Matrix and the Matrix M . It does this by first creating a new Matrix of size numRows and M.numCols. The contents of this new Matrix are then determined and the resulting Matrix is returned. If the two matrices are of incompatible sizes, a warning message is printed and a zeroed Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if M is of type genMatrix. A method to return a new Matrix equal to the product of the transpose of the current Matrix and the Matrix M . It does this by first creating a new Matrix of size numRows and M.numRows. The contents of this new Matrix are then determined and the resulting Matrix is returned. If the two matrices are of incompatible sizes, a warning message is printed and a zeroed Matrix is returned. The method tests for the type of the current Matrix, to see whether the performance can be improved by avoiding having to call the overloaded (i,j) operators, if M is of type genMatrix. To print the contents of the Matrix to the output stream s . The method will print the contents one row at a time. To read the contents of the Matrix from the input stream s . The method expects the components one row at a time. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const Matrix & M ); A function to print out the contents of the Matrix M to the output stream s . Does this by invoking Output() on the Matrix M . friend OPS_Stream & operator $ >> $ ( istream & s , const Matrix & M ); A function to print out the contents of the Matrix M to the output stream s . Does this by invoking Output() on the Matrix M .","title":"Matrix\n"},{"location":"developer/architecture/class_interface/utility/StringContainer/","text":"/* ****************************************************************** OpenSees - Open System for Earthquake Engineering Simulation Pacific Earthquake Engineering Research Center (C) Copyright 1999, The Regents of the University of California All Rights Reserved. Commercial use of this program without express permission of the University of California, Berkeley, is strictly prohibited. See file \u2018COPYRIGHT\u2019 in main directory for information on usage and redistribution, and for a DISCLAIMER OF ALL WARRANTIES. Developed by: Frank McKenna (fmckenna@ce.berkeley.edu) Gregory L. Fenves (fenves@ce.berkeley.edu) Filip C. Filippou (filippou@ce.berkeley.edu) ****************************************************************** */ // $Revision: 1.1 $ // $Date: 2006-11-08 20:06:10 $ // $Source: /usr/local/cvs/OpenSees/SRC/utility/StringContainer.h,v $ // Written: fmk // Created: 11/06 // // Description: This file contains the class definition for StringContainer. // StringContainer is used to store information about a simulation; this // includes start and end times; program version, files opened for reading, files // opened for writing, and all parameters used (specified with pset or -par option // to program) // // What: \u201c@(#) StringContainer.h, revA\u201d #ifndef StringContainer_h #define StringContainer_h class StringContainer { public: StringContainer(); ~StringContainer(); int addString(const char ); const char getString(int) const; const char *operator()(void); int getNumStrings() const; void clear(void); private: char **strings; int numStrings; }; #endif","title":""},{"location":"developer/architecture/class_interface/utility/Timer/","text":"#include \\(<\\tilde{}\\) /Timer/Timer.h \\(>\\) class Timer: public MovableObject MovableObject A Timer object is an object which can be used to measure system resources, i.e. cpu time and memory usage. Currently for Unix systems only. COMPILE FLAG NEEDED. Does nothing. Does nothing. Sets the accounting variables to mark the start of accounting period using the unix functions times() and getrusage . Sets the accounting variables to mark the end of accounting period using the unix functions times() and getrusage . Uses the difference between the starting and ending accounting variables to determine the elapsed real time between the last calls to start() and pause() . Returns this value in units of seconds. Uses the difference between the starting and ending accounting variables to determine the CPU time allocated the process between the last calls to start() and pause() . Returns this value in units of seconds. Uses the difference between the starting and ending accounting variables to determine the number of page faults that required reading of pages from disk between the last calls to start() and pause() . Returns this value. Uses the difference between the starting and ending accounting variables to determine the real time, CPU time, operating system time allocate the process, total number of page faults, number of page faults that required reading of pages from memory, and number of page faults that required no reading from disk between the last calls to start() and pause() . Send these values to s . Invokes Print(s) on the Timer object E .","title":""},{"location":"developer/architecture/class_interface/utility/Vector/","text":"Vector #include \"matrix/Vector.h\" class Vector : The Vector class provides the vector abstraction. A vector of order size is an ordered 1d array of size numbers. For example a vector of order 5: \\(x = [x_0\\) \\(x_1\\) \\(x_2\\) \\(x_3\\) \\(x_4]\\) In the Vector class the data is stored in a 1d double array of length equal to the order of the Vector. At present time none of the methods are declared as being virtual. THIS MAY CHANGE FOR PARALLEL. To construct a Vector of order \\(0\\) . To construct a Vector of order size . The constructor creates an array to store the data and zeroes this array. If not enough memory is available a warning message is printed and a Vector of order \\(0\\) is returned. The Zero() method is invoked on the new Vector before it is returned. To construct a Vector of order size whose data will be stored in the array pointed to by data . The array pointed to by data is not set to zero by the constructor. Note that delete will not be called on this array in the destructor. It is up to the user to ensure that the array pointed to by data is at least as large as size , if this is not the case erroneous results or a segmentation fault may occur. To construct a Vector using another Vector. The new Vector will be identical to the Vector other . The constructor creates an array to store the data and zeroes this array. If not enough memory is available a warning message is printed and a Vector of order \\(0\\) is returned. The contents of the array are then set equal to the contents of other . Will delete any space allocated in the constructors. If the array is passed in the constructor, the space is not deallocated. Returns the order of the Vector, size . Zeros out the Vector, i.e. sets all the components of the Vector to \\(0\\) . Assembles into the current Vector the Vector V . The contents of the current Vector at location ( loc(i) ) is set equal to the current value plus fact times the value of the Vector V at location ( i ). returns \\(0\\) if successful. A warning message is printed for each invalid location in the current Vector or V and a \\(-1\\) is returned. To add a factor fact times the Vector other to the current Vector. returns \\(0\\) if successful. An error message is printed and \\(-1\\) is returned if Vectors are not of the same size. Checks are made to see if the number of operations can be reduced if fact is \\(0\\) or \\(1\\) . To add a factor fact times the Vector formed by the product of the matrix m and the Vector v to the current Vector. No temporary Vector is created. Returns \\(0\\) if successful. Prints a warning message and returns \\(-1\\) if sizes are incompatible. Checks are made to see if the number of operations can be reduced if fact is \\(0\\) or \\(1\\) . Returns the 2 norm of the Vector. Returns the sqrt() of the result of invoking the \\(\\hat{ }\\) operator on the current Vector with the current Vector as the argument. Returns the data at location x in the Vector. Assumes ( x ) is a valid location in the Vector, i.e. \\(0 <= x\\) order, a segmentation fault or erroneous results can occur if this is not the case. Used to set the data at location( x ) in the Vector. Assumes ( x ) is a valid location in the Vector, i.e. \\(0 <= x <\\) order, a segmentation fault or erroneous results can occur if this is not the case. To safely return the data at location x in the Vector. Checks to ensure x is a valid location, i.e. \\(0 <= x\\) order. If x is not a valid location a warning message is printed and VECTOR_NOT_VALID_ENTRY (a static class variable) is returned. This is a slower but safer version of () const . Used to safely set the data at location( x ) in the Vector. Checks to ensure x is a valid location, i.e. \\(0 <= x\\) order. If x is not a valid location a warning message is printed and VECTOR_NOT_VALID_ENTRY (a static class variable) is modified. This is a slower but safer version of () . Returns a Vector of order loc.Size() . The contents of the new Vector are given by the contents of the current Vector at the locations given by the loc . For example the contents of the new Vector at location \\(i\\) are equal to the contents of the current Vector at location loc(i) . Creates a new Vector, copies the data from the current Vector and returns the new Vector. For each invalid location specified in loc for the current Vector, a warning message is printed. Sets the current Vector to be equal to the Vector given by other . If the Vectors are of different sizes, the current data, if allocated in a constructor, is deallocated and more space allocated before the contents are copied. If not enough memory is available a warning message is printed and the order of the current Vector is set to \\(0\\) . A method to add fact to each component of the current Vector. A method to subtract fact from each component of the current Vector. A method to multiply each component of the current Vector by fact. A method which will divide each component of the current Vector by fact . If fact is equal to zero an warning message is printed and the components of the Vector are set to VECTOR_VERY_LARGE_VALUE (defined in <Vector.h> ). A method to return a new Vector whose components are equal to the components of the current Vector plus the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the += operator is invoked on the matrix with fact . If the new Vector and current Vector are of different size, i.e. constructor fails to get enough memory, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector minus the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the -= operator is invoked on the matrix with fact . If the new Vector and current Vector are of different size, i.e. constructor fails to get enough memory, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector times the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the = operator is invoked on the matrix with fact . If the new Vector and current Vector are of different sizes, a warning message is printed. A method to return a new Vector whose components are equal to the components of the current Vector divided the value fact . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the /= operator is invoked on the matrix with fact . Warning messages are printed if fact is equal to \\(0\\) or if the new Vector and current Vector are of different sizes. A method to add the contents of the Vector V to the current Vector. If Vectors are not of same order a warning message is printed and nothing is done. A method to subtract the contents of the Vector V from the current Vector. If Vectors are not of same order a warning message is printed and nothing is done. A method to return a new Vector which is equal to the sum of the the current Vector and the Vector V . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the += operator is invoked on the matrix with V . If the current Vector and V are not of the same size, a warning message is printed and a copy of the current Vector is returned. A warning message is also returned if the new Vector is not of the correct size, i.e. ran out of memory. A method to return a new Vector which is equal to the the current Vector minus the Vector V . A new Vector is constructed using the current Vector as an argument to the constructor; before the new matrix is returned, the -= operator is invoked on the matrix with V . If the current Vector and V are not of the same size, a warning message is printed and a copy of the current Vector is returned. A warning message is also returned if the new Vector is not of the correct size, i.e. ran out of memory. A method to return the dot product of the current Vector and the Vector V . If the current Vector and V are not of the same size, a warning message is printed and \\(0\\) returned. A method to return a new Vector, \\(x\\) , equal to the solution of the matrix equation \\(Mx=\\) the current Vector. A new Vector is created for the return of size M.noRows() . A new Matrix is created of order M.noRows() x M.noRows() and set equal to M if M is square, or \\(M^tM\\) if M is not square. The new Vector is then set equal to the result of invoking Solve ( \\ * this ) on the new Matrix. friend OPS_Stream & operator $ << $ ( OPS_Stream & s , const Vector & V ); A function to print out the contents of the Vector V to the output stream s . prints out the contents of the Vector in the stream and then prints the newline character. friend istream & operator $ >> $ ( istream & s , const Vector & V ); A function to read the contents of the Vector V from the input stream s . Sets the components of V equal to the next V.Size() entries in the stream.","title":"Vector\n"},{"location":"developer/architecture/class_interface/utility/Vertex/","text":"","title":""},{"location":"developer/architecture/class_interface/utility/utility/","text":"Utility Classes Tagged Timer","title":"Utility Classes\n"},{"location":"developer/architecture/class_interface/utility/tagged/TaggedObject/","text":"TaggedObject #include <tagged/TaggedObject.h> class TaggedObject TaggedObject is used as a base class to represent all classes that may have a integer identifier, a tag, to identify the object. It is used in the framework as a base class for many classes, for example DomainComponent and Vertex. The class is provided so that container classes can be written to store objects and provide access to them. This saves us rewriting container classes for each type of object. (templates will be able to provide this functionality when they are provided with all compilers). // Constructor // Destructor // Public Methods // Protected Methods Constructs a TaggedObject with a tag given by tag . The tag of a component is some unique means of identifying the component among like components, i.e. the tag of a node would be its unique node number. Does nothing. Provided so the concrete subclasses destructors will be called. Returns the tag associated with the object. This function is inlined for performance. A pure virtual function. The component is to output itself to the output stream s . The integer flag can be used to select just what should be output, by default \\(0\\) is passed. Invokes Print(s) on the TaggedObject m . Sets the tag of the object to be newTag . It is provided so that MovableObjects can set their tag in recvSelf() .","title":"TaggedObject\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/ArrayOfTaggedObjects/","text":"ArrayOfTaggedObjects #include <tagged/storage/ArrayOfTaggedObjects.h> class ArrayOfTaggedObjects ArrayOfTaggedObjects is used as a container object to store and provide access to objects of type TaggedObject. A single one dimensional array is used to store the pointers to the objects. As a one dimensional array is used, certain ideas are tried to improve performance: (1) if the array needs to be larger to hold more components, the array size is doubled; (2) when adding/retrieving components, the array location given by the components tag is first checked; and (3) a boolean flag is used to keep track of whether all objects have been stored at the location given by the tags. Constructor ### Destructor // Pure Public Methods Creates an array of size sizeInitialArray to hold pointers to the TaggedObject objects that will be added to the container. This array is created using new() to allow the array to grow as needed. Zeros this array and sets a number of integer values: (1) the size of the array; (2) the last position used in the array is \\(0\\) ; (3) the position in the array through which all previous cells are being used for pointers is \\(0\\) ; (4) the number of components added to the container is \\(0\\) ; and (5) all components have been added at the position given by their tag. If not enough space is available, the warning method is invoked on the global ErrorHandler and the integer outlining the array size is set to \\(0\\) . If memory has been allocated for the array, the object invokes the destructor on the current array. If newSize is valid, i.e. \\(>= 1\\) AND newSize \\(>\\) current size of the array, the object allocates memory for a new array of size newSize . It zeros this array and copies the old components to this array, trying to see if they can be located at the positions given by their tags. If all placed at ideal location last time and new size \\(>=\\) position of last entry straight copy, otherwise we reset and add each again using addComponent() . Finally invokes the destructor on the old array. Returns \\(0\\) if successful. If not successful, the warning method is invoked on the global ErrorHandler and a negative value is returned. To add the object newComponent to the container. First checks to see that an object with a similar tag does not already exist in the container, invokes the warning method on the global ErrorHandler and returns false if one does. It then checks to ensure that array is large enough to hold another pointer, if not setSize() is invoked with twice the size of the current array. (If setSize() fails the warning method is invoked and false is returned: NOTE other objects previously added may now be missing!!. The object is then placed into the array by choosing the first of the following that is successful: If the array is large enough, the location given by the objects tag is first tested to see if being used. If not this location is used. If it won\u2019t go in nicely, we find the first location in the array that is not being used and use this location. We keep a marker to this location for subsequent adds so that don\u2019t start at \\(0\\) location all the time. Finally the integer indicating the numbers of objects in the array is incremented and true is returned. To remove the component whose tag is given by tag from the container and return a pointer to the object. If tag is not too large and all components have been added nicely, the contents of the array at location tag is set to \\(0\\) and its old contents returned. Otherwise if the tag is not too large, the contents at position tag is first checked to see if it is pointing to an object and if this object has the same tag as tag , if it does the contents of the array is set to \\(0\\) and the object returned. If the object is not at it\u2019s nice location, the array is searched from the start to the position holding the last entry to see if the array points to the object with the appropriate tag. If it does the array location is set to \\(0\\) and the object returned, otherwise \\(0\\) is returned. If the object has not been found after the last possible location has been checked, \\(0\\) is returned. Returns the number of components currently stored in the container. To return a pointer to the TaggedObject whose identifier is given by tag . If tag is not too large and all components have been added nicely, the contents of the array at location tag is returned. Otherwise if the tag is not too large, the contents at position tag is first checked to see if it is pointing to an object and if this object has the same tag as tag , the object returned. If the object is not at it\u2019s nice location, the array is searched from the start to the position holding the last entry to see if the array points to the object with the appropriate tag. If it does the object is returned. If the object has not been found after the last possible location has been checked, \\(0\\) is returned. To return an iter for iterating through the objects that have been added to the container. Each container object has its own iter. This iter() is reset to point to the start and a reference to this iter is returned. To return an empty copy of the container. Creates a new ArrayOfTaggedObjects object using the current size of the array as the argument for the constructor. It is up to the user of this method to invoke the destructor on the new object. To remove all objects from the container and to invoke the destructor on these objects . Goes through the array, invoking the destructor on any object pointed to by a cell and then setting this cell to \\(0\\) . Resets the internal member data to indicate that zero components have been added to the container. Invokes Print ( s , flag ) on all objects which have been added to the container.","title":"ArrayOfTaggedObjects\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/MapOfTaggedObjects/","text":"MapOfTaggedObjects #include <tagged/storage/MapOfTaggedObjects.h> class MapOfTaggedObjects A MapOfTaggedObjects object is used as a container to store and provide access to objects of type TaggedObject. A MapOfTaggedObjects creates a map object to store the pointers to these objects. A map is created using a template provided by the standard template library. The key used to identify the pointers stored in the map object is the TaggedObjects tag. Each MapOfTaggedObject object also contains a MapOfTaggedObjectsIter object to iterate through the objects which have been added. Constructor ### Destructor // Pure Public Methods Creates the map object and an iter for iterating through the objects that are added to the map. Does nothing. Checks to see that max size for the map (which is a built in value defined for the template class) is larger than newSize . Returns \\(0\\) if successful. If not successful, the warning method is invoked on the global ErrorHandler and \\(-1\\) is returned. To add the object newComponent to the container. First checks to see if an element with a similar tag already exists in the map. If not, the pointer to newElement is added to the map using the insert() method. A check is then made to ensure that the object has been added. (This is done as insert() returns no error flag). Returns true if successful. If not successful, the warning method is invoked on the global ErrorHandler and false is returned. Note that the map template does not allow items with duplicate keys to be added. To remove the component whose tag is given by tag from the container and return a pointer to the object. Invokes find(tag) on the map to first see if the element is there. If it is erase(tag) is invoked on the map to remove the item. \\(0\\) is returned if the component is not in the map, otherwise a pointer to the component is returned. Returns the number of components currently stored in the container. This is found by invoking size() on the map object. To return a pointer to the TaggedObject whose identifier is given by tag . Invokes find(tag) on the map to determine if the component is in the container. If it is a pointer to the component is returned. If it is not in the map \\(0\\) is returned. To return an iter for iterating through the objects that have been added to the container. Each MapOfTaggedObjects object has its own iter. This iter() is first reset and a reference to this iter is then returned. Returns a pointer to a new MapOfTaggedObjects which was created using new() . The new container that is returned is an empty container. If not enough memory is available to create this object the warning method on the global ErrorHandler is invoked and \\(0\\) is returned. Note that it is the responsibility of the caller to invoke the destructor on the object that is returned. To remove all objects from the container and to invoke the destructor on these objects . Goes through the container, invoking the destructor on any object in the map. It then invokes clear() on the map object to clear it. Invokes Print ( s , flag ) on all objects which have been added to the container.","title":"MapOfTaggedObjects\n"},{"location":"developer/architecture/class_interface/utility/tagged/storage/TaggedObjectStorage/","text":"TaggedObjectStorage #include <tagged/storage/TaggedObjectStorage.h> class TaggedObjectStorage TaggedObjectStorage is used as a container object to store and provide access to objects of type TaggedObject. Each TaggedObject object stored in a TaggedObjectStorage object must have a unique integer tag to distinguish it from other the other objects stored. The TaggedObjectStorage class is an abstract base class, it just defines the interface all concrete subclasses must provide. The interface defines methods to add and to remove the components, and methods to obtain access to the components. Constructor ### Destructor // Pure Virtual Public Methods Does nothing. Does nothing. Provided so that the concrete subclasses destructor will be invoked. The subclasses destructor is NOT to delete the objects stored in the object. clearAll() can be invoked by the programmer if this is required. To provide an indication to the container object that newSize components are likely to be added. This is only a hint, it should be acceptable for more or less objects than newSize to be added to the container. To add the object newComponent to the container. To return true if the object was added to the container, false otherwise. The object should not be added if another object with a similar tag already exists in the container. To remove the component whose tag is given by tag from the container. To return a pointer to the removed object if successful, \\(0\\) if not. To return the number of components currently stored in the container. To return a pointer to the TaggedObject whose identifier is given by tag . If the object has not been added to the container \\(0\\) is to be returned. To return an iter for iterating through the objects that have been added to the container. To return an empty copy of the container. To remove all objects from the container and to invoke the destructor on these objects if invokeDestructor is true . To invoke Print ( s , flag ) on all objects which have been added to the container.","title":"TaggedObjectStorage\n"},{"location":"developer/compiling/","text":"Compiling the Application OpenSees uses CMake to provide a consistent cross-platform building experience. A basic walkthrough of this process is developed in build-basic , but users who are new to working with C/C++ projects may first want to read build-tooling . If issues arise while following the basic methodology, it may be necessary to modify some advaced configuration options. For guides on adding new OpenSees components to the CMake build system, see extend . [compile/basic][] [compile/tooling][] [compile/advanced][]","title":"Compiling the Application\n"},{"location":"developer/compiling/advanced/","text":"Advanced Configurations with CMake This section is incomplete Highly customized versions of OpenSees can be configured and built with the help of CMake. In this document, a few special cases are considered: Developing extension libraries for OpenSees. Managing different versions of dependencies like Tcl Linking OpenSees against alternative numerical libraries like BLAS and LAPACK. The CMake build system is primarily composed of 3 files: /Conf.cmake : This file is meant to be modified by intermediate to advanced users who may wish to use non-default configuration options. /ETC/cmake/OpenSeesDependencies*.cmake : This file is used to configure a strategy for locating build dependencies. Users should not have to modify these files for standard builds on common operating systems; a correct strategy should be automatically configured based on the detected OS. /CMakeLists.txt : The root-level CMakeLists.txt defines most of the logic for generating the OpenSees build system. It is responsible for sourcing all other CMake files. Users will not have to modify this file.","title":"Advanced Configurations with CMake\n"},{"location":"developer/compiling/basic/","text":"Compiling Basics The basic steps for building OpenSees can be broken down as follows: Obtain the OpenSees source code Obtain the necessary dependencies Generate and execute the build Before getting started, make sure that you have installed CMake and have suitable C/C++ and Fortran compiler tool chains configured on your computer (see build-chain ). The OpenSees source code repository is hosted on Github and can be downloaded directly from https://github.com/OpenSees/OpenSees . Alternatively, you can clone the repository from a terminal by running the following command: git clone https://github.com/OpenSees/OpenSees If you are planning to contribute changes back to the OpenSees project, you should first fork the repository as mentioned in build-src . Tcl is the only dependency required for a basic OpenSees build that is not already bundled into the source repository on Github. Most Linux distributions and MacOS will already have this installed. A package manager offers the simplest and cleanest way to install such dependencies (see build-pkg ). Explanation needed for adding Tcl paths to CMake config The final step is to generate and run a build system. Users on any platform should be able to use Option I below from a suitable command line environment. Option II outlines an alternative process for building with the graphical Visual Studio environment on Windows. Option I: Command line Open a terminal that is aware of you compiler tool-chain and package manager, or make sure to run any necessary activation scripts to this end. For example, if you are using Anaconda on Windows to manage dependencies, the following steps should be executed through the Anaconda Prompt (on MacOS or Linux this is likely integrated directly into your default terminal application). OpenSees $ mkdir build OpenSees $ cd build build $ cmake .. build $ cmake --build . --target OpenSeesTcl compile/basic-vs.rst Option II: Visual Studio The following steps outline the process of building OpenSees with Visual Studio. This section is incomplete Open Visual Studio. image Select Open a local folder to open the folder containing the OpenSees source repository image Once the directory has been opened, Visual Studio should automatically recognize the CMakeLists.txt file and begin generating the project build files. Once these have been successfully generated, the CMake output console should contain a similar success message to that shown below. image Note In order for this step to succeed, Visual Studio must be correctly configured with a Fortran compiler. See build-chain for more information.","title":"Compiling Basics\n"},{"location":"developer/compiling/dependencies/","text":"Dependencies Try cmake .. ; on Unix-like systems, this is often enough. If a dependency is missing, try one of the following options and run cmake .. again: Install the missing dependency with a system package manager (see below), or Install conan and run conan install .. --build missing from the build directory If a package was successfully installed but CMake still cannot find it, you can manually set one of the variables below: B : use bundled version, S : search operating system ( using CMake\u2019s find_package ) C/S : uses Conan if it has been run, otherwise searches system. Dependency Default Linker variable Compiler include [BLAS] B BLAS_LIBRARIES [LAPACK] [ARPACK] B ARPACK_LIBRARIES - [Tcl] C/S TCL_LIBRARIES TCL_INCLUDE_PATH [SuperLU] B OPS >>> LAPACK: /usr/lib/liblapack.so.3 OPS >>> SUPERLU: OTHER/bin/SuperLU_5.1.1/libSUPERLU.a OPS >>> ARPACK: OTHER/bin/ARPACK/libARPACK.a OPS >>> UMFPACK: OTHER/bin/UMFPACK/libUMFPACK.a OPS >>> CSPARSE: OTHER/bin/CSPARSE/libCSPARSE.a OPS >>> TCL: OPS >>> AMD: OTHER//bin/AMD/libAMD.a OPS >>> BLAS OPS >>> LAPACK OPS >>> SUPERLU APT (Ubuntu, Debian Linux) Dependency Package LAPACK liblapack-dev BLAS libblas-dev SuiteSparse suitesparse-dev SuperLU superlu-dev MySQL* libmysqlclient-dev Tcl* tcl-dev Pacman (Arch, Manjaro Linux) The Pacman package manager Dependency Package LAPACK lapack BLAS blas SuiteSparse suitesparse SuperLU superlu MySQL* mariadb Tcl* tcl Anaconda (Mac, Windows, Linux) Dependency Package Channel LAPACK lapack BLAS blas SuperLU superlu SuiteSparse suitesparse MySQL* mysql conda-forge","title":"Dependencies\n"},{"location":"developer/compiling/tooling/","text":"Tooling This page introduces some basic tools which may be new to users who have not worked with C/C++. Users that are already comfortable with a C/C++ toolchain can skip this page. Source Control A source control tool is like Google Documents, but for source code. It allows developers to track changes that have been made to a project, and easily collaborate by sharing patches. Currently, the industry standard tool for this purpose is Git . Just like Google drive provides a platform for hosting sharing and collaborating on Google documents, GitHub is a platform where developers can host, share and collaborate on software projects. The OpenSees project follows a forking workflow for accepting contributions. The following resources explain more on this matter. For a brief outline on forking we suggest the Atlassians forking workflow page . For a brief introduction to using your new FORK we suggest the Atlassians saving changes . For those interested in programming, you might as well become proficient using git so the link to all of Atlassians git tutorial will make help. Compiler tool-chain ------------------ A compiler tool-chain is the collection of programs that work together to build a final executable program. This includes the actual compiler, a linker, and various other utilities. These programs are typically bundled together and installed collectively in a single step. Different operating systems generally favor a particular tool-chain, but the differences between these can generally be hidden by a build automation tool like CMake. Building OpenSees requires both a C/C++ and a Fortran compiler. Some suggested compilers for various platforms are listed in table-summary Package management APT (Ubuntu, Debian Linux) Dependency Package LAPACK liblapack-dev BLAS libblas-dev SuiteSparse suitesparse-dev SuperLU superlu-dev MySQL* libmysqlclient-dev Tcl* tcl-dev Pacman (Arch, Manjaro Linux) The Pacman package manager Dependency Package LAPACK lapack BLAS blas SuiteSparse suitesparse SuperLU superlu MySQL* mariadb Tcl* tcl Anaconda (Mac, Windows, Linux) Dependency Package Channel LAPACK lapack BLAS blas SuperLU superlu SuiteSparse suitesparse MySQL* mysql conda-forge Command line environments This section is under development Summary The following table gives a brief rundown of the most common configurations for various operating systems. Tool Windows MacOS Linux Source control GitHub Desktop GitHub Desktop Git Build automation CMake CMake CMake Compiler | C++ Visual Studio 2019 Clang GCC Fortran Intel-Fortr an GFortran GFortran Package management Homebrew system","title":"Tooling\n"},{"location":"developer/contributing/","text":"Contributing Bug fixes Link pull request to Bug Report Fill out bug fix template Components Component contributions should include the following: Tests Documentation Extra Resources for contributing Ship small diffs","title":"Contributing\n"},{"location":"developer/extending/FeapElement/","text":"Feap Elements Introduction In this document we will look at the C++ code that is required to introduce a new Truss element, fElmt02, into g3. The new class will call a fortran element subroutine elmt02(), which implements a linear elastic truss element using the FEAP (http://www.ce.berkeley.edu/rlt/feap) element interface. To introduce the new class into g3, two new files are created, fElmt02.h and fElmt02.cpp , to define the class interface and implementation. In addition, two existing files are modified, TclPlaneTruss.cpp and FEM_ObjectBroker.cpp . The new files are outlined in the following subsections. The changes to the two existing files are similar to those outlined in \u2018How to Introduce a New Element into g3\u2019. It should be noted that some additional work may be required by the authors to get other feap element subroutines into g3. This is a consequence of the information the element routines are obtaining from the common blocks. The files outlined in this document can be found in the SRC/element/feap directory of the software distribution. fElmt02.h The file fElmt02.h defines the class interface and details information about the instance variables associated with the objects of type fElmt02 . The interface first declares that the fElmt02 class inherits from the fElement class. class fElmt02 : public fElement { The fElement class is an abstract class which has been provided to hide most of the details of interfacing FEAP element subroutines with g3. It is the fElement class which is responsible for invoking the FEAP subroutine with the appropriate arguments and for managing the data (property and history data) associated with each element. Each new subclass of fElement is responsible for providing the fElement class with information about the element identifier, element end nodes, size of property data, and size of history data associated with the element. The fElmt02 interface then defines three constructors and a destructor. The first two constructors can be used by the analyst to construct the fElmt05 objects. The arguments passed to these constructors include the elements id and the id\u2019s of the two end nodes. In addition to these, the first constructor takes the elements cross sectional area, youngs modulus, and an optional mass density. If no mass density is specified \\(0\\) is assumed. This information is not passed in the second constructor. Instead it is obtained by calling the fortran element subroutine with the isw switch set to \\(1\\) . The third constructor is used in parallel and database programming. The destructor is the method called when the object is being destroyed. It is called so that memory associated with the object is returned to the system. public : // constructors fElmt02 ( int tag , int Nd1 , int Nd2 , double A , double E , double M = 0.0 ); fElmt02 ( int tag , int Nd1 , int Nd2 , int iow ); fElmt02 (); // destructor ~ fElmt02 (); // not actually needed There are no public or protected members defined for this class and no class or instance variables associated with objects of this class. The parent class fElement defines the methods and instance variables. fElmt02.cpp The fElmt02.cpp file contains the implementation. This file contains the implementation of the three constructors and the destructor defined in the interface. The first constructor takes as arguments the objects identifier, the identifiers of the two end nodes, the objects area, youngs modulus and mass density. The constructor first invokes the fElement constructor with the objects identifier, a class identifier, the integer value \\(2\\) indicating that the FEAP subroutine elmt02() is to be invoked, the integer \\(3\\) indicating the number of element properties associated with the subroutine (i.e. size of d), the integer \\(2\\) indicating two nodes are associated with the element, the integer \\(2\\) indicating the dimension of the mesh, the integer \\(2\\) indicating the number of degrees-of-freedom per node, and two integers \\(0\\) and \\(0\\) indicating the sizes of \\(nh1\\) and \\(nh3\\) are \\(0\\) for this FEAP element. The constructor then fills in the property Vector, data, and the ID, connectedNodes, with the appropriate information. Note that data and connectedNodes, which are pointers to the Vector and ID objects, are declared as protected variables in fElement class interface. This constructor basically does the work typically performed when the FEAP subroutine is invoked with isw switch set to \\(1\\) . fElmt02 :: fElmt02 ( int tag , int nd1 , int nd2 , double E , double A , double rho ) : fElement ( tag , ELE_TAG_fElmt02 , 2 , 3 , 2 , 0 , 0 ) { // fill in the property data - feap routine: d(1)=A,d(2)=E,d(3)=rho ( * data )( 0 ) = A ; ( * data )( 1 ) = E ; ( * data )( 2 ) = rho ; // fill in the two end nodes - feap routine: ix(1)=nd1, ix(2)=nd2 ( * connectedNodes )( 0 ) = nd1 ; ( * connectedNodes )( 1 ) = nd2 ; } The second constructor takes as arguments the objects identifier, the identifiers of the two end nodes, and an integer indicating an output file where the element data will be written. The constructor first invokes the fElement constructor with the objects identifier, a class identifier, the integer value \\(2\\) indicating that the FEAP subroutine elmt02() is to be invoked, the integer \\(3\\) indicating the number of element properties associated with the subroutine (i.e. size of d), the integer \\(2\\) indicating two nodes are associated with the element, the integer \\(2\\) indicating the dimension of the mesh, the integer \\(2\\) indicating the number of degrees-of-freedom per node, and the integer iow. The fElement() constructor will in turn invoke the fortran element subroutine elmt02(), with the isw switch set to \\(1\\) , to read in the element data and set the sizes of \\(nh1\\) and \\(nh3\\) . Note that to use this constructor, the feap input routines pinput() and tinput() have to be overridden . After the base constructor has been called, the constructor then fills in the ID, connectedNodes, with the appropriate node information. fElmt02 :: fElmt02 ( int tag , int nd1 , int nd2 , int iow ) : fElement ( tag , ELE_TAG_fElmt02 , 2 , 3 , 2 , 2 , 2 , iow ) { // fill in the two end nodes - feap routine : ix ( 1 ) = nd1 , ix ( 2 ) = nd2 ( * connectedNodes )( 0 ) = nd1 ; (*connectedNodes)(1) = nd2 ; } The third constructor and the destructor are then provided. The second constructor, which is used by an FEM_ObjectBroker, simply invokes an fElement constructor with the classTag. Nothing more is required. The destructor does nothing (might even remove it?) fElmt02::fElmt02() :fElement(ELE_TAG_fElmt02) { // does nothing } fElmt02::~fElmt02() { // does nothing } Example The g3 interpreter can now be modified to include this new element. The modifications to allow the introduction of the new command fTruss eleId iNodeID jNodeId A E into g3 are similar to those outlined in \u2018How to Introduce a New Element into g3\u2019. The example g3tcl script for the static analysis of a simple linear three bar truss example, shown in figure [example1] , is given below: Tcl script #create the ModelBuilder object model Tcl2dTruss # build the model # add nodes - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # add the fElmt02 elements - command: fTruss eleID node1 node2 A E fTruss 1 1 4 10.0 3000 fTruss 2 2 4 5.0 3000 fTruss 3 3 4 5.0 3000 # set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 # apply the load - command: load nodeID xForce yForce load 4 100 - 50 # build the components for the analysis object system BandSPD constraints Plain integrator LoadControl 1 algorithm Linear numberer RCM # create the analysis object analysis Static 1 # perform the analysis analyze # print the results at node 4 and at all elements print node 4 print ele Input script for FEAP Feap ** example 1 4 , 3 , 2 , 2 , 2 , 2 coordinates 1 0 0 . 0 0 . 0 2 0 144 . 0 0 . 0 3 0 168 . 0 0 . 0 4 0 72 . 0 96 . 0 elements 1 0 1 1 4 2 0 2 2 4 3 0 2 3 4 boundary restraints 1 0 1 1 2 0 1 1 3 0 1 1 forces 4 0 100 . 0 - 50 . 0 mate , 1 user , 2 10 , 3000 , 0 mate , 2 user , 2 5 , 3000 , 0 end batch tang ,, 1 disp ,, 4 stre , all end interactive stop When g3 is run and the commands outlined above are input by the analyst at the interpreter prompt, or are sourced in from a file, the following output is generated: Node: 4 Coordinates : 72 96 commitDisps: 0.530093 -0.177894 unbalanced Load: 100 -50 Element: 1 type: elmt02 iNode: 1 jNode: 4 Area: .100E+02 Youngs Modulus: .300E+04 Rho: .000E+00 strain: 0.14645E-02 axial force: 0.43935E+02 Element: 2 type: elmt02 iNode: 2 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.38364E-02 axial force: -0.57546E+02 Element: 3 type: elmt02 iNode: 3 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.36874E-02 axial force: -0.55311E+02 The following can be found at the end of the FEAP output file: Feap ** example 1 N o d a l D i s p l a c e m e n t s Time 0.00000E+00 Prop. Ld. 1.00000E+00 Node 1 Coord 2 Coord 1 Displ 2 Displ 4 7.2000E+01 9.6000E+01 5.3009E-01 -1.7789E-01 *Macro 3 * stre all v: 0.00 0.00 0.00 t= 0.07 0.05 Element: 1 type: elmt02 iNode: 1 jNode: 4 Area: .100E+02 Youngs Modulus: .300E+04 Rho: .000E+00 strain: 0.14645E-02 axial force: 0.43935E+02 Element: 2 type: elmt02 iNode: 2 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.38364E-02 axial force: -0.57546E+02 Element: 3 type: elmt02 iNode: 3 jNode: 4 Area: .500E+01 Youngs Modulus: .300E+04 Rho: .000E+00 strain: -0.36874E-02 axial force: -0.55311E+02 How to Introduce a FEAP Element into g3 Version 0.1 - Preliminary Draft December 20, 1999 Frank McKenna and Gregory L. Fenves PEER, University of California at Berkeley","title":"Feap Elements\n"},{"location":"developer/extending/NewElement/","text":"New Elements Introduction This document is intended to demonstrate the steps necessary to introduce a new element into the OpenSees interpreter. OpenSees is an object-oriented framework under construction for finite element analysis. A key feature of OpenSees is the interchangeably of components and the ability to integrate existing libraries and new components into the framework (not just new element classes) without the need to change the existing code. Core components, that is the abstract base classes, define the minimal interface (minimal to make adding new component classes easier but large enough to ensure all that is required can be accommodated). The OpenSees interpreter is an extension of the Tcl scripting language. Tcl is a string based procedural command language which allows substitution, loops, mathematical expressions, and procedures. The OpenSees interpreter adds commands to Tcl to allow users to create objects from the OpenSees framework and invoke methods on those objects once they have been created. Each of these commands is associated (bound) with a C++ procedure that is provided. It is this procedure that is called upon by the interpreter to parse the command. In this document we provide a simple example of a script that can be used with the OpenSees interpreter to analyze a simple model. We then outline the C++ code necessary to introduce a new element into the framework. In addition, we demonstrate what must be done in addition to use the element with the interpreter. Finally, we show the changes to the script that are needed to use this new element. Note, that all the code and example scripts mentioned in this document can be found in OpenSees/EXAMPLES/NewElement . A Simple Truss Example In this section the example script, example1.tcl, for the static analysis of the simple linear three bar truss example shown in figure [example1] is presented. For a more comprehensive set of examples showing the reader should is referred to the OpenSees examples manual, which can be found at http://opensees.berkeley.edu/OpenSees/OpenSeesExamples.pdf. In the script, the analyst first creates a ModelBuilder object. In this example a BasicBuilder object is created. The construction of this object adds new commands to the interpreter, i.e. node, material, element, fix and load. It is these commands which can be used by the analyst to construct the model. # create the ModelBuilder object model BasicBuilder -ndm 2 -ndf 2 The analyst then constructs the model. This is done by creating the four Node objects, a Material object, three Element objects, some Constraint objects, and finally a Load object. # build the model # node nodeId xLoc yLoc node 1 0 0 node 2 144 0 node 3 168 0 node 4 72 96 # material matId type <type args> uniaxialMaterial Elastic 1 3000 # element truss trussId iNodeId jNodeId Area matId element truss 1 1 4 10 1 element truss 2 2 4 5 1 element truss 3 3 4 5 1 # constraint nodeId xFix? yFix? fix 1 1 1 fix 2 1 1 fix 3 1 1 # pattern type patternID TimeSeries pattern Plain 1 Linear { # load nodeID xForce yForce load 4 100 - 50 } After the model has been defined, the analyst then constructs the Analysis. This is done by first constructing the components of the Analysis object. In this example a BandSPD linear system of equation and a lapack solver (default for BandSPD), a ConstraintHandler object which deals with homogeneous single point constraints, an Integrator object of type LoadControl with a load step increment of one, an Algorithm object of type Linear, and a DOF_Numberer object of type RCM (reverse Cuthill-Mckee). Once these objects have been created, the StaticAnalysis object is constructed. # build the components for the analysis object system BandSPD constraints Plain integrator LoadControl 1 algorithm Linear numberer RCM # create the analysis object analysis Static After the Analysis object is constructed a Recorder object is created. In this example we create a NodeRecorder to record the load factor and the two nodal displacements at Node 4, the results are stored in the file example.out. # create a Recorder object for the nodal displacements at node 4 recorder Node example . out disp - load - nodes 4 - dof 1 2 Finally the analysis is performed and the results are printed. # perform the analysis analyze 1 # print the results at node 4 and at all elements print node 4 print ele playback 1 When OpenSees is run and the commands outlined above are input by the analyst at the interpreter prompt, or are sourced from a file using the source filename command, the following is output by the program. Node : 4 Coordinates : 72 96 commitDisps : 0.530093 - 0.177894 unbalanced Load : 100 - 50 Element : 1 type : Truss iNode : 1 jNode : 4 Area : 10 strain : 0.00146451 axial load : 43.9352 unbalanced load : 26.3611 35.1482 - 26.3611 - 35.1482 Material : ElasticMaterialModel : 1 E : 3000 Element : 2 type : Truss iNode : 2 jNode : 4 Area : 5 strain : - 0.00383642 axial load : - 57.5463 unbalanced load : 34.5278 - 46.0371 - 34.5278 46.0371 Material : ElasticMaterialModel : 1 E : 3000 Element : 3 type : Truss iNode : 3 jNode : 4 Area : 5 strain : - 0.00368743 axial load : - 55.3114 unbalanced load : 39.1111 - 39.1111 - 39.1111 39.1111 Material : ElasticMaterialModel : 1 E : 3000 1 0.530093 - 0.177894 Introducing a New Element into OpenSees We will look at the C++ code that is required to introduce a new Truss element, MyTruss, into the framework and a new command myTruss into the interpreter. The new class will work in planar problems where each node has two degrees-of-freedom. The new type will be complicated by the fact that each instance will be associated with a UniaxialMaterial object, this is done to show what this entails for parallel and database processing. To introduce the new class into OpenSees three new files must be created, MyTruss.h and MyTruss.cpp, to define the class interface and implementation, and TclMyTrussCommand.cpp, to define the procedure to be invoked when the Tcl command myTruss is invoked. In addition two existing files must be modified, TclElementCommands.cpp, and FEM_ObjectBroker.C and FEM_ObjectBroker.C. The new files and modifications to existing files are outlined in the following subsections. All the files can be found in the OpenSees/EXAMPLES/ExampleNewElement directory. MyTruss.h The file MyTruss.h defines the class interface and details information about the instance variables associated with the objects of type MyTruss. The interface first declares that the MyTruss class inherits from the Element class. class MyTruss : public Element { The interface then defines two constructors and a destructor. The first constructor is used to construct each object by the analyst. The arguments passed include the elements id, the id\u2019s of the two end nodes, a reference to a Material object (a copy of which is created by the MyTruss object), and the Area of the bar. In addition the analyst may specify a mass per unit volume, if none is specified \\(0\\) is assumed. The second is used in parallel and database programming. The destructor is the method called when the object is being destroyed. It is called so that memory associated with the object is returned to the system. public : // constructors MyTruss ( int tag , int Nd1 , int Nd2 , UniaxialMaterial & theMat , double A , double rho = 0.0 ); MyTruss (); // destructor ~ MyTruss (); After the destructor comes the public member functions, these define the methods that all other objects in the program will be able to invoke on objects of type MyTruss. These methods are all inherited from the Element class and each subclass of Element must declare them. public : // public methods to obtain information about dof & connectivity int getNumExternalNodes ( void ) const ; const ID & getExternalNodes ( void ); int getNumDOF ( void ); // public methods to set the state of the element void setDomain ( Domain * theDomain ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); int update ( void ); // public methods to obtain stiffness , mass , damping and residual information const Matrix & getTangentStiff ( void ); const Matrix & getSecantStiff ( void ); const Matrix & getDamp ( void ); const Matrix & getMass ( void ); void zeroLoad ( void ); const Vector & getResistingForce ( void ); const Vector & getResistingForceIncInertia ( void ); // public methods for output int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); int displaySelf ( Renderer & theViewer , int displayMode , float fact ); void Print ( OPS_Stream & s , int flag = 0 ); Response * setResponse ( char ** argv , int argc , Information & eleInformation ); int getResponse ( int responseID , Information & eleInformation ); Following the declaration of the public member functions comes the declaration of a private member function, computeStrain(), which can only be called by objects of type MyTruss. private : // private member function - only available to objects of the class double computeCurrentStrain ( void ) const ; After the private member function is defined all the private variables, data which can only be accessed by objects of this type. First the instance variables associated with each object of this class are defined. Each object of this type will store its length, area, mass per unit volume, a pointer to a UniaxialMaterial object, a pointer to each of it\u2019s end nodes, a pointer to a transformation matrix and an ID (integer array) object containing the node identifiers. private : // private attributes - a copy for each object of the class UniaxialMaterial * theMaterial ; // pointer to a material ID externalNodes ; // contains the id's of end nodes Matrix trans ; // hold the transformation matrix double L ; // length of MyTruss based on undeformed configuration double A ; // area of MyTruss double M ; // weight per unit volume Node * end1Ptr , * end2Ptr ; // two pointers to the trusses nodes. After the instance variable is defined some class variables. There is one instance of each of these variables shared by all objects of this class. The class variables comprise of a 3 matrices to return the stiffness, mass and damping matrices from the member functions and a vector to return the residual force. While the class variables could also be declared as instance variables, declaring them as class variables reduces the amount of memory required by each object of type MyTruss. private : // private class attributes - single copy for all objects of the class static Matrix trussK ; // class wide matrix for returning stiffness static Matrix trussD ; // class wide matrix for returning damping static Matrix trussM ; // class wide matrix for returning mass static Vector trussR ; // class wide vector for returning residual MyTruss.C The MyTruss.C file contains the implementation. The file first initializes the class variables defined in the MyTruss.h file. Here the three matrices are initialized to be of size 4*4 and the Vector of size 4. It should be noted that access to the data stored in these objects is done using the C indexing notation, which starts at 0. // initialize the class wide variables Matrix MyTruss::trussK ( 4 , 4 ); Matrix MyTruss::trussM ( 4 , 4 ); Matrix MyTruss::trussD ( 4 , 4 ); Vector MyTruss::trussR ( 4 ); After the initialization of the class variables, the constructors for the class are implemented. The first constructor takes as arguments the objects identifier, the identifiers of the two end nodes, a reference to the objects material and the objects area. The constructor initializes the instance variables with the appropriate values. In addition, the constructor makes a copy of the Material object; it is this copy that will be used by the MyTruss object. The second constructor, which takes no arguments, is used in parallel and database programming for constructing an empty object whose instance variables will be filled in by the object itself when recvSelf() is invoked on the object. MyTruss :: MyTruss ( int tag , int Nd1 , int Nd2 , UniaxialMaterial & theMat , double a , double rho ) : Element ( tag , ELE_TAG_MyTruss ), externalNodes ( 2 ), trans ( 1 , 4 ), L ( 0.0 ), A ( a ), M ( rho ), end1Ptr ( 0 ), end2Ptr ( 0 ) { // create a copy of the material object theMaterial = theMat . getCopy (); // fill in the ID containing external node info with node id 's externalNodes ( 0 ) = Nd1 ; externalNodes ( 1 ) = Nd2 ; } // constructor which should be invoked by an FE_ObjectBroker only MyTruss :: MyTruss () : Element ( 0 , ELE_TAG_MyTruss ), theMaterial ( 0 ), externalNodes ( 2 ), trans ( 1 , 4 ), L ( 0.0 ), A ( 0.0 ), M ( 0.0 ), end1Ptr ( 0 ), end2Ptr ( 0 ) { // does nothing } After the two constructors comes the destructor for the class. This is the function that is invoked when the object is removed from the system. Each object is responsible for cleaning up after itself, anything the object created using the new operator. The destructor is also responsible for memory allocated by other objects, in this case the UniaxialMaterial object. MyTruss ::~ MyTruss () { if (theMaterial != 0) delete theMaterial ; } After the destructor comes a number of utility methods that each Element type must provide. These include the methods getNumberExternalNodes() to return the number of end nodes, getExternalNodes() an ID object containing the identifiers of these nodes, and getNumDOF() to return the number of degrees of freedom associated with the Element. In addition, there is the method setDomain() that is called when the object is added to a Domain object. When this method is invoked each MyTruss object completes the initialization of it\u2019s instance variables. For example, if the two end nodes exist in the Domain the pointers to these end nodes are now set. int MyTruss :: getNumExternalNodes ( void ) const { return 2 ; } const ID & MyTruss :: getExternalNodes ( void ) { return externalNodes ; } int MyTruss :: getNumDOF ( void ) { return 4 ; } void MyTruss :: setDomain ( Domain * theDomain ) { // first ensure nodes exist in Domain and set the node pointers int Nd1 = externalNodes ( 0 ); int Nd2 = externalNodes ( 1 ); end1Ptr = theDomain -> getNode ( Nd1 ); end2Ptr = theDomain -> getNode ( Nd2 ); if ( end1Ptr == 0 ) return ; // don 't go any further - otherwise segmentation fault if ( end2Ptr == 0 ) return ; // don 't go any further - otherwise segmentation fault // call the DomainComponent class method . note : THIS IS VERY VERY IMPORTANT this -> DomainComponent :: setDomain ( theDomain ); // ensure connected nodes have correct number of dof 's int dofNd1 = end1Ptr -> getNumberDOF (); int dofNd2 = end2Ptr -> getNumberDOF (); if (( dofNd1 != 2 ) || ( dofNd2 != 2 )) return ; // don 't go any further - otherwise segmentation fault // now determine the length & transformation matrix const Vector & end1Crd = end1Ptr -> getCrds (); const Vector & end2Crd = end2Ptr -> getCrds (); double dx = end2Crd ( 0 ) - end1Crd ( 0 ); double dy = end2Crd ( 1 ) - end1Crd ( 1 ); L = sqrt ( dx * dx + dy * dy ); if ( L == 0.0 ) return ; // don 't go any further - otherwise divide by 0 error double cs = dx / L ; double sn = dy / L ; trans ( 0 , 0 ) = - cs ; trans ( 0 , 1 ) = - sn ; trans ( 0 , 2 ) = cs ; trans ( 0 , 3 ) = sn ; // determine the nodal mass for lumped mass approach M = M * A * L / 2 ; // remember M was set to rho in the constructor } Following the methods comes a number of methods related to the solution algorithm. These methods include commitState(), which is invoked when a point on the solution path has been achieved for a step in the analysis, revertToLastCommit() which is a method invoked to inform the Element that convergence to an acceptable solution was not achieved and that the Element is to return to the state it was at when the last commit() method was invoked on it. The method revertToStart() is invoked to tell the Element that it is to return to the state it was at the beginning of the analysis. For a MyTruss element type, which has no state information, the object itself will simply invoke the corresponding method on it\u2019s associated material object. int MyTruss :: commitState () { return theMaterial->commitState() ; } int MyTruss :: revertToLastCommit () { return theMaterial->revertToLastCommit() ; } int MyTruss :: revertToStart () { return theMaterial->revertToStart() ; } int MyTruss :: update () { // determine the current strain given trial displacements at nodes double strain = this->computeCurrentStrain() ; // set the strain in the materials theMaterial->setTrialStrain(strain) ; return 0 ; } After these come the implementation of the typical Element methods to obtain the current linearized stiffness, mass and damping matrices, and the residual vector. In each of these methods, a call is made to the objects computeCurrentStrain() method. Once the strain has been computed the tangent matrices and residual vector are computed using standard matlab like operations. It should be noted that the results are placed into the class matrices and vectors. const Matrix & MyTruss :: getTangentStiff ( void ) { if ( L == 0 ) { // if length == zero - we zero and return trussK . Zero (); return trussK ; } // get the current E from the material for the strain that was set // at the material when the update () method was invoked double E = theMaterial -> getTangent (); // form the tangent stiffness matrix trussK = trans ^ trans ; trussK *= A * E / L ; return trussK ; } const Matrix & MyTruss :: getSecantStiff ( void ) { if ( L == 0 ) { // if length == zero - we zero and return trussK . Zero (); return trussK ; } // get the current strain from the material double strain = theMaterial -> getStrain (); // get the current stress from the material double stress = theMaterial -> getStress (); // compute the tangent double E = stress / strain ; // form the tangent stiffness matrix trussK = trans ^ trans ; trussK *= A * E / L ; return trussK ; } const Matrix & MyTruss :: getDamp ( void ) { // no damping associated with this type of element return trussD ; } const Matrix & MyTruss :: getMass ( void ) { if ( L == 0 ) { // if length == zero - we zero and return trussM . Zero (); return trussM ; } // determine mass matrix assuming lumped mass double nodeMass = M * A * L / 2 ; for ( int i = 0 ; i < 4 ; i ++ ) trussM ( i , i ) = nodeMass ; return trussM ; } void MyTruss :: zeroLoad ( void ) { // does nothing - no element loads associated with this object } const Vector & MyTruss :: getResistingForce () { if ( L == 0 ) { // if length == zero - we zero and return trussR . Zero (); return trussR ; } // R = Ku - Pext // force = F * transformation double force = A * theMaterial -> getStress (); for ( int i = 0 ; i < 4 ; i ++ ) trussR ( i ) = trans ( 0 , i ) * force ; return trussR ; } const Vector & MyTruss :: getResistingForceIncInertia () { // R = Ku - Pext + Ma // determine the resisting force sans mass this -> getResistingForce (); // now include the mass portion if ( L != 0 && M != 0 ) { double nodeMass = M * A * L / 2 ; const Vector & accel1 = end1Ptr -> getTrialAccel (); const Vector & accel2 = end2Ptr -> getTrialAccel (); for ( int i = 0 ; i < 2 ; i ++ ) { trussR ( i ) = trussR ( i ) - nodeMass * accel1 ( i ); trussR ( i + 2 ) = trussR ( i + 2 ) - nodeMass * accel2 ( i ); } } return trussR ; } After the more standard Element methods come two pairwise methods that are required for parallel and database processing, sendSelf() and recvSelf(). Each Element object is responsible for sending enough information to a Channel object such that an Element of similar type, on the other end of the Channel, will be able to initialize itself so that the geometry and state information in the two objects are the same. When sending this data to a Channel a MyTruss object initially sends its tag, it\u2019s unique database tag, it\u2019s area, the Material objects tag in a vector object to the Channel. The MyClass object then sends it\u2019s ID to the Channel and finally the MaterialObject is told to send itself. When receiving itself from a Channel a MyTruss object will receive this information. It should be noticed that before the object can invoke recvSelf() on its Material object it must create the appropriate type of Material object, this it does using the FEM_ObjectBroker object and the Material objects class tag. int MyTruss :: sendSelf ( int commitTag , Channel & theChannel ) { // note : we don 't check for dataTag == 0 for Element // objects as that is taken care of in a commit by the Domain // object - don' t want to have to do the check if sending data int dataTag = this- > getDbTag (); // MyTruss packs it's data into a Vector and sends this to theChannel // along with it's dbTag and the commitTag passed in the arguments Vector data(5) ; data(0) = this->getTag() ; data(1) = A ; data(4) = M ; data(2) = theMaterial->getClassTag() ; int matDbTag = theMaterial->getDbTag() ; // NOTE : we do have to ensure that the material has a database // tag if we are sending to a database channel . if ( matDbTag == 0 ) { matDbTag = theChannel . getDbTag (); if (matDbTag != 0) theMaterial->setDbTag(matDbTag) ; } data ( 3 ) = matDbTag ; theChannel . sendVector ( dataTag , commitTag , data ); // MyTruss then sends the tags of it 's two end nodes theChannel.sendID(dataTag, commitTag, externalNodes); // finally MyTruss asks it' s material object to send itself theMaterial- > sendSelf ( commitTag , theChannel ); return 0 ; } int MyTruss :: recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ) { int dataTag = this->getDbTag() ; // MyTruss creates a Vector, receives the Vector and then sets the // internal data with the data in the Vector Vector data(5) ; theChannel.recvVector(dataTag, commitTag, data) ; this->setTag((int)data(0)) ; A = data(1) ; M = data(4) ; // MyTruss now receives the tags of it's two external nodes theChannel.recvID(dataTag, commitTag, externalNodes) ; // we create a material object of the correct type, // sets its database tag and asks this new object to receive itself. int matClass = data(2) ; int matDb = data(3) ; theMaterial = theBroker.getNewUniaxialMaterial(matClass) ; // we set the dbTag before we receive the material - this is important theMaterial->setDbTag(matDb) ; theMaterial->recvSelf(commitTag, theChannel, theBroker) ; return 0 ; } To display graphically an Element in an image the displaySelf() method is invoked on an Element object. What is displayed depends on the flag and display factor values provided as arguments. The display factor is used to magnify the nodal displacements at the member ends so that distortion of the structure is visible. The flag is used to indicate what measure is to be displayed. A MyTruss object will display the strain in the object if a \\(1\\) is passed, otherwise the force in the object is displayed. int MyTruss :: displaySelf ( Renderer & theViewer , int displayMode , float fact ) { // first determine the two end points of the truss based on // the display factor ( a measure of the distorted image ) // store this information in 2 3 d vectors v1 and v2 const Vector & end1Crd = end1Ptr -> getCrds (); const Vector & end2Crd = end2Ptr -> getCrds (); const Vector & end1Disp = end1Ptr -> getDisp (); const Vector & end2Disp = end2Ptr -> getDisp (); Vector v1 ( 3 ); Vector v2 ( 3 ); for ( int i = 0 ; i < 2 ; i ++ ) { v1 ( i ) = end1Crd ( i ) + end1Disp ( i ) * fact ; v2 ( i ) = end2Crd ( i ) + end2Disp ( i ) * fact ; } if ( displayMode == 3 ) { // use the strain as the drawing measure double strain = theMaterial -> getStrain (); return theViewer . drawLine ( v1 , v2 , strain , strain ); } else if ( displayMode == 2 ) { // otherwise use the material stress double stress = A * theMaterial -> getStress (); return theViewer . drawLine ( v1 , v2 , stress , stress ); } else { // use the axial force double force = A * theMaterial -> getStress (); return theViewer . drawLine ( v1 , v2 , force , force ); } } To print the state of the Element, to a file or to the screen, the Print() method is invoked on the Element object. What is printed by the object, depends on the flag passed as an argument. A MyTruss object prints a detailed description of its state if \\(0\\) is passed, a shortened version if \\(1\\) is passed, and nothing at all if anything else is passed. void MyTruss :: Print ( OPS_Stream & s , int flag ) const { // compute the strain and axial force in the member double strain , force ; if ( L == 0.0 ) { strain = 0 ; force = 0.0 ; } else { strain = theMaterial -> getStrain (); force = A * theMaterial -> getStress (); } for ( int i = 0 ; i < 4 ; i ++ ) trussR ( i ) = trans ( 0 , i ) * force ; if ( flag == 0 ) { // print everything s << \"Element: \" << this -> getTag (); s << \" type: MyTruss iNode: \" << externalNodes ( 0 ); s << \" jNode: \" << externalNodes ( 1 ); s << \" Area: \" << A ; if ( M != 0 ) s << \" Mass (PerUnitVolume): \" << M ; s << \" \\n\\t strain: \" << strain ; s << \" axial load: \" << force ; s << \" \\n\\t unbalanced load: \" << trussR ; s << \" \\t Material: \" << * theMaterial ; s << endln ; } else if ( flag == 1 ) { // just print ele id , strain and force s << this -> getTag () << \" \" << strain << \" \" << force << endln ; } } To allow the analyst to obtain information specific to the Truss element the methods setResponse() and getResponse() are provided. The setResponse() method is used to obtain an integer code that is used in subsequent requests to the MyTruss object for information. The integer returned depends on the array of strings passed to the element. A MyTruss object responds to requests for the axial force, \u2018axialForce\u2019, and the tangent stiffness matrix, \u2018stiffness\u2019. Requests for material information are passed to the material object. A \\(-1\\) is returned if the MyTruss does not supply this information. it should be noted that for information returned in ID, vector and Matrix objects the MyTruss elements allocate these objects from the heap, this is done to reduce memory overhead in the elements. The getResponse() method is used to obtain the information. Response * MyTruss :: setResponse ( char ** argv , int argc , Information & eleInformation ) { // // we compare argv [ 0 ] for known response types for the Truss // // axial force if (strcmp(argv [ 0 ] ,\"axialForce\") ==0) return new ElementResponse(this, 1, 0.0) ; // a material quantity else if (strcmp(argv [ 0 ] ,\"material\") == 0) return theMaterial->setResponse(&argv [ 1 ] , argc-1, eleInformation) ; else return 0 ; } int MyTruss :: getResponse ( int responseID , Information & eleInformation ) { switch (responseID) { case -1: return -1 ; case 1: return eleInfo.setDouble(A * theMaterial->getStress()) ; default : return 0 ; } } Finally the private member function for determining the current strain in the element if defined. This method uses the nodal pointers to look at the current trial displacements at the nodes from which the strain can be determined. double MyTruss :: computeCurrentStrain ( void ) const { // determine the strain const Vector & disp1 = end1Ptr -> getTrialDisp (); const Vector & disp2 = end2Ptr -> getTrialDisp (); double dLength = 0.0 ; for ( int i = 0 ; i < 2 ; i ++ ) dLength -= ( disp2 ( i ) - disp1 ( i )) * trans ( 0 , i ); double strain = dLength / L ; return strain ; } TclElementCommands.cpp The TclElementCommands.cpp file contains the C++ procedure TclModelBuilderElementCommand(). It is this procedure that is invoked every time the element command is invoked. This file is modified to allow the analyst to construct a new element of type MyTruss with the command: element myTruss eleId iNodeID jNodeId area materialID massPerUnitVolume To do this in the prototypes section of the file the the procedure TclModelBuilder_addMyTruss() is declared to be an externally defined procedure. (NOTE that the whole element myTruss command could be parsed in this file. However, to keep things modular and allow the command to work with other interpreters that may be developed it has been the convention to place the procedure in a seperate file). extern int TclModelBuilder_MyTruss(ClientData , Tcl_Interp *, int, char **, Domain*, TclModelBuilder *, int); Then in the body of the procedure we inform the interpreter that, if the second argument of the element command is the string myTruss , that the external procedure is to be invoked. This is done by adding the following 4 lines of code: } else if ( strcmp ( argv [ 1 ], \" myTruss \" ) == 0 ) { int result = TclModelBuilder_MyTruss ( clientData , interp , argc , argv , theTclDomain , theTclBuilder ) ; return result ; TclMyTrussCommand.cpp In this file we place the procedure, TclModelBuilder_MyTruss(), that was defined to be external in TclElementCommands.cpp. In this procedure a check is first made to insure that the correct number of arguments have been provided. The arguments are then parsed. A MyTruss element object is finally constructed with the parsed arguments and added to the domain. int TclModelBuilder_MyTruss ( ClientData clientData , Tcl_Interp * interp , int argc , char ** argv ) { // make sure at least one other argument to contain type of system if ( argc != 7 && argc != 8 ) { blah -> result = \"WARNING bad command - myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } // get the id, x_loc and y_loc int trussId , iNode , jNode , matID ; double A , M = 0.0 ; if ( Tcl_GetInt ( interp , argv [ 2 ], & trussId ) != TCL_OK ) { blah -> result = \"WARNING invalid eleId- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } if ( Tcl_GetInt ( interp , argv [ 3 ], & iNode ) != TCL_OK ) { blah -> result = \"WARNING invalid iNode- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } if ( Tcl_GetInt ( interp , argv [ 4 ], & jNode ) != TCL_OK ) { blah -> result = \"WARNING invalid jNode- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } if ( Tcl_GetDouble ( interp , argv [ 5 ], & A ) != TCL_OK ) { blah -> result = \"WARNING invalid A- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } if ( Tcl_GetInt ( interp , argv [ 6 ], & matID ) != TCL_OK ) { blah -> result = \"WARNING invalid matId- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } if ( argc == 8 && Tcl_GetDouble ( interp , argv [ 7 ], & M ) != TCL_OK ) { blah -> result = \"WARNING invalid matId- myTruss eleId iNode jNode Area matID\" ; return TCL_ERROR ; } UniaxialMaterial * theMaterial = theModelBuilder -> getUniaxialMaterial ( matID ); if ( theMaterial == 0 ) { opserr << \"WARNING TclPlaneTruss - truss - no Material found with tag \" ; opserr << matID << endl n ; return TCL_ERROR ; } // now create the truss and add it to the Domain MyTruss * theTruss = new MyTruss ( trussId , iNode , jNode , * theMaterial , A , M ); if ( theTruss == 0 ) { opserr << \"WARNING TclPlaneTruss - addMyTruss - ran out of memory for node \" ; opserr << trussId << endl n ; return TCL_ERROR ; } if ( theDomain -> addElement ( theTruss ) == false ) { delete theTruss ; opserr << \"WARNING TclPlaneTruss - addTruss - could not add Truss to domain \" ; opserr << trussId << endl n ; return TCL_ERROR ; } // if get here we have successfully created the node and added it to the domain return TCL_OK ; } FEM_ObjectBroker.cpp An FEM_ObjectBroker is the object responsible for creating blank objects of a specific type. This object is required for parallel and database programming. The MyTruss.h file is first included in the list of element header files. Then code in the getNewElement() method is revised to return a new MyTruss element if requested. Element * FEM_ObjectBroker::getNewElement ( int classTag ) { switch ( classTag ) { // existing code ... // new two lines of code added for MyTruss element case ELE_TAG_MyTruss : return new MyTruss (); ... Modification to Example Script To use the new element in the new OpenSees interpreter, the code in example1.tcl is modified. The modified code can be found in example2.tcl. The lines with the element command in example1.tcl : # element truss trussId iNodeId jNodeId Area matId element truss 1 1 4 10 1 element truss 2 2 4 5 1 element truss 3 3 4 5 1 are replaced with the following lines in example2.tcl : # element truss trussId iNodeId jNodeId Area matId element myTruss 1 1 4 10 1 element myTruss 2 2 4 5 1 element myTruss 3 3 4 5 1 Frank McKenna and Gregory L. Fenves Pacific Earthquake Engineering Research Center University of California, Berkeley August 21, 2000 Version 1.0","title":"Introducing a New Element into OpenSees"},{"location":"developer/extending/NewMaterial/","text":"Material Models Introduction This document shows how to add a new material implementation to OpenSees. The hierarchical nature of the OpenSees software architecture allows new material models to be seamlessly added to the framework. By keeping element and material implementations separate, a new material model can be used in an existing element without modifying the element implementation, and vice versa. The programming language C++ directly supports the data encapsulation and run-time binding necessary to achieve this complete separation of material from element. Material Abstractions Currently, there are three Material abstractions in OpenSees, each of which can be used across a wide range of element implementations: UniaxialMaterial - Provides the interface for all one-dimensional material models, either stress-strain or force-deformation. UniaxialMaterial models define the stress-strain response of a truss element, uniaxial fiber behavior in a beam-column section, or the force-deformation response of a beam section or zero-length element. NDMaterial - The multi-dimensional generalization of UniaxialMaterial; provides the stress-strain response at a point in a solid element, or multi-dimensional fiber behavior in a plate or beam-column section. SectionForceDeformation - Defines the interface for stress resultant models which are used to describe both plate and beam-column force-deformation response as well as the constitutive response of more general zero-length elements, e.g., for isolator bearings. Each interface listed above is essentially the same with minor differences. The NDMaterial and SectionForceDeformation abstractions both represent multi-dimensional constitutive response. However, a distinction is made between stress and stress resultant response to allow for safer element implementations. Furthermore, the stress-strain equations for continuum material models can be written in terms of tensors. This is not the case for stress resultant models. Lastly, to avoid returning matrices and vectors or tensors of size one, the UniaxialMaterial abstraction is made distinct for reasons of efficiency, as scalar values describe the behavior of a one-dimensional model. ::: {.center} {#fig:Material} ::: As indicated in figure [fig:Material] , each material abstraction is a subclass of Material. The Material class is a subclass of both the TaggedObject and MovableObject classes, and therefore inherits the functionality of these two classes. As a result, it can be said that a Material \u201cis a\u201d TaggedObject as well as a MovableObject. Furthermore, since each of UniaxialMaterial, NDMaterial, and SectionForceDeformation \u201cis a\u201d Material, each is also a TaggedObject and a MovableObject. The TaggedObject class provides functionality for identifying materials, through a tag, during model building; and the MovableObject class provides functionality for parallel processing and database programming. Rather than show examples of implementing a material model under each interface, only the UniaxialMaterial interface is covered herein. The basic concepts of adding a material model to OpenSees carry directly over from UniaxialMaterial to NDMaterial and SectionForceDeformation. The remainder of this document is laid out as follows. First, the UniaxialMaterial interface is listed and explained. Then, an example UniaxialMaterial implementation, HardeningMaterial, is presented. Along with the C++ implementation, it is shown how to 1) add the new model to the OpenSees Tcl model builder, and 2) make the new model \u201cmovable\u201d for parallel processing and database programming. Finally, a FORTRAN interface for programming UniaxialMaterial models in OpenSees is described. UniaxialMaterial Interface Implementations of the UniaxialMaterial interface are used in several contexts within the OpenSees modeling framework. Due to their simplicity, these models can define both stress-strain and force-deformation relationships. It is up to the calling object, be it an element object or another material object, to interpret the meaning appropriately. Listed below is the UniaxialMaterial class interface. All methods in the UniaxialMaterial interface are public, there are no protected or private data or methods. Following the UniaxialMaterial class interface listing, each method in the interface is described. #include <Material.h> class Response ; class Information ; class UniaxialMaterial : public Material { public : UniaxialMaterial ( int tag , int classTag ); virtual ~ UniaxialMaterial ( void ); virtual int setTrialStrain ( double strain , double strainRate = 0.0 ) = 0 ; virtual double getStrain ( void ) = 0 ; virtual double getStrainRate ( void ); virtual double getStress ( void ) = 0 ; virtual double getTangent ( void ) = 0 ; virtual double getDampTangent ( void ); virtual double getSecant ( void ); virtual int commitState ( void ) = 0 ; virtual int revertToLastCommit ( void ) = 0 ; virtual int revertToStart ( void ) = 0 ; virtual UniaxialMaterial * getCopy ( void ) = 0 ; virtual Response * setResponse ( char ** argv , int argc , Information & matInfo ); virtual int getResponse ( int responseID , Information & matInfo ); protected : private : }; A note about the C++ syntax seen in the UniaxialMaterial interface. The keyword \u201cvirtual\u201d at the start of a method declaration indicates this method may be overridden by a subclass of UniaxialMaterial. The UniaxialMaterial base class provides default implementations for its virtual methods. The notation \u201c= 0\u201d at the end of the method declaration indicates the method is pure virtual, meaning it must be defined by subclasses because the UniaxialMaterial base class does not provide a default implementation. The UniaxialMaterial base class constructor takes a tag and classTag as its arguments. The tag passed to the constructor identifies this UniaxialMaterial as unique among all other UniaxialMaterial objects, and the classTag is used primarily for parallel processing and database programming. Class tags are defined in the file classTags.h. The tag and classTag arguments are passed to the Material class constructor, where they are in turn passed to the TaggedObject and MovableObject class constructors, respectively. The UniaxialMaterial destructor is declared, but does not do anything as the UniaxialMaterial base class contains no data. The method setTrialStrain() takes one or two arguments, an updated strain and strain rate. The strain rate is an optional argument, with default value \\(0.0\\) . This method is pure virtual, so it must be implemented in all subclasses of UniaxialMaterial. The next two methods, getStrain() and getStrainRate() , are to return the current strain and strain rate of this UniaxialMaterial. The method getStrain() is pure virtual, while getStrainRate() is only virtual; by default it returns \\(0.0\\) , but may be overridden in subclasses if needed. double UniaxialMaterial :: getStrainRate ( void ) { return 0.0 ; } The next method is getStress() , which is to return the current stress of this UniaxialMaterial. The current stress is a function of the current strain, \\(\\varepsilon\\) , and the current strain rate, \\(\\dot{\\varepsilon}\\) , \\[\\sigma = \\sigma(\\varepsilon,\\dot{\\varepsilon}) \\: .\\] The getStress() method is pure virtual and must be implemented by subclasses of UniaxialMaterial. The current material tangent is returned by the next method, getTangent() . The material tangent is the partial derivative of the material stress with respect to the current strain, \\[D_t = \\frac{\\partial{\\sigma}}{\\partial{\\varepsilon}} \\: .\\] The getTangent() is also pure virtual and must be implemented in all UniaxialMaterial subclasses. The getDampTangent() method is next, and is to return the current damping tangent, which is the partial derivative of the current stress with respect to the current strain rate, \\[\\eta = \\frac{\\partial{\\sigma}}{\\partial{\\dot{\\varepsilon}}} \\: .\\] By default, this method returns \\(0.0\\) , and it may be overridden in subclasses of UniaxialMaterial where there is strain rate dependence. double UniaxialMaterial :: getDampTangent ( void ) { return 0.0 ; } Finally, the getSecant() method is provided to return the material secant, which is the current stress divided by the current strain, \\[D_s = \\frac{\\sigma}{\\varepsilon} \\: .\\] By default, this method returns the result of dividing the current stress by the current strain. If the current strain is zero, the current tangent is returned instead. double UniaxialMaterial :: getSecant ( void ) { double strain = this->getStrain() ; double stress = this->getStress() ; if (strain != 0.0) return stress/strain ; else return this->getTangent() ; } The next set of methods deal with possible path dependent behavior of UniaxialMaterial models. All Material objects in OpenSees are responsible for keeping track of and updating their own history variables. First, the method commitState() is invoked to inform a UniaxialMaterial object that its current state is on the converged solution path and its internal history variables should be updated accordingly. Next, the method revertToLastCommit() is provided to let a UniaxialMaterial object know that it should return to its last committed state at. Finally, revertToStart() informs the UniaxialMaterial object to revert to its initial state, i.e., at the start of the analysis. All three of these methods are pure virtual, and thus must be implemented in all subclasses of UniaxialMaterial. The getCopy() method is declared so a calling object, be it an Element, Fiber, or another Material object, can obtain an exact copy of this UniaxialMaterial object. A pointer to the new object is returned by this function, and the calling object is responsible for deleting this dynamically allocated memory. This method is pure virtual because only a subclass of UniaxialMaterial knows the internal representation of its data. The final two methods, setResponse() and getResponse() , are declared for recording UniaxialMaterial state information. These methods have default implementations to record the material stress, strain, and tangent. These methods may be overridden, but their implementations are not shown in this document. Example \u2013 HardeningMaterial In this section, it is shown how the rate-independent uniaxial hardening material model given in Simo & Hughes, Computational Inelasticity (1998) is implemented in OpenSees. First, the class implementation is shown, followed by its inclusion in the Tcl model builder. Class Implementation The HardeningMaterial class interface is shown below. Here, no methods are virtual since this class provides implementations for the corresponding methods inherited from the UniaxialMaterial class. Note, three additional methods not declared in the UniaxialMaterial interface, sendSelf() , recvSelf() , and Print() , must be defined in implementations of UniaxialMaterial. These methods are inherited from higher level classes in the OpenSees framework, particularly, TaggedObject and MovableObject. An explanation of these methods is provided in what follows. #include <UniaxialMaterial.h> class HardeningMaterial : public UniaxialMaterial { public : HardeningMaterial ( int tag , double E , double sigmaY , double Hiso , double Hkin ); HardeningMaterial (); ~ HardeningMaterial (); int setTrialStrain ( double strain , double strainRate = 0.0 ); double getStrain ( void ); double getStress ( void ); double getTangent ( void ); int commitState ( void ); int revertToLastCommit ( void ); int revertToStart ( void ); UniaxialMaterial * getCopy ( void ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); void Print ( OPS_Stream & s , int flag = 0 ); protected : private : // Material parameters double E ; // Elastic modulus double sigmaY ; // Yield stress double Hiso ; // Isotropic hardening modulus double Hkin ; // Kinematic hardening modulus // Committed history variables double CplasticStrain ; // Committed plastic strain double CbackStress ; // Committed back stress ; double Chardening ; // Committed internal hardening variable // Trial history variables double TplasticStrain ; // Trial plastic strain double TbackStress ; // Trial back stress double Thardening ; // Trial internal hardening variable // Trial state variables double Tstrain ; // Trial strain double Tstress ; // Trial stress double Ttangent ; // Trial tangent }; The first two methods defined for HardeningMaterial are the constructors. The first constructor takes the material tag and the material parameters: elastic modulus, \\(E\\) , yield stress, \\(\\sigma_y\\) , isotropic hardening modulus, \\(H_{iso}\\) , and kinematic hardening modulus, \\(H_{kin}\\) . The UniaxialMaterial base class constructor is invoked with the arguments tag and MAT_TAG_Hardening (defined in classTags.h). The material parameters for this object are initialized in the initialization list with the arguments passed to the constructor, and all history variables are initialized by invoking revertToStart() . The second constructor is a default constructor which sets all material parameters to \\(0.0\\) then invokes revertToStart() . HardeningMaterial :: HardeningMaterial ( int tag , double e , double s , double hi , double hk ) : UniaxialMaterial ( tag , MAT_TAG_Hardening ), E ( e ), sigmaY ( s ), Hiso ( hi ), Hkin ( hk ) { // Initialize variables this -> revertToStart (); } HardeningMaterial :: HardeningMaterial () : UniaxialMaterial ( 0 , MAT_TAG_Hardening ), E ( 0.0 ), sigmaY ( 0.0 ), Hiso ( 0.0 ), Hkin ( 0.0 ) { // Initialize variables this -> revertToStart (); } The next method defined is the destructor, which does nothing since no memory is dynamically allocated by a HardeningMaterial object. HardeningMaterial::~HardeningMaterial() { // Does nothing } The following methods deal with the material state determination. The return mapping algorithm is coded in setTrialStrain() . The stress and tangent of this HardeningMaterial object are computed and stored in the instance variables Tstress and Ttangent and returned by the methods getStress() and getTangent() , respectively. The trial strain, stored in the instance variable Tstrain, is returned by the method getStrain() . int HardeningMaterial :: setTrialStrain ( double strain , double strainRate ) { // Set total strain Tstrain = strain ; // Elastic trial stress Tstress = E * ( Tstrain - CplasticStrain ); // Compute trial stress relative to committed back stress double xsi = Tstress - CbackStress ; // Compute yield criterion double f = fabs ( xsi ) - ( sigmaY + Hiso * Chardening ); // Elastic step ... no updates required if ( f <= 0.0 ) { // Set trial tangent Ttangent = E ; } // Plastic step ... perform return mapping algorithm else { // Compute consistency parameter double dGamma = f / ( E + Hiso + Hkin ); // Find sign of xsi int sign = ( xsi < 0 ) ? - 1 : 1 ; // Bring trial stress back to yield surface Tstress -= dGamma * E * sign ; // Update plastic strain TplasticStrain = CplasticStrain + dGamma * sign ; // Update back stress TbackStress = CbackStress + dGamma * Hkin * sign ; // Update internal hardening variable Thardening = Chardening + dGamma ; // Set trial tangent Ttangent = E * ( Hkin + Hiso ) / ( E + Hkin + Hiso ); } return 0 ; } double HardeningMaterial :: getStress ( void ) { return Tstress ; } double HardeningMaterial :: getTangent ( void ) { return Ttangent ; } double HardeningMaterial :: getStrain ( void ) { return Tstrain ; } The next set of methods deal with the path dependent behavior of this HardeningMaterial object. The method commitState() sets the committed history variables to be their corresponding trial values. Nothing needs to be done in the method revertToLastCommit() , and all history variables are set to \\(0.0\\) in revertToStart() . int HardeningMaterial :: commitState ( void ) { // Commit trial state variables CplasticStrain = TplasticStrain ; CbackStress = TbackStress ; Chardening = Thardening ; return 0 ; } int HardeningMaterial :: revertToLastCommit ( void ) { // Nothing to do here return 0 ; } int HardeningMaterial :: revertToStart ( void ) { // Reset committed history variables CplasticStrain = 0.0 ; CbackStress = 0.0 ; Chardening = 0.0 ; // Reset trial history variables TplasticStrain = 0.0 ; TbackStress = 0.0 ; Thardening = 0.0 ; // Initialize state variables Tstrain = 0.0 ; Tstress = 0.0 ; Ttangent = E ; return 0 ; } The getCopy() method is defined so this HardeningMaterial object can provide a clone of itself to a calling object, be it an Element, Fiber, or other Material object. The constructor is invoked to create a new object, then all instance variables are copied to the new object. The calling object is responsible for deleting this dynamically allocated memory. UniaxialMaterial * HardeningMaterial :: getCopy ( void ) { HardeningMaterial * theCopy = new HardeningMaterial ( this -> getTag (), E , sigmaY , Hiso , Hkin ); // Copy committed history variables theCopy -> CplasticStrain = CplasticStrain ; theCopy -> CbackStress = CbackStress ; theCopy -> Chardening = Chardening ; // Copy trial history variables theCopy -> TplasticStrain = TplasticStrain ; theCopy -> TbackStress = TbackStress ; theCopy -> Thardening = Thardening ; // Copy trial state variables theCopy -> Tstrain = Tstrain ; theCopy -> Tstress = Tstress ; theCopy -> Ttangent = Ttangent ; return theCopy ; } The next two methods are defined for parallel processing and database programming, and are inherited from MovableObject. The first method, sendSelf() , packs the material properties and committed history variables in a Vector, then sends the Vector across the Channel object passed as an argument to the method. The second method, recvSelf() , receives data from the Channel object, then populates the data of this HardeningMaterial object with the received data. int HardeningMaterial :: sendSelf ( int cTag , Channel & theChannel ) { static Vector data ( 8 ); data ( 0 ) = this -> getTag (); data ( 1 ) = E ; data ( 2 ) = sigmaY ; data ( 3 ) = Hiso ; data ( 4 ) = Hkin ; data ( 5 ) = CplasticStrain ; data ( 6 ) = CbackStress ; data ( 7 ) = Chardening ; int res = theChannel . sendVector ( this -> getDbTag (), cTag , data ); if ( res < 0 ) opserr << \"HardeningMaterial::sendSelf() - failed to send data \\n \" ; return res ; } int HardeningMaterial :: recvSelf ( int cTag , Channel & theChannel , FEM_ObjectBroker & theBroker ) { static Vector data ( 8 ); int res = theChannel . recvVector ( this -> getDbTag (), cTag , data ); if ( res < 0 ) { opserr << \"HardeningMaterial::recvSelf() - failed to receive data \\n \" ; this -> setTag ( 0 ); } else { this -> setTag (( int ) data ( 0 )); E = data ( 1 ); sigmaY = data ( 2 ); Hiso = data ( 3 ); Hkin = data ( 4 ); CplasticStrain = data ( 5 ); CbackStress = data ( 6 ); Chardening = data ( 7 ); // Set the trial state variables revertToLastCommit (); } return res ; } The final HardeningMaterial method is Print() , which writes the material name, tag, and parameters to the output stream passed as an argument. This method is inherited from TaggedObject. void HardeningMaterial :: Print ( OPS_Stream & s , int flag ) { s << \"HardeningMaterial, tag : \" << this->getTag() << endln; s << \" E : \" << E << endln; s << \" sigmaY : \" << sigmaY << endln; s << \" Hiso : \" << Hiso << endln; s << \" Hkin : \" << Hkin << endln ; } Tcl Model Builder The new HardeningMaterial model must be added to the OpenSees Tcl model builder in order for it to be used by analysis models defined in Tcl script files. The general from of the uniaxialMaterial command is as follows: uniaxialMaterial materialType tag <specific material parameters> So, for a HardeningMaterial object, it is necessary to read in the material parameters that are passed to its constructor, namely the elastic modulus, yield stress, and isotropic and kinematic hardening moduli. The general form of the command will be: uniaxialMaterial Hardening tag E sigmaY Hiso Hkin An example command to add a HardeningMaterial object with tag \\(1\\) , elastic modulus of \\(30000.0\\) , yield stress of \\(60.0\\) , isotropic hardening modulus of \\(0.0\\) , and kinematic hardening modulus of \\(1000.0\\) may then look like: uniaxialMaterial Hardening 1 30000.0 60.0 0.0 1000.0 How these values are parsed and used to construct a HardeningMaterial object is described next. The parsing of input data for all UniaxialMaterial models is done in the function TclModelBuilderUniaxialMaterialCommand contained in the file TclModelBuilderUniaxialMaterialCommand.cpp. In this file there are multiple if/else statements, one for each UniaxialMaterial that can be added to the model builder. To add the new model only requires adding an additional case with the accompanying code to parse the Tcl command line. The above command is split into an array of character strings (argv) by the Tcl interpreter, then sent to the TclModelBuilderUniaxialMaterialCommand function. argv[0] contains the command name \u201cuniaxialMaterial,\u201d argv[1] holds the material keyword \u201cHardening,\u201d argv[2] contains the material tag, and the remaining entries in the argv array hold the specific material parameters. These parameters are the arguments needed to call the HardeningMaterial constructor. The number of elements in the argv array is stored in the variable argc. Calls are made to the Tcl routines Tcl_GetInt and Tcl_GetDouble to get integer and double values from the character strings contained in argv. These routines perform error checking and return the pre-defined value TCL_OK if there was no error. Once the UniaxialMaterial has been allocated, it is added to the Tcl model builder at the end of the TclModelBuilderUniaxialMaterialCommand function, after the multiple if/else statement has ended. int TclModelBuilderUniaxialMaterialCommand ( ClientData clienData , Tcl_Interp * interp , int argc , char ** argv , TclModelBuilder * theTclBuilder ) { // Pointer to a UniaxialMaterial that will be added to the model builder UniaxialMaterial *theMaterial = 0 ; if (strcmp(argv [ 1 ] ,\"Elastic\") == 0) { // // Additional code not shown // } else if ( strcmp ( argv [ 1 ] , \"Hardening\" ) == 0 ) { if (argc < 7) { opserr << \"WARNING insufficient arguments\\n\" ; printCommand(argc,argv) ; opserr << \" Want : uniaxialMaterial Hardening tag E sigmaY Hiso Hkin \" << endln; return TCL_ERROR; } int tag; double E, sigmaY, Hiso, Hkin; if (Tcl_GetInt(interp, argv [ 2 ] , &tag) != TCL_OK) { opserr << \" WARNING invalid uniaxialMaterial Hardening tag \" << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv [ 3 ] , &E) != TCL_OK) { opserr << \" WARNING invalid E \\ n \"; opserr << \" uniaxialMaterial Hardening : \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv [ 4 ] , &sigmaY) != TCL_OK) { opserr << \" WARNING invalid sigmaY \\ n \"; opserr << \" uniaxialMaterial Hardening : \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv [ 5 ] , &Hiso) != TCL_OK) { opserr << \" WARNING invalid Hiso \\ n \"; opserr << \" uniaxialMaterial Hardening : \" << tag << endln; return TCL_ERROR; } if (Tcl_GetDouble(interp, argv [ 6 ] , &Hkin) != TCL_OK) { opserr << \" WARNING invalid Hkin \\ n \"; opserr << \" uniaxialMaterial Hardening : \" << tag << endln; return TCL_ERROR; } // Parsing was successful, allocate the material theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin); } // // Additional code not shown // // Now add the material to the modelBuilder if (theTclBuilder->addUniaxialMaterial(*theMaterial) < 0) { opserr << \" WARNING could not add uniaxialMaterial to the model builder \\ n \" ; opserr << *theMaterial << endln ; delete theMaterial ; // invoke the material objects destructor, // otherwise memory leak return TCL_ERROR ; } return TCL_OK ; } FEM_ObjectBroker In order for the new HardeningMaterial object to be used for parallel processing and database programming, the getNewUniaxialMaterial() method in the FEM_ObjectBroker class must be modified. An additional case statement should be added, as shown below. The MAT_TAG_Hardening classTag is the same pre-defined value passed to the UniaxialMaterial constructor by the HardeningMaterial constructor described earlier. The FEM_ObjectBroker simply returns a blank HardeningMaterial object, whose data can be subsequently populated by invoking recvSelf() . UniaxialMaterial * FEM_ObjectBroker :: getNewUniaxialMaterial ( int classTag ) { switch(classTag) { case MAT_TAG_Hardening : return new HardeningMaterial (); // // Additional cases not shown // default : opserr << \"FEM_ObjectBroker::getPtrNewUniaxialMaterial - \" ; opserr << \" - no UniaxialMaterial type exists for class tag \" ; opserr << classTag << endln ; return 0 ; } } A FORTRAN Interface for UniaxialMaterial Models Subclasses of UniaxialMaterial hide their implementation details from calling objects, i.e., calling objects only see the public interface defined in the UniaxialMaterial base class. How the interface is implemented is encapsulated by each subclass of UniaxialMaterial. Thus, a particular UniaxialMaterial implementation need not be written in C++ as long as the implementation conforms to the UniaxialMaterial interface. As an example, the FEDEAS uniaxial material library developed by F.C. Filippou is used as a FORTRAN interface for UniaxialMaterial models in OpenSees. This example is meant to demonstrate the process of linking OpenSees with other material libraries and is not limited to just the FEDEAS library. Material libraries with any well-defined interface, e.g. DRAIN, may be linked in a similar manner. Similar concepts carry directly over to implementing NDMaterial and SectionForceDeformation models in FORTRAN. FEDEAS subroutine interface The subroutine interface defined for a FEDEAS uniaxial material model named \u201cML1D\u201d is shown below. subroutine ML1D(matpar,hstvP,hstv,epsP,sigP,deps,sig,tang,ist) The subroutine arguments are given as follows: matpar - a double array of material parameters (in) hstvP - a double array of committed history variables (in) hstv - a double array of trial history variables (out) epsP - strain at the last committed state (in) sigP - stress at the last committed state (in) deps - change in strain from the last committed state (in) sig - the stress at the current trial state (out) tang - the tangent at the current trial state (out) ist - integer indicating the operation to be performed (in): 0 - return number of material parameters and history variables, 1 - compute stress and tangent, 2 - compute stress and secant FedeasMaterial Implementation in OpenSees This section presents an implementation of UniaxialMaterial capable of wrapping any subroutine that conforms to the FEDEAS interface described in the previous section. This implementation, FedeasMaterial, manages the data arrays sent to the FEDEAS subroutine, i.e., FedeasMaterial is responsible for storing the material parameters and history variables, as well as for swapping trial and committed history variables. FedeasMaterial is a subclass of UniaxialMaterial, as shown in figure [fig:Fedeas] . Subclasses of FedeasMaterial are responsible for defining constructors which take the appropriate material parameters. All other functionality (state determination, swapping of history variables, etc.) is common to all subclasses of FedeasMaterial. Therefore, this functionality is defined in the base class, FedeasMaterial. The FedeasMaterial class interface is shown below. All methods are declared as virtual so they may be overridden by subclasses of FedeasMaterial. #include <UniaxialMaterial.h> class FedeasMaterial : public UniaxialMaterial { public : FedeasMaterial ( int tag , int classTag , int nhv , int ndata ); virtual ~ FedeasMaterial (); virtual int setTrialStrain ( double strain , double strainRate = 0.0 ); virtual double getStrain ( void ); virtual double getStress ( void ); virtual double getTangent ( void ); virtual int commitState ( void ); virtual int revertToLastCommit ( void ); virtual int revertToStart ( void ); virtual UniaxialMaterial * getCopy ( void ); virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag = 0 ); protected : // Invokes the FORTRAN subroutine virtual int invokeSubroutine ( int ist ); double * data ; // Material parameters array double * hstv ; // History array : first half is committed , second is trial int numData ; // Number of material parameters int numHstv ; // Number of history variables double epsilonP ; // Committed strain double sigmaP ; // Committed stress private : double epsilon ; // Trial strain double sigma ; // Trial stress double tangent ; // Trial tangent }; Instance variables are declared in FedeasMaterial to store history variables and material parameters. First, data is a double array of size numData, the number of material parameters for this object. Next, hstv is a double array of size 2*numHstv, where numHstv is the number of history variables needed for this FedeasMaterial object. Note that committed history variables are stored in the first half of the hstv array, while the trial values are kept in the second half. The values epsilonP and sigmaP are the committed strain and stress, respectively, of this FedeasMaterial object, as they are required by the FEDEAS subroutine interface. Finally, three trial state variables, epsilon, sigma, and tangent are defined to store the current strain, stress, and tangent. The FedeasMaterial constructor initializes the number of history variables and number of material parameters with arguments passed to the constructor. The UniaxialMaterial base class constructor is invoked with the tag and classTag arguments. The trial and committed strain and stress are initialized to \\(0.0\\) . Then, the history variable and material parameter arrays are allocated. All entries in the history variable and material parameter arrays are initialized to \\(0.0\\) . FedeasMaterial : : FedeasMaterial ( int tag , int classTag , int nhv , int ndata ) : UniaxialMaterial ( tag , classTag ), data ( 0 ), hstv ( 0 ), numData ( ndata ), numHstv ( nhv ), epsilonP ( 0.0 ), sigmaP ( 0.0 ), epsilon ( 0.0 ), sigma ( 0.0 ), tangent ( 0.0 ) { if ( numHstv < 0 ) numHstv = 0 ; if ( numHstv > 0 ) { // Allocate history array hstv = new double [ 2*numHstv ] ; if ( hstv == 0 ) g3ErrorHandler -> fatal ( \"%s -- failed to allocate history array -- type %d\" , \"FedeasMaterial::FedeasMaterial\" , this -> getClassTag ()); // Initialize to zero for ( int i = 0 ; i < 2 * numHstv ; i ++ ) hstv [ i ] = 0.0 ; } if ( numData < 0 ) numData = 0 ; if ( numData > 0 ) { // Allocate material parameter array data = new double [ numData ] ; if ( data == 0 ) g3ErrorHandler -> fatal ( \"%s -- failed to allocate data array -- type %d\" , \"FedeasMaterial::FedeasMaterial\" , this -> getClassTag ()); // Initialize to zero for ( int i = 0 ; i < numData ; i ++ ) data [ i ] = 0.0 ; } } The FedeasMaterial destructor deallocates the memory allocated in the constructor to hold the history variables and material parameters. FedeasMaterial ::~ FedeasMaterial () { if (hstv != 0) delete [] hstv ; if (data != 0) delete [] data ; } The next group of FedeasMaterial methods deals with material state determination. First, setTrialStrain() stores the trial strain, then invokes the FEDEAS subroutine with ist = 1, indicating that normal stress and tangent quantities should be computed. The methods getStrain() , getStress() , and getTangent() return the strain, stress, and tangent of this FedeasMaterial. int FedeasMaterial :: setTrialStrain ( double strain , double strainRate ) { // Store the strain epsilon = strain ; // Tells subroutine to do normal operations for stress and tangent int ist = 1 ; // Call the subroutine return this->invokeSubroutine(ist) ; } double FedeasMaterial :: getStrain ( void ) { return epsilon ; } double FedeasMaterial :: getStress ( void ) { return sigma ; } double FedeasMaterial :: getTangent ( void ) { return tangent ; } The next three methods deal with the path dependent behavior of this FedeasMaterial object. The commitState() method copies the trial history variables from the second half of the hstv array to the first half, where the committed values are stored. The committed values are copied to the trial values in revertToLastCommit() , and all values are set to \\(0.0\\) in the revertToStart() method. int FedeasMaterial : : commitState ( void ) { // Set committed values equal to corresponding trial values for ( int i = 0 ; i < numHstv ; i ++ ) hstv [ i ] = hstv [ i+numHstv ] ; epsilonP = epsilon ; sigmaP = sigma ; return 0 ; } int FedeasMaterial : : revertToLastCommit ( void ) { // Set trial values equal to corresponding committed values for ( int i = 0 ; i < numHstv ; i ++ ) hstv [ i+numHstv ] = hstv [ i ] ; epsilon = epsilonP ; sigma = sigmaP ; return 0 ; } int FedeasMaterial : : revertToStart ( void ) { // Set all trial and committed values to zero for ( int i = 0 ; i < 2 * numHstv ; i ++ ) hstv [ i ] = 0.0 ; epsilonP = 0.0 ; sigmaP = 0.0 ; return 0 ; } A copy of this FedeasMaterial object is returned by getCopy() . First, the FedeasMaterial constructor is called with the necessary tag, type, and array size data. Then, the committed strain and stress, all history variables, and material parameters are copied to the new object before it is returned. UniaxialMaterial * FedeasMaterial : : getCopy ( void ) { FedeasMaterial * theCopy = new FedeasMaterial ( this -> getTag (), this -> getClassTag (), numHstv , numData ); // Copy history variables int i ; for ( i = 0 ; i < 2 * numHstv ; i ++ ) theCopy -> hstv [ i ] = hstv [ i ] ; for ( i = 0 ; i < numData ; i ++ ) theCopy -> data [ i ] = data [ i ] ; theCopy -> epsilonP = epsilonP ; theCopy -> sigmaP = sigmaP ; return theCopy ; } The next two methods are defined for parallel processing and database programming. The first method, sendSelf() , packs the tag and array size information for this FedeasMaterial object into an ID vector and sends it across the Channel. Then, the material properties and committed history variables are put in a Vector, and sent as well. The second method, recvSelf() , receives both the ID and Vector data from the Channel object, then populates the data of this FedeasMaterial object with the appropriate data. int FedeasMaterial : : sendSelf ( int commitTag , Channel & theChannel ) { int res = 0 ; static ID idData ( 3 ); idData ( 0 ) = this -> getTag (); idData ( 1 ) = numHstv ; idData ( 2 ) = numData ; res += theChannel . sendID ( this -> getDbTag (), commitTag , idData ); if ( res < 0 ) opserr << \"FedeasMaterial::sendSelf() - failed to send ID data\\n\" ; Vector vecData ( numHstv + numData + 2 ); int i , j ; // Copy only the committed history variables into vector for ( i = 0 ; i < numHstv ; i ++ ) vecData ( i ) = hstv [ i ] ; // Copy material properties into vector for ( i = 0 , j = numHstv ; i < numData ; i ++ , j ++ ) vecData ( j ) = data [ i ] ; vecData ( j ++ ) = epsilonP ; vecData ( j ++ ) = sigmaP ; res += theChannel . sendVector ( this -> getDbTag (), commitTag , vecData ); if ( res < 0 ) opserr << \"FedeasMaterial::sendSelf() - failed to send Vector data\\n\" ; return res ; } int FedeasMaterial : : recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ) { int res = 0 ; static ID idData ( 3 ); res += theChannel . recvID ( this -> getDbTag (), commitTag , idData ); if ( res < 0 ) { opserr << \"FedeasMaterial::recvSelf() - failed to receive ID data\\n\" ; return res ; } this -> setTag ( idData ( 0 )); numHstv = idData ( 1 ); numData = idData ( 2 ); Vector vecData ( numHstv + numData + 2 ); res += theChannel . recvVector ( this -> getDbTag (), commitTag , vecData ); if ( res < 0 ) { opserr << \"FedeasMaterial::recvSelf() - failed to receive Vector data\\n\" ; return res ; } int i , j ; // Copy committed history variables from vector for ( i = 0 ; i < numHstv ; i ++ ) hstv [ i ] = vecData ( i ); // Copy material properties from vector for ( i = 0 , j = numHstv ; i < numData ; i ++ , j ++ ) data [ i ] = vecData ( j ); epsilonP = vecData ( j ++ ); sigmaP = vecData ( j ++ ); return res ; } The Print() method outputs the name of this FedeasMaterial object to the stream passed as an argument. More cases can be added to the switch statement as additional subroutines are added. void FedeasMaterial :: Print ( OPS_Stream & s , int flag ) { s << \"FedeasMaterial, type : \"; switch (this->getClassTag()) { case MAT_TAG_FedeasHardening: s << \" Hardening \" << endln; break; // Add more cases as needed default: s << \" Material identifier = \" << this- > getClassTag () << endln ; break ; } } In order to link the FORTRAN subroutine with the OpenSees C++ libraries, the following external function declarations are needed. There are two syntactic styles for these declarations, one for Win32 and the other for everything else. The preprocessor directives put the proper declaration into the source code. Additional declarations may be added as more subroutines are included in OpenSees. #ifdef _WIN32 extern \"C\" int _stdcall HARD_1 ( double * matpar , double * hstvP , double * hstv , double * strainP , double * stressP , double * dStrain , double * tangent , double * stress , int * ist ); #define hard_1_ HARD_1 // Add more declarations as needed #else extern \"C\" int hard_1_ ( double * matpar , double * hstvP , double * hstv , double * strainP , double * stressP , double * dStrain , double * tangent , double * stress , int * ist ); // Add more declarations as needed #endif The method invokeSubroutine() calls the appropriate subroutine based on the material classTag. The FedeasMaterial instance variables are passed to the FORTRAN subroutine from this method. Additional cases in the switch statement can be added as more subroutines are linked with OpenSees. int FedeasMaterial : : invokeSubroutine ( int ist ) { // Compute strain increment double dEpsilon = epsilon - epsilonP ; switch ( this -> getClassTag ()) { case MAT_TAG_FedeasHardening : hard_1_ ( data , hstv , & hstv [ numHstv ] , & epsilonP , & sigmaP , & dEpsilon , & sigma , & tangent , & ist ); break ; // Add more cases as needed default : g3ErrorHandler -> fatal ( \"%s -- unknown material type\" , \"FedeasMaterial::invokeSubroutine\" ); return - 1 ; } return 0 ; } Example \u2013 FedeasHardeningMaterial The material data array defined in FedeasMaterial is populated by its subclasses. As an example, consider the case where the uniaxial hardening material is coded in a FORTRAN subroutine. In order to link this subroutine with OpenSees, a subclass of FedeasMaterial, FedeasHardeningMaterial, must be created (see figure fig:FedeasHardening ). The functionality of this subclass is to populate the material parameter array and to determine the number of history variables required for analysis. Fedeas hardening material As additional FEDEAS subroutines are added to OpenSees, new subclasses of FedeasMaterial must be added in order to populate the data array. This is all that need be done in the derived class as the base class, FedeasMaterial, contains all the computational code and keeps track of path dependent behavior. This functionality is inherited from the FedeasMaterial base class. However, the FedeasMaterial class must be modified such that the appropriate subroutine is called during state determination from the method invokeSubroutine() . FEDEAS Hardening Subroutine This section contains the implementation of the uniaxial hardening material coded as a FORTRAN subroutine using the FEDEAS interface. The subroutine declares local variables to store the material parameters passed through the matpar array. The committed history variables are received from hstvP, and the trial history variables are written to hstv upon return. The trial stress and tangent are also set upon return in the variables sig and tang. FORTRAN source code subroutine Hard_1 ( matpar , hstvP , hstv , epsP , sigP , deps , sig , tang , ist ) c I matpar contains fixed properties ( 4 ) c E = Elastic modulus --> matpar ( 1 ) c sigY = Yield stress --> matpar ( 2 ) c Hiso = Isotropic hardening modulus --> matpar ( 3 ) c Hkin = Kinematic hardening modulus --> matpar ( 4 ) c c I hstvP contains committed history variables : c ep = hstvP ( 1 ) --> plastic strain c alpha = hstvP ( 2 ) --> internal hardening variable c kappa = hstvP ( 3 ) --> back stress for kinematic hardening c c O hstv will be set to the corresponding trial values of hstvP c hstv ( 1 ) = ep c hstv ( 2 ) = alpha c hstv ( 3 ) = kappa c c I epsP : strain at last committed state c I sigP : stress at last committed state c I deps : current strain increment c O sig : updated stress c O tang : updated tangent c I ist : tangent calculation switch c 1 = tangent , 2 = incremental secant , 3 = total secant implicit none c Arguments integer ist real * 8 matpar ( 4 ), hstvP ( 3 ), hstv ( 3 ) real * 8 epsP , sigP , deps real * 8 sig , tang c Local variables real * 8 E , sigY , Hiso , Hkin real * 8 ep , alpha , kappa real * 8 eps , f , xsi , dGamma integer sgn c Material parameters E = matpar ( 1 ) sigY = matpar ( 2 ) Hiso = matpar ( 3 ) Hkin = matpar ( 4 ) c History variables ep = hstvP ( 1 ) alpha = hstvP ( 2 ) kappa = hstvP ( 3 ) c Current strain eps = epsP + deps c Elastic predictor sig = E * ( eps - ep ) c Stress relative to back stress xsi = sig - kappa c Yield function f = dabs ( xsi ) - ( sigY + Hiso * alpha ) c Inside yield surface if ( f <= 0.0 ) then tang = E c Outside yield surface ... do return mapping else c Consistency parameter dGamma = f / ( E + Hiso + Hkin ) c Normal to yield surface if ( xsi <= 0.d0 ) then sgn = - 1 else sgn = 1 endif c Updated stress sig = sig - dGamma * E * sgn c Updated plastic strain ep = ep + dGamma * sgn c Updated back stress kappa = kappa + dGamma * Hkin * sgn c Updated internal hardening variable alpha = alpha + dGamma c Elasto - plastic tangent tang = E * ( Hkin + Hiso ) / ( E + Hkin + Hiso ) endif c Update history variables hstv ( 1 ) = ep hstv ( 2 ) = alpha hstv ( 3 ) = kappa c Compute requested tangent if ( ist == 2. and . deps /= 0.d0 ) then tang = ( sig - sigP ) / deps else if ( ist == 3. and . eps /= 0.d0 ) then tang = sig / eps else c add additional cases , if needed endif return end subroutine FedeasHardeningMaterial Subclass As stated previously, the functionality of the FedeasHardeningMaterial class is to read in the material parameters required for the Hard_1 subroutine invoked from the FedeasMaterial method invokeSubroutine() . In addition, the required number of history variables must be passed to the FedeasMaterial base class. The class interface for FedeasHardeningMaterial is shown below. The constructor takes the tag and material parameters as arguments. No other methods are declared in the FedeasHardeningMaterial interface as all functionality is inherited from FedeasMaterial. #include <FedeasMaterial.h> class FedeasHardeningMaterial : public FedeasMaterial { public : FedeasHardeningMaterial ( int tag , double E , double sigmaY , double Hiso , double Hkin ); FedeasHardeningMaterial ( void ); ~ FedeasHardeningMaterial (); protected : private : }; The constructor takes the tag, elastic modulus, yield stress, and isotropic and kinematic hardening moduli as arguments. The FedeasMaterial class constructor is called with the tag and classTag MAT_TAG_FedeasHardening defined in classTags.h and the number of history variables and material parameters required for this particular material model. Then the material parameters are inserted into the data array. The default constructor simply invokes the base class constructor, and the destructor does nothing. FedeasHardeningMaterial :: FedeasHardeningMaterial ( int tag , double E , double sigmaY , double Hiso , double Hkin ): // 3 history variables and 4 material parameters FedeasMaterial ( tag , MAT_TAG_FedeasHardening , 3 , 4 ) { data [ 0 ] = E ; data [ 1 ] = sigmaY ; data [ 2 ] = Hiso ; data [ 3 ] = Hkin ; } FedeasHardeningMaterial :: FedeasHardeningMaterial ( void ): FedeasMaterial ( 0 , MAT_TAG_FedeasHardening , 3 , 4 ) { // Does nothing } FedeasHardeningMaterial :: ~ FedeasHardeningMaterial ( void ) { // Does nothing } Important Polymorphic Note Should any method in the FedeasMaterial class need to be overridden, e.g., if a subclass does not want all of its history variables set to \\(0.0\\) in revertToStart() , the getCopy() method must also be overridden to return a pointer to the subclass. If getCopy() is not overridden, the dynamic type of the returned pointer will be of the FedeasMaterial type and the overridden method, e.g., revertToStart() , will not be called. Tcl Model Builder Adding the FedeasHardeningMaterial model to the Tcl model builder is done in exactly the same manner as for HardeningMaterial since both models have the same material parameters. Only the material allocation would change. The following line in TclModelBuilderUniaxialMaterialCommand.cpp // Parsing was successful, allocate the material theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin); would be changed to // Parsing was successful, allocate the material theMaterial = new FedeasHardeningMaterial ( tag , E , sigmaY , Hiso , Hkin ); FEM_ObjectBroker As for the HardeningMaterial class, an additional case needs to be added to the getNewUniaxialMaterial() method in FEM_ObjectBroker in order for the FedeasHardeningMaterial class to be used for parallel processing and database programming. UniaxialMaterial * FEM_ObjectBroker :: getNewUniaxialMaterial ( int classTag ) { switch(classTag) { case MAT_TAG_Hardening : return new HardeningMaterial (); case MAT_TAG_FedeasHardening : return new FedeasHardeningMaterial (); // // Additional cases not shown // default : opserr << \"FEM_ObjectBroker::getPtrNewUniaxialMaterial - \" ; opserr << \" - no UniaxialMaterial type exists for class tag \" ; opserr << classTag << endln ; return 0 ; } } Michael H. Scott and Gregory L. Fenves PEER, University of California, Berkeley August 21, 2001 Version 1.1","title":"New Material Models"},{"location":"developer/extending/NewRecorder/","text":"Recorder This page is adapted from the OpenSees Wiki. A Recorder in the interpreted OpenSees applications is used to obtain information from the model during the analysis. To add a new Recorder option into the interpreted applications, the developer must provide a new C++ subclass of the Recorder class and an interface function that will be used to parse the input and create the new recorder. Recorder Class The Recorder class itself is an abstract base class. It inherits from both the TaggedObject class and the MovableObject class. The class has a minimal interface, which is as shown below: The Recorder Class: class Recorder : public MovableObject , public TaggedObject { public : Recorder ( int classTag ); virtual ~ Recorder (); virtual int record ( int commitTag , double timeStamp ) = 0 ; virtual int restart ( void ); virtual int domainChanged ( void ); virtual int setDomain ( Domain & theDomain ); virtual int sendSelf ( int commitTag , Channel & theChannel ); virtual int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); virtual void Print ( OPS_Stream & s , int flag ); protected : protected : private : static int lastRecorderTag ; }; The most important methods in the interface are: setDomain() - this is the method that is called when the new recorder object is first added to the domain. It is inside this method that all data, typically memory and pointer values, need to be initialized for subsequent record commands. record() - this is the method that is called when the recorder is called upon to record/save information. The method is called with a tag that will be unique and the current time in the domain. Other Important methods are: domainChanged() - this is a method called when something major has happened in the Domain, ie. a new element, node, constraint and/or load pattern has been added to the domain or removed from the domain. It is necessasry for the Recorder to check in this call if it's pointers are still valid (i.e. if an element it was recording info for has been removed from the domain, it wuill have been deleted and it's old pointer information will no longer be valid.) send/recvSelf() - are two methods called in parallel applications. When invoked the recorders send/recv information about what they are recording. restart() - this method is called if restart() is invoked on the Domain. What the recorder does is up to you the developer. Example - SumElementForcesRecorder In the following section we will provide all necessary code to add a new recorder. The purpose of this recorder will be to sum the forces obtained from the list of inputted elements. The recorder will use the getResistingForce() method in the elements to obtain these forces. A similar class exists in the framework, which uses the setResponse()/getResponse() methods in the element interface. To demonstrate some of the output file options, the result will go to either the screen, a text file, or a binary file. More output options are of course available and the developer should look at existing recorder options. Header The header for thew new class, which we will call SumElementForcesRecorder is as follows: #ifndef SumElementForcesRecorder_h #define SumElementForcesRecorder_h #include <Recorder.h> #include <Information.h> #include <ID.h> class Domain ; class Vector ; class Matrix ; class Element ; class Response ; class FE_Datastore ; class SumElementForcesRecorder : public Recorder { public : // constructors SumElementForcesRecorder (); SumElementForcesRecorder ( const ID eleID , bool echoTime , OPS_Stream * theOutputHandler ); // destructors ~ SumElementForcesRecorder (); // public methods int record ( int commitTag , double timeStamp ); int restart ( void ); int domainChanged ( void ); int setDomain ( Domain & theDomain ); const char * getClassType ( void ) const ; int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : int numEle ; // the number of elements Element ** theElements ; // pointer to array of element pointers ID eleID ; // ID (integer list) of element tags to record Domain * theDomain ; // pointer to domain holding elements OPS_Stream * theOutput ; // pointer to output location bool echoTimeFlag ; // flag indicating if pseudo time to be printed Vector * data ; // Vector (double array) to store sum of element forces }; #endif The header file defines the interface and variables for the class SumElementForceRecorder. It defines the new class to be a sublass of the Recorder class. In the public interface are 2 constructors and 1 destructor in addition to all the methods defined for the Recorder class. There are no protected data or methods as we do not expect this class to be subclassed. In the private section we store data that will be used by the SumElementForceRecorder objects. The header has a number of #include directives, one is needed for the base class and every class used as a variable in the list of data (except those that are used as pointers). For those classes that only appear as pointers in the header file (Domain, Vector, Element, OPS_Stream) a forward declaration is all that is needed (the include could also have been used, but using the forward declaration simplifies dependencies and reduces the amount of code that ha to be recompiled later if changes are made). Implementation It another file, SumElementForcesRecorder.cpp, we place the code that details what the constructors, destructor and methods do. In addition we provide one additional procedure OPS_SumElementForcesRecorder() (NOTE it has the same name as the class with an OPS_ prefix). We will go through each part of the file. Include Directives The first part of the file contains the list of includes. It is necessary to have an #include directive for each class and api file that is used within the .cpp file and is not included in the header. #include \"SumElementForcesRecorder.h\" #include <elementAPI.h> #include <Domain.h> #include <Element.h> #include <ElementIter.h> #include <Matrix.h> #include <Vector.h> #include <ID.h> #include <string.h> #include <Response.h> #include <Message.h> #include <Channel.h> #include <FEM_ObjectBroker.h> #include <StandardStream.h> #include <BinaryFileStream.h> #include <DataFileStream.h> #include <elementAPI.h> Constructors After the list of includes, we provide the 2 constructors. The constructors are rather simple. They just initialize all the data variables defined in the header. Note it is very important to set all pointer values to 0. SumElementForcesRecorder :: SumElementForcesRecorder () : Recorder ( -1 ), numEle ( 0 ), theElements ( 0 ), eleID ( 0 ), theDomain ( 0 ), theOutput ( 0 ), echoTimeFlag ( true ), data ( 0 ) { } SumElementForcesRecorder :: SumElementForcesRecorder ( const ID ele , bool echoTime , OPS_Stream * theoutput ) : Recorder ( -1 ), numEle ( 0 ), theElements ( 0 ), eleID ( ele ), theDomain ( 0 ), theOutput ( theoutput ), echoTimeFlag ( echoTime ), data ( 0 ) { // set numEle numEle = eleID . Size (); if ( numEle == 0 ) { opserr << \"WARNING SumElementForcesRecorder::SumElementForcesRecorder() - no elements tags passed in input! \\n \" ; } } Destructor The we provide the destructor. In the destructor all memory that the Recorder created or was passed to it in the constructor must be destroyed. Failing to delete this memory, will result in memory leaks. SumElementForcesRecorder ::~ SumElementForcesRecorder () { if ( theElements != 0 ) delete [] theElements ; if ( data != 0 ) delete data ; if ( theOutput != 0 ) delete theOutput ; } record() Method After the destructor, we provide the code for the record() method. It does the following operations: Zeros the vector which will contain the final sum If the time stamp is needed, it places it at the first location in the vector. Loops over all valid elements adding their resting force to the vector. Send the vector to the output handler to be written. Returns success. int SumElementForcesRecorder::record ( int commitTag , double timeStamp ) { // check for initialization if ( data == 0 ) { opserr << \"SumElementForcesRecorder::record() - setDomain() has not been called \\n \" ; return -1 ; } // zero the data vector data -> Zero (); int forceSize = data -> Size (); int startLoc = 0 ; // write the time if echTimeFlag set if ( echoTimeFlag == true ) { ( * data )( 0 ) = timeStamp ; forceSize -= 1 ; startLoc = 1 ; } // // for each element that has been added to theElements add force contribution // for ( int i = 0 ; i < numEle ; i ++ ) { if ( theElements [ i ] != 0 ) { int loc = startLoc ; const Vector & force = theElements [ i ] -> getResistingForce (); int forceSize = force . Size (); for ( int j = 0 ; j < forceSize ; j ++ , loc ++ ) ( * data )( loc ) += force ( j ); } } // // send the response vector to the output handler for o/p // if ( theOutput != 0 ) theOutput -> write ( * data ); // succesfull completion - return 0 return 0 ; } restart() and domainChanged() methods Afte the record() method, we have the two simple short methods restart() and domainChanged(). restart does nothing and domainChanged simply calls the objects own setDomain() method. int SumElementForcesRecorder::restart ( void ) { return 0 ; } int SumElementForcesRecorder::domainChanged ( void ) { if ( theDomain != 0 ) this -> setDomain ( * theDomain ); } setDomain() Method The setDomain() method follows. In this method we perform the following: set the pointer for the enclosing domain object. allocate space from memoory for our array of ponters and our data vector. initialize the array components to be 0 or point to an element given by the eleID. determine the size of the vector that will be used to store the sum of the forces. allocate space for the vector. int SumElementForcesRecorder::setDomain ( Domain & theDom ) { theDomain = & theDom ; // set numEle if ( numEle == 0 ) { opserr << \"WARNING SumElementForcesRecorder::initialize() - no elements tags passed in input! \\n \" ; return 0 ; } // create theElements, an array of pointers to elements theElements = new Element * [ numEle ]; if ( theElements == 0 ) { opserr << \"WARNING SumElementForcesRecorder::initialize() - out of memory \\n \" ; numEle = 0 ; // set numEle = 0, in case record() still called return -1 ; } // // loop over the list of elements, // if element exists add it's pointer o the array // get its resisting force, check size to determine compatable with others // int sizeArray = -1 ; for ( int i = 0 ; i < numEle ; i ++ ) { int eleTag = eleID ( i ); Element * theEle = theDomain -> getElement ( eleTag ); if ( theEle != 0 ) { const Vector & force = theEle -> getResistingForce (); int forceSize = force . Size (); if ( sizeArray == -1 ) { sizeArray = forceSize ; theElements [ i ] = theEle ; } else if ( sizeArray != forceSize ) { opserr << \"WARNING: forces mismatch - element: \" << eleTag << \" will not be included \\n \" ; theElements [ i ] = 0 ; } else { theElements [ i ] = theEle ; } } else { theElements [ i ] = 0 ; } } // if echTimeFlag is set, add room for the time to be output if ( echoTimeFlag == true ) sizeArray ++ ; // create the vector to hold the data data = new Vector ( sizeArray ); if ( data == 0 || data -> Size () != sizeArray ) { opserr << \"SumElementForcesRecorder::initialize() - out of memory \\n \" ; delete [] theElements ; theElements = 0 ; numEle = 0 ; } return 0 ; } sendSelf() and recvSelf() methods These methods only need be provided if the object will be used in a parallel program. We provide their implementation for completeness, though typicall developers are interested in running the code in a sequential application and should just return -1. static char myClassType [] = { \"SumElementForcesRecorder\" }; const char * SumElementForcesRecorder::getClassType ( void ) const { return myClassType ; } int SumElementForcesRecorder::sendSelf ( int commitTag , Channel & theChannel ) { // send in an ID (integar array) to the receiving object the following: // recorder tag // size of eleID // class tag of handler // echoTimeFlag static ID idData ( 5 ); idData ( 0 ) = this -> getTag ();; idData ( 1 ) = eleID . Size (); idData ( 2 ) = theOutput -> getClassTag (); if ( echoTimeFlag == true ) idData ( 3 ) = 1 ; else idData ( 3 ) = 0 ; if ( theChannel . sendID ( 0 , commitTag , idData ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return -1 ; } // send eleID to receiving object if ( theChannel . sendID ( 0 , commitTag , eleID ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send idData \\n \" ; return -1 ; } // send theOutput to receiving object if ( theOutput -> sendSelf ( commitTag , theChannel ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send theOutput \\n \" ; return -1 ; } return 0 ; } int SumElementForcesRecorder::recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ) { // receive from the sending object the ID static ID idData ( 5 ); if ( theChannel . recvID ( 0 , commitTag , idData ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv idData \\n \" ; return -1 ; } // with the data received // setTag // resize the eleID array // set echoTimeFlag // get an outputHandler this -> setTag ( idData ( 0 )); eleID . resize ( idData ( 1 )); idData ( 2 ) = theOutput -> getClassTag (); if ( idData ( 3 ) == 0 ) echoTimeFlag = true ; else echoTimeFlag = false ; if ( theOutput != 0 && theOutput -> getClassTag () != idData ( 4 )) delete theOutput ; theOutput = theBroker . getPtrNewStream ( idData ( 4 )); if ( theOutput == 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to get Output of correct type \\n \" ; return -1 ; } // receive eleID if ( theChannel . recvID ( 0 , commitTag , eleID ) < 0 ) { opserr << \"SumElementForcesRecorder::recvSelf() - failed to recv eleID \\n \" ; return -1 ; } // get theOutput to receive data if ( theOutput -> recvSelf ( commitTag , theChannel , theBroker ) < 0 ) { opserr << \"SumElementForcesRecorder::sendSelf() - failed to send theOutput \\n \" ; return -1 ; } return 0 ; } Interface Function At the end of the implementation file is the interface function. This function is required by all new classes. It is a function which will use the api to parse the input based on the input create objects create a recorder object of the correct type, and return it to the calling function. The interface function is the function that is called when the interpreter comes across the command telling it to create a SumElementForcesRecorder. #ifdef _USRDLL #include <windows.h> #define OPS_Export extern \"C\" _declspec(dllexport) #elif _MACOSX #define OPS_Export extern \"C\" __attribute__((visibility(\"default\"))) #else #define OPS_Export extern \"C\" #endif static int numSumElementForcesREcorder = 0 ; OPS_Export void * OPS_SumElementForcesRecorder () { Recorder * theRecorder = 0 ; int numRemainingArgs = OPS_GetNumRemainingInputArgs (); // check for quick return, possibly parallel case if ( numRemainingArgs == 0 ) { Recorder * theRecorder = new SumElementForcesRecorder (); } // // parse args // int numEle = 0 , eleTag ; ID eleID ( 0 ); OPS_Stream * theOutputStream = 0 ; int outMode = 0 ; // standard stream bool echoTime = false ; bool doneParsingArgs = false ; char data [ 100 ]; char outputName [ 200 ]; char ** eleArgs = 0 ; int numEleArgs = 0 ; while ( numRemainingArgs > 0 ) { if ( OPS_GetString ( data , 100 ) < 0 ) return 0 ; // output to standard file if ( strcmp ( data , \"-file\" ) == 0 ) { outMode = 1 ; if ( OPS_GetString ( outputName , 200 ) < 0 ) return 0 ; numRemainingArgs -= 2 ; } // output to binary file else if ( strcmp ( data , \"-binary\" ) == 0 ) { outMode = 2 ; if ( OPS_GetString ( outputName , 200 ) < 0 ) return 0 ; numRemainingArgs -= 2 ; } // echo domain time stamp in output else if ( strcmp ( data , \"-time\" ) == 0 ) { echoTime = true ; numRemainingArgs -= 1 ; } // read the list of elements & place in an ID else if (( strcmp ( data , \"-ele\" ) == 0 ) || ( strcmp ( data , \"-eles\" ) == 0 ) || ( strcmp ( data , \"-element\" ) == 0 )) { numRemainingArgs -- ; int one = 1 ; while ( numRemainingArgs > 0 && OPS_GetIntInput ( & one , & eleTag ) == 0 ) { eleID [ numEle ] = eleTag ; numEle ++ ; numRemainingArgs -- ; } doneParsingArgs = true ; } // // create the output handler // if ( outMode == 0 ) theOutputStream = new StandardStream (); if ( outMode == 1 ) theOutputStream = new DataFileStream ( outputName ); else if ( outMode == 2 ) theOutputStream = new BinaryFileStream ( outputName ); // // create the recorder // theRecorder = new SumElementForcesRecorder ( eleID , echoTime , theOutputStream ); // return it return theRecorder ; } Example Script (OpenSeesDeveloper/recorder/example1.tcl) An example OpenSees tcl input file for this new recorder is: #create the model model basic - ndm 2 - ndf 2 node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 uniaxialMaterial Elastic 1 3000 element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 fix 1 1 1 fix 2 1 1 fix 3 1 1 pattern Plain 1 Linear { # apply the load - command: load nodeID xForce yForce load 4 100 - 50 } # Create the analysis system ProfileSPD constraints Plain integrator LoadControl 1.0 algorithm Linear numberer RCM analysis Static recorder Element - file a.out - time - ele 1 2 3 forces recorder SumElementForcesRecorder - file b.out - time - ele 1 2 3 # perform the analysis analyze 10 Example Output The output shows that the model is in equilibrium, and that at node 4 the node the element resisting forces are equal to the applied forces. 1 - 100 50 100 - 50 2 - 200 100 200 - 100 3 - 300 150 300 - 150 4 - 400 200 400 - 200 5 - 500 250 500 - 250 6 - 600 300 600 - 300 7 - 700 350 700 - 350 8 - 800 400 800 - 400 9 - 900 450 900 - 450 10 - 1000 500 1000 - 500","title":"Recorder\n"},{"location":"developer/extending/component/","text":"Compiling Inside each module-level CMakeLists.txt file there is a function call with the form: target_sources ( OPS_Module PRIVATE <some source files>... PUBLIC <some header files>... ) Simple materials and elements can be added to the CMake build simply by including them in the relevant CMake target_sources call. For example, a new element might be implemented in a file called ElasticFoo.cpp with header ElasticFoo.h in the directory OpenSees/SRC/element/ . These files would simply need to be added to the function call target_sources(OPS_Element ...) in the file OpenSees/SRC/element/CMakeLists.txt .","title":"Compiling\n"},{"location":"developer/extending/element/","text":"Internal CMake use New Elements The ASDEmbeddedNodeElement has been added with the following files: SRC/element/CEqElement/ASDEmbeddedNodeElement.h SRC/element/CEqElement/ASDEmbeddedNodeElement.cpp Create SRC/element/CEqElement/CMakeLists.txt Append to SRC/element/CMakeLists.txt Append to /Conf.cmake Optionally OPSDEF_ELEMENT_CEQ","title":"New Elements\n"},{"location":"gallery/","text":"Gallery .grid.cards>:-webkit-any(ul,ol) { display: contents !important; } ul { list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } .grid { grid-gap: .4rem; display: grid !important; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .grid>.card { text-size-adjust: none; -webkit-font-smoothing: antialiased; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; box-sizing: inherit; grid-gap: .4rem; display: grid; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .li { text-size-adjust: none; --md-text-font: \"Roboto\"; --md-code-font: \"Roboto Mono\"; -webkit-font-smoothing: antialiased; --md-text-font-family: var(--md-text-font,_),-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif; --md-code-font-family: var(--md-code-font,_),SFMono-Regular,Consolas,Menlo,monospace; font-feature-settings: \"kern\",\"liga\"; color: var(--md-typeset-color); font-family: var(--md-text-font-family); --md-default-fg-color: rgba(0,0,0,.87); --md-default-fg-color--light: rgba(0,0,0,.54); --md-default-fg-color--lighter: rgba(0,0,0,.32); --md-default-fg-color--lightest: rgba(0,0,0,.07); --md-default-bg-color: #fff; --md-default-bg-color--light: hsla(0,0%,100%,.7); --md-default-bg-color--lighter: hsla(0,0%,100%,.3); --md-default-bg-color--lightest: hsla(0,0%,100%,.12); --md-shadow-z1: 0 0.2rem 0.5rem rgba(0,0,0,.05),0 0 0.05rem rgba(0,0,0,.1); --md-shadow-z2: 0 0.2rem 0.5rem rgba(0,0,0,.1),0 0 0.05rem rgba(0,0,0,.25); --md-shadow-z3: 0 0.2rem 0.5rem rgba(0,0,0,.2),0 0 0.05rem rgba(0,0,0,.35); --md-typeset-table-sort-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m18 21-4-4h3V7h-3l4-4 4 4h-3v10h3M2 19v-2h10v2M2 13v-2h7v2M2 7V5h4v2H2Z\"/></svg>'); --md-typeset-table-sort-icon--asc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 17h3l-4 4-4-4h3V3h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-typeset-table-sort-icon--desc: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7h3l-4-4-4 4h3v14h2M2 17h10v2H2M6 5v2H2V5m0 6h7v2H2v-2Z\"/></svg>'); --md-toc-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2Z\"/></svg>'); --md-search-result-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h7c-.41-.25-.8-.56-1.14-.9-.33-.33-.61-.7-.86-1.1H6V4h7v5h5v1.18c.71.16 1.39.43 2 .82V8l-6-6m6.31 16.9c1.33-2.11.69-4.9-1.4-6.22-2.11-1.33-4.91-.68-6.22 1.4-1.34 2.11-.69 4.89 1.4 6.22 1.46.93 3.32.93 4.79.02L22 23.39 23.39 22l-3.08-3.1m-3.81.1a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5Z\"/></svg>'); --md-source-forks-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M5 3.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm0 2.122a2.25 2.25 0 1 0-1.5 0v.878A2.25 2.25 0 0 0 5.75 8.5h1.5v2.128a2.251 2.251 0 1 0 1.5 0V8.5h1.5a2.25 2.25 0 0 0 2.25-2.25v-.878a2.25 2.25 0 1 0-1.5 0v.878a.75.75 0 0 1-.75.75h-4.5A.75.75 0 0 1 5 6.25v-.878zm3.75 7.378a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0zm3-8.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5z\"/></svg>'); --md-source-repositories-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2 2.5A2.5 2.5 0 0 1 4.5 0h8.75a.75.75 0 0 1 .75.75v12.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 1 1 0-1.5h1.75v-2h-8a1 1 0 0 0-.714 1.7.75.75 0 0 1-1.072 1.05A2.495 2.495 0 0 1 2 11.5v-9zm10.5-1V9h-8c-.356 0-.694.074-1 .208V2.5a1 1 0 0 1 1-1h8zM5 12.25v3.25a.25.25 0 0 0 .4.2l1.45-1.087a.25.25 0 0 1 .3 0L8.6 15.7a.25.25 0 0 0 .4-.2v-3.25a.25.25 0 0 0-.25-.25h-3.5a.25.25 0 0 0-.25.25z\"/></svg>'); --md-source-stars-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25zm0 2.445L6.615 5.5a.75.75 0 0 1-.564.41l-3.097.45 2.24 2.184a.75.75 0 0 1 .216.664l-.528 3.084 2.769-1.456a.75.75 0 0 1 .698 0l2.77 1.456-.53-3.084a.75.75 0 0 1 .216-.664l2.24-2.183-3.096-.45a.75.75 0 0 1-.564-.41L8 2.694v.001z\"/></svg>'); --md-source-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M2.5 7.775V2.75a.25.25 0 0 1 .25-.25h5.025a.25.25 0 0 1 .177.073l6.25 6.25a.25.25 0 0 1 0 .354l-5.025 5.025a.25.25 0 0 1-.354 0l-6.25-6.25a.25.25 0 0 1-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.75 1.75 0 0 1 1 7.775zM6 5a1 1 0 1 0 0 2 1 1 0 0 0 0-2z\"/></svg>'); --md-tag-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"m5.41 21 .71-4h-4l.35-2h4l1.06-6h-4l.35-2h4l.71-4h2l-.71 4h6l.71-4h2l-.71 4h4l-.35 2h-4l-1.06 6h4l-.35 2h-4l-.71 4h-2l.71-4h-6l-.71 4h-2M9.53 9l-1.06 6h6l1.06-6h-6Z\"/></svg>'); --md-tooltip-width: 20rem; --md-version-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 320 512\"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d=\"m310.6 246.6-127.1 128c-7.1 6.3-15.3 9.4-23.5 9.4s-16.38-3.125-22.63-9.375l-127.1-128C.224 237.5-2.516 223.7 2.438 211.8S19.07 192 32 192h255.1c12.94 0 24.62 7.781 29.58 19.75s3.12 25.75-6.08 34.85z\"/></svg>'); --md-footnotes-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.42L5.83 13H21V7h-2Z\"/></svg>'); --md-details-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42Z\"/></svg>'); --md-tasklist-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-tasklist-icon--checked: url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill-rule=\"evenodd\" d=\"M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12zm16.28-2.72a.75.75 0 0 0-1.06-1.06l-5.97 5.97-2.47-2.47a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l6.5-6.5z\"/></svg>'); --md-accent-fg-color: #526cfe; --md-accent-fg-color--transparent: rgba(82,108,254,.1); --md-accent-bg-color: #fff; --md-accent-bg-color--light: hsla(0,0%,100%,.7); --md-primary-fg-color: #4051b5; --md-primary-fg-color--light: #5d6cc0; --md-primary-fg-color--dark: #303fa1; --md-primary-bg-color: #fff; --md-primary-bg-color--light: hsla(0,0%,100%,.7); --md-code-fg-color: #36464e; --md-code-bg-color: #f5f5f5; --md-code-hl-color: rgba(255,255,0,.5); --md-code-hl-number-color: #d52a2a; --md-code-hl-special-color: #db1457; --md-code-hl-function-color: #a846b9; --md-code-hl-constant-color: #6e59d9; --md-code-hl-keyword-color: #3f6ec6; --md-code-hl-string-color: #1c7d4d; --md-code-hl-name-color: var(--md-code-fg-color); --md-code-hl-operator-color: var(--md-default-fg-color--light); --md-code-hl-punctuation-color: var(--md-default-fg-color--light); --md-code-hl-comment-color: var(--md-default-fg-color--light); --md-code-hl-generic-color: var(--md-default-fg-color--light); --md-code-hl-variable-color: var(--md-default-fg-color--light); --md-typeset-color: var(--md-default-fg-color); --md-typeset-a-color: var(--md-primary-fg-color); --md-typeset-mark-color: rgba(255,255,0,.5); --md-typeset-del-color: rgba(245,80,61,.15); --md-typeset-ins-color: rgba(11,213,112,.15); --md-typeset-kbd-color: #fafafa; --md-typeset-kbd-accent-color: #fff; --md-typeset-kbd-border-color: #b8b8b8; --md-typeset-table-color: rgba(0,0,0,.12); --md-admonition-fg-color: var(--md-default-fg-color); --md-admonition-bg-color: var(--md-default-bg-color); --md-footer-fg-color: #fff; --md-footer-fg-color--light: hsla(0,0%,100%,.7); --md-footer-fg-color--lighter: hsla(0,0%,100%,.3); --md-footer-bg-color: rgba(0,0,0,.87); --md-footer-bg-color--dark: rgba(0,0,0,.32); --md-mermaid-font-family: var(--md-text-font-family),sans-serif; --md-mermaid-edge-color: var(--md-code-fg-color); --md-mermaid-node-bg-color: var(--md-accent-fg-color--transparent); --md-mermaid-node-fg-color: var(--md-accent-fg-color); --md-mermaid-label-bg-color: var(--md-default-bg-color); --md-mermaid-label-fg-color: var(--md-code-fg-color); -webkit-print-color-adjust: exact; font-size: .8rem; line-height: 1.6; list-style-type: disc; box-sizing: inherit; border: .05rem solid var(--md-default-fg-color--lightest); border-radius: .1rem; display: block; margin: 0; padding: .8rem; transition: border .25s,box-shadow .25s; } Basic Structures Install mkdocs-material with pip and get up and running in minutes Getting started Components Studies Focus on your content and generate a responsive and searchable static site Reference Geotech Change the colors, fonts, language, icons, logo and more with a few lines Customization Continua Material for MkDocs is licensed under MIT and available on GitHub License","title":"Gallery\n"},{"location":"gallery/BasicPrimer/","text":"Basics Basic Truss Concrete Frame Learn more \u2026or other spreadsheet programs will find that many of the concepts are transferrable to pandas. Learn more .d-flex { display: flex !important; } .comparison-card { background: #FFF; border-radius: 0; padding: 30px 10px 10px 10px; margin: 10px 0px; } .text-center { text-align: center !important; } .w-100 { width: 100% !important; } .shadow { box-shadow: 0 .5rem 1rem rgba(0,0,0,.15) !important; } /*ul { list-style-type: disc; }*/ .grid { grid-gap: .4rem; display: grid; grid-template-columns: repeat(auto-fit,minmax(16rem,1fr)); margin: 1em 0; } .grid>.card { /* border: .05rem solid var(--md-default-fg-color--lightest);*/ border-radius: .1rem; display: block; margin: 0; padding: .8rem; -webkit-transition: border .25s,box-shadow .25s; transition: border .25s,box-shadow .25s; } /* .card { position: relative; display: flex; flex-direction: column; min-width: 0; word-wrap: break-word; background-color: #fff; background-clip: border-box; border: 1px solid rgba(0,0,0,.125); border-radius: .25rem; } */ Frank McKenna and Michael Scott Pacific Earthquake Engineering Research Center University of California, Berkeley August 20, 2001 Version 1.2","title":"Basics\n"},{"location":"gallery/BasicPrimer/example_1/","text":"Simple Truss The first example is a simple truss structure. The purpose of this example is to show that model generation in OpenSees can resemble typical finite element analysis programs with the definition of nodes, materials, elements, loads and constraints. The example also demonstrates how an analysis object is \u2018built\u2019 from component objects. Example 1.1 \u2013 Linear elasticity This example is of a linear-elastic three bar truss, as shown in figure example1 , subject to static loads. Example1.1.tcl The model consists of four nodes, three truss elements, a single load pattern with a nodal load acting at node 4, and constraints at the three support nodes. Since the truss elements have the same elastic material, a single Elastic material object is created. Example 1.1 The model is linear, so we use a solution Algorithm of type Linear . Even though the solution is linear, we have to select a procedure for applying the load, which is called an Integrator . For this problem, a LoadControl integrator advances the solution. The equations are formed using a banded system, so the System is BandSPD (banded, symmetric positive definite). This is a good choice for most moderate size models. The equations have to be numbered, so typically an RCM numberer object is used (for Reverse Cuthill-McKee). The constraints are most easily represented with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used. When the analysis is complete the state of node 4 and all three elements will be printed to the screen. Nothing is recorded for later use. The Tcl script for the example is shown below. A comment is indicated by a # symbol. In the comments below, the syntax for important commands are given. Tcl source # OpenSees Example 1.1 # OpenSees Primer # # Units: kips, in, sec # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 2 DOF/node) model BasicBuilder - ndm 2 - ndf 2 # Create nodes # ------------ # Create nodes & add to Domain - command: node nodeId xCrd yCrd node 1 0.0 0.0 node 2 144.0 0.0 node 3 168.0 0.0 node 4 72.0 96.0 # Set the boundary conditions - command: fix nodeID xResrnt? yRestrnt? fix 1 1 1 fix 2 1 1 fix 3 1 1 # Define materials for truss elements # ----------------------------------- # Create Elastic material prototype - command: uniaxialMaterial Elastic matID E uniaxialMaterial Elastic 1 3000 # Define elements # --------------- # Create truss elements - command: element truss trussID node1 node2 A matID element truss 1 1 4 10.0 1 element truss 2 2 4 5.0 1 element truss 3 3 4 5.0 1 # Define loads # ------------ # Create a Plain load pattern with a linear TimeSeries pattern Plain 1 \"Linear\" { # Create the nodal load - command: load nodeID xForce yForce load 4 100 - 50 } # End of model generation # ------------------------------ # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a SPD using a band storage scheme system BandSPD # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the constraint handler, a Plain handler is used as homo constraints constraints Plain # Create the integration scheme, the LoadControl scheme using steps of 1.0 integrator LoadControl 1.0 # Create the solution algorithm, a Linear algorithm is created algorithm Linear # create the analysis object analysis Static # End of analysis generation # ------------------------------ # ------------------------------ # Start of recorder generation # ------------------------------ # create a Recorder object for the nodal displacements at node 4 recorder Node - file example . out - load - node 4 - dof 1 2 disp # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Perform the analysis analyze 1 # Print the current state at node 4 and at all elements print node 4 print ele Node : 4 Coordinates : 72 96 commitDisps : 0.530093 - 0.177894 unbalanced Load : 100 - 50 Element : 1 type : Truss iNode : 1 jNode : 4 Area : 10 Total Mass : 0 strain : 0.00146451 axial load : 43.9352 unbalanced load : - 26.3611 - 35.1482 26.3611 35.1482 Material : Elastic tag : 1 E : 3000 eta : 0 Element : 2 type : Truss iNode : 2 jNode : 4 Area : 5 Total Mass : 0 strain : - 0.00383642 axial load : - 57.5463 unbalanced load : - 34.5278 46.0371 34.5278 - 46.0371 Material : Elastic tag : 1 E : 3000 eta : 0 Element : 3 type : Truss iNode : 3 jNode : 4 Area : 5 Total Mass : 0 strain : - 0.00368743 axial load : - 55.3114 unbalanced load : - 39.1111 39.1111 39.1111 - 39.1111 Material : Elastic tag : 1 E : 3000 eta : 0 For the node, displacements and loads are given. For the truss elements, the axial strain and force are provided along with the resisting forces in the global coordinate system. The file example.out , specified in the recorder command, provides the nodal displacements for the x and y directions of node 4. The file consists of a single line of code: 1.0 0.530093 - 0.177894 The \\(1.0\\) corresponds to the load factor (pseudo time) in the model at which point the recorder was invoked. The \\(0.530093\\) and \\(-0.177894\\) correspond to the response at node \\(4\\) for the 1 and 2 degree-of-freedom. Note that if more analysis steps had been peformed, the line would contain a line for every analysis step that completed successfully.","title":"Simple Truss\n"},{"location":"gallery/BasicPrimer/example_3/","text":"Portal Frame Examples This next set of examples covers the nonlinear analysis of a reinforced concrete frame. The nonlinear beam column element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, the if-then-else control structure, and procedures are demonstrated in several elaborations of the example. Example 3.1 This example is of a reinforced concrete portal frame, as shown in figure [example3] , subject to gravity loads. Example3.1.tcl A nonlinear model of the portal frame shown in figure [example3] is created. The model consists of four nodes, two nonlinear beam-column elements, 1 and 2, to model the columns and an elastic beam element, 3, to model the beam. For the column elements a section, identical to the section used in Example 2, is created using steel and concrete fibers. Example 3.1 A single load pattern with a linear time series, two vertical nodal loads acting at nodes 3 and 4, and single point constraints to constrain nodes 1 and 2 are created. The model contains material non-linearities, so a solution algorithm of type Newton is used. The solution algorithm uses a ConvergenceTest which tests convergence of the equilibrium solution with the norm of the displacement increment vector. For this nonlinear problem, the gravity loads are applied incrementally until the full load is applied. To achieve this, a LoadControl integrator which advances the solution with an increment of 0.1 at each load step is used. The equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Static Analysis object is used. To achieve the full gravity load, 10 load steps are performed. At end of analysis, the state at nodes 3 and 4 is output. The state of element 1 is also output. # OpenSees Example 3.1 # OpenSees Primer # # Units: kips, in, sec # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 3 DOF/node) model basic - ndm 2 - ndf 3 # Create nodes # ------------ # Set parameters for overall model geometry set width 360 set height 144 # Create nodes # tag X Y node 1 0.0 0.0 node 2 $width 0.0 node 3 0.0 $height node 4 $width $height # Fix supports at base of columns # tag DX DY RZ fix 1 1 1 1 fix 2 1 1 1 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 - 6.0 - 0.004 - 5.0 - 0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 - 5.0 - 0.002 0.0 - 0.006 # STEEL # Reinforcing steel set fy 60.0 ; # Yield stress set E 30000.0 ; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $fy $E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some paramaters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60 ; # area of no. 7 bars # some variables derived from the parameters set y1 [expr $colDepth / 2.0 ] set z1 [expr $colWidth / 2.0 ] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [expr $cover-$y1 ] [expr $cover-$z1 ] [expr $y1-$cover ] [expr $z1-$cover ] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [expr - $y1 ] [expr $z1-$cover ] $y1 $z1 patch rect 2 10 1 [expr - $y1 ] [expr - $z1 ] $y1 [expr $cover-$z1 ] patch rect 2 2 1 [expr - $y1 ] [expr $cover-$z1 ] [expr $cover-$y1 ] [expr $z1-$cover ] patch rect 2 2 1 [expr $y1-$cover ] [expr $cover-$z1 ] $y1 [expr $z1-$cover ] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $As [expr $y1-$cover ] [expr $z1-$cover ] [expr $y1-$cover ] [expr $cover-$z1 ] layer straight 3 2 $As 0.0 [expr $z1-$cover ] 0.0 [expr $cover-$z1 ] layer straight 3 3 $As [expr $cover-$y1 ] [expr $z1-$cover ] [expr $cover-$y1 ] [expr $cover-$z1 ] } # Define column elements # ---------------------- # Geometry of column elements # tag geomTransf Linear 1 # Number of integration points along length of element set np 5 # Create the coulumns using Beam-column elements # tag ndI ndJ nsecs secID transfTag element nonlinearBeamColumn 1 1 3 $np 1 1 element nonlinearBeamColumn 2 2 4 $np 1 1 # Define beam elment # ----------------------------- # Geometry of column elements # tag geomTransf Linear 2 # Create the beam element # tag ndI ndJ A E Iz transfTag element elasticBeamColumn 3 3 4 360 4030 8640 2 # Define gravity loads # -------------------- # Set a parameter for the axial load set P 180 ; # 10% of axial capacity of columns # Create a Plain load pattern with a Linear TimeSeries pattern Plain 1 \"Linear\" { # Create nodal loads at nodes 3 & 4 # nd FX FY MZ load 3 0.0 [expr - $P ] 0.0 load 4 0.0 [expr - $P ] 0.0 } # ------------------------------ # End of model generation # ------------------------------ # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a sparse solver with partial pivoting system BandGeneral # Create the constraint handler, the transformation method constraints Transformation # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0 e-12 10 3 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, the LoadControl scheme using steps of 0.1 integrator LoadControl 0.1 # Create the analysis object analysis Static # initialize in case we need to do an initial stiffness iteration initialize # ------------------------------ # End of analysis generation # ------------------------------ # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node - file nodeGravity.out - time - node 3 4 - dof 1 2 3 disp # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # perform the gravity load analysis, requires 10 steps to reach the load level analyze 10 # Print out the state of nodes 3 and 4 print node 3 4 # Print out the state of element 1 print ele 1 2 Node : 3 Coordinates : 0 144 commitDisps: 1.7109 e-18 - 0.0183736 - 2.81893 e-20 unbalanced Load: 0 - 180 0 ID : 3 4 5 Node: 4 Coordinates : 360 144 commitDisps: 1.71095 e-18 - 0.0183736 - 2.79765 e-20 unbalanced Load: 0 - 180 0 ID : 0 1 2 Element: 1 Type: NLBeamColumn2d Connected Nodes: 1 3 Number of Sections: 5 Mass density: 0 End 1 Forces ( P V M ) : 180 7.0121 e-31 - 8.88178 e-16 End 2 Forces ( P V M ) : - 180 - 7.0121 e-31 8.88178 e-16 Element : 2 Type: NLBeamColumn2d Connected Nodes: 2 4 Number of Sections: 5 Mass density: 0 End 1 Forces ( P V M ) : 180 0 - 8.88178 e-16 End 2 Forces ( P V M ) : - 180 0 8.88178 e-16 For the two nodes, displacements and loads are given. For the beam-column elements, the element end forces in the local system are provided. The nodeGravity.out file contains ten lines, each line containing 7 entries. The first entry is time in the domain at end of the load step. The next 3 entries are the displacements at node 3, and the final 3 entries the displacements at node 4. Example 3.2 In this example the nonlinear reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a pushover analysis. Example3.2.tcl Example3.1.tcl After performing the gravity load analysis on the model, the time in the domain is reset to 0.0 and the current value of all loads acting are held constant. A new load pattern with a linear time series and horizontal loads acting at nodes 3 and 4 is then added to the model. The static analysis used to perform the gravity load analysis is modified to take a new DisplacementControl integrator. At each new step in the analysis the integrator will determine the load increment necessary to increment the horizontal displacement at node 3 by 0.1 in. 60 analysis steps are performed in this new analysis. For this analysis the nodal displacements at nodes 3 and 4 will be stored in the file nodePushover.out for post-processing. In addition, the end forces in the local coordinate system for elements 1 and 2 will be stored in the file elePushover.out. At the end of the analysis, the state of node 3 is printed to the screen. # OpenSees Example 3.2 # OpenSees Primer # # Units: kips, in, sec # ---------------------------------------------------- # Start of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # Do operations of Example3.1 by sourcing in the tcl file source Example3.1.tcl puts `` Gravity load analysis completed '' # Set the gravity loads to be constant & reset the time in the domain loadConst - time 0.0 # ---------------------------------------------------- # End of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # ---------------------------------------------------- # Start of additional modeling for lateral loads # ---------------------------------------------------- # Define lateral loads # -------------------- # Set some parameters set H 10.0 ; # Reference lateral load # Set lateral load pattern with a Linear TimeSeries pattern Plain 2 \"Linear\" { # Create nodal loads at nodes 3 & 4 # nd FX FY MZ load 3 $H 0.0 0.0 load 4 $H 0.0 0.0 } # ---------------------------------------------------- # End of additional modeling for lateral loads # ---------------------------------------------------- # ---------------------------------------------------- # Start of modifications to analysis for push over # ---------------------------------------------------- # Set some parameters set dU 0.1 ; # Displacement increment # Change the integration scheme to be displacement control # node dof init Jd min max integrator DisplacementControl 3 1 $dU 1 $dU $dU # ---------------------------------------------------- # End of modifications to analysis for push over # ---------------------------------------------------- # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node - file node32.out - time - node 3 4 - dof 1 2 3 disp # Create a recorder to monitor element forces in columns recorder Element - file ele32.out - time - ele 1 2 localForce # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Set some parameters set maxU 6.0 ; # Max displacement set numSteps [expr int ( $maxU / $dU )] # Perform the analysis analyze $numSteps puts `` Pushover analysis completed '' # Print the state at node 3 print node 3 Gravity load analysis completed Setting time in domain to be : 0.0 Pushover analysis completed Node : 3 Coordinates : 0 144 commitDisps: 6 0.488625 - 0.00851377 unbalanced Load: 71.8819 - 180 0 In addition to what is displayed on the screen, the file node32.out and ele32.out have been created by the script. Each line of node32.out contains the time, DX, DY and RZ for node 3 and DX, DY and RZ for node 4 at the end of an iteration. Each line of eleForce.out contains the time, and the element end forces in the local coordinate system. A plot of the load-displacement relationship at node 3 is shown in figure [lateral32] . Load displacement curve for node 3 Example 3.3 In this example the reinforced concrete portal frame which has undergone the gravity load analysis of Example 3.1 is now subjected to a uniform earthquake excitation. Example3.3.tcl Example3.1.tcl ReadSMDFile.tcl After performing the gravity load analysis, the time in the domain is reset to 0.0 and the current value of all active loads is set to constant. Mass terms are added to nodes 3 and 4. A new uniform excitation load pattern is created. The excitation acts in the horizontal direction and reads the acceleration record and time interval from the file ARL360.g3 . The file ARL360.g3 is created from the PEER Strong Motion Database (http://peer.berkeley.edu/smcat/) record ARL360.at2 using the Tcl procedure ReadSMDFile contained in the file ReadSMDFile.tcl . The static analysis object and its components are first deleted so that a new transient analysis object can be created. A new solution Algorithm of type Newton is then created. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the displacement increment vector. The integrator for this analysis will be of type Newmark with a \\(\\gamma\\) of 0.25 and a \\(\\beta\\) of 0.5. The integrator will add some stiffness proportional damping to the system, the damping term will be based on the last committed stifness of the elements, i.e. \\(C = a_c K_{commit}\\) with \\(a_c = 0.000625\\) . The equations are formed using a banded storage scheme, so the System is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 time steps are performed with a time step of 0.01. In addition to the transient analysis, two eigenvalue analysis are performed on the model. The first is performed after the gravity analysis and the second after the transient analysis. For this analysis the nodal displacenments at Nodes 3 and 4 will be stored in the file nodeTransient.out for post-processing. In addition the section forces and deformations for the section at the base of column 1 will also be stored in two seperate files. The results of the eigenvalue analysis will be displayed on the screen. # OpenSees Example 3.3 # OpenSees Primer # # Units: kips, in, sec # ---------------------------------------------------- # Start of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # Do operations of Example3.1 by sourcing in the tcl file source Example3.1.tcl puts \"Gravity load analysis completed\" # Set the gravity loads to be constant & reset the time in the domain loadConst - time 0.0 # ---------------------------------------------------- # End of Model Generation & Initial Gravity Analysis # ---------------------------------------------------- # ---------------------------------------------------- # Start of additional modeling for dynamic loads # ---------------------------------------------------- # Define nodal mass in terms of axial load on columns set g 386.4 set m [expr $P / $g ]; # expr command to evaluate an expression # tag MX MY RZ mass 3 $m $m 0 mass 4 $m $m 0 # Define dynamic loads # -------------------- # Set some parameters set outFile ARL360.g3 set accelSeries \"Path -filePath $outFile -dt $dt -factor $g\" # Source in TCL proc to read a PEER Strong Motion Database record source ReadSMDFile.tcl # Perform the conversion from SMD record to OpenSees record and obtain dt # inFile outFile dt ReadSMDFile ARL360.at2 $outFile dt # Create UniformExcitation load pattern # tag dir pattern UniformExcitation 2 1 - accel $accelSeries # set the rayleigh damping factors for nodes & elements rayleigh 0.0 0.0 0.0 0.000625 # ---------------------------------------------------- # End of additional modeling for dynamic loads # ---------------------------------------------------- # --------------------------------------------------------- # Start of modifications to analysis for transient analysis # --------------------------------------------------------- # Delete the old analysis and all its component objects wipeAnalysis # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0 e-12 10 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, Newmark with gamma = 0.5 and beta = 0.25 integrator Newmark 0.5 0.25 # Create the system of equation, a banded general storage scheme system BandGeneral # Create the constraint handler, a plain handler as homogeneous boundary conditions constraints Plain # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the analysis object analysis Transient # --------------------------------------------------------- # End of modifications to analysis for transient analysis # --------------------------------------------------------- # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder to monitor nodal displacements recorder Node - time - file node33.out - node 3 4 - dof 1 2 3 disp # Create recorders to monitor section forces and deformations # at the base of the left column recorder Element - time - file ele1secForce.out - ele 1 section 1 force recorder Element - time - file ele1secDef.out - ele 1 section 1 deformation # -------------------------------- # End of recorder generation # --------------------------------- # ------------------------------ # Finally perform the analysis # ------------------------------ # Perform an eigenvalue analysis puts \"eigen values at start of transient: [eigen 2]\" # set some variables set tFinal [expr 2000 * 0.01 ] set tCurrent [ getTime ] set ok 0 # Perform the transient analysis while { $ok == 0 && $tCurrent < $tFinal } { set ok [ analyze 1 .01 ] # if the analysis fails try initial tangent iteration if { $ok != 0 } { puts \"regular newton failed .. lets try an initail stiffness for this step\" test NormDispIncr 1.0 e-12 100 0 algorithm ModifiedNewton - initial set ok [ analyze 1 .01 ] if { $ok == 0 } { puts \"that worked .. back to regular newton\" } test NormDispIncr 1.0 e-12 10 algorithm Newton } set tCurrent [ getTime ] } # Print a message to indicate if analysis succesfull or not if { $ok == 0 } { puts \"Transient analysis completed SUCCESSFULLY\" ; } else { puts \"Transient analysis completed FAILED\" ; } # Perform an eigenvalue analysis puts \"eigen values at end of transient: [eigen 2]\" # Print state of node 3 print node 3 Gravity load analysis completed eigen values at start of transient : 2.695422e+02 1.750711e+04 Transient analysis completed SUCCESSFULLY eigen values at start of transient : 1.578616e+02 1.658481e+04 Node : 3 Coordinates : 0 144 commitDisps : - 0.0464287 - 0.0246641 0.000196066 Velocities : - 0.733071 1.86329e-05 0.00467983 commitAccels : - 9.13525 0.277302 38.2972 unbalanced Load : - 3.9475 - 180 0 Mass : 0.465839 0 0 0 0.465839 0 0 0 0 Eigenvectors : - 1.03587 - 0.0482103 - 0.00179081 0.00612275 0.00663473 3.21404e-05 The two eigenvalues for the eigenvalue analysis are printed to the screen. The state of node 3 at the end of the analysis is also printed. The information contains the last committed displacements, velocities and accelerations at the node, the unbalanced nodal forces and the nodal masses. In addition, the eigenvector components of the eigenvector pertaining to the node 3 is also displayed. In addition to the contents displayed on the screen, three files have been created. Each line of nodeTransient.out contains the domain time, and DX, DY and RZ for node 3. Plotting the first and second columns of this file the lateral displacement versus time for node 3 can be obtained as shown in figure [lateral33] . Each line of the files ele1secForce.out and ele1secDef.out contain the domain time and the forces and deformations for section 1 (the base section) of element 1. These can be used to generate the moment-curvature time history of the base section of column 1 as shown in figure [element1MK] . Lateral displacement at node 3 Column section moment-curvature results","title":"Portal Frame Examples\n"},{"location":"gallery/BasicPrimer/example_4/","text":"Multibay Two Story Frame In this next example the use of variable substitution and the Tcl loop control structure for building models is demonstrated. Example 4.1 This example is of a reinforced concrete multibay two story frame, as shown in figure [example4] , subject to gravity loads. Example4.1.tcl A model of the frame shown in figure example4 is created. The number of objects in the model is dependent on the parameter numBay. The \\((\\) numBay \\(+1)*3)\\) nodes are created, one column line at a time, with the node at the base of the columns fixed in all directions. Three materials are constructed, one for the concrete core, one for the concrete cover and one for the reinforcement steel. Three fiber discretized sections are then built, one for the exterior columns, one for the interior columns and one for the girders. Each of the members in the frame is modelled using nonlinear beam-column elements with 4 (nP) integration points and a linear geometric transformation object. For gravity loads, a single load pattern with a linear time series and two vertical nodal loads acting at the first and second floor nodes of each column line is used. The load at the lower level is twice that of the upper level and the load on the interior columns is twice that of the exterior columns. For the lateral load analysis, a second load pattern with a linear time series is introduced after the gravity load analysis. Associated with this load pattern are two nodal loads acting on nodes 2 and 3, with the load level at node 3 twice that acting at node 2. A solution Algorithm of type Newton is created. The solution algorithm uses a ConvergenceTest based on the norm of the displacement increment vector. The integrator for the analysis will be LoadControl with a load step increment of 0.1. The storage for the system of equations is BandGeneral. The equations are numbered using an RCM (reverse Cuthill-McKee) numberer. The constraints are enforced with a Plain constraint handler. Once the components of the analysis have been defined, the analysis object is then created. For this problem a Static analysis object is used and 10 steps are performed to load the model with the desired gravity load. After the gravity load analysis has been performed, the gravity loads are set to constant and the time in the domain is reset to 0.0. A new LoadControl integrator is now added. The new LoadControl integrator has an initial load step of 1.0, but this can vary between 0.02 and 2.0 depending on the number of iterations required to achieve convergence at each load step. 100 steps are then performed. For the pushover analysis the lateral displacements at nodes 2 and 3 will be stored in the file Node41.out for post-processing. In addition, if the variable displayMode is set to \u201cdisplayON\u201d the load-displacement curve for horizontal displacements at node 3 will be displayed in a window on the user\u2019s terminal. # OpenSees Example 4.1 # OpenSees Primer # # Units: kips, in, sec # Parameter identifying the number of bays set numBay 3 # ------------------------------ # Start of model generation # ------------------------------ # Create ModelBuilder (with two-dimensions and 3 DOF/node) model BasicBuilder - ndm 2 - ndf 3 # Create nodes # ------------ # Set parameters for overall model geometry set bayWidth 288 set nodeID 1 # Define nodes for { set i 0 } { $ i <= $ numBay } { incr i 1 } { set xDim [ expr $ i * $ bayWidth ] # tag X Y node $ nodeID $ xDim 0 node [ expr $ nodeID + 1 ] $ xDim 180 node [ expr $ nodeID + 2 ] $ xDim 324 incr nodeID 3 } # Fix supports at base of columns for { set i 0 } { $ i <= $ numBay } { incr i 1 } { # node DX DY RZ fix [ expr $ i * 3 + 1 ] 1 1 1 } # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE # Cover concrete # tag -f'c -epsco -f'cu -epscu uniaxialMaterial Concrete01 1 - 4.00 - 0.002 0.0 - 0.006 # Core concrete uniaxialMaterial Concrete01 2 - 5.20 - 0.005 - 4.70 - 0.02 # STEEL # Reinforcing steel # tag fy E0 b uniaxialMaterial Steel01 3 60 30000 0.02 # Define cross-section for nonlinear columns # ------------------------------------------ # Interior column section - Section A section Fiber 1 { # mat nfIJ nfJK yI zI yJ zJ yK zK yL zL patch quadr 2 1 12 - 11.5 10 - 11.5 - 10 11.5 - 10 11.5 10 patch quadr 1 1 14 - 13.5 - 10 - 13.5 - 12 13.5 - 12 13.5 - 10 patch quadr 1 1 14 - 13.5 12 - 13.5 10 13.5 10 13.5 12 patch quadr 1 1 2 - 13.5 10 - 13.5 - 10 - 11.5 - 10 - 11.5 10 patch quadr 1 1 2 11.5 10 11.5 - 10 13.5 - 10 13.5 10 # mat nBars area yI zI yF zF layer straight 3 6 1.56 - 10.5 9 - 10.5 - 9 layer straight 3 6 1.56 10.5 9 10.5 - 9 } # Exterior column section - Section B section Fiber 2 { patch quadr 2 1 10 - 10 10 - 10 - 10 10 - 10 10 10 patch quadr 1 1 12 - 12 - 10 - 12 - 12 12 - 12 12 - 10 patch quadr 1 1 12 - 12 12 - 12 10 12 10 12 12 patch quadr 1 1 2 - 12 10 - 12 - 10 - 10 - 10 - 10 10 patch quadr 1 1 2 10 10 10 - 10 12 - 10 12 10 layer straight 3 6 0.79 - 9 9 - 9 - 9 layer straight 3 6 0.79 9 9 9 - 9 } # Girder section - Section C section Fiber 3 { patch quadr 1 1 12 - 12 9 - 12 - 9 12 - 9 12 9 layer straight 3 4 1.00 - 9 9 - 9 - 9 layer straight 3 4 1.00 9 9 9 - 9 } # Define column elements # ---------------------- # Number of integration points set nP 4 # Geometric transformation geomTransf Linear 1 set beamID 1 # Define elements for { set i 0 } { $ i <= $ numBay } { incr i 1 } { # set some parameters set iNode [ expr $ i * 3 + 1 ] set jNode [ expr $ i * 3 + 2 ] for { set j 1 } { $ j < 3 } { incr j 1 } { # add the column element (secId == 2 if external, 1 if internal column) if { $ i == 0 } { element nonlinearBeamColumn $ beamID $ iNode $ jNode $ nP 2 1 } elseif { $ i == $ numBay } { element nonlinearBeamColumn $ beamID $ iNode $ jNode $ nP 2 1 } else { element nonlinearBeamColumn $ beamID $ iNode $ jNode $ nP 1 1 } # increment the parameters incr iNode 1 incr jNode 1 incr beamID 1 } } # Define beam elements # ---------------------- # Number of integration points set nP 4 # Geometric transformation geomTransf Linear 2 # Define elements for { set j 1 } { $ j < 3 } { incr j 1 } { # set some parameters set iNode [ expr $ j + 1 ] set jNode [ expr $ iNode + 3 ] for { set i 1 } { $ i <= $ numBay } { incr i 1 } { element nonlinearBeamColumn $ beamID $ iNode $ jNode $ nP 3 2 # increment the parameters incr iNode 3 incr jNode 3 incr beamID 1 } } # Define gravity loads # -------------------- # Constant gravity load set P - 192 # Create a Plain load pattern with a Linear TimeSeries pattern Plain 1 Linear { # Create nodal loads at nodes for { set i 0 } { $ i <= $ numBay } { incr i 1 } { # set some parameters set node1 [ expr $ i * 3 + 2 ] set node2 [ expr $ node1 + 1 ] if { $ i == 0 } { load $ node1 0.0 $ P 0.0 load $ node2 0.0 [ expr $ P / 2.0 ] 0.0 } elseif { $ i == $ numBay } { load $ node1 0.0 $ P 0.0 load $ node2 0.0 [ expr $ P / 2.0 ] 0.0 } else { load $ node1 0.0 [ expr 2.0 *$ P ] 0.0 load $ node2 0.0 $ P 0.0 } } } # ------------------------------ # End of model generation # ------------------------------ # ------------------------------------------------ # Start of analysis generation for gravity analysis # ------------------------------------------------- # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 test NormDispIncr 1.0e-8 10 0 # Create the solution algorithm, a Newton-Raphson algorithm algorithm Newton # Create the integration scheme, the LoadControl scheme using steps of 0.1 integrator LoadControl 0.1 1 0.1 0.1 # Create the system of equation, a SPD using a profile storage scheme system BandGeneral # Create the DOF numberer, the reverse Cuthill-McKee algorithm numberer RCM # Create the constraint handler, the transformation method constraints Plain # Create the analysis object analysis Static # ------------------------------------------------ # End of analysis generation for gravity analysis # ------------------------------------------------- # ------------------------------ # Perform gravity load analysis # ------------------------------ # perform the gravity load analysis, requires 10 steps to reach the load level analyze 10 # set gravity loads to be const and set pseudo time to be 0.0 # for start of lateral load analysis loadConst - time 0.0 # ------------------------------ # Add lateral loads # ------------------------------ # Reference lateral load for pushover analysis set H 10 # Reference lateral loads # Create a Plain load pattern with a Linear TimeSeries pattern Plain 2 Linear { load 2 [ expr $ H / 2.0 ] 0.0 0.0 load 3 $ H 0.0 0.0 } # ------------------------------ # Start of recorder generation # ------------------------------ # Create a recorder which writes to Node.out and prints # the current load factor (pseudo-time) and dof 1 displacements at node 2 & 3 recorder Node - file Node41 . out - time - node 2 3 - dof 1 disp # Source in some commands to display the model # comment out one of lines set displayMode \"displayON\" #set displayMode \"displayOFF\" if { $ displayMode == \"displayON\" } { # a window to plot the nodal displacements versus load for node 3 recorder plot Node41 . out Node_3_Xdisp 10 340 300 300 - columns 3 1 - dT 0.1 } # ------------------------------ # End of recorder generation # ------------------------------ # ------------------------------ # Start of lateral load analysis # ------------------------------ # Change the integrator to take a min and max load increment integrator LoadControl 1.0 4 0.02 2.0 # Perform the analysis # Perform the pushover analysis # Set some parameters set maxU 10.0 ; # Max displacement set controlDisp 0.0 ; set ok 0 ; while { $ controlDisp < $ maxU && $ ok == 0 } { set ok [ analyze 1 ] set controlDisp [ nodeDisp 3 1 ] if { $ ok != 0 } { puts \"... trying an initial tangent iteration with Newton\" test NormDispIncr 1.0e-8 4000 0 algorithm ModifiedNewton - initial set ok [ analyze 1 ] test NormDispIncr 1.0e-8 10 0 algorithm Newton } } if { $ ok != 0 } { puts \"Pushover analysis FAILED\" } else { puts \"Pushover analysis completed SUCCESSFULLY\" } The output consists of the file Node41.out containing a line for each step of the lateral load analysis. Each line contains the load factor, the lateral displacements at nodes 2 and 3. A plot of the load-displacement curve for the frame is given in figure [twostory] .","title":"Multibay Two Story Frame\n"},{"location":"gallery/BasicPrimer/example_5/","text":"Three-Dimensional Rigid Frame Example 5.1 This example is of a three-dimensional reinforced concrete rigid frame, as shown in figure [example5] , subjected to bi-directional earthquake ground motion. Example5.1.tcl RCsection.tcl tabasFN.txt tabasFP.txt A model of the rigid frame shown in figure [example5] is created. The model consists of three stories and one bay in each direction. Rigid diaphragm multi-point constraints are used to enforce the rigid in-plane stiffness assumption for the floors. Gravity loads are applied to the structure and the 1978 Tabas acceleration records are the uniform earthquake excitations. Nonlinear beam column elements are used for all members in the structure. The beam sections are elastic while the column sections are discretized by fibers of concrete and steel. Elastic beam column elements may have been used for the beam members; but, it is useful to see that section models other than fiber sections may be used in the nonlinear beam column element. Example 5.1 A solution Algorithm of type Newton is used for the nonlinear problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. The integrator for this analysis will be of type Newmark with a \\(\\gamma\\) of 0.25 and a \\(\\beta\\) of 0.5. Due to the presence of the multi-point constraints, a Transformation constraint handler is used. The equations are formed using a sparse storage scheme which will perform pivoting during the equation solving, so the System is SparseGeneral. As SparseGeneral will perform it\u2019s own internal numbering of the equations, a Plain numberer is used which simply assigns equation numbers to the degrees-of-freedom. Once all the components of an analysis are defined, the Analysis object itself is created. For this problem a Transient Analysis object is used. 2000 steps are performed with a time step of 0.01. The nodal displacements at nodes 9, 14, and 19 (the retained nodes for the rigid diaphragms) will be stored in the file node51.out for post-processing. # OpenSees Example 5.1 # OpenSees Primer # # Units: kips, in, sec # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model BasicBuilder - ndm 3 - ndf 6 # Define geometry # --------------- # Set parameters for model geometry set h 144.0 ; # Story height set by 240.0 ; # Bay width in Y-direction set bx 240.0 ; # Bay width in X-direction # Create nodes # tag X Y Z node 1 [ expr -$ bx / 2 ] [ expr $ by / 2 ] 0 node 2 [ expr $ bx / 2 ] [ expr $ by / 2 ] 0 node 3 [ expr $ bx / 2 ] [ expr -$ by / 2 ] 0 node 4 [ expr -$ bx / 2 ] [ expr -$ by / 2 ] 0 node 5 [ expr -$ bx / 2 ] [ expr $ by / 2 ] $ h node 6 [ expr $ bx / 2 ] [ expr $ by / 2 ] $ h node 7 [ expr $ bx / 2 ] [ expr -$ by / 2 ] $ h node 8 [ expr -$ bx / 2 ] [ expr -$ by / 2 ] $ h node 10 [ expr -$ bx / 2 ] [ expr $ by / 2 ] [ expr 2 *$ h ] node 11 [ expr $ bx / 2 ] [ expr $ by / 2 ] [ expr 2 *$ h ] node 12 [ expr $ bx / 2 ] [ expr -$ by / 2 ] [ expr 2 *$ h ] node 13 [ expr -$ bx / 2 ] [ expr -$ by / 2 ] [ expr 2 *$ h ] node 15 [ expr -$ bx / 2 ] [ expr $ by / 2 ] [ expr 3 *$ h ] node 16 [ expr $ bx / 2 ] [ expr $ by / 2 ] [ expr 3 *$ h ] node 17 [ expr $ bx / 2 ] [ expr -$ by / 2 ] [ expr 3 *$ h ] node 18 [ expr -$ bx / 2 ] [ expr -$ by / 2 ] [ expr 3 *$ h ] # Retained nodes for rigid diaphragm # tag X Y Z node 9 0 0 $ h node 14 0 0 [ expr 2 *$ h ] node 19 0 0 [ expr 3 *$ h ] # Set base constraints # tag DX DY DZ RX RY RZ fix 1 1 1 1 1 1 1 fix 2 1 1 1 1 1 1 fix 3 1 1 1 1 1 1 fix 4 1 1 1 1 1 1 # Define rigid diaphragm multi-point constraints # normalDir retained constrained rigidDiaphragm 3 9 5 6 7 8 rigidDiaphragm 3 14 10 11 12 13 rigidDiaphragm 3 19 15 16 17 18 # Constraints for rigid diaphragm retained nodes # tag DX DY DZ RX RY RZ fix 9 0 0 1 1 1 0 fix 14 0 0 1 1 1 0 fix 19 0 0 1 1 1 0 # Define materials for nonlinear columns # -------------------------------------- # CONCRETE # Core concrete (confined) # tag f'c epsc0 f'cu epscu uniaxialMaterial Concrete01 1 - 5.0 - 0.005 - 3.5 - 0.02 # Cover concrete (unconfined) set fc 4.0 uniaxialMaterial Concrete01 2 -$ fc - 0.002 0.0 - 0.006 # STEEL # Reinforcing steel # tag fy E b uniaxialMaterial Steel01 3 60 30000 0.02 # Column width set d 18.0 # Source in a procedure for generating an RC fiber section source RCsection . tcl # Call the procedure to generate the column section # id h b cover core cover steel nBars area nfCoreY nfCoreZ nfCoverY nfCoverZ RCsection 1 $ d $ d 2.5 1 2 3 3 0.79 8 8 10 10 # Concrete elastic stiffness set E [ expr 57000.0 * sqrt ( $ fc * 1000 ) / 1000 ]; # Column torsional stiffness set GJ 1.0e10 ; # Linear elastic torsion for the column uniaxialMaterial Elastic 10 $ GJ # Attach torsion to the RC column section # tag uniTag uniCode secTag section Aggregator 2 10 T - section 1 set colSec 2 # Define column elements # ---------------------- #set PDelta \"ON\" set PDelta \"OFF\" # Geometric transformation for columns if { $ PDelta == \"ON\" } { # tag vecxz geomTransf LinearWithPDelta 1 1 0 0 } else { geomTransf Linear 1 1 0 0 } # Number of column integration points (sections) set np 4 # Create the nonlinear column elements # tag ndI ndJ nPts secID transf element nonlinearBeamColumn 1 1 5 $ np $ colSec 1 element nonlinearBeamColumn 2 2 6 $ np $ colSec 1 element nonlinearBeamColumn 3 3 7 $ np $ colSec 1 element nonlinearBeamColumn 4 4 8 $ np $ colSec 1 element nonlinearBeamColumn 5 5 10 $ np $ colSec 1 element nonlinearBeamColumn 6 6 11 $ np $ colSec 1 element nonlinearBeamColumn 7 7 12 $ np $ colSec 1 element nonlinearBeamColumn 8 8 13 $ np $ colSec 1 element nonlinearBeamColumn 9 10 15 $ np $ colSec 1 element nonlinearBeamColumn 10 11 16 $ np $ colSec 1 element nonlinearBeamColumn 11 12 17 $ np $ colSec 1 element nonlinearBeamColumn 12 13 18 $ np $ colSec 1 # Define beam elements # -------------------- # Define material properties for elastic beams # Using beam depth of 24 and width of 18 # -------------------------------------------- set Abeam [ expr 18 * 24 ]; # \"Cracked\" second moments of area set Ibeamzz [ expr 0.5 * 1.0 / 12 * 18 * pow ( 24 , 3 )]; set Ibeamyy [ expr 0.5 * 1.0 / 12 * 24 * pow ( 18 , 3 )]; # Define elastic section for beams # tag E A Iz Iy G J section Elastic 3 $ E $ Abeam $ Ibeamzz $ Ibeamyy $ GJ 1.0 set beamSec 3 # Geometric transformation for beams # tag vecxz geomTransf Linear 2 1 1 0 # Number of beam integration points (sections) set np 3 # Create the beam elements # tag ndI ndJ nPts secID transf element nonlinearBeamColumn 13 5 6 $ np $ beamSec 2 element nonlinearBeamColumn 14 6 7 $ np $ beamSec 2 element nonlinearBeamColumn 15 7 8 $ np $ beamSec 2 element nonlinearBeamColumn 16 8 5 $ np $ beamSec 2 element nonlinearBeamColumn 17 10 11 $ np $ beamSec 2 element nonlinearBeamColumn 18 11 12 $ np $ beamSec 2 element nonlinearBeamColumn 19 12 13 $ np $ beamSec 2 element nonlinearBeamColumn 20 13 10 $ np $ beamSec 2 element nonlinearBeamColumn 21 15 16 $ np $ beamSec 2 element nonlinearBeamColumn 22 16 17 $ np $ beamSec 2 element nonlinearBeamColumn 23 17 18 $ np $ beamSec 2 element nonlinearBeamColumn 24 18 15 $ np $ beamSec 2 # Define gravity loads # -------------------- # Gravity load applied at each corner node # 10% of column capacity set p [ expr 0.1 *$ fc *$ h *$ h ] # Mass lumped at retained nodes set g 386.4 ; # Gravitational constant set m [ expr ( 4 *$ p ) /$ g ] # Rotary inertia of floor about retained node set i [ expr $ m * ( $ bx *$ bx +$ by *$ by ) / 12.0 ] # Set mass at the retained nodes # tag MX MY MZ RX RY RZ mass 9 $ m $ m 0 0 0 $ i mass 14 $ m $ m 0 0 0 $ i mass 19 $ m $ m 0 0 0 $ i # Define gravity loads pattern Plain 1 Constant { foreach node { 5 6 7 8 10 11 12 13 15 16 17 18 } { load $ node 0.0 0.0 -$ p 0.0 0.0 0.0 } } # Define earthquake excitation # ---------------------------- # Set up the acceleration records for Tabas fault normal and fault parallel set tabasFN \"Path -filePath tabasFN.txt -dt 0.02 -factor $g\" set tabasFP \"Path -filePath tabasFP.txt -dt 0.02 -factor $g\" # Define the excitation using the Tabas ground motion records # tag dir accel series args pattern UniformExcitation 2 1 - accel $ tabasFN pattern UniformExcitation 3 2 - accel $ tabasFP # ----------------------- # End of model generation # ----------------------- # ---------------------------- # Start of analysis generation # ---------------------------- # Create the convergence test # tol maxIter printFlag test EnergyIncr 1.0e-8 20 3 # Create the solution algorithm algorithm Newton # Create the system of equation storage and solver system SparseGeneral - piv # Create the constraint handler constraints Transformation # Create the time integration scheme # gamma beta integrator Newmark 0.5 0.25 # Create the DOF numberer numberer RCM # Create the transient analysis analysis Transient # -------------------------- # End of analysis generation # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- # Record DOF 1 and 2 displacements at nodes 9, 14, and 19 recorder Node - file node51 . out - time - node 9 14 19 - dof 1 2 disp # -------------------------- # End of recorder generation # -------------------------- # -------------------- # Perform the analysis # -------------------- # Analysis duration of 20 seconds # numSteps dt analyze 2000 0.01 The results consist of the file node.out, which contains a line for every time step. Each line contains the time and the horizontal and vertical displacements at the diaphragm retained nodes (9, 14 and 19) i.e. time Dx9 Dy9 Dx14 Dy14 Dx19 Dy19. The horizontal displacement time history of the first floor diaphragm node 9 is shown in figure [example4disp] . Notice the increase in period after about 10 seconds of earthquake excitation, when the large pulse in the ground motion propogates through the structure. The displacement profile over the three stories shows a soft-story mechanism has formed in the first floor columns. The numerical solution converges even though the drift is \\(\\approx 20 \\%\\) . The inclusion of P-Delta effects shows structural collapse under such large drifts.","title":"Three-Dimensional Rigid Frame\n"},{"location":"gallery/continuua/example_6/","text":"Simply Supported Beam In this example a simple problem in solid dynamics is considered. The structure is a simply supported beam modelled with two dimensional solid elements. Example6.1.tcl For two dimensional analysis, a typical solid element is defined as a volume in two dimensional space. Each node of the analysis has two displacement degrees of freedom. Thus the model is defined with \\(ndm := 2\\) and \\(ndf := 2\\) . pp For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4} are prescribed to define the two dimensional domain of the beam, which is of size \\(40\\times10\\) . Three possible quadrilateral elements can be used for the analysis. These may be created using the terms \u201cbbarQuad,\u201d \u201cenhancedQuad\u201d or \u201cquad.\u201d This is a plane strain problem. An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and two vertical nodal loads are used. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Ten static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic - ndm 2 - ndf 2 # create the material nDMaterial ElasticIsotropic 1 1000 0.25 6.75 # Define geometry # --------------- # define some parameters set Quad quad set Quad bbarQuad set Quad enhancedQuad if { $ Quad == \"enhancedQuad\" } { set eleArgs \"PlaneStrain2D 1\" } if { $ Quad == \"quad\" } { set eleArgs \"1 PlaneStrain2D 1\" } if { $ Quad == \"bbarQuad\" } { set eleArgs \"1\" } set nx 8 ; # NOTE: nx MUST BE EVEN FOR THIS EXAMPLE set ny 2 set bn [ expr $ nx + 1 ] set l1 [ expr $ nx / 2 + 1 ] set l2 [ expr $ l1 + $ ny * ( $ nx + 1 ) ] # now create the nodes and elements using the block2D command block2D $ nx $ ny 1 1 $ Quad $ eleArgs { 1 0 0 2 40 0 3 40 10 4 0 10 } # Single point constraints # node u1 u2 fix 1 1 1 fix $ bn 0 1 # Gravity loads pattern Plain 1 Linear { load $ l1 0.0 - 1.0 load $ l2 0.0 - 1.0 } # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-12 10 0 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 10 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ l1 - dof 2 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 # create the display recorder display SimplySupportedBaam 10 10 800 200 - wipe prp 20 5.0 100.0 vup 0 1 0 viewWindow - 30 30 - 10 10 display 10 0 5 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-12 10 0 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (50 sec) # numSteps dt analyze 100 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the bottom center of the beam. The time history is shown in figure [beamdisp] .","title":"Simply Supported Beam\n"},{"location":"gallery/continuua/example_7/","text":"Dynamic Shell Analysis In this example a simple problem in shell dynamics is considered. The structure is a curved hoop shell structure that looks like the roof of a Safeway. Example7.1.tcl For shell analysis, a typical shell element is defined as a surface in three dimensional space. Each node of a shell analysis has six degrees of freedom, three displacements and three rotations. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 6\\) . For this model, a mesh is generated using the \u201cblock2D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) and the number of nodes in the local y-direction of the block is \\(ny\\) . The block2D generation nodes {1,2,3,4, 5,7,9} are defined such that the structure is curved in three dimensional space. The OpenSees shell element is constructed using the command \u201cShellMITC4\u201d. An elastic membrane-plate material section model, appropriate for shell analysis, is constructed using the \u201cElasticMembranePlateSection\u201d command. In this case, the elastic modulus \\(E := 3.0e3\\) , Poisson\u2019s ratio \\(\\nu := 0.25\\) , the thickness \\(h := 1.175\\) and the mass density per unit volume \\(\\rho := 1.27\\) For initial gravity load analysis, a single load pattern with a linear time series and three vertical nodal loads are used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1, 0,1,1}. All degrees-of-freedom are fixed except rotation about the x-axis, which is free. The same boundary conditions are applied where the z-coordinate is \\(40.0\\) . A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(250\\) time increments with a time step \\(\\Delta t := 0.50\\) . # ---------------------------- # Start of model generation # ---------------------------- model basic - ndm 3 - ndf 6 # create the material section ElasticMembranePlateSection 1 3.0e3 0.25 1.175 1.27 # set some parameters for node and element generation set Plate ShellMITC4 set eleArgs \"1\" #these should both be even set nx 8 set ny 2 #loaded nodes set mid [ expr ( ( $ nx + 1 ) * ( $ ny + 1 ) + 1 ) / 2 ] set side1 [ expr ( $ nx + 2 ) / 2 ] set side2 [ expr ( $ nx + 1 ) * ( $ ny + 1 ) - $ side1 + 1 ] # generate the nodes and elements block2D $ nx $ ny 1 1 $ Plate $ eleArgs { 1 - 20 0 0 2 - 20 0 40 3 20 0 40 4 20 0 0 5 - 10 10 20 7 10 10 20 9 0 10 20 } # add some loads pattern Plain 1 Linear { load $ mid 0.0 - 0.5 0.0 0.0 0.0 0.0 load $ side1 0.0 - 0.25 0.0 0.0 0.0 0.0 load $ side2 0.0 - 0.25 0.0 0.0 0.0 0.0 } # define the boundary conditions # rotation free about x-axis (remember right-hand-rule) fixZ 0.0 1 1 1 0 1 1 fixZ 40.0 1 1 1 0 1 1 # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test EnergyIncr 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system SparseGeneral - piv #system ProfileSPD # Analysis for gravity load #analysis Transient analysis Static # Perform the gravity load analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ mid - dof 2 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 recorder display shellDynamics 10 10 600 600 - wipe prp - 100 20 30 vup 0 1 0 display 1 0 100 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain #integrator GeneralizedMidpoint 0.50 integrator Newmark 0.50 0.25 analysis Transient # Perform the transient analysis analyze 250 0.5 The results consist of the file Node.out, which contains a line for every time step. Each line contains the time and the vertical displacement at the upper center of the hoop structure. The time history is shown in figure [shelldisp] .","title":"Dynamic Shell Analysis\n"},{"location":"gallery/continuua/example_8/","text":"Cantilever Beam In this example a simple problem in solid dynamics is considered. The structure is a cantilever beam modelled with three dimensional solid elements. Example8.1.tcl For three dimensional analysis, a typical solid element is defined as a volume in three dimensional space. Each node of the analysis has three displacement degrees of freedom. Thus the model is defined with \\(ndm := 3\\) and \\(ndf := 3\\) . For this model, a mesh is generated using the \u201cblock3D\u201d command. The number of nodes in the local x-direction of the block is \\(nx\\) , the number of nodes in the local y-direction of the block is \\(ny\\) and the number of nodes in the local z-direction of the block is \\(nz\\) . The block3D generation nodes {1,2,3,4,5,6,7,8} are prescribed to define the three dimensional domain of the beam, which is of size \\(2\\times2\\times10\\) . Two possible brick elements can be used for the analysis. These may be created using the terms stdBrick or bbarBrick . An elastic isotropic material is used. For initial gravity load analysis, a single load pattern with a linear time series and a single nodal loads is used. Boundary conditions are applied using the fixZ command. In this case, all the nodes whose z-coordiate is \\(0.0\\) have the boundary condition {1,1,1} , fully fixed. A solution algorithm of type Newton is used for the problem. The solution algorithm uses a ConvergenceTest which tests convergence on the norm of the energy increment vector. Five static load steps are performed. Subsequent to the static analysis, the wipeAnalysis and remove loadPatern commands are used to remove the nodal loads and create a new analysis. The nodal displacements have not changed. However, with the external loads removed the structure is no longer in static equilibrium. The integrator for the dynamic analysis if of type GeneralizedMidpoint with \\(\\alpha := 0.5\\) . This choice is uconditionally stable and energy conserving for linear problems. Additionally, this integrator conserves linear and angular momentum for both linear and non-linear problems. The dynamic analysis is performed using \\(100\\) time increments with a time step \\(\\Delta t := 2.0\\) . # ---------------------------- # Start of model generation # ---------------------------- # Create ModelBuilder with 3 dimensions and 6 DOF/node model basic - ndm 3 - ndf 3 # create the material nDMaterial ElasticIsotropic 1 100 0.25 1.27 # Define geometry # --------------- # define some parameters set eleArgs \"1\" set element stdBrick #set element BbarBrick set nz 6 set nx 2 set ny 2 set nn [ expr ( $ nz + 1 ) * ( $ nx + 1 ) * ( $ ny + 1 ) ] # mesh generation block3D $ nx $ ny $ nz 1 1 $ element $ eleArgs { 1 - 1 - 1 0 2 1 - 1 0 3 1 1 0 4 - 1 1 0 5 - 1 - 1 10 6 1 - 1 10 7 1 1 10 8 - 1 1 10 } set load 0.10 # Constant point load pattern Plain 1 Linear { load $ nn $ load $ load 0.0 } # boundary conditions fixZ 0.0 1 1 1 # -------------------------------------------------------------------- # Start of static analysis (creation of the analysis & analysis itself) # -------------------------------------------------------------------- # Load control with variable load steps # init Jd min max integrator LoadControl 1.0 1 1.0 10.0 # Convergence test # tolerance maxIter displayCode test NormUnbalance 1.0e-10 20 1 # Solution algorithm algorithm Newton # DOF numberer numberer RCM # Cosntraint handler constraints Plain # System of equations solver system ProfileSPD # Analysis for gravity load analysis Static # Perform the analysis analyze 5 # -------------------------- # End of static analysis # -------------------------- # ---------------------------- # Start of recorder generation # ---------------------------- recorder Node - file Node . out - time - node $ nn - dof 1 disp recorder plot Node . out CenterNodeDisp 625 10 625 450 - columns 1 2 recorder display ShakingBeam 0 0 300 300 - wipe prp - 100 100 120.5 vup 0 1 0 display 1 0 1 # -------------------------- # End of recorder generation # -------------------------- # --------------------------------------- # Create and Perform the dynamic analysis # --------------------------------------- # Remove the static analysis & reset the time to 0.0 wipeAnalysis setTime 0.0 # Now remove the loads and let the beam vibrate remove loadPattern 1 # add some mass proportional damping rayleigh 0.01 0.0 0.0 0.0 # Create the transient analysis test EnergyIncr 1.0e-10 20 1 algorithm Newton numberer RCM constraints Plain integrator Newmark 0.5 0.25 analysis Transient # Perform the transient analysis (20 sec) # numSteps dt analyze 100 2.0 } The results consist of the file cantilever.out, which contains a line for every time step. Each line contains the time and the horizontal displacement at the upper right corner the beam. The time history is as plotted on the screen. figure [cantileverdisp] .","title":"Cantilever Beam\n"},{"location":"gallery/geotech/","text":"Geotechnical Examples","title":"Geotechnical Examples\n"},{"location":"gallery/geotech/02_StaticPile/","text":"Laterally-Loaded Pile Example prepared by: Christopher McGann and Pedro Arduino, University of Washington This article describes the OpenSees implementation of a simple laterally-loaded pile example. The problem is modeled as a beam on a nonlinear Winkler foundation (BNWF), utilizing displacement-based beam elements for the pile and nonlinear spring elements which represent the vertical and lateral response of the surrounding soil. This example considers a static analysis only. Provided with this article are the files needed to execute this analysis in OpenSees; the main input file, staticBNWFpile.tcl three procedures to define the soil constitutive behavior, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl a file to define the pile section behavior, elasticPileSection.tcl Download them all in a compressed file: staticBNWFanalysis.zip To run this example, the user must download each of the above files and place them in a single directory. Once this has been done, the user can then type \"source staticBNWFpile.tcl\" into the interpreter of the OpenSees.exe application to run the analysis. Representative results are presented in this article to verify the correct implementation of this example. Additionally, the pile response obtained from this analysis is compared to a similar analysis conducted using the commercial program LPile (http://www.ensoftinc.com) to provide verification the results of the OpenSees analysis. Model Description Fig 1. Schematic representation of the BNWF model. The BNWF model simulates the laterally-loaded pile problem using displacement-based beam elements to represent the pile and a series of nonlinear springs to represent the soil. The soil springs are generated using zero-length elements assigned separate uniaxial material objects in the lateral and vertical directions. An idealized schematic of the laterally-loaded pile model is provided in Fig. 1. The pile axis is oriented in the z-coordinate direction, and all of the nodes are initially located on the z-axis (x- and y- coordinates are zero). Node numbering for each set of nodes begins at the bottom of the pile. The model is created with three separate sets of nodes: fixed spring nodes (numbers 1-85 in example) slave spring nodes (numbers 101-185 in example) pile nodes (numbers 201-285 in example) Geometry and Mesh The geometry is rather simple in this example. There is only a single layer of cohesionless soil, and the groundwater table is assumed to be well below the tip of the pile. The pile geometry controls the meshing of the problem. The user can specify the length of the pile head (above the ground surface), L1, and the embedded pile length (below the ground surface), L2. The default values in staticBNWFpile.tcl are L1 = 1 m, and L2 = 20 m. The pile is also assigned a diameter of 1 m. This value is used in the soil constitutive modeling. The mesh is defined by the number of elements specified in the pile. The default value in this example is 84 elements (85 nodes). For the default pile geometry, this results in 80 elements over the embedded length and 4 elements above the ground surface. Note: The input file is only set up to handle up to 100 nodes. Modifications would need to be made to the node numbering scheme to accommodate a larger number of nodes. Spring Nodes The spring nodes are created with three dimensions and three translational degrees-of-freedom. The input file is set up to automatically generate the necessary spring nodes and elements based upon the input geometry (pile head length, $L1 , embedded length, $L2 , and number of pile elements, $nElePile ). Spring nodes are only created over the embedded length of pile. Since zero-length elements are used for the springs, the two sets of nodes share the same set of locations. One set of spring nodes, the fixed-nodes, are initially fixed in all three degrees-of-freedom. The other set of nodes, the slave nodes, are initially fixed in only two degrees-of-freedom, and are later given equal degrees-of-freedom with the pile nodes. Spring Constitutive Behavior The constitutive behavior of the springs is defined such that the springs oriented in the lateral direction represent p-y springs, and the vertically-oriented springs represent t-z and Q-z springs for the pile shaft and tip, respectively. Three procedures are used to properly define the p-y/t-z/Q-z behavior with depth, get_pyParam.tcl , get_tzParam.tcl , and get_qzParam.tcl Several input soil properties are necessary to define these springs: soil unit weight, $gamma soil internal friction angle, $phi soil shear modulus, $Gsoil The default values are set at $gamma = 17 kN/m 3 , $phi = 36 degrees, and $Gsoil = 150000 kPa. The procedure get_pyParam.tcl , which defines the p-y springs, has several options which must be selected. The first switch, $puSwitch, specifies the variation in ultimate lateral resistance with depth. The default, $puSwitch = 1, uses the recommendations of the American Petroleum Institute (API) (1993). The alternative method is that of Brinch Hansen (1961). The second switch, $kSwitch, specifies the variation in initial stiffness with depth. The default, $kSwitch = 1, specifies a linear variation of initial stiffness with depth (API 1993). The alternative uses a modified version of the API stiffness which varies parabolically with depth after Boulanger et al. (2003). The presence of groundwater can be accounted for in the initial stiffness using the third switch, $gwtSwitch. Default, $gwtSwitch = 1, is for no groundwater. The other procedures, get_tzParam.tcl and get_qzParam.tcl , have no input options in this example. The t-z springs have behavior defined using the work of Mosher (1984) and Kulhawy (1991). The Q-z behavior is based on the work of Meyerhof (1976), Vijayvergiya (1977), and Kulhawy and Mayne (1990). The p-y spring constitutive behavior is obtained using the PySimple1 uniaxial material object. The t-z and Q-z springs are defined using the TzSimple1 and QzSimple1 uniaxial materials, respectively. The main input file is set up to automatically generate the required spring material objects based upon the input geometry and soil properties. Spring Elements Zero-length elements are used for the soil springs using the element zeroLength . These elements connect the fixed and slave spring nodes. The the PySimple1 material objects are incorporated in the x-direction (direction of loading), while the TzSimple1 , and at the pile tip, the QzSimple1 , material objects are incorporated in the z-direction (vertical direction). Pile Nodes The pile nodes are created with three dimensions and six degrees-of-freedom (3 translational, 3 rotational). The input file is set up to automatically generate the necessary pile nodes and elements based upon the input geometry. A linear coordinate-transformation object is specified for the orientation of the pile in this example. With the exemption of the uppermost pile head node, the pile nodes are fixed against translation in the y-direction and rotations about the x- and z- axes. The pile head node, where the load is applied, is separated to allow the user to specify a free-head (no rotational fixity) or fixed-head (full rotational fixity) condition at the loading point. The pile nodes over the embedded length of the pile are use linked with the slave spring nodes using the equalDOF command. The pile nodes are the master nodes in this example. These two sets of nodes share equal degrees-of-freedom in the x- and z- translational directions only. Pile Constitutive Behavior and Elements In this example, the pile is given elastic behavior for simplicity. Instead of using the elasticBeamColumn element, this is done using an elastic section object in conjunction with the displacement-based beam element, dispBeamColumn . This was done to facilitate future incorporation of elastoplastic pile section behavior using fiber section models by the user. The properties of the elastic section for this example are defined in the file, elasticPileSection.tcl . The pile is defined with appropriately computed values for the cross-sectional area and the moments of inertia for its 1 m diameter, and is assigned a modulus of elasticity, E = 25000000, and shear modulus, G = 9615385. Recorders Several recorders are defined for this model. The displacements at the pile nodes in all three translational dof are recorded for use in extracting the displaced shape of the pile. The reaction forces in the p-y springs are recorded for use in visualizing the lateral soil response. The element forces in the pile elements are recorded in order to obtain shear and moment diagrams for the pile. The recorders are set up to only record values at 0.5 second increments of pseudo-time during the analysis to facilitate the use of smaller load steps. This is done with the variable $timeStep. A display recorder is included in the input file to allow the user to visualize the deformation of the pile in \"real time\" during the analysis. The parameters are set up for the orientation of the pile in this example. Loading This example considers a 3500 kN load applied in the positive x-direction at the head of the pile (uppermost pile node). This is accomplished in the model using a plain pattern with optional time-series parameters. The load increases linearly from 0 kN to 3500 kN over a 10 second increment of pseudo-time (between 10 and 20 seconds) and is then held constant after the loading period. Setting up the loading object in this manner allows for more control over the analysis. Analysis The analysis is conducted using the load-controlled integrator with a loading step of 0.05. This value is selected based on the 10 second interval specified in the loading object. 200 steps with a loading step of 0.05 will put the last step exactly at 10 seconds of pseudo-time. 201 steps are used in this example to make sure that the last recorded step is at the full loading magnitude. The variables $startT and $endT are used to print the cpu time needed to complete the analysis in the standard output or the OpenSees interpreter. The remaining analysis commands are well-documented in the OpenSees command manual. Representative Results Fig. 2 Lateral soil response after application of full lateral load. A user can verify their downloaded files by running the main input file, staticBNWFpile.tcl , in OpenSees and comparing the recorded results to some representative results included here. The simplest verification is to use the spring reaction forces recorded in the file reaction.out. A plot of the recorded spring reaction forces vs. depth in the final recorded pseudo-time step (20.05) should create something similar to that shown in Fig. 2. The response is negative from the ground surface to about 7.5 m deep, then transitions to positive until about 13 m deep, has a second smaller negative section, and then is nearly zero near the tip of the pile. This verification plot can be made fairly simply using spreadsheet software. For those who prefer Matlab (http://www.mathworks.com/), the following lines will extract the desired information when pasted into an m-file. % create depth vector depth = linspace(-20,1,85); % load data react = load('reaction.out'); % remove pseudo-time information react(:,1) = []; % create plotting variable (divide by tributary area of pile to get force/length) reactPlot = react(end,:)/0.25; plot(reactPlot,depth) The shear and moment diagram plots in the following section can also be used for verification purposes. Comparison of OpenSees Results with LPile Fig. 3 Comparison of OpenSees and LPile analyses for free-head case. Fig. 4 Comparison of OpenSees and LPile analyses for fixed-head case. The commercial pile analysis program LPile (http://www.ensoftinc.com) is used to verify the results obtained using the OpenSees laterally-loaded pile model. The LPile analysis used the same geometric and constitutive parameters defined in the OpenSees analysis, and two cases were considered: A free-head case where there is no rotational fixity about the y-axis at the pile head A fixed-head case where full rotational fixity is enforced at the pile head. The two analysis methods are compared via the recorded pile and soil responses. Figs. 3 and 4 present these comparisons for the free-head and fixed-head cases, respectively. Shown in these figures are the shear and moment diagrams, displaced pile shapes, and the lateral soil response recorded from each analysis. As shown, the LPile and OpenSees results are fairly similar, especially for the free-head case. The main reason for the differences shown in Figs. 3 and 4 is that the p-y curves used in LPile are not the same as those used in the OpenSees analysis. The LPile curves are defined using the method of Reese et al. (1974), while the backbone of the p-y curves for the PySimple1 uniaxial material approximate the API (1993) recommendations. These two sets of curves are similar, and in fact have identical initial and ultimate responses, however, they vary in form over intermediate displacements. This is shown in Fig. 5, which plots the actual p-y response obtained in the OpenSees simulation alongside the p-y curves used by LPile for several depths. As shown, the hyperbolic tangent curves recommended by the API do not match those used by LPile, especially for displacements between approximately 0.001 and 0.037 m. The force returned by the PySimple1 material object for displacements in this range will therefore be greater than corresponding forces used by LPile. This is confirmed by the soil response comparison plots in Figs. 3 and 4. Where the pile displacements are large, the LPile and OpenSees soil reactions are nearly identical, but as the displacements become smaller with increasing depth, the recorded soil reactions begin to differ. This difference in lateral soil response is the main reason behind the small variability observed in the recorded shear and moment diagrams and displaced shapes. [ Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.](pyComp.png \u201d Fig. 5 Comparison of p-y curves for LPile and OpenSees analyses.\u201d) Overall, the agreement between the OpenSees and LPile analyses verifies that the BNWF model implemented in OpenSees is capable of returning sensible results for laterally-loaded pile simulations. There are differences between the results, however, these are relatively minor. The OpenSees simulation predicts maximum pile shear, moment, and deflection demands which are similar to those obtained from LPile, and the discrepancies are attributable to known differences between the two analysis methods. References 1. American Petroleum Institute (API) (1987). Recommended Practice for Planning, Designing and Constructing Fixed Offshore Platforms. API Recommended Practice 2A(RP-2A), Washington D.C, 17th edition. 2. Brinch Hansen, J. (1961). \u201cThe ultimate resistance of rigid piles against transversal forces.\u201d Bulletin No. 12, Geoteknisk Institute, Copenhagen, 59. 3. Boulanger, R. W., Kutter, B. L., Brandenberg, S. J., Singh, P., and Chang, D. (2003). Pile Foundations in liquefied and laterally spreading ground during earthquakes: Centrifuge experiments and analyses. Center for Geotechnical Modeling, University of California at Davis, Davis, CA. Rep. UCD/CGM-03/01. 4. Kulhawy, F.H. (1991). \"Drilled shaft foundations.\" Foundation engineering handbook, 2nd Ed., Chap 14, H.-Y. Fang ed., Van Nostrand Reinhold, New York. 5. Kulhawy, F.H. and Mayne, P.W. (1990). Manual on Estimating Soil Properties for Foundation Design. Electrical Power Research Institute. EPRI EL-6800, Project 1493-6 Final Report. 6. Meyerhof G.G. (1976). \"Bearing capacity and settlement of pile foundations.\" J. Geotech. Eng. Div., ASCE, 102(3), 195-228. 7. Mosher, R.L. (1984). \u201cLoad transfer criteria for numerical analysis of axial loaded piles in sand.\u201d U.S. Army Engineering and Waterways Experimental Station, Automatic Data Processing Center, Vicksburg, Miss. 8. Reese, L.C. and Van Impe, W.F. (2001), Single Piles and Pile Groups Under Lateral Loading. A.A. Balkema, Rotterdam, Netherlands. 9. Vijayvergiya, V.N. (1977). \u201cLoad-movement characteristics of piles.\u201d Proc., Ports 77 Conf., ASCE, New York.","title":"Laterally-Loaded Pile"},{"location":"gallery/sections/section_building/","text":"Damage Monitoring Tools The damage monitoring toolkit consists the files SectionLib.py and get_fibers.py , and the Python package opensees . Currently these files have to be copied to the location from where they are executed, and the opensees package should be installed by running the following command: pip install opensees The toolkit can be used from either Tcl, Python, or directly at the command line. The following example shows how the get_fibers.py module may be invoked from Tcl: proc py { args } { eval \"[exec python.exe {*}$args]\" } foreach ds { dsr1 dsr2 dsr3 } { py get_fibers.py model.json record- $ { ds } .txt - e 4020 ,3020 - d 60 - s $ds } Note: This currently requires the get_fibers.py file to be visible from the current working directory of the Tcl interpreter. 1) Geometry building {#1-geometry-building} Damage regions are built from the same plane geometry primitives that are offered by OpenSees (e.g. the patch and layer commands). Additionally, the function section from the module opensees.render.mpl can be used to visualize components. from opensees import patch , layer , section import opensees.render.mpl as render s = section . FiberSection ( areas = [ patch . circ ( extRad = 20 , intRad = 18 ), layer . line ( vertices = [[ - 14 , - 10 ], [ 14 , 10 ]]), patch . rect ( vertices = [[ - 15 , - 10 ], [ 15 , 10 ]]) ] ) render . section ( s ); Print section properties: print ( s . area ) print ( s . ixc ) print ( s . iyc ) # print(s.ixc) 838.7610416728243 63215.74854278119 88215.74854278119 Additionally, the SectionLib module provides convenient wrappers for building complex sections. The Octagon function from this library can be called in 3 ways: ConfinedPolygon(radius) Constructs an octagon. PolygonRing(extRad, intRad, n) Constructs an n -gon annulus from opensees.section import ConfinedPolygon render . section ( section . ConfiningPolygon ( 8 , 20 , 15 , s = 8 )); render . section ( section . ConfinedPolygon ( 8 , 20 , s = 8 )); render . section ( section . PolygonRing ( 8 , 20 , 18 )); render . section ( section . ConfinedPolygon ( 8 , 20 , 20 )); 2) Define damage state regions; the get_fibers module {#2-define-damage-state-regions-the-get_fibers-module} from fiberRecorders import iter_elem_fibers , damage_states , read_sect_xml The get_fibers module provides the helper function iter_elem_fibers for iterating over a filtered collection of fibers. Fibers are filtered out by supplying a damage state dictionary with a required \"regions\" field, and optional \"material\" field. from opensees.units.english import ft , inch Dcol = 7 * ft Rcol = Dcol / 2 cover = 2 * inch DS = damage_states ( Dcol ) 3) Iterating over fibers {#3-iterating-over-fibers} import json import numpy as np model_file = \"modelDetails.json\" elements = [ 4010 ] import json with open ( model_file , \"r\" ) as f : model = json . load ( f ) If the third argument to iter_elem_fibers is omitted, all fibers are returned (Underscores are used in the following cell to name unused variables). all_fibers = [ # { element | Domain and predicate } f [ \"coord\" ] for _ , __ , f in iter_elem_fibers ( model , elements ) ] ds1_fibers = np . array ([ f [ \"coord\" ] for e , s , f in iter_elem_fibers ( model , elements , filt = DS [ \"dsr1\" ], sections = [ 0 ]) ]) ds2_fibers = np . array ([ f [ \"coord\" ] for e , s , f in iter_elem_fibers ( model , elements , filt = DS [ \"dsr2\" ], sections = [ 0 ]) ]) ds3_fibers = np . array ([ f [ \"coord\" ] for e , s , f in iter_elem_fibers ( model , elements , filt = DS [ \"dsr3\" ], sections = [ 0 ]) ]) ds4_fibers = np . array ([ f [ \"coord\" ] for e , s , f in iter_elem_fibers ( model , elements , filt = DS [ \"dsr3\" ], sections = [ 0 ]) ]) 3) Visualizing {#3-visualizing} sect = section . ConfinedPolygon ( 8 , Dcol / 2 ) ax = render . section ( sect ) render . section ( DS [ \"dsr1\" ][ \"regions\" ][ 0 ], facecolor = \"b\" , ax = ax ) render . section ( DS [ \"dsr2\" ][ \"regions\" ][ 0 ], facecolor = \"pink\" , ax = ax ) render . section ( DS [ \"dsr3\" ][ \"regions\" ][ 0 ], facecolor = \"y\" , ax = ax ) render . section ( DS [ \"dsr4\" ][ \"regions\" ][ 0 ], facecolor = \"g\" , ax = ax ); render . section ( DS [ \"dsr5\" ][ \"regions\" ][ 0 ], facecolor = \"r\" , ax = ax ); # ax.set_xlim([0, Rcol+1]) # ax.set_ylim([-1, Rcol+1]) # Create grid of points import numpy as np # Create plot axis and add sections to it ax = render . section ( sect ) render . section ( DS [ \"dsr1\" ][ \"regions\" ][ 0 ], facecolor = \"b\" , ax = ax ) render . section ( DS [ \"dsr2\" ][ \"regions\" ][ 0 ], facecolor = \"pink\" , ax = ax ) render . section ( DS [ \"dsr3\" ][ \"regions\" ][ 0 ], facecolor = \"y\" , ax = ax ) render . section ( DS [ \"dsr4\" ][ \"regions\" ][ 0 ], facecolor = \"g\" , ax = ax ); render . section ( DS [ \"dsr5\" ][ \"regions\" ][ 0 ], facecolor = \"r\" , ax = ax ); # add filtered fibers to plot ax . scatter ( * list ( zip ( * all_fibers )), color = \"grey\" , alpha = 0.3 , s = 0.5 ); ax . scatter ( * list ( zip ( * ds1_fibers )), marker = \".\" , color = \"blue\" ) ax . scatter ( * list ( zip ( * ds2_fibers )), color = \"r\" , marker = \"o\" ) #, s=0.8) ax . scatter ( * list ( zip ( * ds3_fibers )), color = \"r\" , marker = \"x\" ) #, s=1) ax . scatter ( * list ( zip ( * ds4_fibers )), color = \"r\" , marker = \"+\" ) #, s=1) # Set plot limits ax . set_xlim ([ 0 , Rcol + 1 ]) ax . set_ylim ([ - 1 , Rcol + 1 ]) ax . axis ( \"on\" ); ax = render . section ( sect ) ax . scatter ( * list ( zip ( * all_fibers )), color = \"red\" , s = 0.5 ); ax = render . section ( sect ) ax . scatter ( * np . array ([ f . coord for f in sect . fibers if hasattr ( f , \"coord\" )]) . T , s = 0.1 ); <matplotlib.collections.PathCollection at 0x7f4db59dfeb0> def fiber_strain ( recorder_data , el , s , f , t = None ): if t is not None : eps = recorder_data [ str ( el )][ str ( s )][ \"eps\" ][ t ] kz = recorder_data [ str ( el )][ str ( s )][ \"kappaZ\" ][ t ] ky = recorder_data [ str ( el )][ str ( s )][ \"kappaY\" ][ t ] else : eps = recorder_data [ str ( el )][ str ( s )][ \"eps\" ] kz = recorder_data [ str ( el )][ str ( s )][ \"kappaZ\" ] ky = recorder_data [ str ( el )][ str ( s )][ \"kappaY\" ] return eps - kz * f [ \"coord\" ][ 1 ] + ky * f [ \"coord\" ][ 0 ] import os from pathlib import Path userHome = Path ( os . path . expanduser ( \"~\" )) dataDir = userHome / \"brace\" / \"Caltrans\" / \"Caltrans.Hayward\" / \"Procedures\" / \"datahwd12.1\" xmlName = dataDir / \"SectionDeformationHist.xml\" # xmlNameFib = dataDir/ \"DynResponse\"/ \"LS7Top1.xml\" jsonName = dataDir / \"modelDetails.json\" # recorder_data = read_sect_xml(xmlName) # for e,s,f in iter_elem_fibers(model, [4020]): # f.update({\"strain\": fiber_strain(recorder_data, \"4020\", \"4\", f)}) regions = damage_states ( 84.0 ) elems = [ 4020 ] # ds_strains = { # # X,Y,epsRaw # ds: tuple(zip(*( # ( # fib[\"coord\"][0], # fib[\"coord\"][1], # fiber_strain(recorder_data, elem[\"name\"], sec, fib) # ) for elem, sec, fib in iter_elem_fibers(model, elems, [3], filt=regions[ds]) # ))) # for ds in [\"dsr1\", \"dsr2\"] # } # regions = damage_states(84.0) # elems = [4020] # X,Y,epsRaw = tuple(zip(*( # ( # fib[\"coord\"][0], # fib[\"coord\"][1], # fiber_strain(recorder_data, elem[\"name\"], sec, fib) # ) for ds in [\"dsr1\", \"dsr2\"] for elem, sec, fib in iter_elem_fibers(model, elems, [3], filt=regions[ds]) # ))) # X,Y,epsRaw = ds_strains[\"dsr1\"] # len(X) == len(Y) == len(epsRaw) --------------------------------------------------------------------------- NameError Traceback (most recent call last) /tmp/ipykernel_13359/2960483337 . py in < module > ---- > 1 len(X) == len(Y) == len(epsRaw) NameError: name 'X' is not defined i = 3 t = 5 eps = np . array ([ e . T for e in epsRaw ]) eps [ i , t ]","title":"Damage Monitoring Tools\n"},{"location":"gallery/sections/section_limits/","text":"Elastic Limits Section Eccentricity # %matplotlib widget import numpy as np from section_limits import * import matplotlib.pyplot as plt plt . style . use ( \"typewriter\" ) from itertools import product from interpolate import LagrangeQ4 def meshq4 ( sect , quad , interp = None ): interp = interp or LagrangeQ4 () patches = list ( sect . patches ) if isinstance ( quad , dict ): quad = [ quad ] * len ( patches ) loc , wght = zip ( * ( quad_points ( ** q ) for q in quad )) x , y = zip ( * ( interp ( r , s ) @p . vertices for l , w , p in zip ( loc , wght , patches ) for r , s in product ( l , l ) )) da = np . fromiter ( ( dx * dy * p . area for p , w in zip ( patches , wght ) for dx , dy in product ( w , w )), float , len ( x ) ) / 4 y , x , da = map ( list , zip ( * sorted ( zip ( y , x , da )))) return dict ( x = x , y = y , da = da ) def rotate ( mesh , angle ): cs , sn = np . cos ( angle ), np . sin ( angle ) R = np . array ([[ cs , - sn ],[ sn , cs ]]) x , y = R @np . array ([ mesh [ \"x\" ], mesh [ \"y\" ]]) y , x , da = map ( list , zip ( * sorted ( zip ( y , x , mesh [ \"da\" ])))) return dict ( x = x , y = y , da = da ) Create section geometry import opensees.render.mpl as render from opensees import patch , section , layer , uniaxial m = uniaxial . ElasticPP () # sect = section.FiberSection(areas=[ # patch.rect(vertices=[[-8, 0],[-4, 16]]), # patch.rect(vertices=[[ 4, 0],[ 8, 16]]), # patch.rect(vertices=[[-4, 12],[ 4, 16]]) # ]) sect = section . FiberSection ( areas = [ patch . rect ( vertices = [[ - 8 , 6 ],[ 8 , 8 ]]), patch . rect ( vertices = [[ - 1 , - 6 ],[ 1 , 6 ]]), patch . rect ( vertices = [[ - 8 , - 8 ],[ 8 , - 6 ]]) ]) Create quadrature discretization rule = \"gauss-radau\" mesh = meshq4 ( sect , { 'n' : 10 , 'rule' : rule }) # mesh plt . subplots ()[ 1 ] . scatter ( * mesh . values ()) plt . show () import matplotlib.pyplot as plt class LimitAnalysis : def __init__ ( self , sect , mesh = None ): self . sect = sect self . mesh = mesh self . _mesh_dirty = False try : bounds = mesh [ \"bounds\" ] except : bounds = min ( mesh [ \"x\" ]), min ( mesh [ \"y\" ]), max ( mesh [ \"x\" ]), max ( mesh [ \"y\" ]) self . d = bounds [ 3 ] - bounds [ 1 ] self . bounds = bounds self . yield_prof = None self . plast_prof = None @staticmethod def plastic_profile ( nip , ip ): pass def plot_plast ( self , ax , nip , ip = 1 ): d = self . d x , y = plastic_profile ( nip , ip ) # [a,_,b,c,__] = x # f = [a]*(nip-ip//2) + [b] + [c]*(nip//2-ip//2) ax . fill_betweenx ( y * d , x , [ 0 ] * 4 , alpha = 0.2 , color = \"b\" ) if self . yield_prof is None : self . plast_point = None # else: # self.plast_prof.set_xdata(x) # self.plast_prof.set_ydata(y) return x , y def plot_yield ( self , ax , phi , dy ): d = self . d f1 , f2 , NM = yield_point ( self . sect , phi , dy ) ax . fill_betweenx ([ 0 , d ], [ f2 , f1 ], [ 0 , 0 ], alpha = 0.2 , color = \"red\" ) if self . yield_prof is None : self . yield_prof = ax . plot ([ f2 , f1 ], [ 0 , d ], \"r\" )[ 0 ] else : self . yield_prof . set_xdata ([ f2 , f1 ]) return NM def plot ( self , phi = 0.3 , ip = 3 , fy = 1.0 ): sect , mesh , d = self . sect , self . mesh , self . d nip = len ( mesh [ \"y\" ]) ax = [ None , None , None ] fig = plt . figure () grid = fig . add_gridspec ( nrows = 1 , ncols = 3 , hspace = 0 , wspace = 0 , width_ratios = [ 6 , 2 , 4 ], height_ratios = [ 6 ]) ax [ 0 ] = fig . add_subplot ( grid [ 0 , 0 ]) ax [ 1 ] = fig . add_subplot ( grid [ 0 , 1 ]) #, sharey = ax[0]) ax [ 2 ] = fig . add_subplot ( grid [ 0 , 2 ]) # SECTION GEOMETRY ax [ 0 ] . set_autoscale_on ( True ) render . section ( sect , ax = ax [ 0 ], fix_axes = False ) yc = sect . centroid [ 1 ] ax [ 0 ] . scatter ( mesh [ \"x\" ], mesh [ \"y\" ] + yc , marker = \".\" , color = \"b\" , alpha = 0.5 , s = 0.3 ) ax [ 0 ] . set_title ( \"Geometry\" ) ax [ 0 ] . set_xlabel ( \"$z$\" ) ax [ 0 ] . set_ylabel ( \"$y$\" ) # STRAIN PROFILE f , _ = self . plot_plast ( ax [ 1 ], nip , ip = 1 ) NM = self . plot_yield ( ax [ 1 ], phi , 0.0 ) ax [ 1 ] . set_xlabel ( r \"$\\frac{\\sigma} {f_y} $\" ) ax [ 1 ] . set_title ( \"Stress\" ) ax [ 1 ] . set_yticks ([], []) # SURFACE PLOTS # PP = self.mesh[\"Qm\"]@f self . point = ax [ 2 ] . scatter ( NM [ 1 ], NM [ 0 ], marker = \"x\" , color = \"r\" ) # self.plast_point = ax[2].scatter(PP[1], PP[0], marker=\"o\", color=\"k\") ax [ 2 ] . plot ( * elastic_limit ( sect , self . bounds ), \"r\" ); ax [ 2 ] . plot ( * plastic_limit ( sect , ** mesh , norm = False ), \"b\" ) ax [ 2 ] . yaxis . tick_right () ax [ 2 ] . yaxis . set_label_position ( \"right\" ) ax [ 2 ] . set_xlabel ( \"M\" ) ax [ 2 ] . set_ylabel ( \"N\" ) ax [ 2 ] . axvline ( 0.0 ) ax [ 2 ] . axhline ( 0.0 ) ax [ 2 ] . grid ( \"on\" ) def update ( yref = 4.0 , phi = ( 0. , 1 , 0.05 ), ip = ( 0 , 2 * nip , 1 )): ax [ 1 ] . collections . clear () YP = self . plot_yield ( ax [ 1 ], phi , 0.0 ) f , y = self . plot_plast ( ax [ 1 ], nip , ip ) # PP = self.mesh[\"Qm\"]@f self . point . set_offsets ([ YP [ 1 ], YP [ 0 ]]) # self.plast_point.set_offsets([PP[1], PP[0]]) fig . canvas . draw_idle () return update from ipywidgets import interact # plt.style.use(\"typewriter\") # interact(Anim(sect,mesh).plot()); LimitAnalysis ( sect , rotate ( mesh , np . pi / 4 )) . plot (); elastic_limit(section, bounds, y_ref)->[m,n] Computes the four points of the elastic limit surface for a given section about a particular reference point. plastic_limit(mesh)->[m,n] Computes the plastic limit surface from a given section mesh. Other yield_profile plastic_profile(n,i)->[f,y]","title":"Elastic Limits\n"},{"location":"gallery/sections/MomentCurvature/","text":"Moment-Curvature (Concrete) This next example covers the moment-curvature analysis of a reinforced concrete section. The zero-length element with a fiber discretization of the cross section is used in the model. In addition, Tcl language features such as variable and command substitution, expression evaluation, and procedures are demonstrated. Example 2.1 In this example, a moment-curvature analysis of the fiber section is undertaken. Figure [rcsection4] shows the fiber discretization for the section. Example2.1.tcl MomentCurvature.tcl The model consists of two nodes and a ZeroLengthSection element. A depiction of the element geometry is shown in figure [zerolength] . The drawing on the left of figure [zerolength] shows an edge view of the element where the local z-axis, as seen on the right side of the figure and in figure [rcsection0] , is coming out of the page. Node 1 is completely restrained, while the applied loads act on node 2. A compressive axial load, P, of 180 kips is applied to the section during the moment-curvature analysis. For the zero length element, a section discretized by concrete and steel is created to represent the resultant behavior. UniaxialMaterial objects are created to define the fiber stress-strain relationships: confined concrete in the column core, unconfined concrete in the column cover, and reinforcing steel. The dimensions of the fiber section are shown in figure [rcsection0] . The section depth is 24 inches, the width is 15 inches, and there are 1.5 inches of cover around the entire section. Strong axis bending is about the section z-axis. In fact, the section z-axis is the strong axis of bending for all fiber sections in planar problems. The section is separated into confined and unconfined concrete regions, for which separate fiber discretizations will be generated. Reinforcing steel bars will be placed around the boundary of the confined and unconfined regions. The fiber discretization for the section is shown in figure [rcsection4] . ::: {.center} ::: The section analysis is performed by the Tcl procedure MomentCurvature defined in the file MomentCurvature.tcl. The arguments to the procedure are the tag of the section to be analyzed, the axial load applied to the section, the maximum curvature, and the number of displacement increments to reach the maximum curvature. The output for the moment-curvature analysis will be the section forces and deformations, stored in the file section1.out. In addition, an estimate of the section yield curvature is printed to the screen. In the script below variables, are set and can then be used with the syntax of $variable . Expressions can be evaluated, although the Tcl syntax at first appears cumbersome. An expression is given by an expr command enclosed in square brackets [] \u2019s. Typically, the result of an expression is then set to another variable. A simple example to add 2.0 to a parameter is shown below: set v 3.0 set sum [expr $v + 2.0 ] puts $sum ; # print the sum Comments with # can appear on the same line as a command, but then the command must be terminated with a semi-colon. # OpenSees Example 2.1 # OpenSees Primer # # Units: kips, in, sec # Define model builder # -------------------- model BasicBuilder - ndm 2 - ndf 3 # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial Concrete01 1 - 6.0 - 0.004 - 5.0 - 0.014 # Cover concrete (unconfined) uniaxialMaterial Concrete01 2 - 5.0 - 0.002 0.0 - 0.006 # STEEL # Reinforcing steel set fy 60.0 ; # Yield stress set E 30000.0 ; # Young's modulus # tag fy E0 b uniaxialMaterial Steel01 3 $ fy $ E 0.01 # Define cross-section for nonlinear columns # ------------------------------------------ # set some parameters set colWidth 15 set colDepth 24 set cover 1.5 set As 0.60 ; # area of no. 7 bars # some variables derived from the parameters set y1 [ expr $ colDepth / 2.0 ] set z1 [ expr $ colWidth / 2.0 ] section Fiber 1 { # Create the concrete core fibers patch rect 1 10 1 [ expr $ cover -$ y1 ] [ expr $ cover -$ z1 ] [ expr $ y1 -$ cover ] [ expr $ z1 -$ cover ] # Create the concrete cover fibers (top, bottom, left, right) patch rect 2 10 1 [ expr -$ y1 ] [ expr $ z1 -$ cover ] $ y1 $ z1 patch rect 2 10 1 [ expr -$ y1 ] [ expr -$ z1 ] $ y1 [ expr $ cover -$ z1 ] patch rect 2 2 1 [ expr -$ y1 ] [ expr $ cover -$ z1 ] [ expr $ cover -$ y1 ] [ expr $ z1 -$ cover ] patch rect 2 2 1 [ expr $ y1 -$ cover ] [ expr $ cover -$ z1 ] $ y1 [ expr $ z1 -$ cover ] # Create the reinforcing fibers (left, middle, right) layer straight 3 3 $ As [ expr $ y1 -$ cover ] [ expr $ z1 -$ cover ] [ expr $ y1 -$ cover ] [ expr $ cover -$ z1 ] layer straight 3 2 $ As 0.0 [ expr $ z1 -$ cover ] 0.0 [ expr $ cover -$ z1 ] layer straight 3 3 $ As [ expr $ cover -$ y1 ] [ expr $ z1 -$ cover ] [ expr $ cover -$ y1 ] [ expr $ cover -$ z1 ] } # Estimate yield curvature # (Assuming no axial load and only top and bottom steel) set d [ expr $ colDepth -$ cover ] ; # d -- from cover to rebar set epsy [ expr $ fy /$ E ] ; # steel yield strain set Ky [ expr $ epsy / ( 0.7 *$ d )] # Print estimate to standard output puts \"Estimated yield curvature: $Ky\" # Set axial load set P - 180 set mu 15 ; # Target ductility for analysis set numIncr 100 ; # Number of analysis increments # Call the section analysis procedure source MomentCurvature . tcl MomentCurvature 1 $ P [ expr $ Ky *$ mu ] $ numIncr The Tcl procedure to perform the moment-curvature analysis follows. In this procedure, the nodes are defined to be at the same geometric location and the ZeroLengthSection element is used. A single load step is performed for the axial load, then the integrator is changed to DisplacementControl to impose nodal displacements, which map directly to section deformations. A reference moment of 1.0 is defined in a Linear time series. For this reference moment, the DisplacementControl integrator will determine the load factor needed to apply the imposed displacement. A node recorder is defined to track the moment-curvature results. The load factor is the moment, and the nodal rotation is in fact the curvature of the element with zero thickness. # Arguments # secTag -- tag identifying section to be analyzed # axialLoad -- axial load applied to section (negative is compression) # maxK -- maximum curvature reached during analysis # numIncr -- number of increments used to reach maxK (default 100) # # Sets up a recorder which writes moment-curvature results to file # section$secTag.out ... the moment is in column 1, and curvature in column 2 proc MomentCurvature { secTag axialLoad maxK { numIncr 100 } } { # Define two nodes at (0,0) node 1 0.0 0.0 node 2 0.0 0.0 # Fix all degrees of freedom except axial and bending at node 2 fix 1 1 1 1 fix 2 0 1 0 # Define element # tag ndI ndJ secTag element zeroLengthSection 1 1 2 $ secTag # Create recorder recorder Node - file section $ secTag . out - time - node 2 - dof 3 disp # Define constant axial load pattern Plain 1 \"Constant\" { load 2 $ axialLoad 0.0 0.0 } # Define analysis parameters integrator LoadControl 0 1 0 0 system SparseGeneral - piv ; test NormUnbalance 1.0e-9 10 numberer Plain constraints Plain algorithm Newton analysis Static # Do one analysis for constant axial load analyze 1 # Define reference moment pattern Plain 2 \"Linear\" { load 2 0.0 0.0 1.0 } # Compute curvature increment set dK [ expr $ maxK /$ numIncr ] # Use displacement control at node 2 for section analysis integrator DisplacementControl 2 3 $ dK 1 $ dK $ dK # Do the section analysis analyze $ numIncr } Estimated yield curvature : 0.000126984126984 The file section1.out contains for each committed state a line with the load factor and the rotation at node 3. This can be used to plot the moment-curvature relationship as shown in figure [momcurv] .","title":"Moment-Curvature (Concrete)"},{"location":"gallery/sections/example_9/","text":"Section Building For the case of the uniaxial section, moment-curvature and axial force-deformation curves are defined independently, and numerically. For the case of the fiber sections (steel and RC), uniaxial materials are defined numerically (stress-strain relationship) and are combined into a fiber section where moment-curvature and axial force-deformation characteristics and their interaction are calculated computationally. 2D vs. 3D While this distinction does not affect the section definition itself, it affects the degree-of-freedom associated with moment and curvature in the subsequent analysis. There are two differences between the two models: The space defined with the model command (Defining the model builder, ndm=#dimension ndf=#dofs ) In the 3D model, torsional stiffness needs to be aggregated to the section. Uniaxial Section Notes Flexure and axial behavior are uncoupled in this type of section Fiber Section: AISC Standard W Section Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Unconfined Concrete Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Symmetric Section, Confined Concrete Core Notes Coupled biaxial flexure and axial behavior Fiber Section: Reinforced Concrete Section \u2013 Rectangular Section Notes Coupled biaxial flexure and axial behavior generic rectangular section Fiber Section: Reinforced Concrete Section \u2013 Circular Section, Confined Core Notes Coupled biaxial flexure and axial behavior generic circular section Fiber Section: Reinforced Concrete Hollow Section \u2013 Symmetric Section, Confined Concrete Notes Coupled biaxial flexure and axial behavior Moment-Curvature Analysis This example introduces the moment-curvature procedures for sections in 2D or 3D space, as built in the previous section. (the only difference between them is the degree-of-freedom corresponding to curvature). The moment-curvature analysis of a section is by creating a zero-length rotational-spring element. This section is subjected to a user-defined constant axial load and to a linearly-increasing moment to a user-defined maximum curvature. 2D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature2D.tcl MomentCurvature2D.tcl Notes 3D Moment-Curvature Analysis Files Ex9.analyze.MomentCurvature3D.tcl MomentCurvature3D.tcl Run The model and analysis combinations for this example are numerous. The following are an small subset, for demonstration purposes: To run Uniaxial-Section Model, 2D puts \" --------------------------------- 2D Model ---------------\" puts \" a. Uniaxial Section\" source Ex9a.build.UniaxialSection2D.tcl source Ex9.analyze.MomentCurvature2D.tcl To run RC Section: Rectangular, Confined, Symmetric Model, 3D puts \" --------------------------------- 3D Model ---------------\" puts \" d. RC Section: Rectangular, Confined, Symmetric\" source Ex9d.build.RCSection.RectConfinedSymm3D.tcl source Ex9.analyze.MomentCurvature3D.tcl","title":"Section Building\n"},{"location":"guides/01_install/","text":"Installing OpenSeesRT is distributed primarily as a Python package. For those familiar with Python, you can just run pip install opensees New to Python If you are new to Python, a great way to get started is to install Anaconda.","title":"Installing\n"},{"location":"guides/01_starting/","text":"Getting Started A simulation with opensees is generally configured in the following steps: Modeling : This consists of defining a collection of mathematical abstractions and their relationships with the objective of representing some phenomenon. This generally includes creating Element , Node , LoadPattern and Constraint objects that define the model. Analysis : Once a model is defined, the next step is to create an Analysis. The following are some common analysis routines: Static Analysis Load or displacement controlled Spectral Decomposition Transient Direct Integration Transient Modal Integration These routines are configured and refined in terms of analysis abstractions which generally may include an Integrator , SolutionAlgorithm , and ConstraintHandler strategy. Post-processing : Once the model and analysis have been defined, the user has the option of specifying what is to be monitored during the analysis. This, for example, could be the displacement history at a node or internal state of an element in a transient analysis or the entire state of the model at each step in the solution procedure. Several Recorder objects are created to store what the user wants to examine. Runtime and Numerics : When working on advanced problems, fine-grained control over details such as the analysis runtime, parallelization, and numeric strategies becomes important. Numerics : when the computational cost of an analysis becomes prohibitive, selecting the right numeric strategy can be important. Refinements typically consist of choosing an appropriate linear or eigenvalue solver which appropriatly accounts for the structure of a linear system. Parallelization may also be considered.","title":"Getting Started\n"},{"location":"guides/02_runtime/","text":"Runtime record recorder printModel POST render . elastica ( model , displ ): ... MODLEING (MOVE TO LIBRARY?) remove setElementRayleighDampingFactors modalDamping ANALYSIS? def eig ( model , number , ** runtime ) -> ( freq , displ ): ... def rha ( model , pattern , ** runtime ) -> (): ... def rt . incr ( self , model , pattern , force | displ =< float > ) sdfResponse InitialStateAnalysis systemSize getLoadFactor testIter testNorm numFact numIter - loadConst ? setNumthread getNumthread Runtime [ getTime ] setTime setNodeCoord setNodeDisp setNodeVel setNodeAccel reactions setPrecision updateElementDomain updateMaterialStage reset wipe wipeAnalysis Utilities convertBinaryToText convertTextToBinary stripXML restore save database sectionForce sectionDeformation sectionStiffness sectionFlexibility sectionLocation sectionWeight getEleTags eleDynamicalForce eleForce eleNodes eleResponse basicDeformation basicForce basicStiffness getNodeTags nodeDisp nodeAccel nodeVel nodeBounds nodeCoord nodeEigenvector nodeDOFs nodeMass nodePressure nodeReaction nodeResponse nodeUnbalance printA printB printGID version logFile","title":"Runtime\n"},{"location":"guides/03_simulation/","text":"Simulation Process Build the model model dimensions and degrees-of-freedom nodal coordinates nodal constraints, boundary conditions nodal masses elements and element connectivity recorders for output Define & apply gravity load nodal or element load static-analysis parameters (tolerances & load increments) analyze hold gravity loads constant reset time to zero Define and apply lateral load load pattern (nodal loads for static analysis, support ground motion for earthquake) lateral-analysis parameters (tolerances & displacement/time increments) Static Lateral-Load Analysis define the displacement increments and displacement path Dynamic Lateral-Load Analysis define the input motion and all associated parameters, such as scaling and input type define analysis duration and time increment define damping analyze","title":"Simulation Process\n"},{"location":"guides/cli/","text":"Command Line Use","title":"Command Line Use\n"},{"location":"guides/object_oriented/","text":"Object oriented interfaces Object oriented interfaces are available for the following types: Element SectionForceDeformation UniaxialMaterial NdMaterial Node HystereticBackbone","title":"Object oriented interfaces\n"},{"location":"guides/BeamTheory/","text":"Beam-Column Elements in OpenSees This document provides a brief description of the interaction between a beam-column element and the SectionForceDeformation and CoordTransformation classes in OpenSees. Material and geometric nonlinearities are abstracted, or separated, from the element formulation by using the SectionForceDeformation and CoordTransformation classes. As a result, an element can be programmed in the \u201cbasic system\u201d to account for material nonlinearities, then use one of many transformation types to pick up geometric nonlinearities. A displacement based, distributed plasticity formulation is presented as an example of how a beam-column element is formulated in the basic system. Geometric Nonlinearity In general, the transformation of nodal displacements, \\(\\mathbf{u}\\) , in the global system to deformations, \\(\\mathbf{v}\\) , in the basic system is described by a nonlinear function, \\[%\\label{eq:v=v(u)} \\mathbf{v} = \\mathbf{v}(\\mathbf{u}).\\] In a similar manner, the transformation of basic forces, \\(\\mathbf{q}\\) , to forces \\(\\mathbf{p}\\) in the global frame of reference is given by \\[%\\label{eq:p=p(q,u)} \\mathbf{p} = \\mathbf{p}(\\mathbf{q}(\\mathbf{u}), \\mathbf{u}),\\] where \\(\\mathbf{p}\\) is implicitly a function of \\(\\mathbf{u}\\) via the basic forces, \\(\\mathbf{q}\\) , as well as an explicit function of \\(\\mathbf{u}\\) . The explicit dependence on \\(\\mathbf{u}\\) takes into account approximate geometric nonlinearities such as P- \\(\\Delta\\) . These transformations are shown schematically in figure @fig:Transformation . {#fig:Transformation} As seen in figure [fig:BeamClass] , a beam-column element acquires geometric nonlinearity from the CoordTransformation class, and material nonlinearity from the SectionForceDeformation class. Material Nonlinearity At every cross-section along the element length, a force-deformation relationship holds, providing section stress resultants, \\(\\mathbf{s}\\) , as a function of section deformations, \\(\\mathbf{e}\\) , \\[%\\label{eq:s=s(e)} \\mathbf{s}(x) = \\mathbf{s}(\\mathbf{e}(x)).\\] Linearizing the force-deformation relationship with respect to deformations reveals the section tangent stiffness, \\(\\mathbf{k}_s\\) , \\[\\begin{aligned} \\Delta\\mathbf{s} &= \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\Delta\\mathbf{e} \\\\ \\Delta\\mathbf{s} &= \\mathbf{k}_s \\Delta\\mathbf{e},\\end{aligned}\\] where \\(\\mathbf{k}_s = \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}}\\) , the partial derivative of the section stress resultants with respect to the section deformations. A beam-column element obtains material nonlinearity through use of the SectionForceDeformation class, as seen in figure [fig:BeamClass] . Class Hierarchy Figure [fig:BeamClass] shows the class interaction between a beam-column element and the CoordTransformation and SectionForceDeformation classes. An element can use any one of Linear, \\(P-\\Delta\\) , or Corotational transformations; and any one of ElasticSection or FiberSection constitutive models. When a new transformation or section class is added to the framework, the element can use the new class without modification. Displacement Based Element Formulation This section describes the formulation of a displacement based, distributed plasticity beam-column element. The governing compatibility and equilibrium equations are covered along with the consistent element stiffness. Bending deformations are assumed to be small, and shear deformations are neglected. Compatibility For displacement based elements, there is a strong form of compatibility between basic displacements, \\(\\mathbf{v}\\) , and section deformations \\(\\mathbf{e}\\) , satisfied pointwise along the element length, \\[%\\label{eq:e=av} \\mathbf{e}(x) = \\left[ \\begin{array}{c} \\varepsilon(x) \\\\ \\kappa(x) \\end{array} \\right] = \\mathbf{a}(x) \\mathbf{v},\\] where \\(\\mathbf{a}\\) is the strain-displacement matrix. The section deformations are the axial strain, \\(\\varepsilon\\) , and curvature, \\(\\kappa\\) . Assuming linear axial displacement and transverse displacement based on cubic Hermitian polynomials, the shape functions in the basic system are \\[%\\label{eq:N} \\mathbf{N}(x) = \\left[ \\begin{array}{c} N_1(x) \\\\ \\\\ N_2(x) \\\\ \\\\ N_3(x) \\end{array} \\right] = \\left[ \\begin{array}{c} \\frac{x}{L} \\\\ \\\\ L\\left( \\frac{x}{L} - 2\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\\\ \\\\ L\\left( -\\frac{x^2}{L^2} + \\frac{x^3}{L^3} \\right) \\end{array} \\right].\\] The strain-displacement matrix contains the shape function derivatives. Axial strain is the first derivative of the axial displacement, and curvature is the second derivative of the transverse displacement, \\[\\mathbf{a}(x) = \\left[ \\begin{array}{ccc} N_{1,x} & 0 & 0 \\\\ \\\\ 0 & N_{2,xx} & N_{3,xx} \\end{array} \\right].\\] Using the shape functions defined in equation [eq:N] , the strain-displacement matrix is then, \\[\\mathbf{a}(x) = \\frac{1}{L} \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ \\\\ 0 & -4+6\\frac{x}{L} & -2+6\\frac{x}{L} \\end{array} \\right].\\] The basic displacements, \\(\\mathbf{v}\\) , can be obtained by invoking the method getBasicTrialDisp() . After computing section deformations from basic displacements via equation @eq:e =av , the method setTrialSectionDeformation() may be invoked with the updated deformations, \\(\\mathbf{e}\\) . Equilibrium Using the principle of virtual displacements (virtual work), equilibrium between element end forces, \\(\\mathbf{q}\\) , and section stress resultants, \\(\\mathbf{s}\\) , is satisfied weakly, or in an average sense, along the element length, \\[%\\label{eq:q} \\mathbf{q} = \\int_0^L \\mathbf{a}(x)^T \\mathbf{s}(x) \\: dx,\\] where the section stress resultants are the axial force, \\(P\\) , and bending moment, \\(M\\) , \\[\\mathbf{s}(x) = \\left[ \\begin{array}{c} P(x) \\\\ M(x) \\end{array} \\right].\\] To obtain the current value of section stress resultants, \\(\\mathbf{s}\\) , the method getStressResultant() must be invoked. To perform the transformation from basic to global resisting force (equation [eq:p=p(q,u)] ), the method getGlobalResistingForce() should be invoked. Element Stiffness To solve the structural system of equations, the element stiffness must be assembled along with the resisting force. The element stiffness is obtained by taking the partial derivative of equation [eq:p=p(q,u)] with respect to displacements, \\(\\mathbf{u}\\) . \\[\\begin{aligned} \\mathbf{k} &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}}\\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ &= \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q} \\\\ \\mathbf{k} &= %\\label{eq:stiff} \\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{q}} \\mathbf{k}_b \\frac{\\partial\\mathbf{v}}{\\partial\\mathbf{u}} + \\left.\\frac{\\partial\\mathbf{p}}{\\partial\\mathbf{u}}\\right|_\\mathbf{q}\\end{aligned}\\] The basic element stiffness, \\(\\mathbf{k}_b\\) , is the partial derivative of the basic forces, \\(\\mathbf{q}\\) , with respect to the basic displacements, \\(\\mathbf{v}\\) . Differentiating equation [eq:q] gives, \\[\\begin{aligned} \\mathbf{k}_b &= \\frac{\\partial\\mathbf{q}}{\\partial\\mathbf{v}} \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{v}} \\: dx \\\\ &= \\int_0^L \\mathbf{a}(x)^T \\frac{\\partial\\mathbf{s}}{\\partial\\mathbf{e}} \\frac{\\partial\\mathbf{e}}{\\partial\\mathbf{v}} \\: dx \\\\ \\mathbf{k}_b &= %\\label{eq:kb} \\boxed{ \\int_0^L \\mathbf{a}(x)^T \\mathbf{k}_s(x) \\mathbf{a}(x) \\: dx} \\end{aligned}\\] The section tangent stiffness matrix, \\(\\mathbf{k}_s\\) , is returned upon invoking the method getSectionTangent() . After computing the basic stiffness, \\(\\mathbf{k}_b\\) , the method getGlobalStiffMatrix() should be invoked to perform the transformation in equation [eq:stiff] . The remaining partial derivatives in equation [eq:stiff] are computed by the getGlobalStiffMatrix() method. Numerical Quadrature In general, the element integrals, equations [eq:q] and [eq:kb] , cannot be evaluated in closed form due to nonlinearities in the section constitutive model. These integrals must be approximately evaluated by numerical quadrature, \\[\\begin{aligned} %\\label{eq:qapprox} \\mathbf{q} &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{s}(x_i) \\: W_i \\\\ %\\label{eq:kbapprox} \\mathbf{k}_b &\\approx \\sum_{i=1}^{N_s} \\mathbf{a}(x_i)^T \\mathbf{k}_s(x_i) \\mathbf{a}(x_i) \\: W_i ,\\end{aligned}\\] where \\(N_s\\) is the number of integration points, i.e., the number of section sample points along the element length. Integration points, \\(\\xi_i\\) , and weights, \\(\\omega_i\\) , are typically defined over a fixed domain such as \\(\\left[-1,1\\right]\\) or \\(\\left[0,1\\right]\\) , then mapped to the element domain \\(\\left[0,L\\right]\\) , where \\(L\\) is the element length. Assuming points and weights defined on \\(\\left[-1,1\\right]\\) , the following relationships hold, \\[\\begin{aligned} x_i &= \\frac{L}{2} \\left( \\xi_i+1 \\right) \\\\ W_i &= \\frac{L}{2} \\: \\omega_i .\\end{aligned}\\] After mapping the points and weights to the element domain, equations [eq:qapprox] and [eq:kbapprox] can be evaluated. Michael H. Scott August 22, 2001 PEER, University of California, Berkeley","title":"Beam-Column Elements in OpenSees\n"},{"location":"libraries/","text":"Library Reference The opensees package can be divided by the following objectives: Modeling Analysis Runtime Utilities Post-processing Modeling Libraries opensees.element Materials opensees.uniaxial opensees.material opensees.backbone Sections opensees.section opensees.patch opensees.layer opensees.fiber Utilities opensees.units","title":"Library Reference"},{"location":"libraries/analysis/","text":"Analysis Capabilities Linear equation solvers, time integration schemes, and solution algorithms are the core of the OpenSees computational framework. The components of a solution strategy are interchangeable, allowing analysts to find sets suited to their particular problem. Outlined here are the available solution strategies. New parts of the solution strategy may be seamlessly plugged in to the existing framework. Static Integrators Determing the next time step for an analysis is done by the following schemes Load Control \u2013 Specifies the incremental load factor to be applied to the loads in the domain Displacement Control \u2013 Specifies the incremental displacement at a specified DOF in the domain Minimum Unbalanced Displacement Norm \u2013 Specifies the incremental load factor such that the residual displacement norm in minimized Arc Length \u2013 Specifies the incremental arc-length of the load-displacement path Transient Integrators Determing the next time step for an analysis including inertial effects is done by the following schemes Newmark \u2013 The two parameter time-stepping method developed by Newmark HHT \u2013 The three parameter Hilbert-Hughes-Taylor time-stepping method Generalized Alpha \u2013 Generalization of the HHT algorithm with improved numerical damping Central Difference \u2013 Approximates velocity and acceleration by centered finite differences of displacement Solution Algorithms Iteration from the last time step to the current is done by the following methods Linear \u2013 Uses the solution at the first iteration and continues Newton \u2013 Uses the tangent at the current iteration to iterate to convergence Modified Newton \u2013 Uses the tangent at the first iteration to iterate to convergence Convergence Tests Accepting the current state of the domain as being on the converged solution path is accomplished by the following tests Norm Unbalance \u2013 Specifies a tolerance on the norm of the unbalanced load at the current iteration Norm Displacement Increment \u2013 Specifies a tolerance on the norm of the displacement increments at the current iteration Energy Increment \u2013 Specifies a tolerance on the inner product of the unbalanced load and displacement increments at the current iteration Constraint Handlers The constraints defined on the domain can be handled by the following methods Plain \u2013 Removes constrained degrees of freedom from the system of equations Lagrange \u2013 Uses the method of Lagrange multipliers to enforce constraints Penalty \u2013 Uses penalty numbers to enforce constraints Transformation \u2013 Performs a condensation of constrained degrees of freedom","title":"Analysis Capabilities\n"},{"location":"libraries/analysis/ConvergenceTest/CTestEnergyIncr/","text":"CTestEnergyIncr #include <convergenceTest/CTestEnergyIncr.h> class CTestEnergyIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestEnergyIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestEnergyIncr class tests using the energy increment, 0.5 times the absolute value of the dot product of the LinearSOE objects solution and rhs Vectors, and a user specified tolerance value. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol and the max number of iterations to be performed to maxNumIter . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestEnergyIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if 0.5 times the absolute value of the dot product of the LinearSOE objects X and B Vectors is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.y","title":"CTestEnergyIncr\n"},{"location":"libraries/analysis/ConvergenceTest/CTestNormDispIncr/","text":"CTestNormDispIncr #include <convergenceTest/CTestNormDispIncr.h> class CTestNormDispIncr : public ConvergenceTest MovableObject ConvergenceTest A CTestNormDispIncr object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormDispIncr class tests using the norm of the solution Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormDispIncr , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects X Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 3, puts the tolerance value tol , numIncr and printFlag in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 3, invokes recvVector() on theChannel , and sets the values of tol , numIncr and printFlag . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormDispIncr\n"},{"location":"libraries/analysis/ConvergenceTest/CTestNormUnbalance/","text":"CTestNormUnbalance #include <convergenceTest/CTestNormUnbalance.h> class CTestNormUnbalance : public ConvergenceTest MovableObject ConvergenceTest A CTestNormUnbalance object is an object which can be used in an algorithmic class to test if convergence has been achieved. The CTestNormUnbalance class tests using the norm of the right hand side Vector of a LinearSOE object and a user specified tolerance value. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be tol , the max number of iterations to be performed to maxNumIter and the print flag used to determine what, if anything, is printed on each test to printFlag . To be used by the FEM_ObjectBroker object in parallel programs. The integer CLASS_TAGS_CTestNormUnbalance , defined in <classTags.h> , is passed to the ConvergenceTest constructor. Sets the tolerance used in test() to be 0.0 and maxNumIter to be \\(0\\) . These will be set when recvSelf() is invoked on the object. Does nothing. Sets the tolerance used in test() to be newTol . It sets a pointer to theAlgo \u2019s LinearSOE object. Returns \\(0\\) if successful, a \\(-1\\) is returned and an error message printed if no LinearSOE object has been set in theAlgo . Sets an integer indicating the current number of iterations, currentNumIter to \\(1\\) . Returns \\(0\\) if successfull, an error message and \\(-1\\) are returned if no LinearSOE object has been set. Returns currentNumIter if if the two norm of the LinearSOE objects B Vector is less than the tolerance tol . If no LinearSOE has been set \\(-2\\) is returned. If the currentNumIter \\(>=\\) maxNumIter an error message is printed and \\(-2\\) is returned. If none of these conditions is met, the currentnumIter is incremented and \\(-1\\) is returned. If the print flag is \\(0\\) nothing is printed to opserr during the method, if \\(1\\) the current iteration and norm are printed to opserr, and if \\(2\\) the norm and number of iterations to convergence are printed to opserr. Creates a Vector of size 2, puts the tolerance value tol and numIncr in this, and then invokes sendVector() on theChannel . Returns \\(0\\) if successful. A warning message is printed and a negative number if the Channel object fails to send the Vector. Creates a Vector of size 2, invokes recvVector() on theChannel , and sets the values of tol and numIncr . Returns \\(0\\) if successful. If the Channel object fails to receive the Vector, tol is set to \\(1.0e-8\\) , numIter to \\(25\\) , a warning message is printed, and a negative number returned.","title":"CTestNormUnbalance\n"},{"location":"libraries/analysis/StaticIntegrator/ArcLength/","text":"THE IMPLEMENTATION WILL HAVE TO CHANGE FOR DOMAIN-DECOMPOSITION ANALYSIS .. AS DOES THE CONVERGENCE TEST STUFF .. THIS IS BECAUSE USING DOT PRODUCTS OF VECTORS OBTAINED STRAIGHT FROM SYSTEM OF EQUATION .. MAYBE MODIFY LinearSOE TO DO THE DOT PRODUCT .. WILL WORK IN DD IF ALL USE ONE SOE .. WHAT PetSC DOES, TALK WITH P. DEMMEL ABOUT WHAT HE WILL PROVIDE. ArcLength #include <analysis/integrator/ArcLength.h> class ArcLength : public StaticIntegrator MovableObject Integrator IncrementalIntegrator StaticIntegrator ArcLength is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using an arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation [staticFormTaylor] to produce a linear system of \\(N+1\\) unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of \\(N\\) unknowns using the method of ??(REF). Rewriting equation [staticFormTaylor] as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] substituting for \\(\\Delta {{\\bf U}_n^{(i)}}\\) using equation [splitForm] this can be expressed as: \\[\\Delta \\lambda_n^{(i)^2} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 \\right) + 2* \\Delta \\lambda_n^{(i)} \\left( \\Delta \\dot{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2d \\lambda^{(i)} \\right)\\] \\[+ \\left (\\Delta \\overline{\\bf U}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} \\right) =0\\] which is a quadratic in \\(\\Delta \\lambda_n^{(i)}\\) , which can be solved for two roots. The root chosen is the one which will keep a positive angle between the incremental displacement before and after this step. Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\ Delta U$ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength\n"},{"location":"libraries/analysis/StaticIntegrator/ArcLength1/","text":"ArcLength1 #include <analysis/integrator/ArcLength1.h> class ArcLength1 : public StaticIntegrator MovableObject Integrator IncrementalIntegrator ArcLength1 is a subclass of StaticIntegrator, it is used to when performing a static analysis on the FE_Model using a simplified form of the arc length method. In the arc length method implemented by this class, the following constraint equation is added to equation [staticFormTaylor] of the StaticIntegrator class: \\[\\Delta {\\bf U}_n^T \\Delta {\\bf U}_n + \\alpha^2 \\Delta \\lambda_n^2 = \\Delta s^2\\] where \\[\\Delta {\\bf U}_n = \\sum_{j=1}^{i} \\Delta {\\bf U}_n^{(j)} = \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)}\\] \\[\\Delta \\lambda_n = \\sum_{j=1}^{i} \\Delta \\lambda_n^{(j)} = \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)}\\] this equation cannot be added directly into equation [staticFormTaylor] to produce a linear system of \\(N+1\\) unknowns. To add this equation we make some assumptions ala Yang (REF), which in so doing allows us to solve a system of \\(N\\) unknowns using the method of ??(REF). Rewriting equation [staticFormTaylor] as \\[{\\bf K}_n^{(i)} \\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} {\\bf P} + \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) = \\Delta \\lambda_n^{(i)} {\\bf P} + {\\bf R}_n^{(i)}\\] The idea of ?? is to separate this into two equations: \\[{\\bf K}_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} = \\P\\] \\[{\\bf K}_n^{(i)} \\Delta \\overline{\\bf U}_n^{(i)} = {\\bf R}_n^{(i)}\\] where now \\[\\Delta {\\bf U}_n^{(i)} = \\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)} \\label{splitForm}\\] We now rewrite the constraint equation based on two conditions: \\(i = 1\\) : assuming \\({\\bf R}_n^{(1)} = \\zero\\) , i.e. the system is in equilibrium at the start of the iteration, the following is obtained \\[\\Delta {\\bf U}_n^{(1)} = \\Delta \\lambda_n^{(1)} \\Delta \\dot{\\bf U}_n^{(1)} + \\zero\\] \\[\\Delta \\lambda_n^{(1)} = \\begin{array}{c} + \\\\ - \\end{array} \\sqrt{\\frac{\\Delta s^2}{\\dot{\\bf U}^T \\dot{\\bf U}+ \\alpha^2}}\\] The question now is whether + or - should be used. In this class, \\(d \\lambda\\) from the previous iteration \\((n-1)\\) is used, if it was positive + is assumed, otherwise - . This may change. There are other ideas: ?(REF) number of negatives on diagonal of decomposed matrix, ... \\(i > 1\\) \\[\\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right)^T \\left( \\Delta {\\bf U}_n^{(i)} + d{\\bf U}^{(i)} \\right) + \\alpha^2 \\left( \\Delta \\lambda_n^{(i)} + d\\lambda^{(i)} \\right)^2 = \\Delta s^2\\] \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + {d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\] assuming the constraint equation was solved at \\(i-1\\) , i.e. \\({d{\\bf U}^{(i)}}^T d{\\bf U}^{(i)} + \\alpha^2 {d\\lambda^{(i)}}^2 = \\Delta s^2\\) , this reduces to \\[\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2 + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] For our ArcLength1 method we make the ADDITIONAL assumption that \\(2{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + 2 \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)}\\) \\(>>\\) \\(\\Delta {{\\bf U}_n^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 \\Delta {\\lambda_n^{(i)}}^2\\) the constraint equation at step \\(i\\) reduces to \\[{d{\\bf U}^{(i)}}^T\\Delta {\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] hence if the class was to solve an \\(N+1\\) system of equations at each step, the system would be: \\[\\left[ \\begin{array}{cc} {\\bf K}_n^{(i)} & -{\\bf P} \\\\ {d{\\bf U}^{(i)}}^T & \\alpha^2 d\\lambda^{(i)} \\end{array} \\right] \\left\\{ \\begin{array}{c} \\Delta {\\bf U}_n^{(i)} \\\\ \\Delta \\lambda_n^{(i)} \\end{array} \\right\\} = \\left\\{ \\begin{array}{c} \\lambda_n^{(i)} {\\bf P} - {\\bf F}_R({\\bf U}_n^{(i)}) \\\\ 0 \\end{array} \\right\\}\\] instead of solving an \\(N+1\\) system, equation [splitForm] is used to give \\[{d{\\bf U}^{(i)}}^T \\left(\\Delta \\lambda_n^{(i)} \\Delta \\dot{\\bf U}_n^{(i)} + \\Delta \\overline{\\bf U}_n^{(i)}\\right) + \\alpha^2 d\\lambda^{(i)} \\Delta \\lambda_n^{(i)} = 0\\] which knowing \\(\\dot{\\bf U}_n^{(i)}\\) and \\(\\overline{\\bf U}_n^{(i)}\\) can be solved for \\(\\Delta \\lambda_n^{(i)}\\) \\[\\Delta \\lambda_n^{(i)} = -\\frac{{d{\\bf U}^{(i)}}^T \\Delta \\overline{\\bf U}_n^{(i)}}{{d{\\bf U}^{(i)}}^T \\Delta \\dot{\\bf U}_n^{(i)} + \\alpha^2 d\\lambda^{(i)}}\\] Constructors ### Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_ArcLength 1 (defined in <classTags.h> ) is passed to the StaticIntegrator classes constructor. The value of \\(\\alpha\\) is set to alpha and \\(\\Delta s\\) to dS . Invokes the destructor on the Vector objects created in domainChanged() . int newStep ( void ); newStep() performs the first iteration, that is it solves for \\(\\lambda_n^{(1)}\\) and \\(\\Delta {\\bf U}_n^{(1)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(1)}\\) and increments the load factor by \\(\\lambda_n^{(1)}\\) . To do this it must set the rhs of the LinearSOE to \\(\\P\\) , invoke formTangent() on itself and solve the LinearSOE to get \\(\\Delta \\dot{\\bf U}_n^{(1)}\\) . int update ( const Vector & $ \\ Delta U$ ); Note the argument \\(\\Delta U\\) should be equal to \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) . The object then determines \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) by setting the rhs of the linear system of equations to be \\(\\P\\) and then solving the linearSOE. It then solves for \\(\\Delta \\lambda_n^{(i)}\\) and \\(\\Delta {\\bf U}_n^{(i)}\\) and updates the model with \\(\\Delta {\\bf U}_n^{(i)}\\) and increments the load factor by \\(\\Delta \\lambda_n^{(i)}\\) . Sets the vector \\(x\\) in the LinearSOE object to be equal to \\(\\Delta {\\bf U}_n^{(i)}\\) before returning (this is for the convergence test stuff. The object creates the Vector objects it needs. Vectors are created to stor \\(\\P\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(\\Delta \\dot{\\bf U}_n^{(i)}\\) , \\(\\Delta \\overline{\\bf U}_n^{(i)}\\) , \\(dU^{(i)}\\) . To form \\(\\P\\) , the current load factor is obtained from the model, it is incremented by \\(1.0\\) , formUnbalance() is invoked on the object, and the \\(b\\) vector is obtained from the linearSOE. This is \\(\\P\\) , the load factor on the model is then decremented by \\(1.0\\) . int sendSelf(int commitTag, Channel &theChannel); Places the values of \\(\\Delta s\\) and \\(\\alpha\\) in a vector of size \\(2\\) and invokes sendVector() on theChannel . Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values of \\(\\Delta s\\) and \\(\\alpha\\) . Returns \\(0\\) if successful, a warning message is printed, \\(\\delta \\lambda\\) is set to \\(0\\) , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current value of \\(\\lambda\\) , and \\(\\delta \\lambda\\) .","title":"ArcLength1\n"},{"location":"libraries/analysis/StaticIntegrator/EQPath/","text":"EQPath integrator EQPath $arc_length $type References Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 849 - 878 DOI: https://doi.org/10.12989/sem.2013.48.6.849 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part I : Formulation and characteristics of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/264146397_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_I_Formulation_and_characteristics_of_the_methods Structural Engineeringand Mechanics Volume 48, Number 6, December25 2013, pages 879 - 914 DOI: https://doi.org/10.12989/sem.2013.48.6.879 Comprehensive evaluation of structural geometrical nonlinear solution techniques Part II : Comparing efficiencies of the methods M.Rezaiee - Pajand, M.Ghalishooyan and M.Salehi - Ahmadabad FULLTEXT : https://www.researchgate.net/publication/263361974_Comprehensive_evaluation_of_structural_geometrical_nonlinear_solution_techniques_Part_II_Comparing_efficiencies_of_the_methods Written: M. Salehi opensees.net@gmail.com Created: 02/19","title":"EQPath\n"},{"location":"libraries/analysis/TransientIntegrator/GeneralizedAlpha/","text":"GeneralizedAlpha \\(\\alpha_F\\) and \\(\\alpha_M\\) are defined differently than in the paper, we use \\(\\alpha_F = (1-\\alpha_f)\\) and \\(\\alpha_M=(1-\\gamma_m)\\) where \\(\\alpha_f\\) and \\(\\alpha_m\\) are those used in the paper. Like Newmark and all the implicit schemes, the unconditional stability of this method applies to linear problems. There are no results showing stability of this method over the wide range of nonlinear problems that potentially exist. Experience indicates that the time step for implicit schemes in nonlinear situations can be much greater than those for explicit schemes. \\(\\alpha_M = 1.0, \\alpha_F = 1.0\\) produces the Newmark Method. \\(\\alpha_M = 1.0\\) corresponds to the HHT method. The method is second-order accurate provided \\(\\gamma = \\tfrac{1}{2} + \\alpha_M - \\alpha_F\\) - The method is unconditionally stable provided \\(\\alpha_M >= \\alpha_F >= \\tfrac{1}{2}, \\beta>=\\tfrac{1}{4} +\\tfrac{1}{2}(\\gamma_M - \\gamma_F)\\) \\(\\gamma\\) and \\(\\beta\\) are optional. The default values ensure the method is unconditionally stable, second order accurate and high frequency dissipation is maximized. The defaults are: \\[\\gamma = \\tfrac{1}{2} + \\gamma_M - \\gamma_F\\] and \\[\\beta = \\tfrac{1}{4}(1 + \\gamma_M - \\gamma_F)^2\\] Theory The Generalized \\(\\alpha\\) method (sometimes called the \\(\\alpha\\) method) is a one step implicit method for solving the transient problem which attempts to increase the amount of numerical damping present without degrading the order of accuracy. As with the HHT method, the following Newmark approximations are used: \\[ U_{t+\\Delta t} = U_t + \\Delta t \\dot U_t + [(0.5 - \\beta) \\Delta t^2] \\ddot U_t + [\\beta \\Delta t^2] \\ddot U_{t+\\Delta t} \\\\ \\dot U_{t+\\Delta t} = \\dot U_t + [(1-\\gamma)\\Delta t] \\ddot U_t + [\\gamma \\Delta t ] \\ddot U_{t+\\Delta t} \\] but the time-discrete momentum equation is modified: \\[ R_{t + \\alpha_M \\Delta t} = F_{t+\\Delta t}^\\text{ext} - M \\ddot U_{t + \\alpha_M \\Delta t} - C \\dot U_{t+\\alpha_F \\Delta t} - F^\\text{int}(U_{t + \\alpha_F \\Delta t}) \\] where the displacements and velocities at the intermediate point are given by: \\[\\mathbf{d}_{t+ \\alpha_F \\Delta t} = (1 - \\alpha_F) U_t + \\alpha_F U_{t + \\Delta t} \\\\ \\mathbf{v}_{t+\\alpha_F \\Delta t} = (1-\\alpha_F) \\dot U_t + \\alpha_F \\dot U_{t + \\Delta t} \\\\ \\mathbf{a}_{t+\\alpha_M \\Delta t} = (1-\\alpha_M) \\ddot U_t + \\alpha_M \\ddot U_{t + \\Delta t}\\] Following the methods outlined for Newmarks method, linearization of the nonlinear momentum equation results in the following linear equations: \\[K_{t+\\Delta t}^{*i} d U_{t+\\Delta t}^{i+1} = R_{t+\\Delta t}^i\\] where \\(K_{t+\\Delta t}^{*i} = \\alpha_F K_t + \\frac{\\alpha_F \\gamma}{\\beta \\Delta t} C_t + \\frac{\\alpha_M}{\\beta \\Delta t^2} M\\) and \\[ R_{t+\\Delta t}^i = F_{t + \\Delta t}^\\text{ext} - F(U_{t + \\alpha F \\Delta t}^{i-1})^\\text{int} - C \\dot U_{t+\\alpha F \\Delta t}^{i-1} - M \\ddot U_{t+ \\alpha M \\Delta t}^{i-1} \\] The linear equations are used to solve for \\(U_{t+\\alpha F \\Delta t}, \\dot U_{t + \\alpha F \\Delta t} \\ddot U_{t+ \\alpha M \\Delta t}\\) . Once convergence has been achieved the displacements, velocities and accelerations at time \\(t + \\Delta t\\) can be computed. REFERENCES J. Chung, G.M.Hubert. \u201cA Time Integration Algorithm for Structural Dynamics with Improved Numerical Dissipation: The Generalized- \\(\\alpha\\) Method\u201d ASME Journal of Applied Mechanics, 60, 371:375, 1993.","title":"GeneralizedAlpha\n"},{"location":"libraries/analysis/TransientIntegrator/HHT/","text":"HHT #include <analysis/integrator/HHT.h> class HHT : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator HHT is a subclass of TransientIntegrator which implements the Hilber-Hughes-Taylor (HHT) method. In the HHT method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , by solving the following equilibrium equation \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\alpha \\Delta t},{\\bf U}_{t + \\alpha \\Delta t})\\] where \\[{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) {\\bf U}_t + \\alpha {\\bf U}_{t + \\Delta t}\\] \\[\\dot{\\bf U}_{t + \\alpha} = \\left( 1 - \\alpha \\right) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] and the velocities and accelerations at time \\(t + \\Delta t\\) are determined using the Newmark relations. The HHT method results in the following for determining the response at \\(t + \\Delta t\\) \\[ \\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\alpha \\gamma}{\\beta \\Delta t} {\\bf C} + \\alpha {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)},{\\bf U}_{t + \\alpha \\Delta t}^{(i-1)}\\right) \\] // Constructors // Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_HHT is passed to the TransientIntegrator constructor. \\(\\alpha\\) , \\(\\beta\\) and \\(\\gamma\\) are set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Sets \\(\\alpha\\) to alpha , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1\\alpha {\\bf K} + c2\\alpha \\D + c3 {\\bf M}\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group \\ * theDof ); This performs the following: // while \u0304 while w\u0304hile \u0304 if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(8\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) , and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double \u0394t ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 ; c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta * \\Delta t)\\) and c3 to \\(1/ (\\beta * \\Delta t^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) and the displacement and velocity at time \\(t + \\alpha \\Delta t\\) are set using the difference approximations. \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 ${\\bf U}_{t + \\alpha \\Delta t} = {\\bf U}_t$\\ \\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t \\] \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} = (1 - \\alpha) \\dot{\\bf U}_t + \\alpha \\dot{\\bf U}_{t + \\Delta t}\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements and velocities at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . \\[ %while w\u0304hile w\u0304hile w\u0304hile \u0304 \\texttt{theModel->setResponse}({\\bf U}_{t + \\alpha \\Delta t}, \\dot{\\bf U}_{t+\\alpha \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t}) \\] current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & \u0394U ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The displacement Vector at time \\(t + \\alpha \\Delta t\\) is incremented by \\(c1 \\alpha \\Delta U\\) and the velocity Vector by \\(c2 \\alpha \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement and velocity at time \\(t + \\alpha \\Delta t\\) and the accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. ::: {.tabbing} while \u0304 while w\u0304hile \u0304 \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) \\({\\bf U}_{t + \\alpha \\Delta t} += \\alpha \\Delta \\U\\) \\[\\dot{\\bf U}_{t + \\alpha \\Delta t} += \\frac{\\alpha \\gamma}{\\beta \\Delta t} \\Delta \\U\\] theModel -> setResponse ( U_t_alpha_\u0394t , \\ dot { \\ bf U } _ { t + \\ alpha \\ Delta t }, \\ ddot { \\ bf U } _ { t + \\ Delta t }) theModel -> updateDomain () Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 6 the values of \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"HHT\n"},{"location":"libraries/analysis/TransientIntegrator/Newmark/","text":"Newmark #include <analysis/integrator/Newmark.h> class Newmark: public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator Newmark is a subclass of TransientIntegrator which implements the Newmark method. In the Newmark method, to determine the velocities, accelerations and displacements at time \\(t + \\Delta t\\) , the equilibrium equation (expressed for the TransientIntegrator) is typically solved at time \\(t + \\Delta t\\) for \\({\\bf U}_{t+\\Delta t}\\) , i.e. solve: \\[{\\bf R} ({\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] for \\({\\bf U}_{t+\\Delta t}\\) . The following difference relations are used to relate \\(\\dot{\\bf U}_{t + \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\Delta t}\\) to \\({\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\Delta t} = \\frac{\\gamma}{\\beta \\Delta t} \\left( {\\bf U}_{t + \\Delta t} - {\\bf U}_t \\right) + \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\Delta t} = \\frac{1}{\\beta {\\Delta t}^2} \\left( {\\bf U}_{t+\\Delta t} - {\\bf U}_t \\right) - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\] which results in the following \\[\\left[ \\frac{1}{\\beta \\Delta t^2} {\\bf M} + \\frac{\\gamma}{\\beta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] An alternative approach, which does not involve \\(\\Delta t\\) in the denumerator (useful for impulse problems), is to solve for the accelerations at time \\(t + \\Delta t\\) \\[{\\bf R} (\\ddot{\\bf U}_{t + \\Delta t}) = {\\bf P}(t + \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+\\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\Delta t},{\\bf U}_{t + \\Delta t})\\] where we use following functions to relate \\({\\bf U}_{t + \\Delta t}\\) and \\(\\dot{\\bf U}_{t + \\Delta t}\\) to \\(\\ddot{\\bf U}_{t + \\Delta t}\\) and the response quantities at time \\(t\\) : \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\left[ \\left(\\frac{1}{2} - \\beta\\right)\\ddot{\\bf U}_t + \\beta \\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t^2\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\left[ \\left(1 - \\gamma\\right)\\ddot{\\bf U}_t + \\gamma\\ddot{\\bf U}_{t + \\Delta t}\\right] \\Delta t\\] which results in the following \\[\\left[ {\\bf M} + \\gamma \\Delta t {\\bf C} + \\beta \\Delta t^2 {\\bf K} \\right] \\Delta \\ddot{\\bf U}_{t + \\Delta t}^{(i)} = {\\bf P}(t + \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\Delta t}^{(i-1)},{\\bf U}_{t + \\Delta t}^{(i-1)}\\right)\\] Constructors ### Destructor // Public Methods // Public Methods for Output Sets \\(\\gamma\\) to \\(1/2\\) and \\(\\beta\\) to \\(1/4\\) . Sets a flag indicating whether the incremental solution is done in terms of displacement, \\(\\Delta \\U\\) , if dispFlag is true , or acceleration, \\(\\Delta \\ddot \\U\\) , if dispFlag is false . In addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\gamma\\) to gamma and \\(\\beta\\) to beta . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\gamma\\) to gamma , \\(\\beta\\) to beta , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 {\\bf K} + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 if (RayleighDamping == false) { theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1) theEle- \\(>\\) addCtoTang(c2) theEle- \\(>\\) addMtoTang(c3) } else { theEle- \\(>\\) zeroTang() theEle- \\(>\\) addKtoTang(c1 + c2 * \\(\\beta_K\\) ) theEle- \\(>\\) addMtoTang(c3 + c2 * \\(\\alpha_M\\) ) } int formNodTangent ( DOF_Group \\ * theDof ); The method returns \\(0\\) after performing the following operations: while \u0304 while w\u0304hile \u0304 theDof- \\(>\\) zeroUnbalance() if (RayleighDamping == false) theDof- \\(>\\) addMtoTang(c3) else theDof- \\(>\\) addMtoTang(c3 + c2 * \\(\\alpha_M\\) ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE- \\(>\\) getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) . The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\ Delta t$ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 depending on the flag indicating whether incremental displacements or accelerations are being solved for at each iteration. If dispFlag was true , c1 is set to \\(1.0\\) , c2 to \\(\\gamma / (\\beta \\Delta t)\\) and c3 to \\(1/ (\\beta \\Delta t^2)\\) . If the flag is false c1 is set to \\(\\beta \\Delta t^2\\) , c2 to \\(\\gamma \\Delta t\\) and c3 to \\(1.0\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Delta t\\) are set using the difference approximations if dispFlag was true . (displacement and velocity if false ). while w\u0304hile w\u0304hile w\u0304hile \u0304 if (displIncr == true) { \\(\\dot {\\bf U}_{t + \\Delta t} = \\left( 1 - \\frac{\\gamma}{\\beta}\\right) \\dot {\\bf U}_t + \\Delta t \\left(1 - \\frac{\\gamma}{2 \\beta}\\right) \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\Delta t} = - \\frac{1}{\\beta \\Delta t} \\dot {\\bf U}_t + \\left( 1 - \\frac{1}{2 \\beta} \\right) \\ddot {\\bf U}_t\\) } else { \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t \\dot{\\bf U}_t + \\frac{\\Delta t^2}{2}\\ddot{\\bf U}_t\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\Delta t \\ddot{\\bf U}_t\\) } The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with new quantities for time \\(t + \\Delta t\\) . while w\u0304hile w\u0304hile w\u0304hile \u0304 theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) current time is obtained from the AnalysisModel, incremented by \\(\\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\ Delta U$ ); Invoked this causes the object to increment the DOF_Group response quantities at time \\(t + \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response at the DOF_Group objects are then updated by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. while w\u0304hile w\u0304hile w\u0304hile \u0304 if (displIncr == true) { \\({\\bf U}_{t + \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\Delta t} += \\frac{\\gamma}{\\beta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\Delta t} += \\frac{1}{\\beta {\\Delta t}^2} \\Delta \\U\\) } else { \\(\\ddot{\\bf U}_{t + \\Delta t} += \\Delta \\Udd\\) \\({\\bf U}_{t + \\Delta t} += \\beta \\Delta t^2 \\Delta \\Udd\\) \\(\\dot{\\bf U}_{t + \\Delta t} += \\gamma \\Delta t \\Delta \\Udd\\) } theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+\\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) theModel- \\(>\\) setUpdateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\delta U\\) are of different sizes. int sendSelf(int commitTag, Channel &theChannel); Places in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Then invokes sendVector() on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 6 the values of \\(\\beta\\) , \\(\\gamma\\) , dispFlag , RayleighDampingFlag, \\(\\alpha_M\\) and \\(\\beta_K\\) . Returns \\(0\\) if successful. A warning message is printed, \\(\\gamma\\) is set to 0.5, \\(\\beta\\) to 0.25 and the Rayleigh damping flag set to false , and a \\(-1\\) is returned, if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\gamma\\) and \\(\\beta\\) . If Rayleigh damping is specified, the constants \\(\\alpha_M\\) and \\(\\beta_K\\) are also printed.","title":"Newmark\n"},{"location":"libraries/analysis/TransientIntegrator/WilsonTheta/","text":"WilsonTheta #include <analysis/integrator/WilsonTheta.h> class WilsonTheta : public TransientIntegrator MovableObject Integrator IncrementalIntegrator TransientIntegrator WilsonTheta is a subclass of TransientIntegrator which implements the Wilson- \\(\\Theta\\) method. In the Wilson- \\(\\Theta\\) method, to determine the velocities, accelerations and displacements at time \\(t + \\theta \\Delta t\\) , \\(\\theta \\ge 1.37\\) , for \\({\\bf U}_{t+ \\theta \\Delta t}\\) \\[{\\bf R} ({\\bf U}_{t + \\theta \\Delta t}) = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I(\\ddot{\\bf U}_{t+ \\theta \\Delta t}) - {\\bf F}_R(\\dot{\\bf U}_{t + \\theta \\Delta t},{\\bf U}_{t + \\theta \\Delta t})\\] where we use following functions to relate \\(\\dot{\\bf U}_{t + \\theta \\Delta t}\\) and \\(\\ddot{\\bf U}_{t + \\theta \\Delta t}\\) to \\({\\bf U}_{t + \\theta \\Delta t}\\) and the response quantities at time \\(t\\) : \\[\\dot {\\bf U}_{t + \\theta \\Delta t} = \\frac{3}{\\theta \\Delta t} \\left( {\\bf U}_{t + \\theta \\Delta t} - {\\bf U}_t \\right) - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\] \\[\\ddot {\\bf U}_{t + \\theta \\Delta t} = \\frac{6}{\\theta^2 \\Delta t^2} \\left( {\\bf U}_{t+\\theta \\Delta t} - {\\bf U}_t \\right) - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\] which results in the following for determining the responses at \\(t + \\theta \\Delta t\\) \\[\\left[ \\frac{6}{\\theta^2 \\Delta t^2} {\\bf M} + \\frac{3}{\\theta \\Delta t} {\\bf C} + {\\bf K} \\right] \\Delta {\\bf U}_{t + \\theta \\Delta t}^{(i)} = {\\bf P}(t + \\theta \\Delta t) - {\\bf F}_I\\left(\\ddot{\\bf U}_{t+\\theta \\Delta t}^{(i-1)}\\right) - {\\bf F}_R\\left(\\dot{\\bf U}_{t + \\theta \\Delta t}^{(i-1)},{\\bf U}_{t + \\theta \\Delta t}^{(i-1)}\\right)\\] The response quantities at time \\(t + \\Delta t\\) are then determined using the following \\[\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\] \\[\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\] \\[{\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\] Constructors Destructor // Public Methods // Public Methods for Output The integer INTEGRATOR_TAGS_WilsonTheta is passed to the TransientIntegrator constructor. \\(\\Theta\\) is set to 0.0. This constructor should only be invoked by an FEM_ObjectBroker. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . addition, a flag is set indicating that Rayleigh damping will not be used. Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) and \\(\\beta\\) to \\(0.25*\\alpha^2\\) . In addition, a flag is set indicating that Rayleigh damping will not be used. This constructor is invoked if Rayleigh damping is to be used, i.e. \\(\\D = \\alpha_M M + \\beta_K K\\) . Sets \\(\\Theta\\) to theta , \\(\\gamma\\) to \\((1.5 - \\alpha)\\) , \\(\\beta\\) to \\(0.25*\\alpha^2\\) , \\(\\alpha_M\\) to alphaM and \\(\\beta_K\\) to betaK . Sets a flag indicating whether the incremental solution is done in terms of displacement or acceleration to dispFlag and a flag indicating that Rayleigh damping will be used. Invokes the destructor on the Vector objects created. This tangent for each FE_Element is defined to be \\({\\bf K}_e = c1 \\K + c2 \\D + c3 \\M\\) , where c1,c2 and c3 were determined in the last invocation of the newStep() method. Returns \\(0\\) after performing the following operations: if ( RayleighDamping == false ) { theEle -> zeroTang () theEle -> addKtoTang ( c1 ) theEle -> addCtoTang ( c2 ) theEle -> addMtoTang ( c3 ) } else { theEle -> zeroTang () theEle -> addKtoTang ( c1 + c2 * beta_K ) theEle -> addMtoTang ( c3 + c2 * alpha_M ) } int formNodTangent ( DOF_Group * theDof ); This performs the following: theDof -> zeroUnbalance () if ( RayleighDamping == false ) theDof -> addMtoTang ( c3 ) else theDof -> addMtoTang ( c3 + c2 * alpha_M ) int domainChanged ( void ); If the size of the LinearSOE has changed, the object deletes any old Vectors created and then creates \\(6\\) new Vector objects of size equal to theLinearSOE->getNumEqn() . There is a Vector object created to store the current displacement, velocity and accelerations at times \\(t\\) and \\(t + \\Delta t\\) (between newStep() and commit() the \\(t + \\Delta t\\) quantities store \\(t + \\Theta \\Delta t\\) quantities). The response quantities at time \\(t + \\Delta t\\) are then set by iterating over the DOF_Group objects in the model and obtaining their committed values. Returns \\(0\\) if successful, otherwise a warning message and a negative number is returned: \\(-1\\) if no memory was available for constructing the Vectors. int newStep ( double $ \\ Delta t$ ); The following are performed when this method is invoked: First sets the values of the three constants c1 , c2 and c3 : c1 is set to \\(1.0\\) , c2 to \\(3 / (\\Theta \\Delta t)\\) and c3 to \\(6 / (\\Theta \\Delta t)^2)\\) . Then the Vectors for response quantities at time \\(t\\) are set equal to those at time \\(t + \\Delta t\\) . \\({\\bf U}_t = {\\bf U}_{t + \\Delta t}\\) \\(\\dot{\\bf U}_t = \\dot{\\bf U}_{t + \\Delta t}\\) \\(\\ddot{\\bf U}_t = \\ddot{\\bf U}_{t + \\Delta t}\\) Then the velocity and accelerations approximations at time \\(t + \\Theta \\Delta t\\) are set using the difference approximations, \\({\\bf U}_{t + \\theta \\Delta t} = {\\bf U}_t\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} = - 2 \\dot {\\bf U}_t + \\frac{\\theta \\Delta t}{2} \\ddot {\\bf U}_t\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} = - \\frac{6}{\\theta \\Delta t} \\dot {\\bf U}_t -2 \\ddot{\\bf U}_t\\) The response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with quantities at time \\(t + \\Theta \\Delta t\\) . \\[ \\texttt{theModel->setResponse}({\\bf U}_{t + \\theta \\Delta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\] current time is obtained from the AnalysisModel, incremented by \\(\\Theta \\Delta t\\) , and applyLoad ( time , 1.0 ) is invoked on the AnalysisModel. Finally updateDomain() is invoked on the AnalysisModel. The method returns \\(0\\) if successful, otherwise a negative number is returned: \\(-1\\) if \\(\\gamma\\) or \\(\\beta\\) are \\(0\\) , \\(-2\\) if dispFlag was true and \\(\\Delta t\\) is \\(0\\) , and \\(-3\\) if domainChanged() failed or has not been called. int update ( const Vector & $ \\ Delta U$ ); Invoked this first causes the object to increment the DOF_Group response quantities at time \\(t + \\Theta \\Delta t\\) . The displacement Vector is incremented by \\(c1 * \\Delta U\\) , the velocity Vector by \\(c2 * \\Delta U\\) , and the acceleration Vector by \\(c3 * \\Delta U\\) . The response quantities at the DOF_Group objects are then updated with the new approximations by invoking setResponse() on the AnalysisModel with displacements, velocities and accelerations at time \\(t + \\Theta \\Delta t\\) . Finally updateDomain() is invoked on the AnalysisModel. \\({\\bf U}_{t + \\theta \\Delta t} += \\Delta \\U\\) \\(\\dot {\\bf U}_{t + \\theta \\Delta t} += \\frac{3}{\\theta \\Delta t} \\Delta \\U\\) \\(\\ddot {\\bf U}_{t + \\theta \\Delta t} += \\frac{6}{\\theta^2 \\Delta t^2} \\Delta \\U\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\alpha \\theta t}, \\dot{\\bf U}_{t+\\theta \\Delta t}, \\ddot{\\bf U}_{t+ \\theta \\Delta t})\\) theModel- \\(>\\) updateDomain() Returns \\(0\\) if successful. A warning message is printed and a negative number returned if an error occurs: \\(-1\\) if no associated AnalysisModel, \\(-2\\) if the Vector objects have not been created, \\(-3\\) if the Vector objects and \\(\\Delta U\\) are of different sizes. int commit ( void ); First the quantities at time \\(t + \\Delta t\\) are determined using the quantities at time \\(t\\) and \\(t + \\Theta \\Delta t\\) . Then the response quantities at the DOF_Group objects are updated with the new approximations by invoking setResponse() on the AnalysisModel with displacement, velocity and accelerations at time \\(t + \\Delta t\\) . The time is obtained from the AnalysisModel and \\((\\Theta - 1) \\Delta t\\) is subtracted from the value. The time is set in the Domain by invoking setCurrentDomainTime(time) on the AnalysisModel. Finally updateDomain() and commitDomain() are invoked on the AnalysisModel. \\(\\ddot{\\bf U}_{t + \\Delta t} = \\ddot{\\bf U}_t + \\frac{1}{\\theta} \\left( \\ddot{\\bf U}_{t + \\theta \\Delta t} - \\ddot{\\bf U}_t \\right)\\) \\(\\dot{\\bf U}_{t + \\Delta t} = \\dot{\\bf U}_t + \\frac{\\Delta t}{2}\\left( \\ddot{\\bf U}_{t + \\Delta t} + \\ddot{\\bf U}_t \\right)\\) \\({\\bf U}_{t + \\Delta t} = {\\bf U}_t + \\Delta t\\dot{\\bf U}_t + \\frac{\\Delta t^2}{6}\\left( \\ddot{\\bf U}_{t + \\Delta t} + 2 \\ddot{\\bf U}_t \\right)\\) theModel- \\(>\\) setResponse \\(({\\bf U}_{t + \\Delta t}, \\dot{\\bf U}_{t+ \\Delta t}, \\ddot{\\bf U}_{t+\\Delta t})\\) time = theModel- \\(>\\) getDomainTime() time -= \\((\\theta -1) * \\Delta t\\) theModel- \\(>\\) setTime(time) theModel- \\(>\\) commitDomain() Returns \\(0\\) if successful, a warning message and a negative number if not: \\(-1\\) if no AnalysisModel associated with the object and \\(-2\\) if commitDomain() failed. int sendSelf ( int commitTag , Channel & theChannel ); Places \\(\\Theta\\) , rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) in a vector if size 4 and invokes sendVector on the Channel with this Vector. Returns \\(0\\) if successful, a warning message is printed and a \\(-1\\) is returned if theChannel fails to send the Vector. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 4 the value of \\(\\Theta\\) , the rayleigh damping flag, \\(\\alpha_M\\) and \\(\\beta_K\\) .. Returns \\(0\\) if successful, a warning message is printed, \\(\\Theta\\) is set to \\(0\\) , the rayleigh damping flag to false , and a \\(-1\\) is returned if theChannel fails to receive the Vector. int Print ( OPS_Stream & s , int flag = 0 ); The object sends to \\(s\\) its type, the current time, \\(\\alpha\\) , \\(\\gamma\\) and \\(\\beta\\) .","title":"WilsonTheta\n"},{"location":"libraries/analysis/constraint_enforcement/Lagrange/","text":"Lagrange This command is used to construct a LagrangeMultiplier constraint handler, which enforces the constraints by introducing Lagrange multiplies to the system of equation. The following is the command to construct a plain constraint handler: constraints Lagrange < $alphaS $alphaM > $alphaS \\(\\alpha_S\\) factor on singe points. optional, default = 1.0 $alphaM \\(\\alpha_M\\) factor on multi-points, optional default = 1.0; NOTES: The Lagrange multiplier method introduces new unknowns to the system of equations. The diagonal part of the system corresponding to these new unknowns is 0.0. This ensure that the system IS NOT symmetric positive definite. THEORY: Code Developed by: fmk C++ Interface #include <analysis/handler/LagrangeConstraintHandler.h> class LagrangeConstraintHandler : public ConstraintHandler ; The LagrangeConstraintHandler class is a class which deals with both single and multi point constraints using the Lagrange method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating a LagrangeDOF_Group object and either a LagrangeSP_FE or a LagrangeMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by modifying the tangent matrix and residual vector. The integer HANDLER_TAG_LagrangeConstraintHandler (defined in <classTags.h> ) is passed to the LagrangeConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the LagrangeSP_FE and LagrangeMP_FE objects in handle() . Destructor Currently invokes clearAll() , this will change when clearAll() is rewritten. Methods Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mappinging between Elements and FE_Elements, SP_Constraints and LagrangeSP_FEs, MP_Constraints and LagrangeMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a LagrangeSP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a LagrangeMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf ( int commitTag , Channel & theChannel ); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Lagrange\n"},{"location":"libraries/analysis/constraint_enforcement/Penalty/","text":"Penalty #include <analysis/handler/PenaltyConstraintHandler.h> class PenaltyConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The PenaltyConstraintHandler class is a class which deals with both single and multi point constraints using the penalty method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a PenaltySP_FE or a PenaltyMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PenaltyConstraintHandler (defined in <classTags.h> ) is passed to the PenaltyConstraintHandler constructor. Stores alphaSP and alphaMP which are needed to construct the PenaltySP_FE and PenaltyMP_FE objects in handle() . Currently invokes clearAll() , this will change when clearAll() is rewritten. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements, SP_Constraints and PenaltySP_FEs, MP_Constraints and PenaltyMP_FEs and Nodes and DOF_Groups). Creates two arrays of pointers to store the FE_Elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. The object then iterates through the SP_Constraints of the Domain creating a PenaltySP_FE for each constraint, using the Domain, the constraint and alphaSP as the arguments in the constructor. The object then iterates through the MP_Constraints of the Domain creating a PenaltyMP_FE for each constraint, using the Domain, the constraint and alphaMP as the arguments in the constructor. Finally the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . virtual void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Sends in a Vector of size 2 alphaSP and alphaMP . Returns \\(0\\) if successful. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Receives in a Vector of size 2 the values alphaSP and alphaMP . Returns \\(0\\) if successful.","title":"Penalty\n"},{"location":"libraries/analysis/constraint_enforcement/Plain/","text":"Plain #include <analysis/handler/PlainHandler.h> class PlainHandler: public ConstraintHandler MovableObject ConstraintHandler The PlainHandler class is a class which only deals with homogeneous single point constraints. To do this it creates regular FE_Element and DOF_Group objects and enforces the constraints by specifying that degrees-of-freedom which are constrained are not assigned an equation number. Pointers to the DOF_Group and FE_Element objects are kept in two arrays. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_PlainHandler (defined in <classTags.h> ) is passed to the PlainHandler constructor. Invokes the destructor on all the FE_Element and DOF_Group objects created in handle . Then invokes the destructor on the two pointer arrays. Determines the number of FE_Elements and DOF_Groups needed from the Domain (a one to one mapping between Elements and FE_Elements and Nodes and DOF_Groups) Creates two arrays of pointers to store the FE_elements and DOF_Groups, returning a warning message and a \\(-2\\) or \\(-3\\) if not enough memory is available for these arrays. Then the object will iterate through the Nodes of the Domain, creating a DOF_Group for each node and setting the initial id for each dof to \\(-2\\) if no SP_Constraint exists for the dof, or \\(-1\\) if a SP_Constraint exists or \\(-3\\) if the node identifier is in nodesToBeNumberedLast . The object then iterates through the Elements of the Domain creating a FE_Element for each Element, if the Element is a Subdomain setFE_ElementPtr() is invoked on the Subdomain with the new FE_Element as the argument. If not enough memory is available for any DOF_Group or FE_Element a warning message is printed and a \\(-4\\) or \\(-5\\) is returned. If any MP_Constraint objects exist in the Domain a warning message is printed and \\(-6\\) is returned. If all is successful, the method returns the number of degrees-of-freedom associated with the DOF_Groups in nodesToBeNumberedLast . void clearAll ( void ) = 0 ; Currently this invokes delete on all the FE_Element and DOF_Group objects created in handle() and the arrays used to store pointers to these objects. FOR ANALYSIS INVOLVING DYNAMIC LOAD BALANCING, RE-MESHING AND CONTACT THIS MUST CHANGE. int sendSelf(int commitTag, Channel &theChannel); Returns \\(0\\) . int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) .","title":"Plain\n"},{"location":"libraries/analysis/constraint_enforcement/Transformation/","text":"Transformation UNDER CONSTRUCTION. #include <analysis/handler/TransformationConstraintHandler.h> class TransformationConstraintHandler : public ConstraintHandler MovableObject ConstraintHandler The TransformationConstraintHandler class is a class which deals with both single and multi point constraints using the Transformation method. This is done by, in addition to creating a DOF_Group object for each Node and an FE_Element for each Element in the Domain, creating either a TransformationSP_FE or a TransformationMP_FE object for each constraint in the Domain. It is these objects that enforce the constraints by moifying the tangent matrix and residual vector. Constructor ### Destructor // Public Methods The integer HANDLER_TAG_TransformationConstraintHandler (defined in <classTags.h> ) is passed to the TransformationConstraintHandler constructor. Currently invokes clearAll() , this will change when clearAll() is rewritten.","title":"Transformation\n"},{"location":"libraries/analysis/nonlinear_solve/30-BFGS%20Algorithm/","text":"This command is used to construct a Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm object. The BFGS method is one of the most effective matrix-update or quasi Newton methods for iteration on a nonlinear system of equations. The method computes new search directions at each iteration step based on the initial jacobian, and subsequent trial solutions. The unlike regular Newton-Raphson does not require the tangent matrix be reformulated and refactored at every iteration, however unlike ModifiedNewton it does not rely on the tangent matrix from a previous iteration. algorithm BFGS REFERNCES: Denis, J.E \"A Brief Survey of Convergence Methods for Quasi_Newton Methods\", SIAMS-AMS Proceedings, Vol (9), 185-200, 1976. K.J. Bathe and A.P.Cimento \"Some Practical Procedures for the Solution of Nonlinear Finte Element Equations\", Computer Methods in Applied Mechanics and Engineering, Vol(22) 59-85, 1980. THEORY: Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/356-Krylov-Newton%20Algorithm/","text":"This command is used to construct a KrylovNewton algorithm object which uses a Krylov subspace accelerator to accelerate the convergence of the modified newton method. The command is of the following form: algorithm KrylovNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim> $tangIter tangent to iterate on, options are current, initial, noTangent. default is current. $tangIncr tangent to increment on, options are current, initial, noTangent. default is current $maxDim max number of iterations until the tangent is reformed and the acceleration restarts (default = 3). NOTES: REFERENCES: Scott, M.H. and G.L. Fenves. \"A Krylov Subspace Accelerated Newton Algorithm: Application to Dynamic Progressive Collapse Simulation of Frames.\" Journal of Structural Engineering, 136(5), May 2010. DOI Code Developed by: <span style=\"color:blue\"> Michael Scott, Oregon State University </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/368-Linear%20Algorithm/","text":"This command is used to construct a Linear algorithm object which takes one iteration to solve the system of equations. <math> \\Delta U = - K^{-1}R(U),\\!</math> algorithm Linear <-initial> <-factorOnce> -secant optional flag to indicate to use secant stiffness -initial optional flag to indicate to use initial stiffness -factorOnce optional flag to indicate to only set up and factor matrix once NOTES 1) as the tangent matrix typically will not change during the analysis in case of an elastic system it is highly advantageous to use the -factorOnce option. Do not use this option if you have a nonlinear system and you want the tangent used to be actual tangent at time of the analysis step. Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/398-Modified%20Newton%20Algorithm/","text":"This command is used to construct a ModifiedNewton algorithm object, which uses the modified newton-raphson algorithm to solve the nonlinear residual equation. The command is of the following form: algorithm ModifiedNewton <-initial> -initial optional flag to indicate to use initial stiffness iterations. NOTES: THEORY: The theory for the ModifiedNewton method is similar to that for the Newton-Raphson method . The difference is that the tangent at the initial guess is used in the iterations, instead of the current tangent. The Modified Newmark method is thus an iterative method in which, starting at a good initial guess <math>U_0</math> we keep iterating until <math>\\Delta U</math> is small enough using the following: : <math> \\Delta U = - K_0^{-1}R(U_n),\\!</math> : <math> U_{n+1} = U_n + \\Delta U\\,\\!</math> where: <math>K_0 = \\frac{\\partial R(U_0)}{\\partial U}\\,\\!</math> The advantage of this method over the regular Newton method, is that the system Jacobian is formed only once at the start of the step and factored only once if a direct solver is used. The drawback of this method is that it requires more iterations than Newton's method. note: when -initial flag is provided <math>K_0</math> is Jacobian from undeformed configuration. Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/417-Newton%20Algorithm/","text":"This command is used to construct a NewtonRaphson algorithm object which is uses the Newton-Raphson algorithm to solve the nonlinear residual equation. The Newton-Raphson method is the most widely used and most robust method for solving nonlinear algebraic equations. The command is of the following form: algorithm Newton <-initial> <-initialThenCurrent> -initial optional flag to indicate to use initial stiffness iterations -initialThenCurrent optional flag to indicate to use initial stiffness on first step, then use current stiffness for subsequent steps REFERENCES: Read the page at Wikipedia THEORY: The Newton method used in finite element analysis is identical to that taught in basic calculus courses. It is just extended for the n unknown degrees-of-freedom. The method as taught in basic calculus, is a root-finding algorithm that uses the first few terms of the Taylor series of a function <math>f(x)\\,\\!</math> in the vicinity of a suspected root <math>x_n\\,\\!</math> to find the root <math>x_{n+1}\\,\\!</math>. Newton's method is sometimes also known as Newton's iteration, although in this work the latter term is reserved to the application of Newton's method for computing square roots. The Taylor series of <math>r(x)\\,\\!</math> about the point <math>x=x_n+\\Delta x\\,\\!</math> is given by : <math>f(x_n+\\Delta x) = f(x_n)+r^{'}(x_n)\\Delta x + 1/2r^{''}(x_n) \\Delta x^2+.\u2026\\,\\!</math> Keeping terms only to first order, <math>f(x_n+\\Delta x) \\approx f(x_n)+r^'(x_n)\\Delta x = f(x_n)+ \\frac{df(x_n)}{dx}\\Delta x</math> and since at the root we wish to find <math>x_n + \\Delta x</math>, the function equates to 0, i.e. <math>f(x_n+\\Delta x) = 0</math>, we can solve for an approximate <math>\\Delta x</math> : <math> \\Delta x \\approx -\\frac{f(x_n)}{f^'(x_n)} = - \\frac{df(x_n)}{dx}^{-1}f(x_n)</math> The Newmark method is thus an iterative method in which, starting at a good initial guess <math>x_0\\,\\!</math> we keep iterating until our convergence criteria is met with the following: : <math> \\Delta x = - \\frac{df(x_n)}{dx}^{-1}f(x_n)\\,\\!</math> : <math> x_{n+1} = x_n + \\Delta x\\,\\!</math> The method is generalized to n unknowns by replacing the above scalar equations with matrix ones. : <math>R(U_n+\\Delta x) = R(U_n)+\\frac{\\partial R(U_n)}{\\partial U} \\Delta U + O(\\Delta U ^2) \\,\\!</math> The matrix <math>\\frac{\\partial R(U_n)}{\\partial U}\\,\\!</math> is called the system Jacobian matrix and will be denoted K: : <math>K = \\frac{\\partial R(U_n)}{\\partial U}\\,\\!</math> resulting in our iterative procedure where starting from a good initial guess we iterate until our convergence criteria is met with the following: : <math> \\Delta U = - K^{-1}R(U_n),\\!</math> : <math> U_{n+1} = U_n + \\Delta U\\,\\!</math> Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/418-Newton%20with%20Line%20Search%20Algorithm/","text":"This command is used to construct a NewtonLineSearch algorithm object which introduces line search to the Newton-Raphson algorithm to solve the nonlinear residual equation. Line search increases the effectiveness of the Newton method when convergence is slow due to roughness of the residual. The command is of the following form: algorithm NewtonLineSearch <-type $typeSearch> <-tol $tol> <-maxIter $maxIter> <-minEta $minEta> <-maxEta $maxEta> $typeSearch line search algorithm. optional default is InitialInterpoled. valid types are: Bisection, Secant, RegulaFalsi, InitialInterpolated $tol tolerance for search. optional, defeulat = 0.8 $maxIter max num of iterations to try. optional, default = 10 $minEta a min <math>\\eta\\!</math> value. optional, default = 0.1 $maxEta a max <math>\\eta\\!</math> value. optional, default = 10.0 REFERENCES: M.A. Crisfield, \"Nonlinear Finite Element Analysis of Solids and Structures, Volume 1:Essentials\", Wiley, 1991. THEORY: The rationale behin line search is that: the direction <math>\\Delta U\\,\\!</math> found by the Newton-Raphson method is often a good direction, but the step size <math>\\parallel\\Delta U\\parallel</math> is not. It is cheaper to compute the residual for several points along <math>\\Delta U\\,\\!</math> rather than form and factor a new system Jacobian In NewtonLineSearch the regular Newton-Raphson method is used to compute the <math>\\Delta U\\,\\!</math>, but the update that is used is modified. The modified update is: : <math> U_{n+1} = U_n + \\eta \\Delta U\\,\\!</math> The different line search algorithms use different root finding methods to obtain <math>\\eta\\,\\!</math>, a root to the function <math>s(\\eta)</math> defined as: : <math> s(\\eta) = \\Delta U R(U_{n} + \\eta \\Delta U)\\,\\!</math> with <math> s_0 = \\Delta U R(U_n),\\!</math> Interpolated Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\frac{\\eta_n *s0}{s0 -s_{n+1}} ,\\!</math> } __NOTOC__ RegulaFalsi Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\eta_U - \\frac{s_U*(\\eta_L-\\eta_U)}{s_L-S_U} ,\\!</math> : if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> : if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Bisection Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\frac{\\eta_L - \\eta_U}{2.0} ,\\!</math> if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Secant Line Search: while (<math>\\frac{s_n}{s_0}\\!</math> > $tol && count < $maxIter} { : <math> \\eta_{n+1} = \\eta_j - \\frac{s_j*(\\eta_{j-1}-\\eta_j)}{s_{j-1}-S_j} ,\\!</math> : if <math> s_{n+1} * s_L < 0 \\Rightarrow \\eta_U = \\eta_{n+1}, s_U = s_{n+1},\\!</math> : if <math> s_{n+1} * s_U < 0 \\Rightarrow \\eta_L = \\eta_{n+1}, s_L = s_{n+1},\\!</math> } Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/618-Secant%20Newton%20Algorithm/","text":"This command is used to construct a SecantNewton algorithm object which uses the two-term update to accelerate the convergence of the modified newton method. The command is of the following form: algorithm SecantNewton <-iterate $tangIter> <-increment $tangIncr> <-maxDim $maxDim> $tangIter tangent to iterate on, options are current, initial, noTangent. default is current. $tangIncr tangent to increment on, options are current, initial, noTangent. default is current $maxDim max number of iterations until the tangent is reformed and acceleration restarts (default = 3) NOTES: The default \"cut-out\" values recommended by Crisfield (R1=3.5, R2=0.3) are used. REFERENCES: Crisfield, M.A. \"Non-linear Finite Element Analysis of Solids and Structures\", Vol. 1, Wiley, 1991. Code Developed by: <span style=\"color:blue\"> Michael Scott, Oregon State University </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/67-Broyden%20Algorithm/","text":"This command is used to construct a Broyden algorithm object for general unsymmetric systems which performs successive rank-one updates of the tangent at the first iteration of the current time step. algorithm Broyden <$count> $count number of iterations within a time step until a new tangent is formed Code Developed by: <span style=\"color:blue\"> fmk </span>","title":""},{"location":"libraries/analysis/nonlinear_solve/Linear/","text":"Linear #include <analysis/algorithm/equiSolnAlgo/Linear.h> class Linear : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The Linear class is an algorithmic class which uses the linear solution algorithm to solve the equations. This is based on a Taylor expansion of the linear system \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}_{a}\\) . \\[\\R(\\U) = \\R({\\bf U}_{a}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}_{a}}\\right] \\left( {\\bf U} - {\\bf U}_{a} \\right)\\] which can be expressed as: \\[{\\bf K}_{a} \\Delta {\\bf U} = {\\bf R}({\\bf U}_{a})\\] which is solved for \\(\\Delta \\U\\) to give the approximation \\({\\bf U} = {\\bf U}_{a} + \\Delta \\U\\) . To start the iteration \\({\\bf U}_a = {\\bf U}_\\text{trial}\\) , i.e. the current trial response quantities are chosen as approximate solution quantities. Constructor Destructor Public Methods // Public Methods for Output The integer EquiALGORITHM_TAGS_Linear (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. This method performs the linear solution algorithm: // form {\\bf K}_{a} theIntegrator -> formTangent () // form \\R({\\bf U}_{a}) theIntegrator -> formUnbalance () // solve for \\Delta \\U theSOE -> solveX () // set U = Ua + DU theIntegrator -> update ( theSOE -> getX ()) The method returns a 0 if successful, otherwise warning message is printed and a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. int sendSelf ( int commitTag , Channel & theChannel ); Does nothing. Returns 0. int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Does nothing. Returns 0. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string 'Linear Algorithm' to the stream.","title":"Linear\n"},{"location":"libraries/analysis/nonlinear_solve/ModifiedNewton/","text":"ModifiedNewton #include <analysis/algorithm/equiSolnAlgo/ModifiedNewton.h> class ModifiedNewton : public EquiSolnAlg ; MovableObject SolutionAlgorithm EquiSolnAlgo The ModifiedNewton class is an algorithmic class which obtains a solution to a non-linear system using the modified Newton-Raphson iteration scheme. The Newton-Rapson iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\(\\U{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[\\ {\\bf K}^{(i)} \\Delta \\U{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. in the modified version the tangent is formed only once, i.e \\[\\ {\\bf K}^{(1)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors and Destructors The constructor takes as an argument the ConvregenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_ModifiedNewton (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_ModofiedNewton. recvSelf() must be invoked on this object. ~ ModifiedNewton (); Does nothing. Public Methods int solveCurrentStep ( void ); When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the modified Newton-Raphson iteration algorithm: theTest -> start (); theIntegrator -> formTangent (); do { theIntegrator -> formUnbalance (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. void setTest ( ConvergenceTest & theTest ); A method to set the tolerance criteria of the algorithm to be equal to the value theTol . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. int recvSelf(int commitTag, Channel &theChannel, FEM_ObjectBroker &theBroker); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018ModifiedNewton\u2019 to the stream if flag equals \\(0\\) .","title":"ModifiedNewton\n"},{"location":"libraries/analysis/nonlinear_solve/NewtonRaphson/","text":"NewtonRaphson C++ Interface #include <analysis/algorithm/equiSolnAlgo/NewtonRaphson.h> class NewtonRaphson : public EquiSolnAlg ; MovableObject / SolutionAlgorithm / EquiSolnAlgo The NewtonRaphson class is an algorithmic class which obtains a solution to a non-linear system using the Newton-Raphson iteration scheme. The iteration scheme is based on a Taylor expansion of the non-linear system of equations \\(\\R(\\U) = \\zero\\) about an approximate solution \\({\\bf U}^{(i)}\\) : \\[\\R(\\U) = \\R({\\bf U}^{(i)}) + \\left[ {\\frac{\\partial \\R}{\\partial \\U} \\vert}_{{\\bf U}^{(i)}}\\right] \\left( {\\bf U} - {\\bf U}^{(i)} \\right)\\] which can be expressed as: \\[ {\\bf K}^{(i)} \\Delta {\\bf U}^{(i)} = \\R({\\bf U}^{(i)})\\] which is solved for \\(\\Delta {\\bf U}^{(i)}\\) to give approximation for \\({\\bf U}^{(i+1)} = {\\bf U}^{(i)} + \\Delta {\\bf U}^{(i)}\\) . To start the iteration \\({\\bf U}^{(1)} = {\\bf U}_{trial}\\) , i.e. the current trial response quantities are chosen as initial response quantities. To stop the iteration, a test must be performed to see if convergence has been achieved at each iteration. Each NewtonRaphson object is associated with a ConvergenceTest object. It is this object which determines if convergence has been achieved. Constructors Destructor // Public Member Functions // Public Methods for Output The constructor takes as an argument the ConvergenceTest object theTest , the object which is used at the end of each iteration to determine if convergence has been obtained. The integer EquiALGORITHM_TAGS_NewtonRaphson (defined in <classTags.h> ) is passed to the EquiSolnAlgo classes constructor. Provided for FEM_ObjectBroker to instantiate a blank object with a class tag of EquiALGORITHM_TAGS_NewtonRaphson is passed. recvSelf() must be invoked on this object. Does nothing. When invoked the object first sets itself as the EquiSolnAlgo object that the ConvergenceTest is testing and then it performs the Newton-Raphson iteration algorithm: theTest -> start () theIntegrator -> formUnbalance (); do { theIntegrator -> formTangent (); theSOE -> solveX (); theIntegrator -> update ( theSOE -> getX ()); theIntegrator -> formUnbalance (); } while ( theTest -> test () == false ) The method returns a 0 if successful, otherwise a negative number is returned; a \\(-1\\) if error during formTangent() , a \\(-2\\) if error during formUnbalance() , a \\(-3\\) if error during solve() , and a \\(-4\\) if error during update() . If an error occurs in any of the above operations the method stops at that routine, none of the subsequent operations are invoked. A \\(-5\\) is returned if any one of the links has not been setup. NOTE it is up to ConvergenceTest to ensure an infinite loop situation is not encountered. void setTest ( ConvergenceTest & theTest ); A method to set the ConvergenceTest object associated with the Algorithm to be theTest . int sendSelf ( int commitTag , Channel & theChannel ); Creates an ID object, puts the values of the theTest objects class and database tags into this ID. It then invokes sendVector() on the Channel object theChannel to send the data to the remote object. It then invokes sendSelf() on theTest . Returns \\(0\\) if successful, the channel error if not. * int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); Creates an ID object, invokes recvVector() on the Channel object. Uses the data in the ID to create a ConvergenceTest object of appropriate type and sets its dbTag. It then invokes recvSelf() on this test object. int Print ( OPS_Stream & s , int flag = 0 ); Sends the string \u2018NewtonRaphson\u2019 to the stream if flag equals \\(0\\) .","title":"NewtonRaphson\n"},{"location":"libraries/modeling/","text":"Modeling Capabilities Elements ( opensees.element ) Beam-column \u2013 3D elements with the following integration rules Linear elastic material (closed form), Concentrated plasticity integrated over specified hinge lengths, or Distributed plasticity integrated along the element length. Zero length \u2013 3D element which uses multiple uniaxial materials to model the element force-deformation relation. Truss \u2013 3D element with material non-linearity modeled by Uniaxial material stress-strain integrated over cross-sectional area, or Section force-deformation relationship. Quad \u2013 2D bilinear isoparametric element which uses ND materials at each of its integration points. Geometric Transforms Linear \u2013 first order geometry, P-Delta \u2013 second order \u201cleaning truss\u201d transformation, or Corotational \u2013 large displacement transformation. Cross Sections ( openseees.section ) Fiber \u2013 discretized by fibers which collectively define section response. The fiber models available are opensees.patch opensees.fiber opensees.layer Elastic \u2013 uncoupled axial and bending response. Uniaxial2d/3d \u2013 associates with a uniaxial material and enforces the Bernoulli beam assumption for axial and uni/bi-directional bending Generic1d/Nd \u2013 map stresses from uniaxial and ND materials to section stress resultants. For example, a uniaxial material can be used to model section moment-curvature behavior, or an ND plasticity model can be used to model section moment-axial-shear interaction. Aggregator \u2013 combination of a section and multiple uncoupled uniaxial materials used to define additional section force-deformation relations. For example, a fiber section can be combined with an uncoupled shear force-deformation relation. Backbone Materials Popovic\u2019s (Mander) Hognestad (Kent-Park) Uniaxial Materials ( opensees.uniaxial ) Core Elastic \u2013 linear elastic material tangent with optional linear damping tangent ElasticPP \u2013 elastic-perfectly plastic ElasticPPGap \u2013 one-sided EPP with an initial gap Hardening \u2013 bilinear model with combined linear isotropic and kinematic hardening Parallel \u2013 multiple uniaxial materials in parallel Series \u2013 multiple uniaxial materials in series FEDEAS Steel01 \u2013 bilinear steel model with linear kinematic and exponential isotropic hardening Concrete01 \u2013 concrete model with Kent-Park envelope, degraded linear unloading/reloading, and no tensile strength Hysteretic \u2013 trilinear backbone with pinching, damage, and degraded unloading stiffness SNAP BiLinear \u2013 bilinear hysteretic model with degradation Clough \u2013 Clough type hysteretic model with degradation Pinch \u2013 pinching hysteretic model with degradation ND Materials ElasticIsotropic \u2013 plane stress and plane strain formulations for use with the quad element.","title":"Modeling Capabilities\n"},{"location":"libraries/modeling/section/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } patch A patch is used to generate a number of fibers over a cross-sectional area. Currently there are three types of patches that fibers can be generated over: quadrilateral, rectangular and circular. All patches have the following attributes: area Total area of the patch. moic Second moment of area matrix of the patch about its centroidal axis ixc Second moment of inertia of the patch about its \\(x\\) axis iyc Second moment of inertia of the patch about its \\(y\\) axis fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). Fiber (coord, area, material, **kwds) coord [y,z] \\(y\\) and \\(z\\) coordinate of the fiber in the section (local coordinate system) y Num z Num area Num area of the fiber. material Ref(Material) material tag associated with this fiber (UniaxialMaterial tag for a FiberSection and NDMaterial tag for use in an NDFiberSection). rect (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num quad (material, divs, vertices, **kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [ij,jk] ij Int number of subdivisions (fibers) in the IJ direction. jk Int number of subdivisions (fibers) in the JK direction. vertices [[yI,zI],[yJ,zJ],[yK,zK],[yL,zL]] [yI,zI] Grp \\(y\\) & \\(z\\) -coordinates of vertex I (local coordinate system) yI Num zI Num [yJ,zJ] Grp \\(y\\) & \\(z\\) -coordinates of vertex J (local coordinate system) yJ Num zJ Num [yK,zK] Grp \\(y\\) & \\(z\\) -coordinates of vertex K (local coordinate system) yK Num zK Num [yL,zL] Grp \\(y\\) & \\(z\\) -coordinates of vertex L (local coordinate system) yL Num zL Num circ (material, \u2003\u2003\u2003divs, \u2003\u2003\u2003center, \u2003\u2003\u2003intRad, \u2003\u2003\u2003extRad, \u2003\u2003\u2003startAng, \u2003\u2003\u2003endAng, \u2003\u2003\u2003**kwds) material Ref(Material) tag of previously defined material ( UniaxialMaterial tag for a FiberSection or NDMaterial tag for use in an NDFiberSection ) divs [circ,rad] circ Int number of subdivisions (fibers) in the circumferential direction (number of wedges) rad Int number of subdivisions (fibers) in the radial direction (number of rings) center = [0.0, 0.0] [y,z] \\(y\\) & \\(z\\) -coordinates of the center of the circle y Num z Num intRad Num internal radius extRad Num external radius startAng Num starting angle endAng = 6.283185307179586 Num ending angle line (material, divs, fiber_area, vertices, **kwds) material Ref(Material) Reference to previously created material ( UniaxialMaterial for a FiberSection or NDMaterial for use in an NDFiberSection ) divs Int number of fibers along line area Num area of each fiber vertices [[y,z],[y,z]] start [y,z] \\(y\\) and \\(z\\) -coordinates of first fiber in line (local coordinate system) y Num z Num end [y,z] \\(y\\) and \\(z\\) -coordinates of last fiber in line (local coordinate system) y Num z Num","title":"patch\n"},{"location":"libraries/modeling/backbone/ArctangentBackbone/","text":"Arctangent This file contains the implementation of ArctangentBackbone, which is a continuous function given by K1*atan(K2*strain) as developed by Ranzo and Petrangeli (1998) Written: MHS Created: Aug 2000 class ArctangentBackbone : public HystereticBackbone { public : ArctangentBackbone ( int tag , double K1 , double gammaY , double alpha ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double K1 ; double K2 ; double gammaY ; double alpha ; };","title":"Arctangent\n"},{"location":"libraries/modeling/backbone/CappedBackbone/","text":"Capped This file contains the implementation of CappedBackbone, which overlays two backbone curves. Written: MHS Created: Aug 2000 class CappedBackbone : public HystereticBackbone { public : CappedBackbone ( int tag , HystereticBackbone & backbone , HystereticBackbone & cap ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : HystereticBackbone * theBackbone ; HystereticBackbone * theCap ; double eCap ; };","title":"Capped\n"},{"location":"libraries/modeling/backbone/CementedSoil/","text":"CementedSoil the Evans and Duncan (1982) SILT model at http://www.findapile.com/p-y-curves/p-y-curves-models class CementedSoil : public HystereticBackbone { public : CementedSoil ( int tag , double pM , double pU , double Kpy , double z , double b ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : double pm ; double pu ; double kpy ; double depth ; double diameter ; };","title":"CementedSoil\n"},{"location":"libraries/modeling/backbone/LinearCappedBackbone/","text":"LinearCapped This file contains the implementation of LinearCappedBackbone, which is a linear cap given by a cap deformation and a slope imposed on a hysteretic backbone. Written: MHS Created: Aug 2000 class LinearCappedBackbone : public HystereticBackbone { public : LinearCappedBackbone ( int tag , HystereticBackbone & backbone , double def , double slope , double resStrength ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); private : HystereticBackbone * theBackbone ; double eCap ; double sCap ; double E ; double eRes ; double sRes ; };","title":"LinearCapped\n"},{"location":"libraries/modeling/backbone/LiquefiedSand/","text":"LiquefiedSand https://www.pilegroups.com/single-post/p-y-curve-model-of-liquefied-sand-rollins-et-al-2005 class LiquefiedSand : public HystereticBackbone { public : LiquefiedSand ( int tag , double x , double d , double kn , double m ); private : double X ; double D ; double kN ; double meter ; double yu ; };","title":"LiquefiedSand\n"},{"location":"libraries/modeling/backbone/ManderBackbone/","text":"Mander This file contains the implementation of ManderBackbone, which the concrete backbone function given by Mander, Priestly, and Park (1988) Written: MHS Created: Mar 2001 class ManderBackbone : public HystereticBackbone { public : ManderBackbone ( int tag , double fc , double epsc , double Ec ); private : double fpc ; double epsc ; double Ec ; };","title":"Mander\n"},{"location":"libraries/modeling/backbone/MaterialBackbone/","text":"Material Description: This file contains the implementation of MaterialBackbone, which treats a uniaxial material as a hysteretic backbone by removing path dependency, i.e. commitState is never called on the uniaxial material. Written: MHS Created: Aug 2000 C++ Interface class MaterialBackbone : public HystereticBackbone { public : MaterialBackbone ( int tag , UniaxialMaterial & material ); private : UniaxialMaterial * theMaterial ; };","title":"Material\n"},{"location":"libraries/modeling/backbone/MultilinearBackbone/","text":"Multilinear MultilinearBackbone is a backbone defined by many points. C++ Interface class MultilinearBackbone : public HystereticBackbone { public : MultilinearBackbone ( int tag , int numPoints , const Vector & e , const Vector & s ); private : double * E ; double * e ; double * s ; double * c ; int numPoints ; }; Written: MHS Created: Aug 2000","title":"Multilinear\n"},{"location":"libraries/modeling/backbone/RaynorBackbone/","text":"Raynor C++ Interface class RaynorBackbone : public HystereticBackbone { public : RaynorBackbone ( int tag , double es , double f1 , double f2 , double epsh , double epsm , double c1 , double ey ); private : double Es ; double fy ; double fsu ; double Epsilonsh ; double Epsilonsm ; double C1 ; double Ey ; };","title":"Raynor\n"},{"location":"libraries/modeling/backbone/ReeseSandBackbone/","text":"ReeseSand class ReeseSandBackbone : public HystereticBackbone { public : ReeseSandBackbone ( int tag , double kx , double ym , double pm , double yu , double pu ); private : double kx ; double ym ; double pm ; double yu ; double pu ; }; Written: MHS Created: Aug 2000","title":"ReeseSand\n"},{"location":"libraries/modeling/backbone/ReeseSoftClayBackbone/","text":"ReeseSoftClay Description: This file contains the implementation of ReeseSoftClayBackbone. class ReeseSoftClayBackbone : public HystereticBackbone { public : ReeseSoftClayBackbone ( int tag , double pu , double y50 , double n ); private : double pu ; double y50 ; double n ; }; Written: MHS Created: Aug 2000","title":"ReeseSoftClay\n"},{"location":"libraries/modeling/backbone/ReeseStiffClayAboveWS/","text":"ReeseStiffClayAboveWS Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 336 C++ Interface class ReeseStiffClayAboveWS : public HystereticBackbone { public : ReeseStiffClayAboveWS ( int tag , double pu , double y50 ); ReeseStiffClayAboveWS (); ~ ReeseStiffClayAboveWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double pu ; double y50 ; double hl ; };","title":"ReeseStiffClayAboveWS\n"},{"location":"libraries/modeling/backbone/ReeseStiffClayBelowWS/","text":"ReeseStiffClayBelowWS Response of Stiff Clay below the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 328 class ReeseStiffClayBelowWS : public HystereticBackbone { public : ReeseStiffClayBelowWS ( int tag , double esi , double y , double as , double pc ); ReeseStiffClayBelowWS (); ~ ReeseStiffClayBelowWS (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Esi ; double y50 ; double As ; double Pc ; };","title":"ReeseStiffClayBelowWS\n"},{"location":"libraries/modeling/backbone/TrilinearBackbone/","text":"Trilinear This file contains the implementation of TrilinearBackbone, which is a trilinear backbone Written: MHS Created: Aug 2000 class TrilinearBackbone : public HystereticBackbone { public : TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 , double e3 , double s3 ); TrilinearBackbone ( int tag , double e1 , double s1 , double e2 , double s2 ); TrilinearBackbone (); ~ TrilinearBackbone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double E1 , E2 , E3 ; double e1 , e2 , e3 ; double s1 , s2 , s3 ; };","title":"Trilinear\n"},{"location":"libraries/modeling/backbone/VuggyLimestone/","text":"VuggyLimestone Response of Stiff Clay above the water surface (https://ntrl.ntis.gov/NTRL/dashboard/searchResults/titleDetail/PB94108305.xhtml) page 348 class VuggyLimestone : public HystereticBackbone { public : VuggyLimestone ( int tag , double b , double su ); VuggyLimestone (); ~ VuggyLimestone (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double diameter ; double shearStrength ; };","title":"VuggyLimestone\n"},{"location":"libraries/modeling/backbone/WeakRock/","text":"WeakRock on page 56 of this manual https://www.dropbox.com/s/h3s9qvvz3pb4tlf/Weak%20Rock%20Reference%20Book.pdf?dl=0 class WeakRock : public HystereticBackbone { public : WeakRock ( int tag , double kir , double pur , double yrm ); WeakRock (); ~ WeakRock (); double getYieldStrain ( void ); HystereticBackbone * getCopy ( void ); void Print ( OPS_Stream & s , int flag = 0 ); int setVariable ( char * argv ); int getVariable ( int varID , double & theValue ); int sendSelf ( int commitTag , Channel & theChannel ); int recvSelf ( int commitTag , Channel & theChannel , FEM_ObjectBroker & theBroker ); protected : private : double Kir ; double pur ; double yrm ; };","title":"WeakRock\n"},{"location":"libraries/modeling/constraint/rigidBeam/","text":"h1 { font-family: var(--md-code-font-family); color: var(--md-code-fg-color) !important; font-feature-settings: \"kern\"; } RigidBeam RigidBeamLink (name, nodes, **kwds) name Tag nodes [nodes1,nodes2] nodes1 Ref(uniaxial) nodes2 Ref(uniaxial)","title":"RigidBeam\n"},{"location":"libraries/modeling/damping/rayleigh/","text":"Rayleigh","title":"Rayleigh\n"},{"location":"libraries/modeling/element/Brick/","text":"Brick?N The Eight Node Brick Element element Brick8N eletag? node1? node2? node3? node4? node5? node6? node7? node8? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, eight nodes ordered according to Figure 1 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick8N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cpqall\u201d, \u201cgausspoint\u201d, \u201cplastic\u201d or \u201cplasticGPC\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. If the stress states at all gauss points need to be printed, use the query \u201cpqall\u201d. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. But the coordinates have to be output separated. If one needs to output the gauss point coordinates together with the plastic strain, the query \u201cplasticGPC\u201d needs to be used. {#8node width=\u201c9.0cm\u201d} The Twenty Node Brick Element element Brick20N eletag? node1? node2? node3? node4? node5? node6? node7? node8? node9? node10? node11? node12? node13? node14? node15? node16? node17? node18? node19? node20? matTag? bf1? bf2? bf3? massDens? The Brick8N element is the standard eight node three dimensional element implemented based on tensor operation. The arguments to construct the element are its tag, eletag, twenty nodes ordered according to Figure 2 , the material tag, matTag, the body forces, bf1, bf2, bf3, and the mass density, massDens. By default, \\(3\\times 3 \\times 3\\) integration points are used. Users will be able to specify number of integration points very soon. The valid queries to a Brick20N element when creating an ElementRecorder are \u201cforce\u201d, \u201cstiffness\u201d, \u201cstress\u201d, \u201cpq\u201d, \u201cgausspoint\u201d, or \u201cplastic\u201d. For \u201cstress\u201d output, the six stress components from each Gauss point are output by the order: \\(\\sigma_x\\) , \\(\\sigma_y\\) , \\(\\sigma_z\\) , \\(\\tau_{xy}\\) , \\(\\tau_{xz}\\) , \\(\\tau_{yz}\\) . The stresses can also be output in \\(p\\) and \\(q\\) format by using query \u201cpq\u201d, where \\(p\\) is the hydrostatic pressure, while \\(q\\) is the equivalent deviatoric stress. In this case, the stress state at one gauss point is printed in the \\(pq\\) format. For \u201cgausspoint\u201d, the coordinates of all Gauss points are printed out. For \u201cplastic\u201d, the equivalent deviatoric plastic strain from each Gauss point is output in the same order as the coordinates are printed. {#20node width=\u201c9cm\u201d}","title":"Brick?N\n"},{"location":"libraries/modeling/element/dispBeamColumn/","text":"dispBeamColumn opensees.element.DisplBeamColumn opensees.element.ForceBeamColumn","title":"dispBeamColumn\n"},{"location":"libraries/modeling/element/zeroLength/","text":"ZeroLength opensees.element.ZeroLength","title":"ZeroLength\n"},{"location":"libraries/modeling/nD/BidirectionalMaterial/","text":"BidirectionalMaterial #include <material/nD/BidirectionalMaterial.h> class BidirectionalMaterial : public NDMaterial TaggedObject MovableObject Material NDMaterial BidirectionalMaterial is an implementation of NDMaterial. BidirectionalMaterial is a two-dimensional elasto-plastic material model with combined linear isotropic and kinematic hardening. The yield surface is circular with a specified radius. A radial return map algorithm is used in the state determination. Constructors Destructor // Public Methods // Public Methods for Output Constructs a BidirectionalMaterial whose unique integer among NDMaterials in the domain is given by tag . Sets the elastic modulus to E , initial yield stress to fy , and isotropic and kinematic hardening moduli to Hiso and Hkin , respectively. Sets all committed history variables to \\(0.0\\) . The integers tag and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Constructs a BidirectionalMaterial with tag 0. All material parameters and committed history variables are set to \\(0.0\\) . The integers 0 and ND_TAG_Bidirectional, defined in <classTags.h> , are passed to the NDMaterial constructor. Does nothing. Sets the trial strain of this material to be strain . Returns 0. Returns the current trial strain of this material. Returns the current stress computed by the radial return mapping algorithm. This is the 2d generalization of the 1d algorithm described in Simo & Hughes (1998), Box \\(1.5\\) . Returns the tangent consistent with the stress computed by the radial return mapping algorithm in getStress() . Sets the committed history variables to be their corresponding trial values. Returns 0. Does nothing. Returns 0. Sets all committed history variables to \\(0.0\\) . Returns 0. Returns a pointer to a new instance of BidirectionalMaterial with the same tag, elastic modulus, initial yield stress, and hardening moduli. Copies the committed history variables to the new object. It is up to the caller to invoke the destructor. Returns 0 if successful and a negative number if any of the send operation fails. Returns 0 if successful and a negative number if any of the receive operation fails. Prints the tag of this object and its elastic modulus, initial yield stress, and hardening moduli to the stream s .","title":"BidirectionalMaterial\n"},{"location":"libraries/modeling/nD/ElasticCrossAnisotropic/","text":"ElasticCrossAnisotropic","title":"ElasticCrossAnisotropic\n"},{"location":"libraries/modeling/nD/ElasticIsotropicPlaneStrain2D/","text":"ElasticIsotropicPlaneStrain2D #include <material/nD/ElasticIsotropicPlaneStrain2D.h> class ElasticIsotropicPlaneStrain2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStrain2D provides the implementation of an elastic isotropic material which exhibits plane strain behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStrain2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ \\begin{array}{ccc} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & 1-2\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStrain2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStrain2D\n"},{"location":"libraries/modeling/nD/ElasticIsotropicPlaneStress2D/","text":"ElasticIsotropicPlaneStress2D #include <material/nD/ElasticIsotropicPlaneStress2D.h> class ElasticIsotropicPlaneStress2D : public ElasticIsotropicMaterial TaggedObject MovableObject Material NDMaterial ElasticIsotropicMaterial ElasticIsotropicPlaneStress2D provides the implementation of an elastic isotropic material which exhibits plane stress behavior in two dimensions. Constructor ### Destructor // Public Methods To construct an ElasticIsotropicPlaneStress2D whose unique integer tag among NDMaterials in the domain is given by tag . The material model have Young\u2019s modulus E and Poisson\u2019s ratio v . Does nothing. Sets the value of the current trial strain vector, \\(\\myepsilon\\) , to be strain . Returns \\(0\\) . \\[\\myepsilon := \\left[ \\begin{array}{c} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ 2 \\gamma_{xy} \\end{array} \\right]\\] Returns the material stress vector, \\(\\mysigma\\) , for the current trial strain. \\[\\mysigma := \\left[ \\begin{array}{c} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\tau_{xy} \\end{array} \\right]\\] Returns the material tangent stiffness matrix, \\(\\D\\) . \\[\\D := \\frac{E}{1-\\nu^2} \\left[ \\begin{array}{ccc} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & 1-\\nu \\end{array} \\right]\\] Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . Returns a pointer to a new ElasticIsotropicPlaneStress2D, with the same values for tag , E , and \\(\\nu\\) . It is up to the caller to ensure that the destructor is invoked.","title":"ElasticIsotropicPlaneStress2D\n"},{"location":"libraries/modeling/nD/Template3Dep/","text":"Template Elasto-Plastic Framework Yield Surface Command set ys \"-YieldSurfaceType <parameter list>\" This command sets the yield surface variable ys to be the specified type. A list of paramaters can be passed to define the yield surface and the number of parameters depend on the type of yield surface. Valid strings for YieldSurfaceType are DP , VM , CC , and RMC01 , which are described in the following subsections. Drucker-Prager Yield Surface set ys \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Yield Surface set ys \"-VM\" VM stands for von Mises type, i.e. cylinder shaped yield surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Yield Surface set ys \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped yield surface. For CC type yield surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Yield Surface set ys \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped yield surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager yield surface. Potential Surface Command set ps \"-PotentialSurfaceType <parameter list>\" This command sets the potential surface variable ps to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for PotentialSurfaceType are DP , VM , and CC , which are described in the following subsections. Drucker-Prager Potential Surface set ps \"-DP\" DP stands for Drucker-Prager type, i.e. cone shaped potential surface. In this case, no parameter needs to be supplied since the slope \\(\\alpha\\) is treated as an internal variable. von Mises Potential Surface set ps \"-VM\" VM stands for von Mises type, i.e. cylinder shaped potential surface. In this case, no parameter needs to be supplied since the size of the cylinder is treated as an internal variable. Cam-Clay Potential Surface set ps \"-CC M?\" CC stands for Cam-Clay type, i.e. ellipsoid shaped potential surface. For CC type potential surface, the slope of the critical state line in p\u2013q space, i.e. M, need to be supplied. Rounded Mohr-Coulomb (Willam-Warnke) Potential Surface set ps \"-RMC01\" RMC01 stands for rounded Mohr-Coulomb (Willam-Warnke) type, i.e. cone shaped Potential surface. In this case, no parameter needs to be supplied, this is similar to the Drucker-Prager Potential surface. Evolution Law Command set el \"-EvolutionLawType <parameter list>\" This command sets the evolution law variable el to be the specified type. A list of paramaters can be passed to define the potential surface and the number of parameters depend on the type of potential surface. Valid strings for EvolutionLawType are Leq , NLp , and ``, which are described in the following subsections. Linear Scalar Evolution Law set el \"-Leq a?\" Leq stands for Linear Scalar Evolution Law. This hardening rule is based on the equivalent deviatoric plastic strain \\(\\epsilon_q^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any scalar internal variable, such as the slope of Drucker\u2013Prager yield surface, the diameter of von Mises yield surface, and so on. Nonlinear Scalar Evolution Law set el \"-NLp e0? lambda? kappa? \" NLp stands for Nonlinear Scalar Evolution Law. This hardening rule is based on the volumetic plastic strain \\(\\epsilon_p^{pl}\\) . In this case, parameters including void ration e0 , lambda and kappa need to be supplied. This hardening rule is primarily for the evolution of the tip stress \\(p^{'}_{o}\\) in Cam-Clay model. Linear Tensorial Evolution Law set et \"-LEij a?\" LEij stands for Linear Tensorial Evolution Law. This hardening rule is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, linear hardening coefficient a needs to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. Nonlinear Tensorial Evolution Law (Armstrong-Frederick model ) set et \"-NLEij ha? Cr?\" NLEij stands for Nonlinear Tensorial Evolution Law from Armstrong\u2013Frederick nonlinear model. This kinematic hardening law is based on the plastic strain \\(\\epsilon_{ij}^{pl}\\) . In this case, nonlinear hardening coefficients ha and Cr need to be supplied. This hardening rule can be applied to any tensorial internal variable, such as the the center \\(\\alpha_{ij}\\) of Drucker\u2013Prager yield surface or von Mises yield surface, and so on. EPState Command < set sts \"Sxx? Sxy? Sxz? Syx? Syy? Syz? Szx? Szy? Szz?\" > set eps \"<-NOD nt?> -NOS ns? sc1? sc2? ... <-stressp sts>\" First statement sets the initial stress tensor to variable sts (if it is not stated here, no initial stress by default). Second statement assigns to the Elasto-Plastic state variable eps the specified state parameters, including number of tensorial internal variables nt (if it is not stated here, \\(nt=0\\) by default), number of scalar internal variables ns and corresponding initial values sc1 , sc2 , ..., and initial stresses defined in $sts (if it has been previously defined). Template Elasto-Plastic Material Command nDMaterial Template3Dep mTag ? - YS $ ys ? - PS $ ps ? - EPS $ eps ? <- ELS1 $ el ?> <$- ELT1 et ?> A template elasto-plastic material is constructed using nDMaterial command. The argument mTag is used to uniquely identify this nDMaterial object among nDMaterial objects in the BasicBuilder object. The other parameters include previously defined yield surface object ys , potential surface object ps , elasto-plastic state object eps , scalar evolution law object el , and tensorial evolution law object et . Examples von Mises Model # Yield surface set ys \"-VM\" # Potential surface set ps \"-VM\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # EPState #______________k=f(Cu) set EPS \"-NOD 0 -NOS 1 20\"# # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 -YS $ys -PS $ps -EPS $EPS -ELS1 $ES1 Drucker\u2013Prager Model # Yield surface set ys \"-DP\" # Potential surface set ps \"-DP 0.1\" # Scalar evolution law: linear hardening coef = 1.0 set ES1 \"-Leq 1.10\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" # EPState #______________alpha___k set EPS \"-NOD 0 -NOS 2 0.2 0.0 -stressp $sts\" # # where #alpha = 2 sin(phi) / (3^0.5) / (3-sin(phi) ), phi is the friction angle # and k is the cohesion # Creating nDMaterial using Template Elastic-Plastic Model nDMaterial Template3Dep 1 - YS $ys - PS $ps - EPS $EPS - ELS1 $ES1 Cam-clay Model # Yield surface M = 1.2 set ys \"-CC 1.2\" # Potential surface M = 1.2 set ps \"-CC 1.2\" # Scalar evolution law___void ratio___Lamda___Kappa set ES1 \"-NLp 0.85 0.19 0.06\" # Initial stress set sts \"0.10 0 0 0 0.10 0 0 0 0.10\" #________________po set EPS \"-NOS 1 200.1 -stressp $sts\" # nDMaterial Template3Dep 1 - YS $ys - PS $ps - EPS $EPS - ELS1 $ES1","title":"Template Elasto-Plastic Framework\n"},{"location":"libraries/modeling/section/GenericSection1D/","text":"GenericSection1D #include <material/section/GenericSection1D.h> class GenericSection1D : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSection1D provides a wrapper around a UniaxialMaterial so that any UniaxialMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSection1D whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the UniaxialMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the UniaxialMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the UniaxialMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the UniaxialMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Sets the section flexibility matrix, \\(\\fsec\\) , to be the inverse of the result of invoking getTangent() on the UniaxialMaterial, then returns \\(\\fsec\\) . This function overrides the base class implementation. Returns the section flexibility matrix, \\(\\fsec\\) , from the previous trial state. This function overrides the base class implementation. Invokes commitState() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the UniaxialMaterial and returns the result of that invocation. Invokes revertToStart() on the UniaxialMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSection1D, using the same tag, UniaxialMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantity returned by this instance of GenericSection1D. Returns 1. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the UniaxialMaterial using the same values of s and flag .","title":"GenericSection1D\n"},{"location":"libraries/modeling/section/GenericSectionND/","text":"GenericSectionND #include <material/section/GenericSectionND.h> class GenericSectionND : public SectionForceDeformation TaggedObject MovableObject Material SectionForceDeformation GenericSectionND provides a wrapper around a NDMaterial so that any NDMaterial may be used to model section response. The design of this class follows the Object Adapter pattern in Design Patterns by Gamma et al. Constructor Destructor // Public Methods // Public Methods for Output Constructs a GenericSectionND whose unique integer tag among SectionForceDeformation objects in the domain is given by tag . Obtains a copy of the NDMaterial m via a call to getCopy() . The section code is set to be code . Invokes the destructor of the NDMaterial. Sets the trial section deformation vector, \\(\\esec\\) , to be def , then invokes setTrialStrain() on the NDMaterial. Returns the trial section deformation vector, \\(\\esec\\) . Sets the section resisting force, \\(\\ssec\\) , to be the result of invoking getStress() on the NDMaterial, then returns \\(\\ssec\\) . Returns the section resisting force, \\(\\ssec\\) , from the previous trial state. Sets the section tangent stiffness matrix, \\(\\ksec\\) , to be the result of invoking getTangent() on the NDMaterial, then returns \\(\\ksec\\) . Returns the section tangent stiffness matrix, \\(\\ksec\\) from the previous trial state. Invokes commitState() on the NDMaterial and returns the result of that invocation. Invokes revertToLastCommit() on the NDMaterial and returns the result of that invocation. Invokes revertToStart() on the NDMaterial and returns the result of that invocation. Returns a pointer to a new instance of GenericSectionND, using the same tag, NDMaterial reference, and code. It is up to the caller to ensure that the destructor is invoked. Returns the section ID code that indicates the type of response quantities returned by this instance of GenericSectionND. Returns the result of invoking getOrder() on the NDMaterial. FILL IN. FILL IN. Prints to the stream s the object\u2019s tag , then invokes Print() on the NDMaterial using the same values of s and flag .","title":"GenericSectionND\n"},{"location":"libraries/modeling/transform/Corotational/","text":"Corotational This command is used to construct the Corotational Coordinate Transformation ( CorotCrdTransf ) object. Corotational transformation can be used in large displacement-small strain problems. NOTE: Currently the transformation does not deal with element loads and will ignore any that are applied to the element. For a two-dimensional problem: geomTransf Corotational $transfTag <- jntOffset $dXi $dYi $dXj $dYj > For a three-dimensional problem: geomTransf Corotational $transfTag $vecxzX $vecxzY $vecxzZ $transfTag integer tag identifying transformation $vecxzX $vecxzY $vecxzZ X, Y, and Z components of vecxz, the vector used to define the local x-z plane of the local-coordinate system. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. These components are specified in the global-coordinate system X,Y,Z and define a vector that is in a plane parallel to the x-z plane of the local-coordinate system. These items need to be specified for the three-dimensional problem. $dXi $dYi joint offset values -- absolute offsets specified with respect to the global coordinate system for element-end node i (optional) $dXj $dYj joint offset values -- absolute offsets specified with respect to the global coordinate system for element-end node j (optional) The element coordinate system is specified as follows: The x-axis is the axis connecting the two element nodes; the y- and z-axes are then defined using a vector that lies on a plane parallel to the local x-z plane -- vecxz. The local y-axis is defined by taking the cross product of the vecxz vector and the x-axis. The z-axis by taking cross product of x and new y. The section is attached to the element such that the y-z coordinate system used to specify the section corresponds to the y-z axes of the element. Example Element 1 : tag 1 : vecxZ = zaxis tcl geomTransf Corotational 1 0 0 -1 Element 2 : tag 2 : vecxZ = y axis geomTransf Corotational 2 0 1 0 Code Developed by: Remo Magalhaes de Souza Images Developed by: Silvia Mazzoni","title":"Corotational\n"},{"location":"libraries/modeling/uniaxial/Concrete01/","text":"UNDER CONSTRUCTION. Concrete01 #include <material/Concrete01.h> class Concrete01: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial Provides a uniaxial Kent-Scott-Park concrete model with linear unloading/reloading according to the work of Karsan-Jirsa and no strength in tension. The model contains a compressive strength of fpc, a strain at the compressive strength of epsc0, a crushing strength of fpcu, and a strain at the crushing strength of epscu. Compressive concrete parameters should be input as negative numeric values for this model to behave properly. Specification of minimum and maximum failure strains through the -min and -max switches is optional. The argument matTag is used to uniquely identify the material object among material objects in the BasicBuilder object. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"Concrete01\n"},{"location":"libraries/modeling/uniaxial/ElasticMaterial/","text":"ElasticMaterial #include <material/ElasticMaterial.h> class ElasticMaterial : public MaterialModel \\ TaggedObject MovableObject MaterialModel UniaxialMaterial ElasticMaterial provides the abstraction of an elastic uniaxial material, i.e. the stress-strain relationship is given by the linear equation \\(\\sigma = E * \\epsilon\\) . Constructor ### Destructor // Public Methods // Public Methods for Output To construct an ElasticMaterial with an integer identifier tag , an elastic tangent modulus of \\(E\\) and a current strain \\(\\epsilon\\) of \\(0.0\\) . The integers tag and MAT_TAG_ElasticMaterial, defined in <classTags.h> , are passed to the UniaxialMaterial classes constructor. Does nothing. Sets the value of the trial strain, \\(\\epsilon\\) to be strain . Returns \\(0\\) . Returns the product of \\(E * \\epsilon\\) , where \\(\\epsilon\\) is the current trial strain. Returns the value of \\(E\\) passed in the constructor. Returns \\(0\\) . Returns \\(0\\) . Returns \\(0\\) . returns a pointer to a new ElasticMaterial object, constructed using the same values of tag and \\(E\\) . It is up to the caller to ensure that the destructor is invoked. Creates a Vector of size \\(2\\) into which it places tag and E . Invokes sendVector() on theChannel using the ElasticMaterialObjects dbTag , the integer commitTag and the Vector as arguments. Returns \\(0\\) if successful, a warning message and a negative number are returned if the Channel object fails to send the Vector. Creates a Vector of size \\(2\\) . Invokes recvVector() on theChannel using the ElasticMaterialObjects dbTag , the integer commitTag and the Vector as arguments. Using the data in the Vector to set it\u2019s tag and \\(E\\) . Returns \\(0\\) if successful, a warning message is printed, tag and \\(E\\) are set to \\(0.0\\) , and a negative number is returned if the Channel object fails to receive the Vector. Prints to the stream s the objects tag and \\(E\\) values.","title":"ElasticMaterial\n"},{"location":"libraries/modeling/uniaxial/ElasticPPMaterial/","text":"UNDER CONSTRUCTION. ElasticPPModel #include <material/ElasticPPModel.h> class ElasticPPMaterial: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial ElasticPPMaterial provides the abstraction of an elastic perfectly plastic uniaxial material, i.e. the stress-strain relationship is given by the linear equation \\(\\sigma = E * \\epsilon\\) while the material is elastic and \\(| \\sigma = E * \\epsilon_p |\\) while the material is undergoing plastic deformation. SOME MORE THEORY. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"ElasticPPModel\n"},{"location":"libraries/modeling/uniaxial/ParallelMaterial/","text":"UNDER CONSTRUCTION. POSSIBLE NAME CHANGE IF MATERIAL GENERAL. ParallelModel #include <material/ParallelModel.h> class ParallelModel: public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial A ParallelModel object is an aggregation of UniaxialMaterial objects all considered acting in parallel. SOME THEORY. Constructor ### Destructor // Public Methods // Public Methods for Output","title":"ParallelModel\n"},{"location":"libraries/modeling/uniaxial/Steel01/","text":"UNDER CONSTRUCTION. Steel01 #include <material/Steel01.h> class Steel01 : public MaterialModel TaggedObject MovableObject MaterialModel UniaxialMaterial Steel01 provides the abstraction of a bilinear steel model with isotropic hardening. The model contains a yield strength of fy, an initial elastic tangent of E0, and a hardening ratio of b. The optional parameters a1, a2, a3, and a4 control the amount of isotropic hardening (default values are provided). Specification of minimum and maximum failure strains through the -min and -max switches is optional and must appear after the specification of the hardening parameters, if present. The argument matTag is used to uniquely identify the material object among material objects in the BasicBuilder object. Constructor ### Destructor // Public Methods // Public Methods for Output // Private Methods Does nothing.","title":"Steel01\n"},{"location":"libraries/modeling/uniaxial/ConcreteCM/","text":"Developed and Implemented by: [mailto:kkolozvari@fullerton.edu Kristijan Kolozvari ], California State University, Fullerton Kutay Orakcal , Bogazici University, Istanbul, Turkey John Wallace , Univeristy of California, Los Angeles This command is used to construct a uniaxialMaterial ConcreteCM (Kolozvari et al., 2015), which is a uniaxial hysteretic constitutive model for concrete developed by Chang and Mander (1994). This model is a refined, rule-based, generalized, and non-dimensional constitutive model that allows calibration of the monotonic and hysteretic material modeling parameters, and can simulate the hysteretic behavior of confined and unconfined, ordinary and high-strength concrete, in both cyclic compression and tension (Figure 1). The model addresses important behavioral features, such as continuous hysteretic behavior under cyclic compression and tension, progressive stiffness degradation associated with smooth unloading and reloading curves at increasing strain values, and gradual crack closure effects. Details of the model are available in the report by Chang and Mander (1994). [[File:ConcreteCM_0.png|500px|thumb|center|Figure 1. Hysteretic Constitutive Model for Concrete by Chang and Mander (1994)]] The Chang and Mander (1994) model successfully generates continuous hysteretic stress-strain relationships with slope continuity for confined and unconfined concrete in both compression and tension. The compression envelope curve of the model is defined by the initial tangent slope, (E c ), the peak coordinate ( \\(\\epsilon\\) \u2019 c , f\u2019 c ), a parameter (r c ) from Tsai\u2019s (1988) equation defining the shape of the envelope curve, and a parameter ( \\(\\epsilon^-_{cr}\\) ) to define normalized (with respect to \\(\\epsilon\\) \u2019 c ) strain where the envelope curve starts following a straight line, until zero compressive stress is reached at the spalling strain, \\(\\epsilon\\) sp . These parameters can be controlled based on specific experimental results for a refined calibration of the compression envelope (Figure 2). Chang and Mander (1994) proposed empirical relationships for parameters E c , \\(\\epsilon'\\) c , and r c for unconfined concrete with compressive strength \\(f^\\prime_c\\) , based on review of previous research. Parameters \\(f^\\prime_c\\) , \\(\\epsilon^\\prime_c\\) , E c , r c , and \\(\\epsilon\\) - cr can also be calibrated to represent the stress-strain behavior of confined concrete in compression, to follow the constitutive relationships for confined concrete proposed by Mander et al (1988) or similar. [[File:ConcreteCM_1.png|500px|thumb|center|Figure 2. Compression and Tension Envelope Curves]] The shape of the tension envelope curve in the model is the same as that of the compression envelope; however, the tension envelope curve is shifted to a new origin that is based on the unloading strain from the compression envelope (Figure 2). As well, the strain ductility experienced previously on the compression envelope is also reflected on the tension envelope. The parameters associated with the tension envelope curve include the tensile strength of concrete ( \\(f_t\\) ), the monotonic strain at tensile strength ( \\(\\epsilon\\) t ), a parameter ( \\(r_t\\) ) from Tsai\u2019s (1988) equation defining the shape of the tension envelope curve, and a parameter ( \\(\\epsilon\\) + cr ) to define normalized (with respect to \\(\\epsilon\\) t ) strain where the tension envelope curve starts following a straight line, until zero tensile stress is reached at a strain of \\(\\epsilon\\) crk . These parameters can also be controlled and calibrated based on specific experimental results or empirical relations proposed by other researchers (e.g., Belarbi and Hsu, 1994) to model the behavior of concrete in tension and the tension stiffening phenomenon. Concrete experiencing tension stiffening can be considered not to crack completely; that is, a large value for parameter \\(\\epsilon\\) + cr (e.g., 10000) can be defined. Source: /usr/local/cvs/OpenSees/SRC/material/uniaxial/ Parameters {| | style=\u201cbackground:yellow; color:black; width:800px\u201d | uniaxialMaterial ConcreteCM $mattag $fpcc $epcc $Ec $rc $xcrn $ft $et $rt $xcrp <-GapClose $gap> |} {| | style=\u201cwidth:150px\u201d | $mattag || Unique \u2018\u2019uniaxialMaterial\u2019\u2019 tag |- | $fpcc || Compressive strength (f\u2019 c ) |- | $epcc || Strain at compressive strength ( \\(\\epsilon\\) \u2019 c ) |- | $Ec || Initial tangent modulus (E c ) |- | $rc || Shape parameter in Tsai\u2019s equation defined for compression (r c ) |- | $xcrn || Non-dimensional critical strain on compression envelope ( \\(\\epsilon\\) - cr , where the envelope curve starts following a straight line) |- | $ft || Tensile strength ( \\(f_t\\) ) |- | $et || Strain at tensile strength ( \\(\\epsilon\\) t ) |- | $rt || Shape parameter in Tsai\u2019s equation defined for tension ( \\(r_t\\) ) |- | $xcrp || Non-dimensional critical strain on tension envelope ( \\(\\epsilon\\) + cr , where the envelope curve starts following a straight line \u2013 large value [e.g., 10000] recommended when tension stiffening is considered) |- | <-GapClose $gap> || gap = 0, less gradual gap closure (default); gap = 1, more gradual gap closure |} Example uniaxialMaterial ConcreteCM 1 -6.2 -0.0021 4500 7 1.035 0.30 0.00008 1.2 10000 Example of hysteretic stress\u2013strain history generated by the model code is illustrated in Figure 3. [[File:ConcreteCM_2.PNG|500px|thumb|center|Figure 3. Concrete Stress-Strain Behavior]] ### Discussion An optional input parameter gap is introduced in the ConcreteCM model implemented in OpenSees for providing the users with the opportunity to control the intensity of gap closure in the stress-strain behavior of concrete, which in-turn influences the level of pinching in the lateral load-displacement behavior of a RC wall. The original Chang and Mander (1994) model adopts a non-zero tangent stiffness at zero stress level upon unloading from the tension envelope, which is represented by gap = 1 in ConcreteCM . Using gap = 0 (default) produces less gradual gap closure, since it assumes zero tangent stiffness at zero stress level upon unloading from the tension envelope, and is suitable for most analyses. Figure 4 illustrates the effect of plastic stiffness upon unloading from tension envelope ( \\(E^+_{pl}\\) ) on crack closure, i.e. use of more gradual ( gap = 1) or less gradual ( gap = 0) gap closure. The effect of parameter gap on predictions of flexural behavior of a RC wall is illustrated in Example 1 of [http://opensees.berkeley.edu/wiki/index.php/MVLEM_-_Multiple-Vertical-Line-Element-Model_for_RC_Walls MVLEM ] element. [[File:ConcreteCM_3.png|500px|thumb|center|Figure 4. Effect of Plastic Stiffness upon Unloading from Tension Envelope (Epl+) on Crack Closure]] Constitutive stress-strain concrete behavior is also implemented in OpenSees in uniaxialMaterial [http://opensees.berkeley.edu/wiki/index.php/Concrete07_%E2%80%93_Chang_%26_Mander%E2%80%99s_1994_Concrete_Model Cocnrete07 ]. However, ConcreteCM incorporates sophisticated unloading/reloading rules defined originally by Chang and Mander (1994), as opposed to Concrete07 that adopts simplified hysteretic rules. Comparison between stress-strain response predicted using ConcreteCM and Concrete07 is shown in Figure 5. [[File:ConcreteCMvsConcrete07.png|500px|thumb|center|Figure 5. Comparison of ConcreteCM and Concrete07]] References: Belarbi H. and Hsu T.C.C. (1994), \u201cConstitutive Laws of Concrete in Tension and Reinforcing Bars Stiffened by Concrete\u201d, ACI Structural Journal, V. 91, No. 4, pp. 465-474. Chang, G.A. and Mander, J.B. (1994), \u201cSeismic Energy Based Fatigue Damage Analysis of Bridge Columns: Part I \u2013 Evaluation of Seismic Capacity\u201d, NCEER Technical Report No. NCEER-94-0006, State University of New York, Buffalo. Kolozvari K., Orakcal K., and Wallace J. W. (2015). \u201cShear-Flexure Interaction Modeling of reinforced Concrete Structural Walls and Columns under Reversed Cyclic Loading\u201d, Pacific Earthquake Engineering Research Center, University of California, Berkeley, [http://peer.berkeley.edu/publications/peer_reports/reports_2015/webPEER-2015-12-kolozvari.pdf PEER Report No. 2015/12] Mander J.B., Priestley M.J.N., and Park R. (1988). \u201cTheoretical Stress-Strain Model for Confined Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 8, pp. 1804-1826. Orakcal K.(2004), \u201cNonlinear Modeling and Analysis of Slender Reinforced Concrete Walls\u201d, PhD Dissertation, Department of Civil and Environmental Engineering, University of California, Los Angeles. Tsai W.T. (1988), \u201cUniaxial Compressional Stress-Strain Relation of Concrete\u201d, ASCE Journal of Structural Engineering, V. 114, No. 9, pp. 2133-2136.","title":""},{"location":"libraries/modeling/uniaxial/PyTzQz/","text":"SimplePyTzQz","title":"SimplePyTzQz\n"},{"location":"libraries/modeling/uniaxial/PyTzQz/PySimple/","text":"PY Simple1 This command is used to construct a PySimple1 uniaxial material object: uniaxialMaterial PySimple1 $matTag $soilType $pult $Y50 $Cd < $c > Parameter Description matTag integer tag identifying material soilType soilType = 1 Backbone of p-y curve approximates Matlock (1970) soft clay relation. soilType = 2 Backbone of p-y curve approximates API (1993) sand relation. pult Ultimate capacity of the p-y material. Note that \u201cp\u201d or \u201cpult\u201d are distributed loads [force per length of pile] in common design equations, but are both loads for this uniaxialMaterial [i.e., distributed load times the tributary length of the pile]. Y50 Displacement at which 50% of pult is mobilized in monotonic loading. Cd Variable that sets the drag resistance within a fully-mobilized gap as Cd*pult . c The viscous damping term (dashpot) on the far-field (elastic) component of the displacement rate (velocity). (optional Default = 0.0). Nonzero c values are used to represent radiation damping effects Notes In general the HHT algorithm is preferred over a Newmark algorithm when using this material. This is due to the numerical oscillations that can develop with viscous damping forces under transient loading with certain solution algorithms and damping ratios. EQUATIONS and EXAMPLE RESPONSES The equations describing PySimple1 behavior are described in [1] Only minor changes have been made in its implementation for OpenSees. The nonlinear \\(p-y\\) behavior is conceptualized as consisting of elastic ( \\(p-y^e\\) ), plastic ( \\(p-y^p\\) ), and gap \\((p-y^g)\\) components in series. Radiation damping is modeled by a dashpot on the \u201cfar-field\u201d elastic component \\((p-y^e)\\) of the displacement rate. The gap component consists of a nonlinear closure spring ( \\(p^c-y^g\\) ) in parallel with a nonlinear drag spring \\((p^d-y^g)\\) . Note that \\(y = y^e + y^p + y^g\\) , and that \\(p = p^d + p^c\\) . The plastic component has an initial range of rigid behavior between \\(-C_r p_\\text{ult} < p < C_r p_\\text{ult}\\) where \\(C_r\\) is the ratio of \\(p/p_\\text{ult}\\) when plastic yielding first occurs in virgin loading. The rigid range of \\(p\\) , which is initially \\(2 C_r p_\\text{ult}\\) , translates with plastic yielding (kinematic hardening). The rigid range of \\(p\\) can be constrained to maintain a minimum size on both the positive and negative loading sides (e.g., 25% of \\(p\\text{ult}\\) ), and this is accomplished by allowing the rigid range to expand or contract as necessary. Beyond the rigid range, loading of the plastic \\((p-y^p)\\) component is described by: \\[p = p_{\\text{ult}} - (p_{\\text{ult}} - p_o) \\left [\\frac{c y_{50}}{c y_{50} + | z_p - z^p_0|} \\right ]^n \\] where \\(p_\\text{ult}\\) is the ultimate resistance of the \\(p-y\\) material in the current loading direction, \\(p_o = p\\) at the start of the current plastic loading cycle, \\(y^p_o = y_p\\) at the start of the current plastic loading cycle, \\(c\\) = constant to control the tangent modulus at the start of plastic yielding, and n = an exponent to control sharpness of the \\(p-y^p\\) curve. The closure \\((p^c-y^g)\\) spring is described by: \\[p^c = 1.8 p_{\\text{ult}} \\left [\\frac{y_{50}}{y_{50} + 50(y_o^\\text{+} - y^g)} - \\frac{y_{50}}{y_{50} + 50(y_o^\\text{-} - y^g)} \\right ] \\] where \\(y_o^+\\) is the memory term for the positive side of the gap, \\(y_o^-\\) = memory term for the negative side of the gap. The initial values of \\(y_o^+\\) and \\(y_o^-\\) were set as \\(y_{50}/100\\) and \\(- y_{50}/100\\) , respectively. The factor of 1.8 brings \\(p^c\\) up to \\(p_\\text{ult}\\) during virgin loading to \\(y_o^+\\) (or \\(y_o^-\\) ). Gap enlargement follows logic similar to that of Matlock et al. (1978). The gap grows on the positive side when the plastic deformation occurs on the negative loading side. Consequently, the \\(y_o^+\\) value equals the opposite value of the largest past negative value of, \\(y^p + y^g + 1.5 y_{50}\\) where the \\(1.5y_{50}\\) represents some rebounding of the gap. Similarly, the \\(y_o^-\\) value equals the opposite value of the largest past positive value of \\(y^p+y^g-1.5y_{50}\\) . This closure spring allows for a smooth transition in the load displacement behavior as the gap opens or closes. The nonlinear drag \\((p^d-y^g)\\) spring is described by: \\[p^d = C_d p_{\\text{ult}} - (C_d p_{\\text{ult}} - p^d_o) \\left [\\frac{y_{50}}{y_{50} + 2| y^g - y^g_o|} \\right ]^n\\] where \\(C_d\\) is the ratio of the maximum drag force to the ultimate resistance of the p-y material, \\(d^p_o =p^d\\) at the start of the current loading cycle, and \\(y^g_o = y^g\\) at the start of the current loading cycle. The flexibility of the above equations can be used to approximate different p-y backbone relations. Matlock\u2019s (1970) recommended backbone for soft clay is closely approximated using \\(c = 10\\) , \\(n = 5\\) , and \\(C_r = 0.35\\) . API\u2019s (1993) recommended backbone for drained sand is closely approximated using \\(c = 0.5\\) , \\(n = 2\\) , and \\(C_r = 0.2\\) . PySimple1 is currently implemented to allow use of these two default sets of values. Values of \\(p_\\text{ult}\\) , \\(y_{50}\\) , and \\(C_d\\) must then be specified to define the \\(p-y\\) material behavior. Viscous damping on the far-field (elastic) component of the p-y material is included for approximating radiation damping. For implementation in OpenSees the viscous damper is placed across the entire material, but the viscous force is calculated as proportional to the component of velocity (or displacement) that developed in the far-field elastic component of the material. For example, this correctly causes the damper force to become zero during load increments across a fully formed gap. In addition, the total force across the p-y material is restricted to pult in magnitude so that the viscous damper cannot cause the total force to exceed the near-field soil capacity. Users should also be familiar with numerical oscillations that can develop in viscous damper forces under transient loading with certain solution algorithms and damping ratios. In general, an HHT algorithm is preferred over a Newmark algorithm for reducing such oscillations in materials like PySimple1. [1]: Boulanger, R. W., Curras, C. J., Kutter, B. L., Wilson, D. W., and Abghari, A. (1999). \u201cSeismic soil-pile-structure interaction experiments and analyses.\u201d Journal of Geotechnical and Geoenvironmental Engineering, ASCE, 125(9): 750-759.","title":"PY Simple1\n"},{"location":"libraries/modeling/uniaxial/ScottHysteretic/","text":"ScottHysteretic uniaxialMaterial OOHysteretic tag ? bkbn +? unlRul +? stfDeg +? strDeg +? < bkbn- ? unlRul- ? stfDeg- ? strDeg- ?> < pinchX ? pinchY ?> HystereticBackbone hystereticBackbone type? tag? hystereticBackbone ReeseSoftClay tag? pu? y50? n? hystereticBackbone ReeseSand tag? kx? ym? pm? yu? pu? hystereticBackbone ReeseStiffClayBelowWS tag? Esi? y50? As? Pc? hystereticBackbone Raynor tag? Es? fy? fsu? Epsilonsh? Epsilonsm? C1? Ey? hystereticBackbone Capped tag? hystereticBackboneTag? capTag? hystereticBackbone LinearCapped tag? backboneTag? eCap? E? sRes? hystereticBackbone Material tag? matTag?\" << endln; hystereticBackbone Bilinear void *theBB = OPS_BilinearBackbone(rt); hystereticBackbone Trilinear void *theBB = OPS_TrilinearBackbone(rt); hystereticBackbone Multilinear void *theBB = OPS_MultilinearBackbone(rt); hystereticBackbone Arctangent void *theBB = OPS_ArctangentBackbone(rt); hystereticBackbone Mander void *theBB = OPS_ManderBackbone(rt); UnloadingRule unloadingRule type? tag? StiffnessDegradation StrengthDegradation strengthDegradation type? tag? Class Interface","title":"ScottHysteretic\n"},{"location":"libraries/numerics/","text":"Numeric Libraries Linear Equation Solvers The following methods provide the solution of the linear system of equations \\(Ku = P\\) . Each solver is tailored to a specific matrix topology. Profile SPD \u2013 Direct profile solver for symmetric positive definite matrices Band General \u2013 Direct solver for banded unsymmetric matrices Band SPD \u2013 Direct solver for banded symmetric positive definite matrices Sparse General \u2013 Direct solver for unsymmetric sparse matrices Sparse Symmetric \u2013 Direct solver for symmetric sparse matrices UmfPack General \u2013 Direct UmfPack solver for unsymmetric matrices Full General \u2013 Direct solver for unsymmetric dense matrices Conjugate Gradient \u2013 Iterative solver using the preconditioned conjugate gradient method Eigenvalue Solvers The following methods provide the solution of the generalized eigenvalue problem \\(Kv = MvL\\) Symmetric Arpack \u2013 Arpack solver for symmetric matrices Band Arpack \u2013 Arpack solver for banded matrices DOF Numberers The numbering of the degrees of freedom in the domain is done by the following methods Plain \u2013 Uses the numbering provided by the user RCM \u2013 Renumbers the DOF to minimize the matrix band-width using the Reverse Cuthill-McKee algorithm","title":"Numeric Libraries\n"},{"location":"libraries/numerics/EigenDecomp/ArpackSolver/","text":"ArpackSolver This is the solver that works on the ArpackSOE. It uses the LinearSOE in the SOE to perform the solve() operation if required. It uses the ARPACK library to perform the eigenvalue analysis. ARPACK is an eigen analysis package which was developed by R.B.Lehoucq, D.C.Sorensen and C.Yang at Rice University. ARPACK is a collection of FORTRAN77 subroutines designed to solve large scale eigen problems. ARPACK is capable of solving large scale non-Hermitian standard and generalized eigen problems. When the matrix K is symmetric, the method is a variant of the Lanczos process called Implicitly Restarted Lanczos Method (IRLM). It is based on previous work of Jun Peng(Stanford) Written : fmk Created : 05.09","title":"ArpackSolver\n"},{"location":"libraries/numerics/LinearSolve/BandGenLapack/","text":"BandGenLinLapackSolver This command is used to construct a BandGeneralSOE linear system of equation object. As the name implies, this class is used for matrix systems which have a banded profile. The matrix is stored as shown below in a one-dimensional array of size equal to the bandwidth times the number of unknowns. When a solution is required, the Lapack routines DGBSV and SGBTRS are used. Theory An \\(n\\timesn\\) matrix A =( a i,j ) is a band matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k 1 and k 2 : \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j<i-k_1 \\quad\\mbox{ or }\\quad j>i+k_2; \\quad k_1, k_2 \\ge 0.\\,\\] The quantities k 1 and k 2 are the left and right half-bandwidth , respectively. The bandwidth of the matrix is k 1 + k 2 + 1 (in other words, the smallest number of adjacent diagonals to which the non-zero elements are confined). and matrices are usually stored by storing the diagonals in the band; the rest is implicitly zero. For example, 6-by-6 a matrix with bandwidth 3: \\[\\begin{bmatrix} B_{11} & B_{12} & 0 & \\cdots & \\cdots & 0 \\\\ B_{21} & B_{22} & B_{23} & \\ddots & \\ddots & \\vdots \\\\ 0 & B_{32} & B_{33} & B_{34} & \\ddots & \\vdots \\\\ \\vdots & \\ddots & B_{43} & B_{44} & B_{45} & 0 \\\\ \\vdots & \\ddots & \\ddots & B_{54} & B_{55} & B_{56} \\\\ 0 & \\cdots & \\cdots & 0 & B_{65} & B_{66} \\end{bmatrix}\\] is stored as the 6-by-3 matrix \\[\\begin{bmatrix} 0 & B_{11} & B_{12}\\\\ B_{21} & B_{22} & B_{23} \\\\ B_{32} & B_{33} & B_{34} \\\\ B_{43} & B_{44} & B_{45} \\\\ B_{54} & B_{55} & B_{56} \\\\ B_{65} & B_{66} & 0 \\end{bmatrix}.\\] C++ Interface #include <system_of_eqn/linearSOE/bandGEN/BandGenLinLapackSolver.h> class BandGenLinLapackSolver : public BandGenLinSolver MovableObject Solver LinearSOESolver A BandGenLinLapackSolver object can be constructed to solve a BandGenLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the BandGenLinSOE class (see <BandGenLinSOE.h> ). Constructor ### Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the BandGenLinSolver constructor. Sets the size of iPiv to \\(0\\) , iPiv being an integer array needed by the LAPACK routines. Invokes delete on iPiv to free the memory allocated to store the array. The solver first copies the B vector into X and then solves the BandGenLinSOE system by calling the LAPACK routines dgbsv() , if the system is marked as not having been factored, and dgbtrs() if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is used to construct a 1d integer array, iPiv that is needed by the LAPACK solvers. It checks to see if current size of iPiv is large enough, if not it deletes the cold and creates a larger array. Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for this new array. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Code Developed by: fmk","title":"BandGenLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/BandSPDLapack/","text":"BandSPDLinLapackSolver system BandSPD This command is used to construct a BandSPDSOE linear system of equation object. As the name implies, this class is used for symmetric positive definite matrix systems which have a banded profile. The matrix is stored as shown below in a one dimensional array of size equal to the ( bandwidth /2) times the number of unknowns. When a solution is required, the Lapack routines DPBSV and DPBTRS are used. Theory An n \u00d7 n matrix A =( a i,j ) is a symmmetric banded matrix if all matrix elements are zero outside a diagonally bordered band whose range is determined by constants k : \\[a_{i,j}=0 \\quad\\mbox{if}\\quad j<i-k \\quad\\mbox{ or }\\quad j>i+k; \\quad k \\ge 0.\\,\\] \\[a_{i,j} = a_{j,i}\\,\\] \\[y^T A y != 0 \\,\\] for all non-zero vectors y with real entries ( \\(y \\in \\mathbb{R}^n\\) ), The bandwidth of the matrix is k + k + 1. For example, a symmetric 6-by-6 matrix with a right bandwidth of 2: \\[\\begin{bmatrix} A_{11} & A_{12} & A_{13} & 0 & \\cdots & 0 \\\\ & A_{22} & A_{23} & A_{24} & \\ddots & \\vdots \\\\ & & A_{33} & A_{34} & A_{35} & 0 \\\\ & & & A_{44} & A_{45} & A_{46} \\\\ & sym & & & A_{55} & A_{56} \\\\ & & & & & A_{66} \\end{bmatrix}.\\] This matrix is stored as the 6-by-3 matrix: \\[\\begin{bmatrix} A_{11} & A_{12} & A_{13} \\\\ A_{22} & A_{23} & A_{24} \\\\ A_{33} & A_{34} & A_{35} \\\\ A_{44} & A_{45} & A_{46} \\\\ A_{55} & A_{56} & 0 \\\\ A_{66} & 0 & 0 \\end{bmatrix}.\\] Code Developed by: fmk C++ #include <system_of_eqn/linearSOE/bandSPD/BandSPDLinLapackSolver.h> class BandSPDLinLapackSolver : public BandSPDLinSolver MovableObject Solver LinearSOESolver A BandSPDLinLapackSolver object can be constructed to solve a BandSPDLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the BandSPDLinSOE class. Constructor Destructor // Public Methods A unique class tag (defined in <classTags.h> ) is passed to the BandSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X and then solves the BandSPDLinSOE system by calling the LAPACK routines dpbsv() , if the system is marked as not having been factored, and dpbtrs() if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"BandSPDLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/FullGenLapack/","text":"FullGenLinLapackSolver #include <~/system_of_eqn/linearSOE/fullGEN/FullGenLinLapackSolver.h> class FullGenLinLapackSolver : public FullGenLinSolver MovableObject Solver LinearSOESolver A FullGenLinLapackSolver object can be constructed to solve a FullGenLinSOE object. It obtains the solution by making calls on the the LAPACK library. The class is defined to be a friend of the FullGenLinSOE class (see FullGenLinSOE ). Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the FullGenLinSolver constructor. Sets the size of iPiv to \\(0\\) , iPiv being an integer array needed by the LAPACK routines. Invokes delete on iPiv to free the memory it was allocated. First copies \\(B\\) into \\(X\\) and then solves the FullGenLinSOE system it is associated with (pointer kept by parent class) by calling the LAPACK routines dgesv() , if the system is marked as not having been factored, or dgetrs() , if system is marked as having been factored. If the solution is successfully obtained, i.e. the LAPACK routines return \\(0\\) in the INFO argument, it marks the system has having been factored and returns \\(0\\) , otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is used to construct a 1d integer array, iPiv that is needed by the LAPACK solvers. It checks to see if current size of iPiv is large enough, if not it deletes the cold and creates a larger array. Returns \\(0\\) if successful, prints a warning message and returns a \\(-1\\) if not enough memory is available for this new array. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"FullGenLinLapackSolver\n"},{"location":"libraries/numerics/LinearSolve/ITPACK/","text":"ITPACK Introduction For several years, we have been involved with the development and use of research-oriented programs using iterative algorithms for solving large sparse linear systems \\(Au = b\\) with positive diagonal elements. One solves for the N component unknown vector \\(u\\) given the \\({\\bf N \\times N}\\) nonsingular coefficient matrix \\(A\\) and the N component right-hand side vector \\(b\\) . The current ITPACK software package of subroutines, version 2C, provides for the use of seven alternative iterative procedures. While these subroutines are not designed as production software, they should successfully handle industrial problems of moderate size, that is, ones that fit in high-speed memory. This package is written in standard FORTRAN-66 code. It has been tested over a wide variety of computer systems using various FORTRAN compilers, including one which is FORTRAN-77 compatible (see Acknowledgements). The seven iterative solution modules are based on several basic iterative procedures, such as the Jacobi method, the Successive Overrelaxation (SOR) method, the Symmetric SOR (SSOR) method, and the RS method for the reduced system. With the exception of SOR, the convergence of these basic methods are accelerated by Chebyshev (Semi-Iteration, SI) or Conjugate Gradient (CG) acceleration. All methods are available with adaptive parameter estimation and automatic stopping tests. When using the RS method it is required that the linear system be reordered into a \u201cred-black\" 1 system [@6; @12] . A switch to compute, if possible, the red-black indexing, permute the linear system, and permute associated vectors is provided. The successful convergence of iterative methods may be dependent on conditions that are difficult to determine in advance. For example, determining whether the coefficient matrix is positive definite can be as costly to check as solving the system. On the other hand, some conditions affecting convergence, such as positive diagonal elements, diagonal dominance, and symmetry are relatively easy to verify. For some applications, the theory may not exist to guarantee the convergence of an iterative method. The algorithms in ITPACK have been tested most extensively for linear systems arising from elliptic partial differential equations. The routines can be applied, formally, to any linear system which fits in high-speed memory. However, rapid convergence, and indeed convergence itself cannot be guaranteed unless the matrix of the system is symmetric and positive definite. Success can be expected, though not guaranteed, for mildly nonsymmetric systems. In other words, iterative methods may not converge when applied to systems with coefficient matrices which are completely general with no special properties. This article discusses the usage of ITPACK and gives a few test results. The description of the iterative methods is given in [@4] . The underlying theory on which the iterative algorithms are based is described in [@6] . A survey of the iterative methods in ITPACK is presented in [@11] . Throughout this paper, we adopt notation such as SOR() when referring to a subroutine and A(*) for a single-dimensioned array. The residual vector is \\(b-Au^{(n)}\\) for the linear system \\(Au=b\\) and the pseudo-residual vector is \\(Gu^{(n)}+k-u^{(n)}\\) for a basic iterative method of the form \\(u^{(n+1)}=Gu^{(n)}+k\\) . The smallest and largest eigenvalues of the iteration matrix \\(G\\) are denoted \\(m(G)\\) and \\(M(G)\\) , respectively. Sparse Matrix Storage The sparse storage scheme used in ITPACK is a common one. It is a row-wise representation of the nonzero entries in the coefficient matrix of the linear system. For a nonsymmetric coefficient matrix, all of the nonzero values in each row are stored in a contiguous block of data in a real-valued array A(*) . If the matrix is symmetric, computer memory can be saved by storing only the nonzero entries in each row on and above the main diagonal. For either nonsymmetric or symmetric sparse storage, associated column numbers are stored in an integer-valued array JA(*) such that \\({\\bf JA(K)}\\) is the column number for the value \\({\\bf A(K)}\\) . A mapping vector IA(*) is used to denote the starting locations of each of the contiguous blocks. The beginning of the linear block for row \\(I\\) is given by \\({\\bf IA(I)}\\) , the end by \\({\\bf IA(I+1)-1}\\) , and its length by \\({\\bf IA(I+1)-IA(I)}\\) . Thus, IA(*) will contain \\({\\bf N+1}\\) elements to accommodate a linear system of order N . The entries for each row may be stored in any order in the contiguous block for that row. For example, the coefficient matrix \\[ \\left[\\begin{array}{ccccc} 11. & 0. & 0. & 14. & 15. \\\\ 0. & 22. & 0. & 0. & 0. \\\\ 0. & 0. & 33. & 0. & 0. \\\\ 14. & 0. & 0. & 44. & 45. \\\\ 15. & 0. & 0. & 45. & 55. \\end{array} \\right] \\] would be represented in nonsymmetric sparse storage as \\[\\begin{aligned} {\\bf A(*)} & = & [11.,14.,15.,22.,33.,14.,44.,45.,15.,45.,55.] \\\\ {\\bf JA(*)} & = & [1,4,5,2,3,1,4,5,1,4,5] \\\\ {\\bf IA(*)} & = & [1,4,5,6,9,12] \\end{aligned}\\] and in symmetric sparse storage as \\[\\begin{aligned} {\\bf A(*)} & = & [11.,14.,15.,22.,33.,44.,45.,55.] \\\\ {\\bf JA(*)} & = & [1, 4, 5, 2, 3, 4, 5, 5] \\\\ {\\bf IA(*)} & = & [1, 4, 5, 6, 8, 9]\\end{aligned}\\] Usage The user is expected to provide the coefficient matrix and the right-hand side of the linear system to be solved. The data structure for the matrix of the system is either the symmetric or nonsymmetric sparse storage format described in Section 2 . An initial guess for the solution should be provided, if one is known; otherwise, it can be set to all zero values. A series of approximations for the solution are generated iteratively until the convergence criteria is satisfied. The algorithms are performed in two work space arrays and some control over the algorithmic procedure can be obtained from switches in two parameter arrays. There are seven main subroutines in ITPACK, each corresponding to an iterative method. They are: Subroutine Method JCG() Jacobi Conjugate Gradient JSI() Jacobi Semi-Iteration SOR() Successive Overrelaxation SSORCG() Symmetric SOR Conjugate Gradient SSORSI() Symmetric SOR Semi-Iteration RSCG() Reduced System Conjugate Gradient RSSI() Reduced System Semi-Iteration and the calling sequence is: CALL \\(\\langle\\) method \\(\\rangle\\) (N, IA, JA, A, RHS, U, IWKSP, NW, WKSP, IPARM, RPARM, IER) where the parameters are defined in the following. Here \u201cinput\" means that the subroutine expects the user to provide the necessary input data and\u201doutput\" means that the routine passes back information in the variable or array indicated. All parameters are linear arrays except variables N , NW , and IER . Moreover, all parameters may be altered by the subroutine call except variables N and NW . (See Section 7 for additional details.) N is the order of the linear system. [integer; input] IA(*) is a vector of length \\({\\bf N+1}\\) used in the sparse matrix storage format. It contains the row pointers into JA(*) and A(*) . [integer array; input] JA(*) is a vector of length NZ (defined in A(*) below) used in the sparse matrix storage format. It contains the column numbers for the corresponding entries in A(*) . [integer array; input] A(*) is a vector of length NZ used in the sparse matrix storage format. It contains the nonzero entries of the coefficient matrix with positive diagonal elements. ( NZ is the number of nonzero entries in the upper triangular part of the coefficient matrix when symmetric storage is used and is the total number of nonzeros when nonsymmetric storage is used.) [real array; input] RHS(*) is a vector of length N containing the right-hand side of the linear system. [real array; input] U(*) is a vector of length N containing the initial guess to the solution of the linear system on input and the latest approximate solution on output. [real array; input/output] IWKSP(*) is a vector of length \\({\\bf 3*N}\\) used for integer workspace. When reindexing for red-black ordering, the first N locations contain on output the permutation vector for the red-black indexing, the next N locations contain its inverse, and the last N are used for integer workspace. 2 [integer array; output] NW is a scalar. On input, NW is the available length for WKSP(*) . On output, IPARM(8) is the actual amount used (or needed). [integer; input] WKSP(*) is a vector used for real working space whose length depends on the iterative method being used. It must be at least NW entries long. (See the table near the end of this section for the required amount of workspace for each method.) [real array] IPARM(*) is a vector of length 12 used to initialize various integer and logical parameters. Default values may be set by calling subroutine DFAULT() described below. On output, IPARM(*) contains the values of the parameters that were changed. (Further details are given later in this section.) [integer array; input/output] RPARM(*) is a vector of length 12 used to initialize various real parameters on input. Default values may be set by calling subroutine DFAULT() described below. On output, RPARM(*) contains the final values of the parameters that were changed. (Further details are given later in this section.) [real array; input/output] IER is the error flag which is set to zero for normal convergence and to a nonzero integer when an error condition is present. (See the table at the end of this section for the meaning of nonzero values.) [integer; output] The user may supply nondefault values for selected quantities in IPARM(*) and by first executing CALL DFAULT (IPARM, RPARM) and then assigning the appropriate nondefault values before calling a solution module of ITPACK. The iterative algorithms used in ITPACK are quite complicated and some knowledge of iterative methods is necessary to completely understand them. The interested reader should consult the technical report [@4] and the book [@6] for details. Important variables in this package which may change adaptively are CME (estimate of \\(M(B)\\) , the largest eigenvalue of the Jacobi matrix), SME (estimate of \\(m(B)\\) , the smallest eigenvalue of the Jacobi matrix), OMEGA (overrelaxation parameter \\(\\omega\\) for the SOR and SSOR methods), SPECR (estimated spectral radius of the SSOR matrix), BETAB (estimate for the spectral radius of the matrix \\(LU\\) where \\(L\\) and \\(U\\) are strictly lower and upper triangular matrices, respectively, such that the Jacobi matrix \\(B=L+U\\) ). The integer array IPARM(*) and real array RPARM(*) allow the user to control certain parameters which affect the performance of the iterative algorithms. Furthermore, these arrays allow the updated parameters from the automatic adaptive procedures to be communicated back to the user. The entries in IPARM(*) and RPARM(*) are: DIGIT1 is determined from the actual stopping test computed on the final iteration, whereas DIGIT2 is based on the computed residual vector using the final approximate solution after the algorithm has converged. If these values differ greatly, then either the stopping test has not worked successfully or the original system is ill-conditioned. (See [@6] for additional details.) For storage of certain intermediate results, the solution modules require a real vector WKSP(*) and a corresponding variable NW indicating the available space. The length of the workspace array varies with each solution module and the maximum amount needed is given in the following table. Solution Module Maximum Length of WKSP(*) JCG() \\({\\bf 4*N + NCG}\\) JSI() \\({\\bf 2*N}\\) SOR() \\({\\bf N}\\) SSORCG() \\({\\bf 6*N + NCG}\\) SSORSI() \\({\\bf 5*N}\\) RSCG() \\({\\bf N + 3*NB + NCG}\\) RSSI() \\({\\bf N + NB}\\) The value of NCG is \\({\\bf 2*IPARM(1)}\\) for symmetric sparse storage and \\({\\bf 4*IPARM(1)}\\) for nonsymmetric sparse storage. It should be noted that the actual amount of workspace used may be somewhat less than these upper limits since some of the latter are dependent on the maximum number of iterations allowed, ITMAX , stored in IPARM(1) . Clearly, the array WKSP(*) must be dimensioned to at least the value of NW . Nonzero integer values of the error flag IER indicate that an error condition was detected. These values are listed below according to their numerical value and to the name of the routine in which the flag was set. Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , Normal convergence was obtained. \\(=\\) \\(1+{\\rm Mth}\\) , Invalid order of the system, N . \\(=\\) \\(2+{\\rm Mth}\\) , Workspace array WKSP(*) is not large enough. IPARM(8) is set to the amount of required workspace, NW . \\(=\\) \\(3+{\\rm Mth}\\) , Failure to converge in IPARM(1) iterations. RPARM(1) is reset to the last stopping value computed. \\(=\\) \\(4+{\\rm Mth}\\) , Invalid order of the black subsystem, NB . \\(=\\) \\(101\\) , A diagonal element is not positive. \\(=\\) \\(102\\) , No diagonal element in a row. \\(=\\) \\(201\\) , Red-black indexing is not possible. \\(=\\) \\(301\\) , No entry in a row of the original matrix. \\(=\\) \\(302\\) , No entry in a row of the permuted matrix. \\(=\\) \\(303\\) , Sorting error in a row of the permuted matrix. \\(=\\) \\(401\\) , A diagonal element is not positive. \\(=\\) \\(402\\) , No diagonal element in a row. \\(=\\) \\(501\\) , Failure to converge in ITMAX function evaluations. \\(=\\) \\(502\\) , Function does not change sign at the endpoints. \\(=\\) \\(601\\) , Successive iterates are not monotone increasing. JCG() , JSI() , SOR() , SSORCG() , SSORSI() , RSCG() , RSSI() assign values to Mth of 10,20,30,40,50,60,70, respectively. SBELM() , PRBNDX() , PERMAT() , SCAL() , ZBRENT() , EQRT1S() are subroutines with error flags in the 100\u2019s, 200\u2019s, 300\u2019s, 400\u2019s, 500\u2019s, 600\u2019s, respectively. These routines perform the following functions: SBELM() removes rows and columns, PRBNDX() determines the red-black indexing, SCAL() scales the system, ZBRENT() is a modified IMSL routine for computing a zero of a function which changes sign in a given interval, EQRT1S() is a modified IMSL routine for computing the largest eigenvalue of a symmetric tridiagonal matrix. 3 User-Oriented Modules The array U(*) should contain an initial approximation to the solution of the linear system before any ITPACK module is called. If the user has no information for making such a guess, then the zero vector may be used as the starting vector. The subroutine VFILL() can be used to fill a vector with a constant: CALL VFILL (N, U, VAL) fills the array U(*) of length N with the value VAL in each entry. To aid the user in using the iterative methods of ITPACK, four modules for constructing the sparse matrix storage arrays are included. The modules are: SBINI() is called at the beginning to initialize the arrays IA(*) , JA(*) , A(*) , and IWORK(*) ; SBSIJ() is called repeatedly to set the individual entries in the matrix and build a link list representation of the matrix structure; SBEND() is called at the end to restructure the link list into final sparse storage form; SBAGN() is called to return again to the link list representation if SBEND() has been called but additional elements are to be added or modified. These modules are described below. (a) Initialization: CALL SBINI (N,NZ,IA,JA,A,IWORK) Initializes IA(*) , JA(*) , A(*) , and IWORK(*) for a system of order N . IA(*) , JA(*) , and IWORK(*) are integer arrays of length at least \\({\\bf N+1}\\) , NZ , and NZ , respectively. A(*) is a real array of length at least NZ . (b) Set individual entries: CALL SBSIJ (N,NZ,IA,JA,A,IWORK,I,J,VAL,MODE,LEVEL,NOUT,IER) Inserts the value, VAL , of the (I,J) entry of the user\u2019s matrix into the link list representation for that matrix. When using symmetric sparse storage, J must be greater than or equal to I . If the (I,J) entry has already been set then MODE specifies the way in which the entry is to be treated: \\({\\bf MODE}<0\\) , Current entry value is left as is; \\(=0\\) , Current entry value is reset to VAL ; \\(>0\\) , VAL is added to the current entry value. If LEVEL is less than \\(0\\) , SBSIJ() causes no printing. If LEVEL is \\(0\\) , fatal errors messages are written to output unit number NOUT ; and if LEVEL is \\(1\\) or greater, a message is printed when SBSIJ() encounters a value it has already set with the value being reset according to the value of MODE . IER is an error parameter and returns values of Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , New (I,J) entry is established. \\(=\\) \\(700\\) , (I,J) entry is already set\u2014reset according to MODE . \\(=\\) \\(701\\) , Improper values for either I or J . \\(=\\) \\(702\\) , NZ is too small\u2014no room for the new entry. (c) Finalization: CALL SBEND (N,NZ,IA,JA,A,IWORK) Restructures the link list data structure built by SBINI() and SBSIJ() into the final data structure required by ITPACK. (d) Undo Finalization: CALL SBAGN (N,NZ,IA,JA,A,IWORK,LEVEL,NOUT,IER) Returns to link list representation for modification or addition of elements to the system. Repeated calls to SBSIJ() can then be made followed by a single call to SBEND() to close-out the sparse matrix representation. If LEVEL is less than \\(0\\) , no printing is done and if LEVEL is \\(0\\) or greater, fatal error information is written to the output unit number NOUT . IER is an error flag indicating: Error Flag Meaning \\({\\bf IER} =\\) \\(0\\) , Successful completion. \\(=\\) \\(703\\) , NZ is too small\u2014no room for the new entry. Note that SBINI() should not be called after SBAGN() is called since it would destroy the previous data. Examples Given a linear system \\(Au=b\\) with \\[A = \\left[\\begin{array}{rrrr} 4 & -1 & -1 & 0 \\\\ -1 & 4 & 0 & -1 \\\\ -1 & 0 & 4 & -1 \\\\ 0 & -1 & -1 & 4 \\end{array} \\right], \\hspace{0.3in} b = \\left[\\begin{array}{c} 6 \\\\ 0 \\\\ 0 \\\\ 6 \\end{array} \\right],\\] a program to solve this problem with an initial guess of \\(u^T = (0, 0, 0, 0)\\) using JCG() with symmetric sparse storage and printing the final approximate solution vector follows. INTEGER IA ( 5 ), JA ( 8 ), IPARM ( 12 ), IWKSP ( 12 ) REAL A ( 8 ), RHS ( 4 ), u ( 4 ), WKSP ( 24 ), RPARM ( 12 ) DATA A ( 1 ), A ( 2 ), A ( 3 ), A ( 4 ) / 4.0 , - 1.0 , - 1.0 , 4.0 / DATA A ( 5 ), A ( 6 ), A ( 7 ), A ( 8 ) / - 1.0 , 4.0 , - 1.0 , 4.0 / DATA JA ( 1 ), JA ( 2 ), JA ( 3 ), JA ( 4 ) / 1 , 2 , 3 , 2 / DATA JA ( 5 ), JA ( 6 ), JA ( 7 ), JA ( 8 ) / 4 , 3 , 4 , 4 / DATA IA ( 1 ), IA ( 2 ), IA ( 3 ), IA ( 4 ), IA ( 5 ) / 1 , 4 , 6 , 8 , 9 / DATA RHS ( 1 ), RHS ( 2 ), RHS ( 3 ), RHS ( 4 ) / 6.0 , 0.0 , 0.0 , 6.0 / DATA N / 4 / , NW / 24 / , ITMAX / 4 / , LEVEL / 1 / , IDGTS / 2 / C CALL DFAULT ( IPARM , RPARM ) IPARM ( 1 ) = ITMAX IPARM ( 2 ) = LEVEL IPARM ( 12 ) = IDGTS CALL VFILL ( N , U , 0 . E0 ) CALL JCG ( N , IA , JA , A , RHS , U , IWKSP , NW , WKSP , IPARM , RPARM , IER ) STOP END The output for this run would be BEGINNING OF ITPACK SOLUTION MODULE JCG JCG HAS CONVERGED IN 2 ITERATIONS . APPROX . NO . OF DIGITS ( EST . REL . ERROR ) = 14.6 ( DIGIT1 ) APPROX . NO . OF DIGITS ( EST . REL . RESIDUAL ) = 14.3 ( DIGIT2 ) SOLUTION VECTOR . 1 2 3 4 ------------------------------------------------------------- 2.00000E+00 1.00000E+00 1.00000E+00 2.00000E+00 Textbook methods such as the Jacobi (J), Gauss-Seidel (GS), Successive Overrelaxation (SOR\u2014fixed relaxation factor omega), Symmetric Successive Overrelaxation (SSOR\u2014fixed relaxation factor omega), and the RS method can be obtained from this package by resetting appropriate parameters after the subroutine DFAULT() is called but before ITPACK routines are called. Method Use Parameters J JSI() \\({\\bf IPARM(6)=0, IPARM(7)=2}\\) GS SOR() \\({\\bf IPARM(6)=0}\\) SOR\u2014fixed omega SOR() \\({\\bf IPARM(6)=0, RPARM(5)=OMEGA}\\) SSOR\u2014fixed omega SSORSI() \\({\\bf IPARM(6)=0, RPARM(5)=OMEGA}\\) RS RSSI() \\({\\bf IPARM(6)=0}\\) These methods were not included as separate routines because they are usually slower than the accelerated methods included in this package. On the black unknowns, the Cyclic Chebyshev Semi-Iterative (CCSI) method of Golub and Varga [@2] gives the same result as the RSSI method. The CCSI and RSSI methods converge at the same rate, and each of them converges twice as fast as the JSI method. This is a theoretical result [@6] and does not count the time involved in establishing the red-black indexing and the red-black partitioned system. Similarly, the Cyclic Conjugate Gradient (CCG) method with respect to the black unknowns, considered by Reid [@16] (see also Hageman and Young [@6] ), gives the same results as the RSCG method. Also, the CCG and the RSCG methods converge at the same rate, and each of them converges, theoretically, exactly twice as fast as the JCG method. Hence, the accelerated RS methods are preferable to the accelerated J methods when using a red-black indexing. Numerical Results The iterative algorithms in ITPACK have been tested over a wide class of matrix problems arising from elliptic partial differential equations with Dirichlet, Neumann, and mixed boundary conditions on arbitrary two-dimensional regions (including cracks and holes) and on rectangular three-dimensional regions [@1] . Both finite-difference and finite-element procedures have been employed to obtain the linear systems. The two sample problems presented here, while simple to pose, are representative of the behavior of the ITPACK routines for more complex problems. The iterative algorithms make no use of the constant coefficients in these two problems or of the particular structure of the resulting linear system. Because the ITPACK code is not tailored to any particular class of partial differential equations or discretization procedure, but rather to sparse linear systems, it is felt that the package can be used to solve a wider class of problems. We now consider two simple partial differential equations which when discretized by finite-difference methods give rise to large sparse linear systems. We obtain the solution of each of these systems by the seven algorithms in ITPACK 2C. These numerical results should aid the user of ITPACK in determining the amount of time required when solving more complicated sparse systems. However, one should not interpret these execution times as conclusive by themselves. Variances introduced by different compilers, computer systems, and timing functions can sometimes be significant. Moreover, the number of iterations required by an iterative method is dependent on the problem being solved, the initial estimate for the solution, the parameter estimates used, and the relative accuracy requested in the stopping criterion RPARM(1) . These tests were run on the CDC Cyber 170/750 at the University of Texas with the FTN 4.8 compiler (OPT=2). To obtain representative sparse linear systems, we discretize the following two self-adjoint elliptic partial differential equations in a region with prescribed conditions on the boundary. Here \\(u_{xx}\\) , \\(u_{yy}\\) , \\(u_{zz}\\) are partial derivatives and \\(du/dn\\) is the derivative in the normal direction. \\[\\begin{aligned} u_{xx} + 2u_{yy} = 0, && \\mbox{$(x,y)$ in $S=(0,1)\\times (0,1)$} \\\\ u = 1 + xy, && \\mbox{$(x,y)$ on the boundary of $S$} \\nonumber\\end{aligned}\\] Using the standard 5-point symmetric finite-difference operator with \\(h=\\frac{1}{20}\\) , we obtain a sparse linear system with \\(1729\\) nonzero elements and \\(361\\) unknowns. \\[\\begin{aligned} u_{xx}+2u_{yy}+3u_{zz}=0, && \\mbox{$(x,y,z)$ in $C=(0,1)\\times (0,1)\\times (0,1)$} \\nonumber \\\\ \\mbox{On the boundary of C:} && \\\\ u=1, && \\mbox{$(0,y,z)$, $(x,0,z)$, or $(x,y,0)$} \\nonumber \\\\ du/dn = yz(1 + yz), && (1,y,z) \\nonumber \\\\ du/dn = xz(1 + xz), && (x,1,z) \\nonumber \\\\ du/dn = xy(1 + xy), && (x,y,1) \\nonumber \\end{aligned}\\] Using the standard 7-point symmetric finite difference operator with \\(h=\\frac{1}{7}\\) , we obtain a sparse linear system with \\(1296\\) nonzero elements and \\(216\\) unknowns. Tables 1 and 2 display the number of iterations and execution times (in seconds) for the seven methods in ITPACK 2C for the linear systems corresponding to problems (1) and (2), respectively, using symmetric sparse storage. Both the time for the iteration algorithm and the total time for the subroutine call are given. The stopping criterion was set to \\(5\\times 10^{-6}\\) . To illustrate how effective the adaptive procedures are, we have included in these tables the number of iterations and the time when the optimum iteration parameters were used with no adaptive procedures. Routine Ordering Iterations Iteration time Total time JCG() Natural 61 (61) .250 (.247) .281 (.271) Red-black 61 (61) .232 (.246) .402 (.413) JSI() Natural 108 (95) .408 (.344) .439 (.375) Red-black 108 (95) .393 (.332) .569 (.498) SOR() Natural 72 (54) .356 (.280) .368 (.307) Red-black 65 (47) .311 (.224) .469 (.411) SSORCG() Natural 17 (13) .232 (.173) .264 (.185) SSORSI() Natural 23 (22) .242 (.213) .273 (.244) RSCG() Red-black 31 (31) .104 (.117) .269 (.297) RSSI() Red-black 60 (48) .207 (.166) .358 (.344) Number of Iterations and Execution Times for Problem (1) Using Adaptive and Nonadaptive Procedures (Nonadaptive Data in Parentheses) Routine Ordering Iterations Iteration time Total time JCG() Natural 28 (28) .092 (.090) .107 (.090) Red-black 28 (28) .079 (.074) .191 (.202) JSI() Natural 64 (54) .166 (.136) .196 (.152) Red-black 64 (54) .160 (.130) .268 (.266) SOR() Natural 42 (29) .139 (.095) .150 (.110) Red-black 38 (29) .124 (.097) .236 (.231) SSORCG() Natural 15 (11) .136 (.097) .167 (.111) SSORSI() Natural 19 (15) .138 (.101) .153 (.117) RSCG() Red-black 15 (15) .032 (.051) .150 (.169) RSSI() Red-black 31 (27) .075 (.064) .186 (.196) Number of Iterations and Execution Times for Problem (2) Using Adaptive and Nonadaptive Procedures (Nonadaptive Data in Parentheses) Values corresponding to the red-black ordering with the SSOR methods are omitted from the tables since it is known that these methods are ineffective with this ordering. Since the RS methods are defined for only the red-black ordering, the table entries for these methods with the natural ordering are not included. Notes on Use Before an iterative algorithm is called to solve a linear system, the values in the array A(*) are permuted and scaled. Afterwards, these values are unpermuted and unscaled. Consequently, the values in arrays A(*) and RHS(*) may change slightly due to roundoff errors in the computer arithmetic. Moreover, since entries in each row of the linear system may be stored in any order within a contiguous block of data, the locations of elements of A(*) and of corresponding ones in JA(*) may change from those given before the permuting and unpermuting was done. The same linear system is defined by the arrays A(*) , JA(*) , and IA(*) whether or not corresponding elements in A(*) and JA(*) have changed locations within contiguous blocks. Scaling of the linear system is done as follows to reduce the number of arithmetic operations. The diagonal entries of the linear system are checked for positivity and are moved to the first N locations of the array A(*) . The nonzero off-diagonal entries of the linear system \\(Au=b\\) are scaled. The scaling involves the diagonal matrix \\(D^{\\frac{1}{2}}\\) of square roots of the diagonal entries of the linear system, that is, \\[(D^{-\\frac{1}{2}}AD^{-\\frac{1}{2}})(D^{\\frac{1}{2}}u) = (D^{-\\frac{1}{2}}b).\\] The algorithms iterate until convergence is reached based on the relative accuracy requested via the stopping criterion set in RPARM(1) for the scaled solution vector \\((D^{\\frac{1}{2}}u)\\) . Unscaling solves for \\(u\\) and returns the linear system to its original form subject to roundoff errors in the arithmetic and to possible movement of entries within contiguous blocks of data. When requested, a red-black permutation of the data will be done before and after the iterative algorithm is called. Otherwise, the linear system is used in the order it is given which we call the \u201cnatural ordering.\" The Successive Overrelaxation (SOR) method has been shown to be more effective with the red-black ordering than with the natural ordering for some problems [@18] . In the SOR algorithm, the first iteration uses \\(\\omega= 1\\) and the stopping criterion is set to a large value so that at least one Gauss-Seidel iteration is performed before an approximate value for the optimum relaxation parameter is computed. Optional features of this package are red-black ordering, effective removal of rows and columns when the diagonal entry is extremely large, and error analysis. In the event that one is not using some of these options and needs additional memory space for a very large linear system, the relevant subroutines which can be replaced with dummy subroutines are as follows: red-black ordering [ PRBNDX() , PERMAT() , PERVEC() , QSORT() ], removal of rows [ SBELM() ], error analysis [ PERROR() ]. The timing routine TIMER() should call a routine which returns the run time in seconds. The value of the machine relative precision is contained in the variable SRELPR which is set in the subroutine DFAULT() and in the test program. This and other default values may be permanently changed when the code is installed by changing their values in the subroutine DFAULT() . SRELPR must be changed when moving the code to another computer. If the installer of this package does not know its value, an approximate value can be determined from a simple FORTRAN program given in the comment statements of subroutine DFAULT() . Since the amount of precision may change from computer to computer, the relative accuracy requested in the stopping criterion ZETA must not be less than about \\(500\\) times the machine relative precision SRELPR . If a value of ZETA is requested that is too small then the code resets it to this value. The current default value for ZETA , \\(5 \\times 10^{-6}\\) , is set by the routine DFAULT() into RPARM(1) . The distribution tape contains the ITPACK 2C software package of \\(71\\) subprograms and a testing program MAIN() together with its \\(27\\) subprograms. The routines DFAULT() and TIMER() in ITPACK and the program MAIN() are the only ones requiring editing by the installer of the package. ITPACK can be made into a compiled program library although not all of it would normally be used in a particular application. ITPACK History The 2C version of the ITPACK codes described here is the result of several years of research and development. The development of ITPACK began in the early 1970\u2019s when Professor Garrett Birkhoff suggested that general purpose software for solving linear systems should be developed for iterative methods as well as for direct methods. Initially, prototype programs were written based on preliminary iterative algorithms involving adaptive selection of parameters and automatic stopping procedures. These programs were tested on a large set of elliptic partial differential equations over domains compatible with the subroutine REGION() [@8] which superimposed a square grid over the domain. These routines were designed for solving self-adjoint elliptic partial differential equations. Next a preliminary version of ITPACK was coded in standard FORTRAN. The ITPACK routines used iterative algorithms which were refined from the prototype programs. However, these routines were designed to solve large sparse linear systems of algebraic equations instead of partial differential equations. The use of three interchangeable symmetric sparse storage modes in ITPACK 1.0 [@3] allowed for great flexibility and made it possible to solve a wider class of problems than the prototype programs and to study different storage modes for iterative methods. The next version, ITPACK 2.0 [@4] , was significantly faster than its predecessor since it was restricted to allow only one sparse symmetric storage format. Most of the iterative algorithms utilized in the 2.0 version of this package assume that the coefficient matrix of the linear system is symmetric positive definite. As with many packages, the need to handle a slightly larger class of problems, namely, nearly symmetric systems, soon became evident. This required adapting the routines to allow a switch for either a symmetric or nonsymmetric storage mode in ITPACK 2A [@5] . Moreover, a modification of the Conjugate Gradient algorithms was developed to handle nearly symmetric systems [@12] . ITPACK has been improved in the 2B version [@14] by (a) writing more efficient versions of several key subroutines, (b) incorporating Basic Linear Algebra Subprograms, BLAS [@15] , and (c) improving the user interface with better printing and documentation. Some additional improvements and corrections were made in the 2C version. The algorithms in ITPACK are not guaranteed to converge for all linear systems but have been shown to work successfully for a large number of symmetric and nonsymmetric systems which arise from solving elliptic partial differential equations [@1; @13] . The numerical algorithms in ITPACK 2C correspond to those described in the appendix of technical report [@5] and outlined in the book [@7] . In particular, the SOR code is based on an algorithm suggested to us by L. Hageman. Various other algorithms exist for iterative methods. For example, S. Eisenstat has an implementation of the Symmetric Successive Overrelaxation preconditioned Conjugate Gradient procedure. 4 Modules based on the seven iterative routines in ITPACK have been incorporated into the elliptic partial differential equation solving package ELLPACK [@17] together with all the necessary translation routines needed. The user-oriented modules described in Section 4 are not in ELLPACK. Moreover, if the ELLPACK system is not being used to generate the linear system for ITPACK, it is recommended that ITPACK be used as a stand-alone package apart from ELLPACK. Acknowledgements The authors wish to thank the referee for carefully going through the code and documentation for several different versions. Test runs were made on a variety of computer systems and helpful suggestions were made by R. Boisvert, W. Coughran, J. Dongarra, W. Dyksen, S. Eisenstat, S. Fillebrown, P. Gaffney, W. Gordon, R. Hanson, R. Lynch, J. Rice, B. Ward, and others. These suggestions and comments together with those of the referee have resulted in an improved software package. ITPACK has been tested on the following computing machines: CDC 6400, 6500, 6600, 7600, Cyber 170/750, 203, 205; Cray 1; DEC 10, 20, PDP 10, VAX 11/750, 11/780; IBM 195, 370/158, 3033; PRIME 400, 750; and others. 99 S. Eisenstat, A. George, R. Grimes, D. Kincaid, and A. Sherman. \u201cSome Comparisons of Software Packages for Large Sparse Linear Systems,\" in Advances in Computer Methods for Partial Differential Equations III , (R. Vichnevetsky and R. Stepleman, eds.), Publ. IMACS, Department of Computer Science, Rutgers University, New Brunswick, New Jersey, 08903, 1979, pp. 98-106. G. Golub and R. Varga. \u201cChebyshev Semi-Iterative Methods, Successive Overrelaxation Iterative Methods, and Second-Order Richardson Iterative Methods,\" Parts I & II, Numerische Mathematik , Vol. 3, 1961, pp. 147-168. R. Grimes, D. Kincaid, W. Macgregor, and D. Young. \u201cITPACK Report: Adaptive Iterative Algorithms Using Symmetric Sparse Storage,\" CNA-139, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1978. R. Grimes, D. Kincaid, and D. Young. \u201cITPACK 2.0 User\u2019s Guide,\" CNA-150, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1979. R. Grimes, D. Kincaid, and D. Young. \u201cITPACK 2A: A FORTRAN Implementation of Adaptive Accelerated Iterative Methods for Solving Large Sparse Linear Systems,\" CNA-164, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, October 1980. L. Hageman and D. Young. Applied Iterative Methods , Academic Press, New York, 1981. L. Hayes and D. Young. \u201cThe Accelerated SSOR Method for Solving Large Linear Systems: Preliminary Report,\" CNA-123, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, May 1977. D. Kincaid and R. Grimes. \u201cNumerical Studies of Several Adaptive Iterative Algorithms,\" CNA-126, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, August 1977. D. Kincaid, R. Grimes, W. Macgregor, and D. Young. \u201cITPACK\u2014Adaptive Iterative Algorithms Using Symmetric Sparse Storage,\" in Symposium on Reservoir Simulation , Society of Petroleum Engineers of AIME, 6200 North Central Expressway, Dallas, Texas, 75206, February 1979, pp. 151-160. D. Kincaid, R. Grimes, and D. Young. \u201cThe Use of Iterative Methods for Solving Large Sparse PDE-Related Linear Systems,\" Mathematics and Computers in Simulation XXI , North-Holland Publishing Company, New York, 1979, pp. 368-375. D. Kincaid and D. Young. \u201cSurvey of Iterative Methods,\" in Encyclopedia of Computer Sciences and Technology , Vol. 13 (J. Belzer, A. Holzman, and A. Kent, eds.), Marcel Dekker, Inc., New York, 1979, pp. 354-391. D. Kincaid and D. Young. \u201cAdapting Iterative Algorithms Developed for Symmetric Systems to Nonsymmetric Systems,\" in Elliptic Problem Solvers , (M. Schultz, ed.), Academic Press, New York, 1981, p. 353-359. D. Kincaid. \u201cAcceleration Parameters for a Symmetric Successive Overrelaxation Conjugate Gradient Method for Nonsymmetric Systems,\" in Advances in Computer Methods for Partial Differential Equations IV , (R. Vichnevetsky and R. Stepleman, eds.), Publ. IMACS, Department of Computer Science, Rutgers University, New Brunswick, New Jersey, 08903, 1981, pp. 294-299. D. Kincaid, R. Grimes, J. Respess, and D. Young. \u201cITPACK 2B: A FORTRAN Implementation of Adaptive Accelerated Iterative Methods for Solving Large Sparse Linear Systems,\" CNA-173, Center for Numerical Analysis, University of Texas, Austin, Texas, 78712, September 1981. C. Lawson, R. Hanson, D. Kincaid, and F. Krogh. \u201cBasic Linear Algebra Subprograms for FORTRAN Usage,\" ACM Transactions on Mathematical Software , Vol. 5., No. 3, September 1979, pp. 308-323. J. Reid. \u201cThe Use of Conjugate Gradients for Systems of Linear Equations Possessing Property A,\" SIAM Journal of Numerical Analysis , Vol. 9, 1972, pp. 325-332. J. Rice and R. Boisvert. Solving Elliptic Problems Using ELLPACK . New York: Springer-Verlag, 1985. D. Young. Iterative Solution of Large Linear Systems , Academic Press, New York, 1971. D. Young and D. Kincaid. \u201cThe ITPACK Package for Large Sparse Linear Systems,\" in Elliptic Problem Solvers , (M. Schultz, ed.), Academic Press, New York, 1981, pp. 163-185. In this ordering, the components of the unknown vector \\(u\\) are considered as either \u201cred\" or\u201dblack\". A \u201cred-black ordering\" is any ordering such that every black unknown follows all of the red unknowns. This ordering of unknowns leads to a \\(2\\times 2\\) \u201dred-black partitioning\" of the coefficient matrix, that is, a matrix of the form \\[\\left[\\begin{array}{cc} D_R & H \\\\ K & D_B \\end{array} \\right]\\] with diagonal submatrices \\(D_R\\) and \\(D_B\\) . The original linear system may require rearrangement in order to arrive at this form. \u21a9\ufe0e For the red-black ordering, the I th entry of a permutation array P(*) indicates the position J into which the I th unknown of the original system is being mapped, that is, if \\({\\bf P(I)=J}\\) then unknown I is mapped into position J . The J th entry of an inverse permutation array IP(*) indicates the position I into which the J th unknown of the permuted system must be mapped to regain the original ordering, that is, \\({\\bf IP(J)=I}\\) . \u21a9\ufe0e IMSL (International Mathematical and Statistical Libraries, Inc.), Sixth Floor NBC Bldg., 7500 Bellaire Blvd., Houston, TX, 77036. \u21a9\ufe0e Private communication. \u21a9\ufe0e","title":"ITPACK\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectBlock/","text":"ProfileSPDDirectBlockSolver UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectBlockSolver.h> class ProfileSPDLinDirectBlockSolver : public LinearSOESolver \\ MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectBlockSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one block row at a time using a right-looking approach. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDDirectBlockSolver\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectSkypack/","text":"ProfileSPDDirectSkypack #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectSkypackSolver.h> class ProfileSPDLinDirectSkypackSolver : public LinearSOESolver MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectSkypackSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this by direct means using the routines supplied in the SKYPACK library, a library which uses the BLAS levels 1,2 and 3 for the factorization and substitution. The routines in SKYPACK require a number of work areas: int block[3] and double invD[size] . In addition, to allow the use of the BLAS 2 and 3, work areas double rw[mRows x mCols] , double tw[mRows x mRows] and int index[max(mCols,mRows)] are created. Constructors Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Sets mCols and mRows equal to \\(0\\) and does not try and allocate any memory for the work arrays. A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Sets mCols and mRows and allocates space in memory for the work arrays rw , tw and index . If not enough memory is available in memory, mCols and mRows is set equal to \\(0\\) and an error message is printed. Invokes delete on any work areas that have been constructed. The solver first copies the B vector into X and then solves the BandSPDLinSOE system. If the matrix has not been factored, the matrix is first factored using the SKYPACK routine skysf2() , if mCols and mRows equal \\(0\\) , or skypf2() . skysf2() is a routine which uses the BLAS level 1 routines, skypf2() is a routine which uses BLAS levels 2 and 3. If skypf2() has been called, invD is set up. Once the matrix has been factored, skyss() is called. If the solution is successfully obtained, i.e. the skyss() routine returns \\(0\\) in the INFO argument, \\(0\\) is returned, otherwise it prints a warning message and returns INFO. The solve process changes \\(A\\) and \\(X\\) . Is responsible for setting the block information required by the SKYPACK routines (block[0]=1; block[1]=size, block[2]=1) and for creating space for the invD work array. Returns \\(0\\) if successful, otherwise a warning message is printed and a \\(-1\\) is returned. Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDDirectSkypack\n"},{"location":"libraries/numerics/LinearSolve/ProfileSPDDirectThread/","text":"ProfileSPDLinDirectThread UNDER CONSTRUCTION #include <system_of_eqn/linearSOE/profileSPD/ProfileSPDLinDirectThreadSolver.h> class ProfileSPDLinDirectThreadSolver : public LinearSOESolver MovableObject Solver LinearSOESolver ProfileSPDLinSolver A ProfileSPDLinDirectThreadSolver object can be constructed to solve a ProfileSPDLinSOE object. It does this in parallel using threads by direct means, using the \\(LDL^t\\) variation of the cholesky factorization. The matrx \\(A\\) is factored one row block at a time using a left-looking approach. Within a row block the factorization is performed by \\(NP\\) threads. No BLAS or LAPACK routines are called for the factorization or subsequent substitution. Constructor Destructor Public Methods A unique class tag (defined in <classTags.h> ) is passed to the ProfileSPDLinSolver constructor. Does nothing. The solver first copies the B vector into X. FILL IN The solve process changes \\(A\\) and \\(X\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) . Does nothing but return \\(0\\) .","title":"ProfileSPDLinDirectThread\n"},{"location":"libraries/numerics/LinearSolve/SparseGenCol/","text":"SparseGenColLinSolver #include <system_of_eqn/linearSOE/SparseGen/SparseGenColLinSolver.h> class SparseGenColLinSolver : public LinearSOESolver MovableObject Solver SparseGenColLinSolver is an abstract class. The SparseGenColLinSolver class provides access for each subclass to the SparseGenColLinSOE object through the pointer theSOE , which is a protected pointer. Constructor ### Destructor // Public Methods The integer classTag is passed to the LinearSOESolver classes constructor. Does nothing, provided so the subclasses destructor will be called. Sets the link to the SparseGenColLinSOE object theSOE . This is the object on which the solver will perform the numerical computations.","title":"SparseGenColLinSolver\n"},{"location":"libraries/numerics/Numberer/PlainNumberer/","text":"PlainNumberer #include <analysis/numberer/PlainNumberer.h> class PlainNumberer : public DOF_Numberer MovableObject DOF_Numberer The PlainNumberer class is a DOF_Numberer. An object of this class assigns the equation numbers to thee DOF_Groups based on the order in which they are obtained from the DOF_GroupIter object obtained from the AnalyisModel. The class is useful for situations where the SystemOfEqn or Solver objects will impose a renumbering on the equations, which makes performing a complex numbering of the degrees-of-freedom a waste of computational effort. Constructor ### Destructor // Public Methods The integer NUMBERER_TAG_PlainNumberer is passed to the DOF_Numberer classes constructor. Does nothing. The PlainNumberer will twice obtain the DOF_GroupIter from the AnalysisModel. It iterates twice through the DOF_Groups first assigning the dofs with eqn numbers assigned -2 a number and then on the next pass the dofs assigned -3. The PlainNumberer then invokes setID() on each FE_Element in the AnalysisModel. Finally it invokes setEqnNum(numEqn) on the AnalyisModel. Returns a positive integer equal to the last equation number set if successful, a negative number if not; the value of which depends on the type of the PlainNumberer. A PlainNumberer will not use the lastDOF_Group integer, if one is supplied a warning message is printed. The method is identical to that outlined above. A PlainNumberer will not use the lastDOF_Groups ID, if this method is invoked a warning message is printed. Returns \\(0\\) . Returns \\(0\\) .","title":"PlainNumberer\n"},{"location":"libraries/numerics/Numberer/RCM/","text":"RCM #include <graph/numberer/RCM.h> class RCM: public GraphNumberer; MovableObject GraphNumberer RCM is a subclass of GraphNumberer which performs the numbering using the reverse Cuthill-McKee numbering algorithm. Constructor ### Destructor // Public Methods The integer classTag is passed to the MovableObject classes constructor. The flag GPS is used to mark whether the Gibbs-Poole-Stodlmyer algorithm is used to determine a starting vertex when no starting vertex is given. Invokes the destructor on any ID object created when number() is invoked. If the present ID used for the result is not of size equal to the number of Vertices in theGraph , it deletes the old and constructs a new ID. Starts by iterating through the Vertices of the graph setting the tmp variable of each to \\(-1\\) . The Vertices are then numbered using a depth first sort of the Graph, with each unmarked Vertex in the Graph at a distance \\(d\\) from starting Vertex being placed in the d\u2019th level set. As this is RCM, the Vertices in level set \\(n\\) are assigned a higher number than those in level set \\(n+1\\) with the tmp variable of the starting Vertex being assigned numVertices \\(-1\\) . The tags of the Vertices are placed into the ID at location given by their tmp variable. These are replaced with the ref variable of each Vertex, which is returned on successful completion. The Vertex chosen as the starting Vertex is the one whose tag is given by lastVertex . If this is \\(-1\\) or the Vertex corresponding to lastVertex does not exist then another Vertex is chosen. If the GPS flag in constructor is false the first Vertex from the Graphs VertexIter is used; if true a RCM numbering using the first Vertex from the VertexIter is performed and the Vertices in the last level set are then used to create an ID lastVertices with which number(theGraph, lastVertices) can be invoked to determine the numbering. This method is invoked to determine the best starting Vertex for a RCM using a Vertex whose tag is in lastVertices . To do a RCM numbering is performed using each of the Vertices in startVertices as the Vertex in level set \\(0\\) . The Vertex which results in the numbering with the smallest profile is chosen as the starting Vertex. The RCM algorithm outlined above is then called with this starting Vertex. int sendSelf ( Channel & theChannel , FEM_ObjectBroker & theBroker ); Returns \\(0\\) . int recvSelf(Channel &theChannel, FEM_ObjectBroker &theBroker); Returns \\(0\\) .","title":"RCM\n"},{"location":"libraries/numerics/Partitioner/Metis/","text":"Metis #include <graph/partitioner/Metis.h> class GraphPartitioner: GraphPartitioner Metis is a GraphPartitioner. The Metis graph partitioner calls procedures defined in the METIS library to partition the graph. METIS is currently being developed by G. Karypis and V. Kumar at the University of Minnesota. At the present time the Graph to be partitioned MUST have the vertices labeled \\(0\\) through \\(numVertex-1\\) . The METIS library uses two integer arrays to represent the graph, xadj and adjncy . \\(xadj(i)\\) stores the location in adjncy of the start of the \\(i\\) \u2019th Vertices adjacent Vertices. adjncy contains the tags of all the adjacent vertices. For example, the graph which is represented by the following matrix \\(A\\) : \\[A = \\left[ \\begin{array}{ccccc} 1 & 0 & 1 & 1 & 0 \\\\ 1 & 1 & 0 & 0 & 0 \\\\ 0 & 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 0 & 1 \\end{array} \\right]\\] is represented by: \\[xadj = \\left[ \\begin{array}{cccccccccccccc} 0 & 2 & 3 & 4 & 5 & 7 \\end{array} \\right]\\] and \\[adjncy = \\left[ \\begin{array}{cccccccccccccc} 2 & 3 & 0 & 1 & 4 & 0 & 1 \\end{array} \\right]\\] note that there is no space allocated for the diagonal components. Constructors ### Destructor // Public Methods // Private Method To construct a Metis object which will use the default settings when partitioning. To construct a Metis object which will use the setting passed into the constructor as options to metis\u2019s PMETIS() routine. checkOptions() is invoked to ensure the settings are valid. This is the method invoked to partition the graph into numPart partitions. On completion of the routine each vertex will be assigned a color \\(1\\) through numPart , the color assigned indicating the partition to which the vertex belongs. To partition a number of integer arrays are created, options[5] , partition[numVertex+1] , xadj[numVertex+1] and adjncy[2*numEdge] (CURRENTLY ASSUMING GRAPH IS SYMMETRIC - THIS MAY CHANGE & xadj and partition 1 LARGER THAN REQUIRED). If not enough memory is available for the arrays, a warning message is printed and \\(-2\\) is returned. The data for xadj and adjncy are determined from the Vertices of the Graph by iterating over each Vertex from \\(0\\) through numVertex \\(-1\\) . If default options are specified options[0] is set to \\(0\\) , otherwise \\(1\\) with options[1:4] = coarsenTo, mType, ipType, rType . if pType equals \\(1\\) PMETIS is called, otherwise KMETIS is called. Both are called with the following arguments: numVertex, xadj,adjncy, 0, 0, &weightFlag, options, numPart, &numbering, &edgecut, partition The colors of the partitions are then set equal to the color indicated in partition . The integer arrays are destroyed and \\(0\\) returned. Sets the default options. Sets the options for the partitioning to those passed as arguments. Then invokes checkOptions() to see if the options are valid. HOW ABOUT REFERRINGR TO MANUAL TO SEE WHAT OPTIONS MEAN. If options are not valid sets the default options. EXPAND ON VALID OPTIONS OR REFER TO METIS MANUAL.","title":"Metis\n"},{"location":"libraries/pattern/Plain/","text":"Plain Pattern","title":"Plain Pattern\n"},{"location":"libraries/pattern/UniformExcitation/","text":"UniformExcitation #include <domain/pattern/UniformExcitation.h> class UniformExcitation : public EarthquakeLoad TaggedObject MovableObject DomainComponent LoadPattern EarthquakePattern A UniformExcitation is an object which adds the loads imposed by a single ground excitation to the model. For a UniformExcitation this means that the R matrix at each node will have \\(1\\) column and all entries but those corresponding to the degree of freedom direction will be set to \\(0\\) , the value for the degree of freedom direction will be set to \\(1\\) .","title":"UniformExcitation\n"},{"location":"libraries/runtime/","text":"PlainRuntime","title":"PlainRuntime\n"},{"location":"libraries/runtime/MomentCurvature/","text":"","title":""},{"location":"libraries/utilities/quadrature/","text":"Quadrature","title":"Quadrature\n"},{"location":"libraries/utilities/torsion/","text":"Torsion","title":"Torsion\n"},{"location":"libraries/utilities/units/","text":"units meter [\u2018m\u2019] milimeter [\u2018mm\u2019] inch [\u2018inch\u2019, \u2018in\u2019] international_foot [\u2018foot\u2019, \u2018ft\u2019] us_survey_foot [\u2018s_foot\u2019, \u2018s_ft\u2019] international_yard [\u2018yard\u2019, \u2018yd\u2019] kilogram [\u2018kg\u2019] pound_mass [\u2018lb\u2019] newton [\u2018N\u2019] pound_force [\u2018lbf\u2019] kip [\u2018kip\u2019] hertz [\u2018Hz\u2019] radian [\u2018radian\u2019, \u2018rad\u2019] arc_degree [\u2018deg\u2019]","title":"units\n"},{"location":"reference/ast/","text":"AST Reference","title":"AST Reference\n"},{"location":"reference/framework/","text":"Framework","title":"Framework\n"}]}